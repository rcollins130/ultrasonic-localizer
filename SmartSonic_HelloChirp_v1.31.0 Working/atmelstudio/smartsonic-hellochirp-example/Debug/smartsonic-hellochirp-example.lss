
smartsonic-hellochirp-example.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000e178  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0040e178  0040e178  0001e178  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000348  20000000  0040e180  00020000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00002630  20000348  0040e4c8  00020348  2**3
                  ALLOC
  4 .stack        00003000  20002978  00410af8  00020348  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020348  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020376  2**0
                  CONTENTS, READONLY
  7 .debug_info   00039097  00000000  00000000  000203cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00005f35  00000000  00000000  00059466  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000e345  00000000  00000000  0005f39b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001968  00000000  00000000  0006d6e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00001808  00000000  00000000  0006f048  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000e888  00000000  00000000  00070850  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00007b9b  00000000  00000000  0007f0d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000079e4  00000000  00000000  00086c74  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	78 59 00 20 49 53 40 00 19 54 40 00 19 54 40 00     xY. IS@..T@..T@.
  400010:	19 54 40 00 19 54 40 00 19 54 40 00 00 00 00 00     .T@..T@..T@.....
	...
  40002c:	19 54 40 00 19 54 40 00 00 00 00 00 19 54 40 00     .T@..T@......T@.
  40003c:	19 54 40 00 19 54 40 00 19 54 40 00 19 54 40 00     .T@..T@..T@..T@.
  40004c:	65 14 40 00 19 54 40 00 19 54 40 00 19 54 40 00     e.@..T@..T@..T@.
  40005c:	19 54 40 00 c5 94 40 00 c9 12 40 00 00 00 00 00     .T@...@...@.....
  40006c:	bd 11 40 00 ed 40 40 00 19 54 40 00 19 54 40 00     ..@..@@..T@..T@.
  40007c:	19 54 40 00 19 54 40 00 19 54 40 00 19 54 40 00     .T@..T@..T@..T@.
  40008c:	dd 12 40 00 19 54 40 00 19 54 40 00 19 54 40 00     ..@..T@..T@..T@.
  40009c:	7d 14 40 00 8d 14 40 00 19 54 40 00 19 54 40 00     }.@...@..T@..T@.
  4000ac:	19 54 40 00 19 54 40 00 09 38 40 00 19 54 40 00     .T@..T@..8@..T@.
	...
  4000fc:	19 54 40 00 19 54 40 00 19 54 40 00 00 00 00 00     .T@..T@..T@.....
	...

00400148 <__do_global_dtors_aux>:
  400148:	b510      	push	{r4, lr}
  40014a:	4c05      	ldr	r4, [pc, #20]	; (400160 <__do_global_dtors_aux+0x18>)
  40014c:	7823      	ldrb	r3, [r4, #0]
  40014e:	b933      	cbnz	r3, 40015e <__do_global_dtors_aux+0x16>
  400150:	4b04      	ldr	r3, [pc, #16]	; (400164 <__do_global_dtors_aux+0x1c>)
  400152:	b113      	cbz	r3, 40015a <__do_global_dtors_aux+0x12>
  400154:	4804      	ldr	r0, [pc, #16]	; (400168 <__do_global_dtors_aux+0x20>)
  400156:	f3af 8000 	nop.w
  40015a:	2301      	movs	r3, #1
  40015c:	7023      	strb	r3, [r4, #0]
  40015e:	bd10      	pop	{r4, pc}
  400160:	20000348 	.word	0x20000348
  400164:	00000000 	.word	0x00000000
  400168:	0040e180 	.word	0x0040e180

0040016c <frame_dummy>:
  40016c:	4b0c      	ldr	r3, [pc, #48]	; (4001a0 <frame_dummy+0x34>)
  40016e:	b143      	cbz	r3, 400182 <frame_dummy+0x16>
  400170:	480c      	ldr	r0, [pc, #48]	; (4001a4 <frame_dummy+0x38>)
  400172:	490d      	ldr	r1, [pc, #52]	; (4001a8 <frame_dummy+0x3c>)
  400174:	b510      	push	{r4, lr}
  400176:	f3af 8000 	nop.w
  40017a:	480c      	ldr	r0, [pc, #48]	; (4001ac <frame_dummy+0x40>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b923      	cbnz	r3, 40018a <frame_dummy+0x1e>
  400180:	bd10      	pop	{r4, pc}
  400182:	480a      	ldr	r0, [pc, #40]	; (4001ac <frame_dummy+0x40>)
  400184:	6803      	ldr	r3, [r0, #0]
  400186:	b933      	cbnz	r3, 400196 <frame_dummy+0x2a>
  400188:	4770      	bx	lr
  40018a:	4b09      	ldr	r3, [pc, #36]	; (4001b0 <frame_dummy+0x44>)
  40018c:	2b00      	cmp	r3, #0
  40018e:	d0f7      	beq.n	400180 <frame_dummy+0x14>
  400190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400194:	4718      	bx	r3
  400196:	4b06      	ldr	r3, [pc, #24]	; (4001b0 <frame_dummy+0x44>)
  400198:	2b00      	cmp	r3, #0
  40019a:	d0f5      	beq.n	400188 <frame_dummy+0x1c>
  40019c:	4718      	bx	r3
  40019e:	bf00      	nop
  4001a0:	00000000 	.word	0x00000000
  4001a4:	0040e180 	.word	0x0040e180
  4001a8:	2000034c 	.word	0x2000034c
  4001ac:	0040e180 	.word	0x0040e180
  4001b0:	00000000 	.word	0x00000000

004001b4 <main>:
 * and configuration, callback routine registration, and timer setup.  After 
 * the initialization sequence completes, this routine enters an infinite 
 * loop that will run for the remainder of the application execution.
 */

int main(void) {
  4001b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4001b8:	b091      	sub	sp, #68	; 0x44
  4001ba:	af04      	add	r7, sp, #16
	ch_group_t	*grp_ptr = &chirp_group;
  4001bc:	4b96      	ldr	r3, [pc, #600]	; (400418 <main+0x264>)
  4001be:	62bb      	str	r3, [r7, #40]	; 0x28
	uint8_t chirp_error = 0;
  4001c0:	2300      	movs	r3, #0
  4001c2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	 *
	 *   The chbsp_board_init() function also initializes fields within the 
	 *   sensor group descriptor, including number of supported sensors and 
	 *   the RTC clock calibration pulse length.
	 */
	chbsp_board_init(grp_ptr);
  4001c6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  4001c8:	4b94      	ldr	r3, [pc, #592]	; (40041c <main+0x268>)
  4001ca:	4798      	blx	r3

	printf("\n\nHello Chirp! - Chirp SonicLib Example Application\n");
  4001cc:	4894      	ldr	r0, [pc, #592]	; (400420 <main+0x26c>)
  4001ce:	4b95      	ldr	r3, [pc, #596]	; (400424 <main+0x270>)
  4001d0:	4798      	blx	r3
	printf("    Compile time:  %s %s\n", __DATE__, __TIME__);
  4001d2:	4a95      	ldr	r2, [pc, #596]	; (400428 <main+0x274>)
  4001d4:	4995      	ldr	r1, [pc, #596]	; (40042c <main+0x278>)
  4001d6:	4896      	ldr	r0, [pc, #600]	; (400430 <main+0x27c>)
  4001d8:	4b92      	ldr	r3, [pc, #584]	; (400424 <main+0x270>)
  4001da:	4798      	blx	r3
	printf("    Version: %u.%u.%u", APP_VERSION_MAJOR, APP_VERSION_MINOR,
  4001dc:	2300      	movs	r3, #0
  4001de:	221f      	movs	r2, #31
  4001e0:	2101      	movs	r1, #1
  4001e2:	4894      	ldr	r0, [pc, #592]	; (400434 <main+0x280>)
  4001e4:	4c8f      	ldr	r4, [pc, #572]	; (400424 <main+0x270>)
  4001e6:	47a0      	blx	r4
										  APP_VERSION_REV);
	printf("    SonicLib version: %u.%u.%u\n", SONICLIB_VER_MAJOR, 
  4001e8:	2308      	movs	r3, #8
  4001ea:	2201      	movs	r2, #1
  4001ec:	2102      	movs	r1, #2
  4001ee:	4892      	ldr	r0, [pc, #584]	; (400438 <main+0x284>)
  4001f0:	4c8c      	ldr	r4, [pc, #560]	; (400424 <main+0x270>)
  4001f2:	47a0      	blx	r4
										  SONICLIB_VER_MINOR, SONICLIB_VER_REV);
	printf("\n");
  4001f4:	4891      	ldr	r0, [pc, #580]	; (40043c <main+0x288>)
  4001f6:	4b8b      	ldr	r3, [pc, #556]	; (400424 <main+0x270>)
  4001f8:	4798      	blx	r3
	//uart_init(0, &uart_rx_buffer);
	
	/* Get the number of (possible) sensor devices on the board
	 *   Set by the BSP during chbsp_board_init() 
	 */
	num_ports = ch_get_num_ports(grp_ptr);
  4001fa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  4001fc:	4b90      	ldr	r3, [pc, #576]	; (400440 <main+0x28c>)
  4001fe:	4798      	blx	r3
  400200:	4603      	mov	r3, r0
  400202:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	 *   it will be added to, the device number within the group, and the sensor
	 *   firmware initialization routine that will be used.  (The sensor 
	 *   firmware selection effectively specifies whether it is a CH101 or 
	 *   CH201 sensor, as well as the exact feature set.)
	 */
	printf("Initializing sensor(s)... ");
  400206:	488f      	ldr	r0, [pc, #572]	; (400444 <main+0x290>)
  400208:	4b86      	ldr	r3, [pc, #536]	; (400424 <main+0x270>)
  40020a:	4798      	blx	r3

	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  40020c:	2300      	movs	r3, #0
  40020e:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  400212:	e01b      	b.n	40024c <main+0x98>
		ch_dev_t *dev_ptr = &(chirp_devices[dev_num]);	// init struct in array
  400214:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  400218:	4613      	mov	r3, r2
  40021a:	011b      	lsls	r3, r3, #4
  40021c:	1a9b      	subs	r3, r3, r2
  40021e:	011b      	lsls	r3, r3, #4
  400220:	4a89      	ldr	r2, [pc, #548]	; (400448 <main+0x294>)
  400222:	4413      	add	r3, r2
  400224:	623b      	str	r3, [r7, #32]
		 *
		 *   However, it is possible for different sensors to use different 
		 *   firmware images, by specifying different firmware init routines 
		 *   when ch_init() is called for each.
		 */
		chirp_error |= ch_init(dev_ptr, grp_ptr, dev_num, 
  400226:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  40022a:	4b88      	ldr	r3, [pc, #544]	; (40044c <main+0x298>)
  40022c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  40022e:	6a38      	ldr	r0, [r7, #32]
  400230:	4c87      	ldr	r4, [pc, #540]	; (400450 <main+0x29c>)
  400232:	47a0      	blx	r4
  400234:	4603      	mov	r3, r0
  400236:	461a      	mov	r2, r3
  400238:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40023c:	4313      	orrs	r3, r2
  40023e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  400242:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  400246:	3301      	adds	r3, #1
  400248:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  40024c:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  400250:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  400254:	429a      	cmp	r2, r3
  400256:	d3dd      	bcc.n	400214 <main+0x60>
	 *   the firmware specified above during ch_init()) and waits for it to 
	 *   perform a self-calibration step.  Then, once it has found all the 
	 *   sensors, ch_group_start() completes a timing reference calibration by 
	 *   applying a pulse of known length to the sensor's INT line.
	 */
	if (chirp_error == 0) {
  400258:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40025c:	2b00      	cmp	r3, #0
  40025e:	d108      	bne.n	400272 <main+0xbe>
		printf("starting group... ");
  400260:	487c      	ldr	r0, [pc, #496]	; (400454 <main+0x2a0>)
  400262:	4b70      	ldr	r3, [pc, #448]	; (400424 <main+0x270>)
  400264:	4798      	blx	r3
		chirp_error = ch_group_start(grp_ptr);
  400266:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  400268:	4b7b      	ldr	r3, [pc, #492]	; (400458 <main+0x2a4>)
  40026a:	4798      	blx	r3
  40026c:	4603      	mov	r3, r0
  40026e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	}

	if (chirp_error == 0) {
  400272:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  400276:	2b00      	cmp	r3, #0
  400278:	d103      	bne.n	400282 <main+0xce>
		printf("OK\n");
  40027a:	4878      	ldr	r0, [pc, #480]	; (40045c <main+0x2a8>)
  40027c:	4b69      	ldr	r3, [pc, #420]	; (400424 <main+0x270>)
  40027e:	4798      	blx	r3
  400280:	e005      	b.n	40028e <main+0xda>
	} else {
		printf("FAILED: %d\n", chirp_error);
  400282:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  400286:	4619      	mov	r1, r3
  400288:	4875      	ldr	r0, [pc, #468]	; (400460 <main+0x2ac>)
  40028a:	4b66      	ldr	r3, [pc, #408]	; (400424 <main+0x270>)
  40028c:	4798      	blx	r3
	}
	printf("\n");
  40028e:	486b      	ldr	r0, [pc, #428]	; (40043c <main+0x288>)
  400290:	4b64      	ldr	r3, [pc, #400]	; (400424 <main+0x270>)
  400292:	4798      	blx	r3
	 *   This loop checks each device number in the sensor group to determine 
	 *   if a sensor is actually connected.  If so, it makes a series of 
	 *   function calls to get different operating values, including the 
	 *   operating frequency, clock calibration values, and firmware version.
 	 */
	printf("Sensor\tType \t   Freq\t\t RTC Cal \tFirmware \t Scale Facto\n");
  400294:	4873      	ldr	r0, [pc, #460]	; (400464 <main+0x2b0>)
  400296:	4b63      	ldr	r3, [pc, #396]	; (400424 <main+0x270>)
  400298:	4798      	blx	r3

	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  40029a:	2300      	movs	r3, #0
  40029c:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  4002a0:	e039      	b.n	400316 <main+0x162>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  4002a2:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  4002a6:	4619      	mov	r1, r3
  4002a8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  4002aa:	4b6f      	ldr	r3, [pc, #444]	; (400468 <main+0x2b4>)
  4002ac:	4798      	blx	r3
  4002ae:	61f8      	str	r0, [r7, #28]
		
		if (ch_sensor_is_connected(dev_ptr)) {
  4002b0:	69f8      	ldr	r0, [r7, #28]
  4002b2:	4b6e      	ldr	r3, [pc, #440]	; (40046c <main+0x2b8>)
  4002b4:	4798      	blx	r3
  4002b6:	4603      	mov	r3, r0
  4002b8:	2b00      	cmp	r3, #0
  4002ba:	d027      	beq.n	40030c <main+0x158>
			printf("%d\tCH%d\t %u Hz\t%u@%ums\t%s\t%u\n", dev_num,
  4002bc:	f897 402e 	ldrb.w	r4, [r7, #46]	; 0x2e
									ch_get_part_number(dev_ptr),
  4002c0:	69f8      	ldr	r0, [r7, #28]
  4002c2:	4b6b      	ldr	r3, [pc, #428]	; (400470 <main+0x2bc>)
  4002c4:	4798      	blx	r3
  4002c6:	4603      	mov	r3, r0
			printf("%d\tCH%d\t %u Hz\t%u@%ums\t%s\t%u\n", dev_num,
  4002c8:	4698      	mov	r8, r3
									(unsigned int) ch_get_frequency(dev_ptr),
  4002ca:	69f8      	ldr	r0, [r7, #28]
  4002cc:	4b69      	ldr	r3, [pc, #420]	; (400474 <main+0x2c0>)
  4002ce:	4798      	blx	r3
  4002d0:	4681      	mov	r9, r0
									ch_get_rtc_cal_result(dev_ptr),
  4002d2:	69f8      	ldr	r0, [r7, #28]
  4002d4:	4b68      	ldr	r3, [pc, #416]	; (400478 <main+0x2c4>)
  4002d6:	4798      	blx	r3
  4002d8:	4603      	mov	r3, r0
			printf("%d\tCH%d\t %u Hz\t%u@%ums\t%s\t%u\n", dev_num,
  4002da:	461d      	mov	r5, r3
									ch_get_rtc_cal_pulselength(dev_ptr),
  4002dc:	69f8      	ldr	r0, [r7, #28]
  4002de:	4b67      	ldr	r3, [pc, #412]	; (40047c <main+0x2c8>)
  4002e0:	4798      	blx	r3
  4002e2:	4603      	mov	r3, r0
			printf("%d\tCH%d\t %u Hz\t%u@%ums\t%s\t%u\n", dev_num,
  4002e4:	461e      	mov	r6, r3
  4002e6:	69f8      	ldr	r0, [r7, #28]
  4002e8:	4b65      	ldr	r3, [pc, #404]	; (400480 <main+0x2cc>)
  4002ea:	4798      	blx	r3
  4002ec:	6078      	str	r0, [r7, #4]
									ch_get_fw_version_string(dev_ptr),
									ch_get_scale_factor(dev_ptr));	
  4002ee:	69f8      	ldr	r0, [r7, #28]
  4002f0:	4b64      	ldr	r3, [pc, #400]	; (400484 <main+0x2d0>)
  4002f2:	4798      	blx	r3
  4002f4:	4603      	mov	r3, r0
			printf("%d\tCH%d\t %u Hz\t%u@%ums\t%s\t%u\n", dev_num,
  4002f6:	9303      	str	r3, [sp, #12]
  4002f8:	687b      	ldr	r3, [r7, #4]
  4002fa:	9302      	str	r3, [sp, #8]
  4002fc:	9601      	str	r6, [sp, #4]
  4002fe:	9500      	str	r5, [sp, #0]
  400300:	464b      	mov	r3, r9
  400302:	4642      	mov	r2, r8
  400304:	4621      	mov	r1, r4
  400306:	4860      	ldr	r0, [pc, #384]	; (400488 <main+0x2d4>)
  400308:	4c46      	ldr	r4, [pc, #280]	; (400424 <main+0x270>)
  40030a:	47a0      	blx	r4
	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  40030c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  400310:	3301      	adds	r3, #1
  400312:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  400316:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  40031a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40031e:	429a      	cmp	r2, r3
  400320:	d3bf      	bcc.n	4002a2 <main+0xee>
			
		}
	}
	printf("\n");
  400322:	4846      	ldr	r0, [pc, #280]	; (40043c <main+0x288>)
  400324:	4b3f      	ldr	r3, [pc, #252]	; (400424 <main+0x270>)
  400326:	4798      	blx	r3
	
	
	/* Register callback function to be called when Chirp sensor interrupts */
	ch_io_int_callback_set(grp_ptr, sensor_int_callback);
  400328:	4958      	ldr	r1, [pc, #352]	; (40048c <main+0x2d8>)
  40032a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  40032c:	4b58      	ldr	r3, [pc, #352]	; (400490 <main+0x2dc>)
  40032e:	4798      	blx	r3

	/* Register callback function called when non-blocking I/Q readout completes
 	 *   Note, this callback will only be used if READ_IQ_DATA_NONBLOCK is 
	 *   defined to enable non-blocking I/Q readout in this application.
	 */
	ch_io_complete_callback_set(grp_ptr, io_complete_callback);
  400330:	4958      	ldr	r1, [pc, #352]	; (400494 <main+0x2e0>)
  400332:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  400334:	4b58      	ldr	r3, [pc, #352]	; (400498 <main+0x2e4>)
  400336:	4798      	blx	r3
	/* Configure each sensor with its operating parameters 
	 *   Initialize a ch_config_t structure with values defined in the
	 *   app_config.h header file, then write the configuration to the 
	 *   sensor using ch_set_config().
	 */
	printf ("Configuring sensor(s)...\n");
  400338:	4858      	ldr	r0, [pc, #352]	; (40049c <main+0x2e8>)
  40033a:	4b3a      	ldr	r3, [pc, #232]	; (400424 <main+0x270>)
  40033c:	4798      	blx	r3
	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  40033e:	2300      	movs	r3, #0
  400340:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  400344:	e0d0      	b.n	4004e8 <main+0x334>
		ch_config_t dev_config;
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  400346:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  40034a:	4619      	mov	r1, r3
  40034c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  40034e:	4b46      	ldr	r3, [pc, #280]	; (400468 <main+0x2b4>)
  400350:	4798      	blx	r3
  400352:	61b8      	str	r0, [r7, #24]

		if (ch_sensor_is_connected(dev_ptr)) {
  400354:	69b8      	ldr	r0, [r7, #24]
  400356:	4b45      	ldr	r3, [pc, #276]	; (40046c <main+0x2b8>)
  400358:	4798      	blx	r3
  40035a:	4603      	mov	r3, r0
  40035c:	2b00      	cmp	r3, #0
  40035e:	f000 80be 	beq.w	4004de <main+0x32a>
			 *   All connected sensors are placed in hardware triggered mode.
 	 		 *   The first connected (lowest numbered) sensor will transmit and 
			 *   receive, all others will only receive.
 	 		 */

			num_connected_sensors++;			// count one more connected
  400362:	4b4f      	ldr	r3, [pc, #316]	; (4004a0 <main+0x2ec>)
  400364:	781b      	ldrb	r3, [r3, #0]
  400366:	3301      	adds	r3, #1
  400368:	b2da      	uxtb	r2, r3
  40036a:	4b4d      	ldr	r3, [pc, #308]	; (4004a0 <main+0x2ec>)
  40036c:	701a      	strb	r2, [r3, #0]
			active_devices |= (1 << dev_num);	// add to active device bit mask
  40036e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  400372:	2201      	movs	r2, #1
  400374:	fa02 f303 	lsl.w	r3, r2, r3
  400378:	461a      	mov	r2, r3
  40037a:	4b4a      	ldr	r3, [pc, #296]	; (4004a4 <main+0x2f0>)
  40037c:	681b      	ldr	r3, [r3, #0]
  40037e:	4313      	orrs	r3, r2
  400380:	4a48      	ldr	r2, [pc, #288]	; (4004a4 <main+0x2f0>)
  400382:	6013      	str	r3, [r2, #0]
			
			if (num_connected_sensors == 1) {	// if this is the first sensor
  400384:	4b46      	ldr	r3, [pc, #280]	; (4004a0 <main+0x2ec>)
  400386:	781b      	ldrb	r3, [r3, #0]
  400388:	2b01      	cmp	r3, #1
  40038a:	d102      	bne.n	400392 <main+0x1de>
				dev_config.mode = CHIRP_FIRST_SENSOR_MODE;
  40038c:	2310      	movs	r3, #16
  40038e:	723b      	strb	r3, [r7, #8]
  400390:	e001      	b.n	400396 <main+0x1e2>
			} else {									
				dev_config.mode = CHIRP_OTHER_SENSOR_MODE;
  400392:	2320      	movs	r3, #32
  400394:	723b      	strb	r3, [r7, #8]
			}

			if (dev_config.mode != CH_MODE_FREERUN) {	// unless free-running
  400396:	7a3b      	ldrb	r3, [r7, #8]
  400398:	2b02      	cmp	r3, #2
  40039a:	d005      	beq.n	4003a8 <main+0x1f4>
				num_triggered_devices++;				// will be triggered
  40039c:	4b42      	ldr	r3, [pc, #264]	; (4004a8 <main+0x2f4>)
  40039e:	781b      	ldrb	r3, [r3, #0]
  4003a0:	3301      	adds	r3, #1
  4003a2:	b2da      	uxtb	r2, r3
  4003a4:	4b40      	ldr	r3, [pc, #256]	; (4004a8 <main+0x2f4>)
  4003a6:	701a      	strb	r2, [r3, #0]
			}

			/* Init config structure with values from app_config.h */
			dev_config.max_range       = CHIRP_SENSOR_MAX_RANGE_MM;
  4003a8:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
  4003ac:	817b      	strh	r3, [r7, #10]
			dev_config.static_range    = CHIRP_SENSOR_STATIC_RANGE;
  4003ae:	2300      	movs	r3, #0
  4003b0:	81bb      	strh	r3, [r7, #12]

			/* If sensor will be free-running, set internal sample interval */
			if (dev_config.mode == CH_MODE_FREERUN) {
  4003b2:	7a3b      	ldrb	r3, [r7, #8]
  4003b4:	2b02      	cmp	r3, #2
  4003b6:	d103      	bne.n	4003c0 <main+0x20c>
				dev_config.sample_interval = MEASUREMENT_INTERVAL_MS;
  4003b8:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
  4003bc:	81fb      	strh	r3, [r7, #14]
  4003be:	e001      	b.n	4003c4 <main+0x210>
			} else {
				dev_config.sample_interval = 0;
  4003c0:	2300      	movs	r3, #0
  4003c2:	81fb      	strh	r3, [r7, #14]
			}

			/* Set detection thresholds (CH201 only) */
			if (ch_get_part_number(dev_ptr) == CH201_PART_NUMBER) {
  4003c4:	69b8      	ldr	r0, [r7, #24]
  4003c6:	4b2a      	ldr	r3, [pc, #168]	; (400470 <main+0x2bc>)
  4003c8:	4798      	blx	r3
  4003ca:	4603      	mov	r3, r0
  4003cc:	2bc9      	cmp	r3, #201	; 0xc9
  4003ce:	d102      	bne.n	4003d6 <main+0x222>
				/* Set pointer to struct containing detection thresholds */
				dev_config.thresh_ptr = &chirp_ch201_thresholds;	
  4003d0:	4b36      	ldr	r3, [pc, #216]	; (4004ac <main+0x2f8>)
  4003d2:	613b      	str	r3, [r7, #16]
  4003d4:	e001      	b.n	4003da <main+0x226>
			} else {
				dev_config.thresh_ptr = 0;							
  4003d6:	2300      	movs	r3, #0
  4003d8:	613b      	str	r3, [r7, #16]
			}

			/* Apply sensor configuration */
			chirp_error = ch_set_config(dev_ptr, &dev_config);
  4003da:	f107 0308 	add.w	r3, r7, #8
  4003de:	4619      	mov	r1, r3
  4003e0:	69b8      	ldr	r0, [r7, #24]
  4003e2:	4b33      	ldr	r3, [pc, #204]	; (4004b0 <main+0x2fc>)
  4003e4:	4798      	blx	r3
  4003e6:	4603      	mov	r3, r0
  4003e8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

			/* Enable sensor interrupt if using free-running mode 
			 *   Note that interrupt is automatically enabled if using 
			 *   triggered modes.
			 */
			if ((!chirp_error) && (dev_config.mode == CH_MODE_FREERUN)) {
  4003ec:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4003f0:	2b00      	cmp	r3, #0
  4003f2:	d108      	bne.n	400406 <main+0x252>
  4003f4:	7a3b      	ldrb	r3, [r7, #8]
  4003f6:	2b02      	cmp	r3, #2
  4003f8:	d105      	bne.n	400406 <main+0x252>
				chbsp_set_io_dir_in(dev_ptr);
  4003fa:	69b8      	ldr	r0, [r7, #24]
  4003fc:	4b2d      	ldr	r3, [pc, #180]	; (4004b4 <main+0x300>)
  4003fe:	4798      	blx	r3
				chbsp_io_interrupt_enable(dev_ptr);
  400400:	69b8      	ldr	r0, [r7, #24]
  400402:	4b2d      	ldr	r3, [pc, #180]	; (4004b8 <main+0x304>)
  400404:	4798      	blx	r3
			}

			/* Read back and display config settings */
			if (!chirp_error) {
  400406:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40040a:	2b00      	cmp	r3, #0
  40040c:	d158      	bne.n	4004c0 <main+0x30c>
				ultrasound_display_config_info(dev_ptr);
  40040e:	69b8      	ldr	r0, [r7, #24]
  400410:	4b2a      	ldr	r3, [pc, #168]	; (4004bc <main+0x308>)
  400412:	4798      	blx	r3
  400414:	e05a      	b.n	4004cc <main+0x318>
  400416:	bf00      	nop
  400418:	20000440 	.word	0x20000440
  40041c:	00402041 	.word	0x00402041
  400420:	0040cebc 	.word	0x0040cebc
  400424:	00409ee9 	.word	0x00409ee9
  400428:	0040cef4 	.word	0x0040cef4
  40042c:	0040cf00 	.word	0x0040cf00
  400430:	0040cf0c 	.word	0x0040cf0c
  400434:	0040cf28 	.word	0x0040cf28
  400438:	0040cf40 	.word	0x0040cf40
  40043c:	0040cf60 	.word	0x0040cf60
  400440:	00405b6f 	.word	0x00405b6f
  400444:	0040cf64 	.word	0x0040cf64
  400448:	200024f4 	.word	0x200024f4
  40044c:	0040569d 	.word	0x0040569d
  400450:	004058d9 	.word	0x004058d9
  400454:	0040cf80 	.word	0x0040cf80
  400458:	00405a95 	.word	0x00405a95
  40045c:	0040cf94 	.word	0x0040cf94
  400460:	0040cf98 	.word	0x0040cf98
  400464:	0040cfa4 	.word	0x0040cfa4
  400468:	00405b1b 	.word	0x00405b1b
  40046c:	00405ad1 	.word	0x00405ad1
  400470:	00405ae9 	.word	0x00405ae9
  400474:	00405d5f 	.word	0x00405d5f
  400478:	00405d91 	.word	0x00405d91
  40047c:	00405d77 	.word	0x00405d77
  400480:	00405b87 	.word	0x00405b87
  400484:	00405da9 	.word	0x00405da9
  400488:	0040cfdc 	.word	0x0040cfdc
  40048c:	004005c5 	.word	0x004005c5
  400490:	00405f3f 	.word	0x00405f3f
  400494:	00400659 	.word	0x00400659
  400498:	00405f5b 	.word	0x00405f5b
  40049c:	0040cffc 	.word	0x0040cffc
  4004a0:	20000370 	.word	0x20000370
  4004a4:	20000368 	.word	0x20000368
  4004a8:	20000371 	.word	0x20000371
  4004ac:	200000fc 	.word	0x200000fc
  4004b0:	00405979 	.word	0x00405979
  4004b4:	00402145 	.word	0x00402145
  4004b8:	004024f5 	.word	0x004024f5
  4004bc:	00400935 	.word	0x00400935
			} else {
				printf("Device %d: Error during ch_set_config()\n", dev_num);
  4004c0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  4004c4:	4619      	mov	r1, r3
  4004c6:	4826      	ldr	r0, [pc, #152]	; (400560 <main+0x3ac>)
  4004c8:	4b26      	ldr	r3, [pc, #152]	; (400564 <main+0x3b0>)
  4004ca:	4798      	blx	r3
			}

			/* Turn on an LED to indicate device connected */
			if (!chirp_error) {
  4004cc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4004d0:	2b00      	cmp	r3, #0
  4004d2:	d104      	bne.n	4004de <main+0x32a>
				chbsp_led_on(dev_num);
  4004d4:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  4004d8:	4618      	mov	r0, r3
  4004da:	4b23      	ldr	r3, [pc, #140]	; (400568 <main+0x3b4>)
  4004dc:	4798      	blx	r3
	for (dev_num = 0; dev_num < num_ports; dev_num++) {
  4004de:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  4004e2:	3301      	adds	r3, #1
  4004e4:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  4004e8:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
  4004ec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  4004f0:	429a      	cmp	r2, r3
  4004f2:	f4ff af28 	bcc.w	400346 <main+0x192>
			}
		}
	}

	printf("\n");
  4004f6:	481d      	ldr	r0, [pc, #116]	; (40056c <main+0x3b8>)
  4004f8:	4b1a      	ldr	r3, [pc, #104]	; (400564 <main+0x3b0>)
  4004fa:	4798      	blx	r3

	/* Enable receive sensor pre-triggering, if specified */
	ch_set_rx_pretrigger(grp_ptr, RX_PRETRIGGER_ENABLE);
  4004fc:	2100      	movs	r1, #0
  4004fe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  400500:	4b1b      	ldr	r3, [pc, #108]	; (400570 <main+0x3bc>)
  400502:	4798      	blx	r3
	 *   registers a callback function that will be called from the timer 
	 *   handler when the interrupt occurs.  The callback function will be 
	 *   used to trigger a measurement cycle on the group of sensors.
	 */
	
	if (num_triggered_devices > 0) {
  400504:	4b1b      	ldr	r3, [pc, #108]	; (400574 <main+0x3c0>)
  400506:	781b      	ldrb	r3, [r3, #0]
  400508:	2b00      	cmp	r3, #0
  40050a:	d010      	beq.n	40052e <main+0x37a>
		printf("Initializing sample timer for %dms interval... ", 
  40050c:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
  400510:	4819      	ldr	r0, [pc, #100]	; (400578 <main+0x3c4>)
  400512:	4b14      	ldr	r3, [pc, #80]	; (400564 <main+0x3b0>)
  400514:	4798      	blx	r3
				MEASUREMENT_INTERVAL_MS);

		chbsp_periodic_timer_init(MEASUREMENT_INTERVAL_MS, 
  400516:	4919      	ldr	r1, [pc, #100]	; (40057c <main+0x3c8>)
  400518:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  40051c:	4b18      	ldr	r3, [pc, #96]	; (400580 <main+0x3cc>)
  40051e:	4798      	blx	r3
							      periodic_timer_callback);

		/* Enable interrupt and start timer to trigger sensor sampling */
		chbsp_periodic_timer_irq_enable();
  400520:	4b18      	ldr	r3, [pc, #96]	; (400584 <main+0x3d0>)
  400522:	4798      	blx	r3
		chbsp_periodic_timer_start();
  400524:	4b18      	ldr	r3, [pc, #96]	; (400588 <main+0x3d4>)
  400526:	4798      	blx	r3

		printf("OK\n");
  400528:	4818      	ldr	r0, [pc, #96]	; (40058c <main+0x3d8>)
  40052a:	4b0e      	ldr	r3, [pc, #56]	; (400564 <main+0x3b0>)
  40052c:	4798      	blx	r3
	}

	printf("Starting measurements\n");
  40052e:	4818      	ldr	r0, [pc, #96]	; (400590 <main+0x3dc>)
  400530:	4b0c      	ldr	r3, [pc, #48]	; (400564 <main+0x3b0>)
  400532:	4798      	blx	r3
		/*
		 * Put processor in light sleep mode if there are no pending tasks, but 
		 * never turn off the main clock, so that interrupts can still wake 
		 * the processor.
		 */
		if (taskflags==0) {
  400534:	4b17      	ldr	r3, [pc, #92]	; (400594 <main+0x3e0>)
  400536:	681b      	ldr	r3, [r3, #0]
  400538:	2b00      	cmp	r3, #0
  40053a:	d101      	bne.n	400540 <main+0x38c>
			chbsp_proc_sleep();			// put processor in low-power sleep mode
  40053c:	4b16      	ldr	r3, [pc, #88]	; (400598 <main+0x3e4>)
  40053e:	4798      	blx	r3

			/* We only continue here after an interrupt wakes the processor */
		}

		/* Check for sensor data-ready interrupt(s) */
		if (taskflags & DATA_READY_FLAG) {
  400540:	4b14      	ldr	r3, [pc, #80]	; (400594 <main+0x3e0>)
  400542:	681b      	ldr	r3, [r3, #0]
  400544:	f003 0301 	and.w	r3, r3, #1
  400548:	2b00      	cmp	r3, #0
  40054a:	d0f3      	beq.n	400534 <main+0x380>

			/* All sensors have interrupted - handle sensor data */
			taskflags &= ~DATA_READY_FLAG;		// clear flag
  40054c:	4b11      	ldr	r3, [pc, #68]	; (400594 <main+0x3e0>)
  40054e:	681b      	ldr	r3, [r3, #0]
  400550:	f023 0301 	bic.w	r3, r3, #1
  400554:	4a0f      	ldr	r2, [pc, #60]	; (400594 <main+0x3e0>)
  400556:	6013      	str	r3, [r2, #0]
			handle_data_ready(grp_ptr);			// read and display measurement
  400558:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  40055a:	4b10      	ldr	r3, [pc, #64]	; (40059c <main+0x3e8>)
  40055c:	4798      	blx	r3
		if (taskflags==0) {
  40055e:	e7e9      	b.n	400534 <main+0x380>
  400560:	0040d018 	.word	0x0040d018
  400564:	00409ee9 	.word	0x00409ee9
  400568:	00402f81 	.word	0x00402f81
  40056c:	0040cf60 	.word	0x0040cf60
  400570:	00406005 	.word	0x00406005
  400574:	20000371 	.word	0x20000371
  400578:	0040d044 	.word	0x0040d044
  40057c:	004005a1 	.word	0x004005a1
  400580:	00402c75 	.word	0x00402c75
  400584:	00402ebd 	.word	0x00402ebd
  400588:	00402ee5 	.word	0x00402ee5
  40058c:	0040cf94 	.word	0x0040cf94
  400590:	0040d074 	.word	0x0040d074
  400594:	20000364 	.word	0x20000364
  400598:	00402f6d 	.word	0x00402f6d
  40059c:	0040067d 	.word	0x0040067d

004005a0 <periodic_timer_callback>:
 *
 * This function is registered by the call to chbsp_periodic_timer_init() 
 * in main().
 */

void periodic_timer_callback(void) {
  4005a0:	b580      	push	{r7, lr}
  4005a2:	af00      	add	r7, sp, #0

	if (num_triggered_devices > 0) {
  4005a4:	4b04      	ldr	r3, [pc, #16]	; (4005b8 <periodic_timer_callback+0x18>)
  4005a6:	781b      	ldrb	r3, [r3, #0]
  4005a8:	2b00      	cmp	r3, #0
  4005aa:	d002      	beq.n	4005b2 <periodic_timer_callback+0x12>
		ch_group_trigger(&chirp_group);
  4005ac:	4803      	ldr	r0, [pc, #12]	; (4005bc <periodic_timer_callback+0x1c>)
  4005ae:	4b04      	ldr	r3, [pc, #16]	; (4005c0 <periodic_timer_callback+0x20>)
  4005b0:	4798      	blx	r3
	}
}
  4005b2:	bf00      	nop
  4005b4:	bd80      	pop	{r7, pc}
  4005b6:	bf00      	nop
  4005b8:	20000371 	.word	0x20000371
  4005bc:	20000440 	.word	0x20000440
  4005c0:	00405ab5 	.word	0x00405ab5

004005c4 <sensor_int_callback>:
 * DATA_READY_FLAG is set.  That flag will be detected in the main() loop.
 *
 * This callback function is registered by the call to ch_io_int_callback_set() 
 * in main().
 */
static void sensor_int_callback(ch_group_t *grp_ptr, uint8_t dev_num) {
  4005c4:	b580      	push	{r7, lr}
  4005c6:	b084      	sub	sp, #16
  4005c8:	af00      	add	r7, sp, #0
  4005ca:	6078      	str	r0, [r7, #4]
  4005cc:	460b      	mov	r3, r1
  4005ce:	70fb      	strb	r3, [r7, #3]
	ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  4005d0:	78fb      	ldrb	r3, [r7, #3]
  4005d2:	4619      	mov	r1, r3
  4005d4:	6878      	ldr	r0, [r7, #4]
  4005d6:	4b18      	ldr	r3, [pc, #96]	; (400638 <sensor_int_callback+0x74>)
  4005d8:	4798      	blx	r3
  4005da:	60f8      	str	r0, [r7, #12]
	
	data_ready_devices |= (1 << dev_num);		// add to data-ready bit mask
  4005dc:	78fb      	ldrb	r3, [r7, #3]
  4005de:	2201      	movs	r2, #1
  4005e0:	fa02 f303 	lsl.w	r3, r2, r3
  4005e4:	461a      	mov	r2, r3
  4005e6:	4b15      	ldr	r3, [pc, #84]	; (40063c <sensor_int_callback+0x78>)
  4005e8:	681b      	ldr	r3, [r3, #0]
  4005ea:	4313      	orrs	r3, r2
  4005ec:	4a13      	ldr	r2, [pc, #76]	; (40063c <sensor_int_callback+0x78>)
  4005ee:	6013      	str	r3, [r2, #0]
	if (data_ready_devices == active_devices) {
  4005f0:	4b12      	ldr	r3, [pc, #72]	; (40063c <sensor_int_callback+0x78>)
  4005f2:	681a      	ldr	r2, [r3, #0]
  4005f4:	4b12      	ldr	r3, [pc, #72]	; (400640 <sensor_int_callback+0x7c>)
  4005f6:	681b      	ldr	r3, [r3, #0]
  4005f8:	429a      	cmp	r2, r3
  4005fa:	d118      	bne.n	40062e <sensor_int_callback+0x6a>
		/* All active sensors have interrupted after performing a measurement */
		data_ready_devices = 0;
  4005fc:	4b0f      	ldr	r3, [pc, #60]	; (40063c <sensor_int_callback+0x78>)
  4005fe:	2200      	movs	r2, #0
  400600:	601a      	str	r2, [r3, #0]

		/* Set data-ready flag - it will be checked in main() loop */
		taskflags |= DATA_READY_FLAG;
  400602:	4b10      	ldr	r3, [pc, #64]	; (400644 <sensor_int_callback+0x80>)
  400604:	681b      	ldr	r3, [r3, #0]
  400606:	f043 0301 	orr.w	r3, r3, #1
  40060a:	4a0e      	ldr	r2, [pc, #56]	; (400644 <sensor_int_callback+0x80>)
  40060c:	6013      	str	r3, [r2, #0]

		/* Disable interrupt unless in free-running mode
			*   It will automatically be re-enabled by the next ch_group_trigger() 
			*/
		if (ch_get_mode(dev_ptr) == CH_MODE_FREERUN) {
  40060e:	68f8      	ldr	r0, [r7, #12]
  400610:	4b0d      	ldr	r3, [pc, #52]	; (400648 <sensor_int_callback+0x84>)
  400612:	4798      	blx	r3
  400614:	4603      	mov	r3, r0
  400616:	2b02      	cmp	r3, #2
  400618:	d106      	bne.n	400628 <sensor_int_callback+0x64>
			chbsp_set_io_dir_in(dev_ptr);				// set INT line as input
  40061a:	68f8      	ldr	r0, [r7, #12]
  40061c:	4b0b      	ldr	r3, [pc, #44]	; (40064c <sensor_int_callback+0x88>)
  40061e:	4798      	blx	r3
			chbsp_group_io_interrupt_enable(grp_ptr);
  400620:	6878      	ldr	r0, [r7, #4]
  400622:	4b0b      	ldr	r3, [pc, #44]	; (400650 <sensor_int_callback+0x8c>)
  400624:	4798      	blx	r3
		} else {
			
			chbsp_group_io_interrupt_disable(grp_ptr);
		}
	}
}
  400626:	e002      	b.n	40062e <sensor_int_callback+0x6a>
			chbsp_group_io_interrupt_disable(grp_ptr);
  400628:	6878      	ldr	r0, [r7, #4]
  40062a:	4b0a      	ldr	r3, [pc, #40]	; (400654 <sensor_int_callback+0x90>)
  40062c:	4798      	blx	r3
}
  40062e:	bf00      	nop
  400630:	3710      	adds	r7, #16
  400632:	46bd      	mov	sp, r7
  400634:	bd80      	pop	{r7, pc}
  400636:	bf00      	nop
  400638:	00405b1b 	.word	0x00405b1b
  40063c:	2000036c 	.word	0x2000036c
  400640:	20000368 	.word	0x20000368
  400644:	20000364 	.word	0x20000364
  400648:	00405b9f 	.word	0x00405b9f
  40064c:	00402145 	.word	0x00402145
  400650:	004024a9 	.word	0x004024a9
  400654:	00402555 	.word	0x00402555

00400658 <io_complete_callback>:
 * ch_io_complete_callback_set() in main().
 *
 *  Note: This callback is only used if READ_IQ_NONBLOCKING is defined to 
 *  select non-blocking I/Q readout in this application.
 */
static void io_complete_callback(ch_group_t __attribute__((unused)) *grp_ptr) {
  400658:	b480      	push	{r7}
  40065a:	b083      	sub	sp, #12
  40065c:	af00      	add	r7, sp, #0
  40065e:	6078      	str	r0, [r7, #4]

	taskflags |= IQ_READY_FLAG;
  400660:	4b05      	ldr	r3, [pc, #20]	; (400678 <io_complete_callback+0x20>)
  400662:	681b      	ldr	r3, [r3, #0]
  400664:	f043 0302 	orr.w	r3, r3, #2
  400668:	4a03      	ldr	r2, [pc, #12]	; (400678 <io_complete_callback+0x20>)
  40066a:	6013      	str	r3, [r2, #0]
}
  40066c:	bf00      	nop
  40066e:	370c      	adds	r7, #12
  400670:	46bd      	mov	sp, r7
  400672:	f85d 7b04 	ldr.w	r7, [sp], #4
  400676:	4770      	bx	lr
  400678:	20000364 	.word	0x20000364

0040067c <handle_data_ready>:
 *
 * See the comments in app_config.h for information about the amplitude data
 * and I/Q readout build options.
 *
 */
static uint8_t handle_data_ready(ch_group_t *grp_ptr) {
  40067c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
  400680:	b08a      	sub	sp, #40	; 0x28
  400682:	af04      	add	r7, sp, #16
  400684:	6078      	str	r0, [r7, #4]
	uint8_t 	dev_num;
	int 		num_samples = 0;
  400686:	2300      	movs	r3, #0
  400688:	613b      	str	r3, [r7, #16]
	uint8_t 	ret_val = 0;
  40068a:	2300      	movs	r3, #0
  40068c:	73fb      	strb	r3, [r7, #15]
	/* Read and display data from each connected sensor 
	 *   This loop will write the sensor data to this application's "chirp_data"
	 *   array.  Each sensor has a separate chirp_data_t structure in that 
	 *   array, so the device number is used as an index.
	 */
	printf("Outputting Measurement Results\n");
  40068e:	4861      	ldr	r0, [pc, #388]	; (400814 <handle_data_ready+0x198>)
  400690:	4b61      	ldr	r3, [pc, #388]	; (400818 <handle_data_ready+0x19c>)
  400692:	4798      	blx	r3
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  400694:	2300      	movs	r3, #0
  400696:	75fb      	strb	r3, [r7, #23]
  400698:	e0a9      	b.n	4007ee <handle_data_ready+0x172>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  40069a:	7dfb      	ldrb	r3, [r7, #23]
  40069c:	4619      	mov	r1, r3
  40069e:	6878      	ldr	r0, [r7, #4]
  4006a0:	4b5e      	ldr	r3, [pc, #376]	; (40081c <handle_data_ready+0x1a0>)
  4006a2:	4798      	blx	r3
  4006a4:	60b8      	str	r0, [r7, #8]

		if (ch_sensor_is_connected(dev_ptr)) {
  4006a6:	68b8      	ldr	r0, [r7, #8]
  4006a8:	4b5d      	ldr	r3, [pc, #372]	; (400820 <handle_data_ready+0x1a4>)
  4006aa:	4798      	blx	r3
  4006ac:	4603      	mov	r3, r0
  4006ae:	2b00      	cmp	r3, #0
  4006b0:	f000 809a 	beq.w	4007e8 <handle_data_ready+0x16c>
			 *   For sensor in transmit/receive mode, report one-way echo 
			 *   distance,  For sensor(s) in receive-only mode, report direct 
			 *   one-way distance from transmitting sensor 
			 */
			
			if (ch_get_mode(dev_ptr) == CH_MODE_TRIGGERED_RX_ONLY) {
  4006b4:	68b8      	ldr	r0, [r7, #8]
  4006b6:	4b5b      	ldr	r3, [pc, #364]	; (400824 <handle_data_ready+0x1a8>)
  4006b8:	4798      	blx	r3
  4006ba:	4603      	mov	r3, r0
  4006bc:	2b20      	cmp	r3, #32
  4006be:	d10d      	bne.n	4006dc <handle_data_ready+0x60>
				chirp_data[dev_num].range = ch_get_range(dev_ptr, 
  4006c0:	7dfc      	ldrb	r4, [r7, #23]
  4006c2:	2102      	movs	r1, #2
  4006c4:	68b8      	ldr	r0, [r7, #8]
  4006c6:	4b58      	ldr	r3, [pc, #352]	; (400828 <handle_data_ready+0x1ac>)
  4006c8:	4798      	blx	r3
  4006ca:	4601      	mov	r1, r0
  4006cc:	4a57      	ldr	r2, [pc, #348]	; (40082c <handle_data_ready+0x1b0>)
  4006ce:	f44f 63e2 	mov.w	r3, #1808	; 0x710
  4006d2:	fb03 f304 	mul.w	r3, r3, r4
  4006d6:	4413      	add	r3, r2
  4006d8:	6019      	str	r1, [r3, #0]
  4006da:	e00c      	b.n	4006f6 <handle_data_ready+0x7a>
														CH_RANGE_DIRECT);
			} else {
				chirp_data[dev_num].range = ch_get_range(dev_ptr, 
  4006dc:	7dfc      	ldrb	r4, [r7, #23]
  4006de:	2100      	movs	r1, #0
  4006e0:	68b8      	ldr	r0, [r7, #8]
  4006e2:	4b51      	ldr	r3, [pc, #324]	; (400828 <handle_data_ready+0x1ac>)
  4006e4:	4798      	blx	r3
  4006e6:	4601      	mov	r1, r0
  4006e8:	4a50      	ldr	r2, [pc, #320]	; (40082c <handle_data_ready+0x1b0>)
  4006ea:	f44f 63e2 	mov.w	r3, #1808	; 0x710
  4006ee:	fb03 f304 	mul.w	r3, r3, r4
  4006f2:	4413      	add	r3, r2
  4006f4:	6019      	str	r1, [r3, #0]
														CH_RANGE_ECHO_ONE_WAY);
			}

			if (chirp_data[dev_num].range == CH_NO_TARGET) {
  4006f6:	7dfb      	ldrb	r3, [r7, #23]
  4006f8:	4a4c      	ldr	r2, [pc, #304]	; (40082c <handle_data_ready+0x1b0>)
  4006fa:	f44f 61e2 	mov.w	r1, #1808	; 0x710
  4006fe:	fb01 f303 	mul.w	r3, r1, r3
  400702:	4413      	add	r3, r2
  400704:	681b      	ldr	r3, [r3, #0]
  400706:	f1b3 3fff 	cmp.w	r3, #4294967295
  40070a:	d10f      	bne.n	40072c <handle_data_ready+0xb0>
				/* No target object was detected - no range value */

				chirp_data[dev_num].amplitude = 0;  /* no updated amplitude */
  40070c:	7dfb      	ldrb	r3, [r7, #23]
  40070e:	4a47      	ldr	r2, [pc, #284]	; (40082c <handle_data_ready+0x1b0>)
  400710:	f44f 61e2 	mov.w	r1, #1808	; 0x710
  400714:	fb01 f303 	mul.w	r3, r1, r3
  400718:	4413      	add	r3, r2
  40071a:	3304      	adds	r3, #4
  40071c:	2200      	movs	r2, #0
  40071e:	801a      	strh	r2, [r3, #0]

				printf("Port %d:          no target found        ", dev_num);
  400720:	7dfb      	ldrb	r3, [r7, #23]
  400722:	4619      	mov	r1, r3
  400724:	4842      	ldr	r0, [pc, #264]	; (400830 <handle_data_ready+0x1b4>)
  400726:	4b3c      	ldr	r3, [pc, #240]	; (400818 <handle_data_ready+0x19c>)
  400728:	4798      	blx	r3
  40072a:	e042      	b.n	4007b2 <handle_data_ready+0x136>
			} else {
				/* Target object was successfully detected (range available) */

				 /* Get the new amplitude value - it's only updated if range 
				  * was successfully measured.  */
				chirp_data[dev_num].amplitude = ch_get_amplitude(dev_ptr);
  40072c:	7dfc      	ldrb	r4, [r7, #23]
  40072e:	68b8      	ldr	r0, [r7, #8]
  400730:	4b40      	ldr	r3, [pc, #256]	; (400834 <handle_data_ready+0x1b8>)
  400732:	4798      	blx	r3
  400734:	4603      	mov	r3, r0
  400736:	4619      	mov	r1, r3
  400738:	4a3c      	ldr	r2, [pc, #240]	; (40082c <handle_data_ready+0x1b0>)
  40073a:	f44f 63e2 	mov.w	r3, #1808	; 0x710
  40073e:	fb03 f304 	mul.w	r3, r3, r4
  400742:	4413      	add	r3, r2
  400744:	3304      	adds	r3, #4
  400746:	460a      	mov	r2, r1
  400748:	801a      	strh	r2, [r3, #0]
				//dev_ptr->store_scalefactor(dev_ptr);
				printf("Port %d:  Range: %0.1f mm  Amp: %u  Samples: %u  Op_freq: %lu  Bandwidth: %u", dev_num, 
  40074a:	7dfc      	ldrb	r4, [r7, #23]
						(float) chirp_data[dev_num].range/32.0f,
  40074c:	7dfb      	ldrb	r3, [r7, #23]
  40074e:	4a37      	ldr	r2, [pc, #220]	; (40082c <handle_data_ready+0x1b0>)
  400750:	f44f 61e2 	mov.w	r1, #1808	; 0x710
  400754:	fb01 f303 	mul.w	r3, r1, r3
  400758:	4413      	add	r3, r2
  40075a:	681b      	ldr	r3, [r3, #0]
  40075c:	ee07 3a90 	vmov	s15, r3
  400760:	eef8 7a67 	vcvt.f32.u32	s15, s15
  400764:	ed9f 7a34 	vldr	s14, [pc, #208]	; 400838 <handle_data_ready+0x1bc>
  400768:	eec7 6a87 	vdiv.f32	s13, s15, s14
				printf("Port %d:  Range: %0.1f mm  Amp: %u  Samples: %u  Op_freq: %lu  Bandwidth: %u", dev_num, 
  40076c:	4b33      	ldr	r3, [pc, #204]	; (40083c <handle_data_ready+0x1c0>)
  40076e:	ee16 0a90 	vmov	r0, s13
  400772:	4798      	blx	r3
  400774:	4680      	mov	r8, r0
  400776:	4689      	mov	r9, r1
					   	chirp_data[dev_num].amplitude, ch_get_num_samples(dev_ptr), dev_ptr->op_frequency, dev_ptr->bandwidth);
  400778:	7dfb      	ldrb	r3, [r7, #23]
  40077a:	4a2c      	ldr	r2, [pc, #176]	; (40082c <handle_data_ready+0x1b0>)
  40077c:	f44f 61e2 	mov.w	r1, #1808	; 0x710
  400780:	fb01 f303 	mul.w	r3, r1, r3
  400784:	4413      	add	r3, r2
  400786:	3304      	adds	r3, #4
  400788:	881b      	ldrh	r3, [r3, #0]
				printf("Port %d:  Range: %0.1f mm  Amp: %u  Samples: %u  Op_freq: %lu  Bandwidth: %u", dev_num, 
  40078a:	461d      	mov	r5, r3
					   	chirp_data[dev_num].amplitude, ch_get_num_samples(dev_ptr), dev_ptr->op_frequency, dev_ptr->bandwidth);
  40078c:	68b8      	ldr	r0, [r7, #8]
  40078e:	4b2c      	ldr	r3, [pc, #176]	; (400840 <handle_data_ready+0x1c4>)
  400790:	4798      	blx	r3
  400792:	4603      	mov	r3, r0
				printf("Port %d:  Range: %0.1f mm  Amp: %u  Samples: %u  Op_freq: %lu  Bandwidth: %u", dev_num, 
  400794:	4619      	mov	r1, r3
  400796:	68bb      	ldr	r3, [r7, #8]
  400798:	691b      	ldr	r3, [r3, #16]
					   	chirp_data[dev_num].amplitude, ch_get_num_samples(dev_ptr), dev_ptr->op_frequency, dev_ptr->bandwidth);
  40079a:	68ba      	ldr	r2, [r7, #8]
  40079c:	8a92      	ldrh	r2, [r2, #20]
				printf("Port %d:  Range: %0.1f mm  Amp: %u  Samples: %u  Op_freq: %lu  Bandwidth: %u", dev_num, 
  40079e:	9203      	str	r2, [sp, #12]
  4007a0:	9302      	str	r3, [sp, #8]
  4007a2:	9101      	str	r1, [sp, #4]
  4007a4:	9500      	str	r5, [sp, #0]
  4007a6:	4642      	mov	r2, r8
  4007a8:	464b      	mov	r3, r9
  4007aa:	4621      	mov	r1, r4
  4007ac:	4825      	ldr	r0, [pc, #148]	; (400844 <handle_data_ready+0x1c8>)
  4007ae:	4c1a      	ldr	r4, [pc, #104]	; (400818 <handle_data_ready+0x19c>)
  4007b0:	47a0      	blx	r4
			}

			/* Store number of active samples in this measurement */
			num_samples = ch_get_num_samples(dev_ptr);
  4007b2:	68b8      	ldr	r0, [r7, #8]
  4007b4:	4b22      	ldr	r3, [pc, #136]	; (400840 <handle_data_ready+0x1c4>)
  4007b6:	4798      	blx	r3
  4007b8:	4603      	mov	r3, r0
  4007ba:	613b      	str	r3, [r7, #16]
			chirp_data[dev_num].num_samples = num_samples;
  4007bc:	7dfb      	ldrb	r3, [r7, #23]
  4007be:	693a      	ldr	r2, [r7, #16]
  4007c0:	b290      	uxth	r0, r2
  4007c2:	4a1a      	ldr	r2, [pc, #104]	; (40082c <handle_data_ready+0x1b0>)
  4007c4:	f44f 61e2 	mov.w	r1, #1808	; 0x710
  4007c8:	fb01 f303 	mul.w	r3, r1, r3
  4007cc:	4413      	add	r3, r2
  4007ce:	3306      	adds	r3, #6
  4007d0:	4602      	mov	r2, r0
  4007d2:	801a      	strh	r2, [r3, #0]
#endif
#endif

			/* Optionally read raw I/Q values for all samples */
#ifdef READ_IQ_DATA
			display_iq_data(dev_ptr);
  4007d4:	68b8      	ldr	r0, [r7, #8]
  4007d6:	4b1c      	ldr	r3, [pc, #112]	; (400848 <handle_data_ready+0x1cc>)
  4007d8:	4798      	blx	r3
#endif
			/* If more than 2 sensors, put each on its own line */
			if (num_connected_sensors > 2) {
  4007da:	4b1c      	ldr	r3, [pc, #112]	; (40084c <handle_data_ready+0x1d0>)
  4007dc:	781b      	ldrb	r3, [r3, #0]
  4007de:	2b02      	cmp	r3, #2
  4007e0:	d902      	bls.n	4007e8 <handle_data_ready+0x16c>
				printf("\n");
  4007e2:	481b      	ldr	r0, [pc, #108]	; (400850 <handle_data_ready+0x1d4>)
  4007e4:	4b0c      	ldr	r3, [pc, #48]	; (400818 <handle_data_ready+0x19c>)
  4007e6:	4798      	blx	r3
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  4007e8:	7dfb      	ldrb	r3, [r7, #23]
  4007ea:	3301      	adds	r3, #1
  4007ec:	75fb      	strb	r3, [r7, #23]
  4007ee:	6878      	ldr	r0, [r7, #4]
  4007f0:	4b18      	ldr	r3, [pc, #96]	; (400854 <handle_data_ready+0x1d8>)
  4007f2:	4798      	blx	r3
  4007f4:	4603      	mov	r3, r0
  4007f6:	461a      	mov	r2, r3
  4007f8:	7dfb      	ldrb	r3, [r7, #23]
  4007fa:	4293      	cmp	r3, r2
  4007fc:	f4ff af4d 	bcc.w	40069a <handle_data_ready+0x1e>
			}
		}
	}
	printf("\n");
  400800:	4813      	ldr	r0, [pc, #76]	; (400850 <handle_data_ready+0x1d4>)
  400802:	4b05      	ldr	r3, [pc, #20]	; (400818 <handle_data_ready+0x19c>)
  400804:	4798      	blx	r3
	
	return ret_val;
  400806:	7bfb      	ldrb	r3, [r7, #15]
}
  400808:	4618      	mov	r0, r3
  40080a:	3718      	adds	r7, #24
  40080c:	46bd      	mov	sp, r7
  40080e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
  400812:	bf00      	nop
  400814:	0040d08c 	.word	0x0040d08c
  400818:	00409ee9 	.word	0x00409ee9
  40081c:	00405b1b 	.word	0x00405b1b
  400820:	00405ad1 	.word	0x00405ad1
  400824:	00405b9f 	.word	0x00405b9f
  400828:	00405cff 	.word	0x00405cff
  40082c:	200008b4 	.word	0x200008b4
  400830:	0040d0ac 	.word	0x0040d0ac
  400834:	00405d31 	.word	0x00405d31
  400838:	42000000 	.word	0x42000000
  40083c:	0040c515 	.word	0x0040c515
  400840:	00405c2f 	.word	0x00405c2f
  400844:	0040d0d8 	.word	0x0040d0d8
  400848:	00400859 	.word	0x00400859
  40084c:	20000370 	.word	0x20000370
  400850:	0040cf60 	.word	0x0040cf60
  400854:	00405b6f 	.word	0x00405b6f

00400858 <display_iq_data>:
 * If READ_IQ_NONBLOCKING is defined, the I/Q read operation will be queued
 * and this routine will return immediately.  A callback routine will be called
 * when the read operation is complete.  The callback routine must have been 
 * registered using the ch_io_complete_callback_set function.
 */
uint8_t display_iq_data(ch_dev_t *dev_ptr) {
  400858:	b590      	push	{r4, r7, lr}
  40085a:	b089      	sub	sp, #36	; 0x24
  40085c:	af02      	add	r7, sp, #8
  40085e:	6078      	str	r0, [r7, #4]
	uint16_t 	start_sample = 0;
  400860:	2300      	movs	r3, #0
  400862:	81fb      	strh	r3, [r7, #14]
	uint8_t 	error = 0;
  400864:	2300      	movs	r3, #0
  400866:	737b      	strb	r3, [r7, #13]
	uint16_t 	num_samples = ch_get_num_samples(dev_ptr);
  400868:	6878      	ldr	r0, [r7, #4]
  40086a:	4b29      	ldr	r3, [pc, #164]	; (400910 <display_iq_data+0xb8>)
  40086c:	4798      	blx	r3
  40086e:	4603      	mov	r3, r0
  400870:	817b      	strh	r3, [r7, #10]
	uint8_t		dev_num = ch_get_dev_num(dev_ptr);
  400872:	6878      	ldr	r0, [r7, #4]
  400874:	4b27      	ldr	r3, [pc, #156]	; (400914 <display_iq_data+0xbc>)
  400876:	4798      	blx	r3
  400878:	4603      	mov	r3, r0
  40087a:	727b      	strb	r3, [r7, #9]

#if defined(READ_IQ_BLOCKING)
	/* Reading I/Q data in normal, blocking mode */
	error = ch_get_iq_data(dev_ptr, chirp_data[dev_num].iq_data, 
  40087c:	7a7b      	ldrb	r3, [r7, #9]
  40087e:	f44f 62e2 	mov.w	r2, #1808	; 0x710
  400882:	fb02 f303 	mul.w	r3, r2, r3
  400886:	3308      	adds	r3, #8
  400888:	4a23      	ldr	r2, [pc, #140]	; (400918 <display_iq_data+0xc0>)
  40088a:	1899      	adds	r1, r3, r2
  40088c:	8978      	ldrh	r0, [r7, #10]
  40088e:	89fa      	ldrh	r2, [r7, #14]
  400890:	2300      	movs	r3, #0
  400892:	9300      	str	r3, [sp, #0]
  400894:	4603      	mov	r3, r0
  400896:	6878      	ldr	r0, [r7, #4]
  400898:	4c20      	ldr	r4, [pc, #128]	; (40091c <display_iq_data+0xc4>)
  40089a:	47a0      	blx	r4
  40089c:	4603      	mov	r3, r0
  40089e:	737b      	strb	r3, [r7, #13]
								start_sample, num_samples, CH_IO_MODE_BLOCK);
	if (!error) {
  4008a0:	7b7b      	ldrb	r3, [r7, #13]
  4008a2:	2b00      	cmp	r3, #0
  4008a4:	d129      	bne.n	4008fa <display_iq_data+0xa2>
		printf("     %d I/Q samples copied", num_samples);
  4008a6:	897b      	ldrh	r3, [r7, #10]
  4008a8:	4619      	mov	r1, r3
  4008aa:	481d      	ldr	r0, [pc, #116]	; (400920 <display_iq_data+0xc8>)
  4008ac:	4b1d      	ldr	r3, [pc, #116]	; (400924 <display_iq_data+0xcc>)
  4008ae:	4798      	blx	r3

#ifdef OUTPUT_IQ_DATA_CSV
		/* Output IQ values in CSV format, one pair (sample) per line */
		ch_iq_sample_t *iq_ptr;

		iq_ptr = (ch_iq_sample_t *) &(chirp_data[dev_num].iq_data);
  4008b0:	7a7b      	ldrb	r3, [r7, #9]
  4008b2:	f44f 62e2 	mov.w	r2, #1808	; 0x710
  4008b6:	fb02 f303 	mul.w	r3, r2, r3
  4008ba:	3308      	adds	r3, #8
  4008bc:	4a16      	ldr	r2, [pc, #88]	; (400918 <display_iq_data+0xc0>)
  4008be:	4413      	add	r3, r2
  4008c0:	617b      	str	r3, [r7, #20]
		printf("\n");
  4008c2:	4819      	ldr	r0, [pc, #100]	; (400928 <display_iq_data+0xd0>)
  4008c4:	4b17      	ldr	r3, [pc, #92]	; (400924 <display_iq_data+0xcc>)
  4008c6:	4798      	blx	r3
		for (int count = 0; count < num_samples; count++) {
  4008c8:	2300      	movs	r3, #0
  4008ca:	613b      	str	r3, [r7, #16]
  4008cc:	e010      	b.n	4008f0 <display_iq_data+0x98>
			printf("%d,%d\n", iq_ptr->q, iq_ptr->i);	// output Q before I
  4008ce:	697b      	ldr	r3, [r7, #20]
  4008d0:	f9b3 3000 	ldrsh.w	r3, [r3]
  4008d4:	4619      	mov	r1, r3
  4008d6:	697b      	ldr	r3, [r7, #20]
  4008d8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
  4008dc:	461a      	mov	r2, r3
  4008de:	4813      	ldr	r0, [pc, #76]	; (40092c <display_iq_data+0xd4>)
  4008e0:	4b10      	ldr	r3, [pc, #64]	; (400924 <display_iq_data+0xcc>)
  4008e2:	4798      	blx	r3
			iq_ptr++;
  4008e4:	697b      	ldr	r3, [r7, #20]
  4008e6:	3304      	adds	r3, #4
  4008e8:	617b      	str	r3, [r7, #20]
		for (int count = 0; count < num_samples; count++) {
  4008ea:	693b      	ldr	r3, [r7, #16]
  4008ec:	3301      	adds	r3, #1
  4008ee:	613b      	str	r3, [r7, #16]
  4008f0:	897a      	ldrh	r2, [r7, #10]
  4008f2:	693b      	ldr	r3, [r7, #16]
  4008f4:	429a      	cmp	r2, r3
  4008f6:	dcea      	bgt.n	4008ce <display_iq_data+0x76>
  4008f8:	e004      	b.n	400904 <display_iq_data+0xac>
		}
		
#endif
	} else {
		printf("     Error reading %d I/Q samples", num_samples);
  4008fa:	897b      	ldrh	r3, [r7, #10]
  4008fc:	4619      	mov	r1, r3
  4008fe:	480c      	ldr	r0, [pc, #48]	; (400930 <display_iq_data+0xd8>)
  400900:	4b08      	ldr	r3, [pc, #32]	; (400924 <display_iq_data+0xcc>)
  400902:	4798      	blx	r3
	} else {
		printf("**ERROR**");
	}
#endif  // defined(READ_IQ_BLOCKING)

	return error;
  400904:	7b7b      	ldrb	r3, [r7, #13]
}
  400906:	4618      	mov	r0, r3
  400908:	371c      	adds	r7, #28
  40090a:	46bd      	mov	sp, r7
  40090c:	bd90      	pop	{r4, r7, pc}
  40090e:	bf00      	nop
  400910:	00405c2f 	.word	0x00405c2f
  400914:	00405b01 	.word	0x00405b01
  400918:	200008b4 	.word	0x200008b4
  40091c:	00405dc1 	.word	0x00405dc1
  400920:	0040d128 	.word	0x0040d128
  400924:	00409ee9 	.word	0x00409ee9
  400928:	0040cf60 	.word	0x0040cf60
  40092c:	0040d144 	.word	0x0040d144
  400930:	0040d14c 	.word	0x0040d14c

00400934 <ultrasound_display_config_info>:
 * ________________________________________________________________________________________________________
 */
#include "ultrasound_display_config_info.h"

uint8_t ultrasound_display_config_info(ch_dev_t *dev_ptr)
{
  400934:	b590      	push	{r4, r7, lr}
  400936:	b091      	sub	sp, #68	; 0x44
  400938:	af00      	add	r7, sp, #0
  40093a:	6078      	str	r0, [r7, #4]
	ch_config_t 	read_config;
	uint8_t 		chirp_error;
	uint8_t 		dev_num = ch_get_dev_num(dev_ptr);
  40093c:	6878      	ldr	r0, [r7, #4]
  40093e:	4b5e      	ldr	r3, [pc, #376]	; (400ab8 <ultrasound_display_config_info+0x184>)
  400940:	4798      	blx	r3
  400942:	4603      	mov	r3, r0
  400944:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

	/* Read configuration values for the device into ch_config_t structure */
	chirp_error = ch_get_config(dev_ptr, &read_config);
  400948:	f107 0320 	add.w	r3, r7, #32
  40094c:	4619      	mov	r1, r3
  40094e:	6878      	ldr	r0, [r7, #4]
  400950:	4b5a      	ldr	r3, [pc, #360]	; (400abc <ultrasound_display_config_info+0x188>)
  400952:	4798      	blx	r3
  400954:	4603      	mov	r3, r0
  400956:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

	if (!chirp_error) {
  40095a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  40095e:	2b00      	cmp	r3, #0
  400960:	f040 809e 	bne.w	400aa0 <ultrasound_display_config_info+0x16c>
		const char *mode_string;

		switch (read_config.mode) {
  400964:	f897 3020 	ldrb.w	r3, [r7, #32]
  400968:	2b20      	cmp	r3, #32
  40096a:	d851      	bhi.n	400a10 <ultrasound_display_config_info+0xdc>
  40096c:	a201      	add	r2, pc, #4	; (adr r2, 400974 <ultrasound_display_config_info+0x40>)
  40096e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400972:	bf00      	nop
  400974:	004009f9 	.word	0x004009f9
  400978:	00400a11 	.word	0x00400a11
  40097c:	004009ff 	.word	0x004009ff
  400980:	00400a11 	.word	0x00400a11
  400984:	00400a11 	.word	0x00400a11
  400988:	00400a11 	.word	0x00400a11
  40098c:	00400a11 	.word	0x00400a11
  400990:	00400a11 	.word	0x00400a11
  400994:	00400a11 	.word	0x00400a11
  400998:	00400a11 	.word	0x00400a11
  40099c:	00400a11 	.word	0x00400a11
  4009a0:	00400a11 	.word	0x00400a11
  4009a4:	00400a11 	.word	0x00400a11
  4009a8:	00400a11 	.word	0x00400a11
  4009ac:	00400a11 	.word	0x00400a11
  4009b0:	00400a11 	.word	0x00400a11
  4009b4:	00400a05 	.word	0x00400a05
  4009b8:	00400a11 	.word	0x00400a11
  4009bc:	00400a11 	.word	0x00400a11
  4009c0:	00400a11 	.word	0x00400a11
  4009c4:	00400a11 	.word	0x00400a11
  4009c8:	00400a11 	.word	0x00400a11
  4009cc:	00400a11 	.word	0x00400a11
  4009d0:	00400a11 	.word	0x00400a11
  4009d4:	00400a11 	.word	0x00400a11
  4009d8:	00400a11 	.word	0x00400a11
  4009dc:	00400a11 	.word	0x00400a11
  4009e0:	00400a11 	.word	0x00400a11
  4009e4:	00400a11 	.word	0x00400a11
  4009e8:	00400a11 	.word	0x00400a11
  4009ec:	00400a11 	.word	0x00400a11
  4009f0:	00400a11 	.word	0x00400a11
  4009f4:	00400a0b 	.word	0x00400a0b
			case CH_MODE_IDLE:
				mode_string = "IDLE";
  4009f8:	4b31      	ldr	r3, [pc, #196]	; (400ac0 <ultrasound_display_config_info+0x18c>)
  4009fa:	63bb      	str	r3, [r7, #56]	; 0x38
				break;
  4009fc:	e00a      	b.n	400a14 <ultrasound_display_config_info+0xe0>
			case CH_MODE_FREERUN:
				mode_string = "FREERUN";
  4009fe:	4b31      	ldr	r3, [pc, #196]	; (400ac4 <ultrasound_display_config_info+0x190>)
  400a00:	63bb      	str	r3, [r7, #56]	; 0x38
				break;
  400a02:	e007      	b.n	400a14 <ultrasound_display_config_info+0xe0>
			case CH_MODE_TRIGGERED_TX_RX:
				mode_string = "TRIGGERED_TX_RX";
  400a04:	4b30      	ldr	r3, [pc, #192]	; (400ac8 <ultrasound_display_config_info+0x194>)
  400a06:	63bb      	str	r3, [r7, #56]	; 0x38
				break;
  400a08:	e004      	b.n	400a14 <ultrasound_display_config_info+0xe0>
			case CH_MODE_TRIGGERED_RX_ONLY:
				mode_string = "TRIGGERED_RX_ONLY";
  400a0a:	4b30      	ldr	r3, [pc, #192]	; (400acc <ultrasound_display_config_info+0x198>)
  400a0c:	63bb      	str	r3, [r7, #56]	; 0x38
				break;
  400a0e:	e001      	b.n	400a14 <ultrasound_display_config_info+0xe0>
			default:
				mode_string = "UNKNOWN";
  400a10:	4b2f      	ldr	r3, [pc, #188]	; (400ad0 <ultrasound_display_config_info+0x19c>)
  400a12:	63bb      	str	r3, [r7, #56]	; 0x38
		}

		/* Display sensor number, mode and max range */
		printf("Sensor %d:\tmax_range=%dmm \tmode=%s  ", dev_num,
  400a14:	f897 1033 	ldrb.w	r1, [r7, #51]	; 0x33
				read_config.max_range, mode_string);
  400a18:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
		printf("Sensor %d:\tmax_range=%dmm \tmode=%s  ", dev_num,
  400a1a:	461a      	mov	r2, r3
  400a1c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  400a1e:	482d      	ldr	r0, [pc, #180]	; (400ad4 <ultrasound_display_config_info+0x1a0>)
  400a20:	4c2d      	ldr	r4, [pc, #180]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400a22:	47a0      	blx	r4

		/* Display static target rejection range, if used */
		if (read_config.static_range != 0) {
  400a24:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  400a26:	2b00      	cmp	r3, #0
  400a28:	d004      	beq.n	400a34 <ultrasound_display_config_info+0x100>
			printf("static_range=%d samples", read_config.static_range);
  400a2a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  400a2c:	4619      	mov	r1, r3
  400a2e:	482b      	ldr	r0, [pc, #172]	; (400adc <ultrasound_display_config_info+0x1a8>)
  400a30:	4b29      	ldr	r3, [pc, #164]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400a32:	4798      	blx	r3
		}

		/* Display detection thresholds (only supported on CH201) */
		if (ch_get_part_number(dev_ptr) == CH201_PART_NUMBER) {
  400a34:	6878      	ldr	r0, [r7, #4]
  400a36:	4b2a      	ldr	r3, [pc, #168]	; (400ae0 <ultrasound_display_config_info+0x1ac>)
  400a38:	4798      	blx	r3
  400a3a:	4603      	mov	r3, r0
  400a3c:	2bc9      	cmp	r3, #201	; 0xc9
  400a3e:	d12b      	bne.n	400a98 <ultrasound_display_config_info+0x164>
			ch_thresholds_t read_thresholds;

			/* Get threshold values in structure */
			chirp_error = ch_get_thresholds(dev_ptr, &read_thresholds);
  400a40:	f107 0308 	add.w	r3, r7, #8
  400a44:	4619      	mov	r1, r3
  400a46:	6878      	ldr	r0, [r7, #4]
  400a48:	4b26      	ldr	r3, [pc, #152]	; (400ae4 <ultrasound_display_config_info+0x1b0>)
  400a4a:	4798      	blx	r3
  400a4c:	4603      	mov	r3, r0
  400a4e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

			if (!chirp_error) {
  400a52:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  400a56:	2b00      	cmp	r3, #0
  400a58:	d11e      	bne.n	400a98 <ultrasound_display_config_info+0x164>
				printf("\n  Detection thresholds:\n");
  400a5a:	4823      	ldr	r0, [pc, #140]	; (400ae8 <ultrasound_display_config_info+0x1b4>)
  400a5c:	4b1e      	ldr	r3, [pc, #120]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400a5e:	4798      	blx	r3
				for (int i = 0; i < CH_NUM_THRESHOLDS; i++) {
  400a60:	2300      	movs	r3, #0
  400a62:	637b      	str	r3, [r7, #52]	; 0x34
  400a64:	e015      	b.n	400a92 <ultrasound_display_config_info+0x15e>
					printf("     %d\tstart: %2d\tlevel: %d\n", i,
							read_thresholds.threshold[i].start_sample,
  400a66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400a68:	009b      	lsls	r3, r3, #2
  400a6a:	f107 0240 	add.w	r2, r7, #64	; 0x40
  400a6e:	4413      	add	r3, r2
  400a70:	f833 3c38 	ldrh.w	r3, [r3, #-56]
					printf("     %d\tstart: %2d\tlevel: %d\n", i,
  400a74:	461a      	mov	r2, r3
							read_thresholds.threshold[i].level);
  400a76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400a78:	009b      	lsls	r3, r3, #2
  400a7a:	f107 0140 	add.w	r1, r7, #64	; 0x40
  400a7e:	440b      	add	r3, r1
  400a80:	f833 3c36 	ldrh.w	r3, [r3, #-54]
					printf("     %d\tstart: %2d\tlevel: %d\n", i,
  400a84:	6b79      	ldr	r1, [r7, #52]	; 0x34
  400a86:	4819      	ldr	r0, [pc, #100]	; (400aec <ultrasound_display_config_info+0x1b8>)
  400a88:	4c13      	ldr	r4, [pc, #76]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400a8a:	47a0      	blx	r4
				for (int i = 0; i < CH_NUM_THRESHOLDS; i++) {
  400a8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400a8e:	3301      	adds	r3, #1
  400a90:	637b      	str	r3, [r7, #52]	; 0x34
  400a92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400a94:	2b05      	cmp	r3, #5
  400a96:	dde6      	ble.n	400a66 <ultrasound_display_config_info+0x132>
				}
			}
		}
		printf("\n");
  400a98:	4815      	ldr	r0, [pc, #84]	; (400af0 <ultrasound_display_config_info+0x1bc>)
  400a9a:	4b0f      	ldr	r3, [pc, #60]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400a9c:	4798      	blx	r3
  400a9e:	e005      	b.n	400aac <ultrasound_display_config_info+0x178>

	} else {
		printf(" Device %d: Error during ch_get_config()\n", dev_num);
  400aa0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
  400aa4:	4619      	mov	r1, r3
  400aa6:	4813      	ldr	r0, [pc, #76]	; (400af4 <ultrasound_display_config_info+0x1c0>)
  400aa8:	4b0b      	ldr	r3, [pc, #44]	; (400ad8 <ultrasound_display_config_info+0x1a4>)
  400aaa:	4798      	blx	r3
	}

	return chirp_error;
  400aac:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  400ab0:	4618      	mov	r0, r3
  400ab2:	3744      	adds	r7, #68	; 0x44
  400ab4:	46bd      	mov	sp, r7
  400ab6:	bd90      	pop	{r4, r7, pc}
  400ab8:	00405b01 	.word	0x00405b01
  400abc:	00405935 	.word	0x00405935
  400ac0:	0040d170 	.word	0x0040d170
  400ac4:	0040d178 	.word	0x0040d178
  400ac8:	0040d180 	.word	0x0040d180
  400acc:	0040d190 	.word	0x0040d190
  400ad0:	0040d1a4 	.word	0x0040d1a4
  400ad4:	0040d1ac 	.word	0x0040d1ac
  400ad8:	00409ee9 	.word	0x00409ee9
  400adc:	0040d1d4 	.word	0x0040d1d4
  400ae0:	00405ae9 	.word	0x00405ae9
  400ae4:	00405ecf 	.word	0x00405ecf
  400ae8:	0040d1ec 	.word	0x0040d1ec
  400aec:	0040d208 	.word	0x0040d208
  400af0:	0040d228 	.word	0x0040d228
  400af4:	0040d22c 	.word	0x0040d22c

00400af8 <time_get_in_us>:
 */
#include "time.h"
#include "time_hal.h"

uint64_t time_get_in_us(void)
{
  400af8:	b598      	push	{r3, r4, r7, lr}
  400afa:	af00      	add	r7, sp, #0
	return time_hal_get_in_us();
  400afc:	4b03      	ldr	r3, [pc, #12]	; (400b0c <time_get_in_us+0x14>)
  400afe:	4798      	blx	r3
  400b00:	4603      	mov	r3, r0
  400b02:	460c      	mov	r4, r1
  400b04:	4618      	mov	r0, r3
  400b06:	4621      	mov	r1, r4
  400b08:	bd98      	pop	{r3, r4, r7, pc}
  400b0a:	bf00      	nop
  400b0c:	00402ff1 	.word	0x00402ff1

00400b10 <osc_enable>:
#define OSC_MAINCK_XTAL_HZ          BOARD_FREQ_MAINCK_XTAL          //!< External crystal oscillator.
#define OSC_MAINCK_BYPASS_HZ        BOARD_FREQ_MAINCK_BYPASS        //!< External bypass oscillator.
//@}

static inline void osc_enable(uint32_t ul_id)
{
  400b10:	b580      	push	{r7, lr}
  400b12:	b082      	sub	sp, #8
  400b14:	af00      	add	r7, sp, #0
  400b16:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400b18:	687b      	ldr	r3, [r7, #4]
  400b1a:	2b07      	cmp	r3, #7
  400b1c:	d831      	bhi.n	400b82 <osc_enable+0x72>
  400b1e:	a201      	add	r2, pc, #4	; (adr r2, 400b24 <osc_enable+0x14>)
  400b20:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400b24:	00400b81 	.word	0x00400b81
  400b28:	00400b45 	.word	0x00400b45
  400b2c:	00400b4d 	.word	0x00400b4d
  400b30:	00400b55 	.word	0x00400b55
  400b34:	00400b5d 	.word	0x00400b5d
  400b38:	00400b65 	.word	0x00400b65
  400b3c:	00400b6d 	.word	0x00400b6d
  400b40:	00400b77 	.word	0x00400b77
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  400b44:	2000      	movs	r0, #0
  400b46:	4b11      	ldr	r3, [pc, #68]	; (400b8c <osc_enable+0x7c>)
  400b48:	4798      	blx	r3
		break;
  400b4a:	e01a      	b.n	400b82 <osc_enable+0x72>

	case OSC_SLCK_32K_BYPASS:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  400b4c:	2001      	movs	r0, #1
  400b4e:	4b0f      	ldr	r3, [pc, #60]	; (400b8c <osc_enable+0x7c>)
  400b50:	4798      	blx	r3
		break;
  400b52:	e016      	b.n	400b82 <osc_enable+0x72>


	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  400b54:	2000      	movs	r0, #0
  400b56:	4b0e      	ldr	r3, [pc, #56]	; (400b90 <osc_enable+0x80>)
  400b58:	4798      	blx	r3
		break;
  400b5a:	e012      	b.n	400b82 <osc_enable+0x72>

	case OSC_MAINCK_16M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_16_MHz);
  400b5c:	2010      	movs	r0, #16
  400b5e:	4b0c      	ldr	r3, [pc, #48]	; (400b90 <osc_enable+0x80>)
  400b60:	4798      	blx	r3
		break;
  400b62:	e00e      	b.n	400b82 <osc_enable+0x72>

	case OSC_MAINCK_24M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_24_MHz);
  400b64:	2020      	movs	r0, #32
  400b66:	4b0a      	ldr	r3, [pc, #40]	; (400b90 <osc_enable+0x80>)
  400b68:	4798      	blx	r3
		break;
  400b6a:	e00a      	b.n	400b82 <osc_enable+0x72>


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  400b6c:	213e      	movs	r1, #62	; 0x3e
  400b6e:	2000      	movs	r0, #0
  400b70:	4b08      	ldr	r3, [pc, #32]	; (400b94 <osc_enable+0x84>)
  400b72:	4798      	blx	r3
			pmc_us_to_moscxtst(BOARD_OSC_STARTUP_US,
				OSC_SLCK_32K_RC_HZ));
		break;
  400b74:	e005      	b.n	400b82 <osc_enable+0x72>

	case OSC_MAINCK_BYPASS:
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  400b76:	213e      	movs	r1, #62	; 0x3e
  400b78:	2001      	movs	r0, #1
  400b7a:	4b06      	ldr	r3, [pc, #24]	; (400b94 <osc_enable+0x84>)
  400b7c:	4798      	blx	r3
			pmc_us_to_moscxtst(BOARD_OSC_STARTUP_US,
				OSC_SLCK_32K_RC_HZ));
		break;
  400b7e:	e000      	b.n	400b82 <osc_enable+0x72>
		break;
  400b80:	bf00      	nop
	}
}
  400b82:	bf00      	nop
  400b84:	3708      	adds	r7, #8
  400b86:	46bd      	mov	sp, r7
  400b88:	bd80      	pop	{r7, pc}
  400b8a:	bf00      	nop
  400b8c:	00404281 	.word	0x00404281
  400b90:	004042ed 	.word	0x004042ed
  400b94:	0040435d 	.word	0x0040435d

00400b98 <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint32_t ul_id)
{
  400b98:	b580      	push	{r7, lr}
  400b9a:	b082      	sub	sp, #8
  400b9c:	af00      	add	r7, sp, #0
  400b9e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400ba0:	687b      	ldr	r3, [r7, #4]
  400ba2:	2b07      	cmp	r3, #7
  400ba4:	d826      	bhi.n	400bf4 <osc_is_ready+0x5c>
  400ba6:	a201      	add	r2, pc, #4	; (adr r2, 400bac <osc_is_ready+0x14>)
  400ba8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400bac:	00400bcd 	.word	0x00400bcd
  400bb0:	00400bd1 	.word	0x00400bd1
  400bb4:	00400bd1 	.word	0x00400bd1
  400bb8:	00400be3 	.word	0x00400be3
  400bbc:	00400be3 	.word	0x00400be3
  400bc0:	00400be3 	.word	0x00400be3
  400bc4:	00400be3 	.word	0x00400be3
  400bc8:	00400be3 	.word	0x00400be3
	case OSC_SLCK_32K_RC:
		return 1;
  400bcc:	2301      	movs	r3, #1
  400bce:	e012      	b.n	400bf6 <osc_is_ready+0x5e>

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  400bd0:	4b0b      	ldr	r3, [pc, #44]	; (400c00 <osc_is_ready+0x68>)
  400bd2:	4798      	blx	r3
  400bd4:	4603      	mov	r3, r0
  400bd6:	2b00      	cmp	r3, #0
  400bd8:	bf14      	ite	ne
  400bda:	2301      	movne	r3, #1
  400bdc:	2300      	moveq	r3, #0
  400bde:	b2db      	uxtb	r3, r3
  400be0:	e009      	b.n	400bf6 <osc_is_ready+0x5e>
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_16M_RC:
	case OSC_MAINCK_24M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  400be2:	4b08      	ldr	r3, [pc, #32]	; (400c04 <osc_is_ready+0x6c>)
  400be4:	4798      	blx	r3
  400be6:	4603      	mov	r3, r0
  400be8:	2b00      	cmp	r3, #0
  400bea:	bf14      	ite	ne
  400bec:	2301      	movne	r3, #1
  400bee:	2300      	moveq	r3, #0
  400bf0:	b2db      	uxtb	r3, r3
  400bf2:	e000      	b.n	400bf6 <osc_is_ready+0x5e>
	}

	return 0;
  400bf4:	2300      	movs	r3, #0
}
  400bf6:	4618      	mov	r0, r3
  400bf8:	3708      	adds	r7, #8
  400bfa:	46bd      	mov	sp, r7
  400bfc:	bd80      	pop	{r7, pc}
  400bfe:	bf00      	nop
  400c00:	004042b9 	.word	0x004042b9
  400c04:	004043d5 	.word	0x004043d5

00400c08 <osc_get_rate>:

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400c08:	b480      	push	{r7}
  400c0a:	b083      	sub	sp, #12
  400c0c:	af00      	add	r7, sp, #0
  400c0e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400c10:	687b      	ldr	r3, [r7, #4]
  400c12:	2b07      	cmp	r3, #7
  400c14:	d825      	bhi.n	400c62 <osc_get_rate+0x5a>
  400c16:	a201      	add	r2, pc, #4	; (adr r2, 400c1c <osc_get_rate+0x14>)
  400c18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400c1c:	00400c3d 	.word	0x00400c3d
  400c20:	00400c43 	.word	0x00400c43
  400c24:	00400c49 	.word	0x00400c49
  400c28:	00400c4f 	.word	0x00400c4f
  400c2c:	00400c53 	.word	0x00400c53
  400c30:	00400c57 	.word	0x00400c57
  400c34:	00400c5b 	.word	0x00400c5b
  400c38:	00400c5f 	.word	0x00400c5f
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400c3c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400c40:	e010      	b.n	400c64 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400c42:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400c46:	e00d      	b.n	400c64 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400c48:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400c4c:	e00a      	b.n	400c64 <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400c4e:	4b08      	ldr	r3, [pc, #32]	; (400c70 <osc_get_rate+0x68>)
  400c50:	e008      	b.n	400c64 <osc_get_rate+0x5c>

	case OSC_MAINCK_16M_RC:
		return OSC_MAINCK_16M_RC_HZ;
  400c52:	4b08      	ldr	r3, [pc, #32]	; (400c74 <osc_get_rate+0x6c>)
  400c54:	e006      	b.n	400c64 <osc_get_rate+0x5c>

	case OSC_MAINCK_24M_RC:
		return OSC_MAINCK_24M_RC_HZ;
  400c56:	4b08      	ldr	r3, [pc, #32]	; (400c78 <osc_get_rate+0x70>)
  400c58:	e004      	b.n	400c64 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400c5a:	2300      	movs	r3, #0
  400c5c:	e002      	b.n	400c64 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400c5e:	2300      	movs	r3, #0
  400c60:	e000      	b.n	400c64 <osc_get_rate+0x5c>
#endif
	}

	return 0;
  400c62:	2300      	movs	r3, #0
}
  400c64:	4618      	mov	r0, r3
  400c66:	370c      	adds	r7, #12
  400c68:	46bd      	mov	sp, r7
  400c6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  400c6e:	4770      	bx	lr
  400c70:	007a1200 	.word	0x007a1200
  400c74:	00f42400 	.word	0x00f42400
  400c78:	016e3600 	.word	0x016e3600

00400c7c <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  400c7c:	b580      	push	{r7, lr}
  400c7e:	b082      	sub	sp, #8
  400c80:	af00      	add	r7, sp, #0
  400c82:	4603      	mov	r3, r0
  400c84:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  400c86:	bf00      	nop
  400c88:	79fb      	ldrb	r3, [r7, #7]
  400c8a:	4618      	mov	r0, r3
  400c8c:	4b05      	ldr	r3, [pc, #20]	; (400ca4 <osc_wait_ready+0x28>)
  400c8e:	4798      	blx	r3
  400c90:	4603      	mov	r3, r0
  400c92:	f083 0301 	eor.w	r3, r3, #1
  400c96:	b2db      	uxtb	r3, r3
  400c98:	2b00      	cmp	r3, #0
  400c9a:	d1f5      	bne.n	400c88 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  400c9c:	bf00      	nop
  400c9e:	3708      	adds	r7, #8
  400ca0:	46bd      	mov	sp, r7
  400ca2:	bd80      	pop	{r7, pc}
  400ca4:	00400b99 	.word	0x00400b99

00400ca8 <pll_config_init>:
 * \note The SAMG PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  400ca8:	b580      	push	{r7, lr}
  400caa:	b086      	sub	sp, #24
  400cac:	af00      	add	r7, sp, #0
  400cae:	60f8      	str	r0, [r7, #12]
  400cb0:	607a      	str	r2, [r7, #4]
  400cb2:	603b      	str	r3, [r7, #0]
  400cb4:	460b      	mov	r3, r1
  400cb6:	72fb      	strb	r3, [r7, #11]

	Assert(e_src < PLL_NR_SOURCES);
	Assert(ul_div < 2);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  400cb8:	7afb      	ldrb	r3, [r7, #11]
  400cba:	4618      	mov	r0, r3
  400cbc:	4b0d      	ldr	r3, [pc, #52]	; (400cf4 <pll_config_init+0x4c>)
  400cbe:	4798      	blx	r3
  400cc0:	4602      	mov	r2, r0
  400cc2:	687b      	ldr	r3, [r7, #4]
  400cc4:	fbb2 f3f3 	udiv	r3, r2, r3
  400cc8:	617b      	str	r3, [r7, #20]

	vco_hz *= ul_mul;
  400cca:	697b      	ldr	r3, [r7, #20]
  400ccc:	683a      	ldr	r2, [r7, #0]
  400cce:	fb02 f303 	mul.w	r3, r2, r3
  400cd2:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= (PLL_OUTPUT_MIN_HZ - (PLL_OUTPUT_MIN_HZ >> 6)));
	Assert(vco_hz <= (PLL_OUTPUT_MAX_HZ + (PLL_OUTPUT_MAX_HZ >> 6)));

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_PLLAEN(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  400cd4:	683b      	ldr	r3, [r7, #0]
  400cd6:	3b01      	subs	r3, #1
  400cd8:	041a      	lsls	r2, r3, #16
  400cda:	4b07      	ldr	r3, [pc, #28]	; (400cf8 <pll_config_init+0x50>)
  400cdc:	4013      	ands	r3, r2
  400cde:	687a      	ldr	r2, [r7, #4]
  400ce0:	b2d2      	uxtb	r2, r2
  400ce2:	4313      	orrs	r3, r2
  400ce4:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  400ce8:	68fb      	ldr	r3, [r7, #12]
  400cea:	601a      	str	r2, [r3, #0]
}
  400cec:	bf00      	nop
  400cee:	3718      	adds	r7, #24
  400cf0:	46bd      	mov	sp, r7
  400cf2:	bd80      	pop	{r7, pc}
  400cf4:	00400c09 	.word	0x00400c09
  400cf8:	1fff0000 	.word	0x1fff0000

00400cfc <pll_enable>:
#endif
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  400cfc:	b580      	push	{r7, lr}
  400cfe:	b082      	sub	sp, #8
  400d00:	af00      	add	r7, sp, #0
  400d02:	6078      	str	r0, [r7, #4]
  400d04:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  400d06:	683b      	ldr	r3, [r7, #0]
  400d08:	2b00      	cmp	r3, #0
  400d0a:	d106      	bne.n	400d1a <pll_enable+0x1e>
		pmc_disable_pllack(); // Always stop PLL first!
  400d0c:	4b08      	ldr	r3, [pc, #32]	; (400d30 <pll_enable+0x34>)
  400d0e:	4798      	blx	r3
		PMC->CKGR_PLLAR = p_cfg->ctrl;
  400d10:	4a08      	ldr	r2, [pc, #32]	; (400d34 <pll_enable+0x38>)
  400d12:	687b      	ldr	r3, [r7, #4]
  400d14:	681b      	ldr	r3, [r3, #0]
  400d16:	6293      	str	r3, [r2, #40]	; 0x28
	} else {
		pmc_disable_pllbck(); // Always stop PLL first!
		PMC->CKGR_PLLBR = p_cfg->ctrl;
#endif
	}
}
  400d18:	e005      	b.n	400d26 <pll_enable+0x2a>
		pmc_disable_pllbck(); // Always stop PLL first!
  400d1a:	4b07      	ldr	r3, [pc, #28]	; (400d38 <pll_enable+0x3c>)
  400d1c:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  400d1e:	4a05      	ldr	r2, [pc, #20]	; (400d34 <pll_enable+0x38>)
  400d20:	687b      	ldr	r3, [r7, #4]
  400d22:	681b      	ldr	r3, [r3, #0]
  400d24:	62d3      	str	r3, [r2, #44]	; 0x2c
}
  400d26:	bf00      	nop
  400d28:	3708      	adds	r7, #8
  400d2a:	46bd      	mov	sp, r7
  400d2c:	bd80      	pop	{r7, pc}
  400d2e:	bf00      	nop
  400d30:	004043f1 	.word	0x004043f1
  400d34:	400e0400 	.word	0x400e0400
  400d38:	00404425 	.word	0x00404425

00400d3c <pll_is_locked>:
#endif
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  400d3c:	b580      	push	{r7, lr}
  400d3e:	b082      	sub	sp, #8
  400d40:	af00      	add	r7, sp, #0
  400d42:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  400d44:	687b      	ldr	r3, [r7, #4]
  400d46:	2b00      	cmp	r3, #0
  400d48:	d103      	bne.n	400d52 <pll_is_locked+0x16>
		return pmc_is_locked_pllack();
  400d4a:	4b08      	ldr	r3, [pc, #32]	; (400d6c <pll_is_locked+0x30>)
  400d4c:	4798      	blx	r3
  400d4e:	4603      	mov	r3, r0
  400d50:	e007      	b.n	400d62 <pll_is_locked+0x26>
#if SAMG55
	} else if (ul_pll_id == PLLB_ID) {
  400d52:	687b      	ldr	r3, [r7, #4]
  400d54:	2b01      	cmp	r3, #1
  400d56:	d103      	bne.n	400d60 <pll_is_locked+0x24>
		return pmc_is_locked_pllbck();
  400d58:	4b05      	ldr	r3, [pc, #20]	; (400d70 <pll_is_locked+0x34>)
  400d5a:	4798      	blx	r3
  400d5c:	4603      	mov	r3, r0
  400d5e:	e000      	b.n	400d62 <pll_is_locked+0x26>
#endif
	} else {
		return 0;
  400d60:	2300      	movs	r3, #0
	}
}
  400d62:	4618      	mov	r0, r3
  400d64:	3708      	adds	r7, #8
  400d66:	46bd      	mov	sp, r7
  400d68:	bd80      	pop	{r7, pc}
  400d6a:	bf00      	nop
  400d6c:	00404409 	.word	0x00404409
  400d70:	0040443d 	.word	0x0040443d

00400d74 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  400d74:	b580      	push	{r7, lr}
  400d76:	b082      	sub	sp, #8
  400d78:	af00      	add	r7, sp, #0
  400d7a:	4603      	mov	r3, r0
  400d7c:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  400d7e:	79fb      	ldrb	r3, [r7, #7]
  400d80:	3300      	adds	r3, #0
  400d82:	2b01      	cmp	r3, #1
  400d84:	d808      	bhi.n	400d98 <pll_enable_source+0x24>
	case PLL_SRC_SLCK_RC:
	case PLL_SRC_SLCK_XTAL:
		osc_enable(e_src);
  400d86:	79fb      	ldrb	r3, [r7, #7]
  400d88:	4618      	mov	r0, r3
  400d8a:	4b06      	ldr	r3, [pc, #24]	; (400da4 <pll_enable_source+0x30>)
  400d8c:	4798      	blx	r3
		osc_wait_ready(e_src);
  400d8e:	79fb      	ldrb	r3, [r7, #7]
  400d90:	4618      	mov	r0, r3
  400d92:	4b05      	ldr	r3, [pc, #20]	; (400da8 <pll_enable_source+0x34>)
  400d94:	4798      	blx	r3
		break;
  400d96:	e000      	b.n	400d9a <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  400d98:	bf00      	nop
	}
}
  400d9a:	bf00      	nop
  400d9c:	3708      	adds	r7, #8
  400d9e:	46bd      	mov	sp, r7
  400da0:	bd80      	pop	{r7, pc}
  400da2:	bf00      	nop
  400da4:	00400b11 	.word	0x00400b11
  400da8:	00400c7d 	.word	0x00400c7d

00400dac <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  400dac:	b580      	push	{r7, lr}
  400dae:	b082      	sub	sp, #8
  400db0:	af00      	add	r7, sp, #0
  400db2:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400db4:	bf00      	nop
  400db6:	6878      	ldr	r0, [r7, #4]
  400db8:	4b04      	ldr	r3, [pc, #16]	; (400dcc <pll_wait_for_lock+0x20>)
  400dba:	4798      	blx	r3
  400dbc:	4603      	mov	r3, r0
  400dbe:	2b00      	cmp	r3, #0
  400dc0:	d0f9      	beq.n	400db6 <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  400dc2:	2300      	movs	r3, #0
}
  400dc4:	4618      	mov	r0, r3
  400dc6:	3708      	adds	r7, #8
  400dc8:	46bd      	mov	sp, r7
  400dca:	bd80      	pop	{r7, pc}
  400dcc:	00400d3d 	.word	0x00400d3d

00400dd0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400dd0:	b580      	push	{r7, lr}
  400dd2:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  400dd4:	2001      	movs	r0, #1
  400dd6:	4b04      	ldr	r3, [pc, #16]	; (400de8 <sysclk_get_main_hz+0x18>)
  400dd8:	4798      	blx	r3
  400dda:	4602      	mov	r2, r0
  400ddc:	f640 634e 	movw	r3, #3662	; 0xe4e
  400de0:	fb03 f302 	mul.w	r3, r3, r2

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400de4:	4618      	mov	r0, r3
  400de6:	bd80      	pop	{r7, pc}
  400de8:	00400c09 	.word	0x00400c09

00400dec <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400dec:	b580      	push	{r7, lr}
  400dee:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400df0:	4b02      	ldr	r3, [pc, #8]	; (400dfc <sysclk_get_cpu_hz+0x10>)
  400df2:	4798      	blx	r3
  400df4:	4603      	mov	r3, r0
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400df6:	4618      	mov	r0, r3
  400df8:	bd80      	pop	{r7, pc}
  400dfa:	bf00      	nop
  400dfc:	00400dd1 	.word	0x00400dd1

00400e00 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE
#endif

void sysclk_init(void)
{
  400e00:	b590      	push	{r4, r7, lr}
  400e02:	b0a5      	sub	sp, #148	; 0x94
  400e04:	af02      	add	r7, sp, #8
	uint32_t unique_id[32];
	uint32_t trim_value;
#endif

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  400e06:	4820      	ldr	r0, [pc, #128]	; (400e88 <sysclk_init+0x88>)
  400e08:	4b20      	ldr	r3, [pc, #128]	; (400e8c <sysclk_init+0x8c>)
  400e0a:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  400e0c:	2001      	movs	r0, #1
  400e0e:	4b20      	ldr	r3, [pc, #128]	; (400e90 <sysclk_init+0x90>)
  400e10:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  400e12:	4638      	mov	r0, r7
  400e14:	f640 634e 	movw	r3, #3662	; 0xe4e
  400e18:	2201      	movs	r2, #1
  400e1a:	2101      	movs	r1, #1
  400e1c:	4c1d      	ldr	r4, [pc, #116]	; (400e94 <sysclk_init+0x94>)
  400e1e:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  400e20:	463b      	mov	r3, r7
  400e22:	2100      	movs	r1, #0
  400e24:	4618      	mov	r0, r3
  400e26:	4b1c      	ldr	r3, [pc, #112]	; (400e98 <sysclk_init+0x98>)
  400e28:	4798      	blx	r3
		pll_wait_for_lock(0);
  400e2a:	2000      	movs	r0, #0
  400e2c:	4b1b      	ldr	r3, [pc, #108]	; (400e9c <sysclk_init+0x9c>)
  400e2e:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400e30:	2000      	movs	r0, #0
  400e32:	4b1b      	ldr	r3, [pc, #108]	; (400ea0 <sysclk_init+0xa0>)
  400e34:	4798      	blx	r3
	}
#endif
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  400e36:	4b1b      	ldr	r3, [pc, #108]	; (400ea4 <sysclk_init+0xa4>)
  400e38:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  400e3a:	4b1b      	ldr	r3, [pc, #108]	; (400ea8 <sysclk_init+0xa8>)
  400e3c:	4798      	blx	r3
  400e3e:	4603      	mov	r3, r0
  400e40:	4618      	mov	r0, r3
  400e42:	4b12      	ldr	r3, [pc, #72]	; (400e8c <sysclk_init+0x8c>)
  400e44:	4798      	blx	r3
	}
#endif

#if SAMG55
	/* Set the trim value when system run near 120M */
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  400e46:	4b19      	ldr	r3, [pc, #100]	; (400eac <sysclk_init+0xac>)
  400e48:	681b      	ldr	r3, [r3, #0]
  400e4a:	4a19      	ldr	r2, [pc, #100]	; (400eb0 <sysclk_init+0xb0>)
  400e4c:	4293      	cmp	r3, r2
  400e4e:	d816      	bhi.n	400e7e <sysclk_init+0x7e>
	(SystemCoreClock >= (CHIP_FREQ_CPU_MAX - (CHIP_FREQ_CPU_MAX >> 3)))) {
  400e50:	4b16      	ldr	r3, [pc, #88]	; (400eac <sysclk_init+0xac>)
  400e52:	681b      	ldr	r3, [r3, #0]
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  400e54:	4a17      	ldr	r2, [pc, #92]	; (400eb4 <sysclk_init+0xb4>)
  400e56:	4293      	cmp	r3, r2
  400e58:	d911      	bls.n	400e7e <sysclk_init+0x7e>
		/* Get the trim value from unique ID area */
		efc_perform_read_sequence(EFC, EFC_FCMD_STUI, EFC_FCMD_SPUI,
  400e5a:	1d3a      	adds	r2, r7, #4
  400e5c:	2320      	movs	r3, #32
  400e5e:	9300      	str	r3, [sp, #0]
  400e60:	4613      	mov	r3, r2
  400e62:	220f      	movs	r2, #15
  400e64:	210e      	movs	r1, #14
  400e66:	4814      	ldr	r0, [pc, #80]	; (400eb8 <sysclk_init+0xb8>)
  400e68:	4c14      	ldr	r4, [pc, #80]	; (400ebc <sysclk_init+0xbc>)
  400e6a:	47a0      	blx	r4
		unique_id, 32);

		trim_value = unique_id[16] & 0x0000FFFF;
  400e6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  400e6e:	b29b      	uxth	r3, r3
  400e70:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		supc_set_regulator_trim_user(SUPC, trim_value);
  400e74:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  400e78:	4811      	ldr	r0, [pc, #68]	; (400ec0 <sysclk_init+0xc0>)
  400e7a:	4b12      	ldr	r3, [pc, #72]	; (400ec4 <sysclk_init+0xc4>)
  400e7c:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  400e7e:	bf00      	nop
  400e80:	378c      	adds	r7, #140	; 0x8c
  400e82:	46bd      	mov	sp, r7
  400e84:	bd90      	pop	{r4, r7, pc}
  400e86:	bf00      	nop
  400e88:	07270e00 	.word	0x07270e00
  400e8c:	00405545 	.word	0x00405545
  400e90:	00400d75 	.word	0x00400d75
  400e94:	00400ca9 	.word	0x00400ca9
  400e98:	00400cfd 	.word	0x00400cfd
  400e9c:	00400dad 	.word	0x00400dad
  400ea0:	004041fd 	.word	0x004041fd
  400ea4:	00405421 	.word	0x00405421
  400ea8:	00400ded 	.word	0x00400ded
  400eac:	20000170 	.word	0x20000170
  400eb0:	080befc0 	.word	0x080befc0
  400eb4:	06422c3f 	.word	0x06422c3f
  400eb8:	400e0a00 	.word	0x400e0a00
  400ebc:	2000000b 	.word	0x2000000b
  400ec0:	400e1410 	.word	0x400e1410
  400ec4:	00404a2d 	.word	0x00404a2d

00400ec8 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
  400ec8:	b480      	push	{r7}
  400eca:	b083      	sub	sp, #12
  400ecc:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
  400ece:	4b11      	ldr	r3, [pc, #68]	; (400f14 <cpu_irq_enter_critical+0x4c>)
  400ed0:	681b      	ldr	r3, [r3, #0]
  400ed2:	2b00      	cmp	r3, #0
  400ed4:	d112      	bne.n	400efc <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  400ed6:	f3ef 8310 	mrs	r3, PRIMASK
  400eda:	607b      	str	r3, [r7, #4]
  return(result);
  400edc:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
  400ede:	2b00      	cmp	r3, #0
  400ee0:	d109      	bne.n	400ef6 <cpu_irq_enter_critical+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
  400ee2:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  400ee4:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
  400ee8:	4b0b      	ldr	r3, [pc, #44]	; (400f18 <cpu_irq_enter_critical+0x50>)
  400eea:	2200      	movs	r2, #0
  400eec:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
  400eee:	4b0b      	ldr	r3, [pc, #44]	; (400f1c <cpu_irq_enter_critical+0x54>)
  400ef0:	2201      	movs	r2, #1
  400ef2:	701a      	strb	r2, [r3, #0]
  400ef4:	e002      	b.n	400efc <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
  400ef6:	4b09      	ldr	r3, [pc, #36]	; (400f1c <cpu_irq_enter_critical+0x54>)
  400ef8:	2200      	movs	r2, #0
  400efa:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
  400efc:	4b05      	ldr	r3, [pc, #20]	; (400f14 <cpu_irq_enter_critical+0x4c>)
  400efe:	681b      	ldr	r3, [r3, #0]
  400f00:	3301      	adds	r3, #1
  400f02:	4a04      	ldr	r2, [pc, #16]	; (400f14 <cpu_irq_enter_critical+0x4c>)
  400f04:	6013      	str	r3, [r2, #0]
}
  400f06:	bf00      	nop
  400f08:	370c      	adds	r7, #12
  400f0a:	46bd      	mov	sp, r7
  400f0c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f10:	4770      	bx	lr
  400f12:	bf00      	nop
  400f14:	20000374 	.word	0x20000374
  400f18:	20000114 	.word	0x20000114
  400f1c:	20000378 	.word	0x20000378

00400f20 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
  400f20:	b480      	push	{r7}
  400f22:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
  400f24:	4b0c      	ldr	r3, [pc, #48]	; (400f58 <cpu_irq_leave_critical+0x38>)
  400f26:	681b      	ldr	r3, [r3, #0]
  400f28:	3b01      	subs	r3, #1
  400f2a:	4a0b      	ldr	r2, [pc, #44]	; (400f58 <cpu_irq_leave_critical+0x38>)
  400f2c:	6013      	str	r3, [r2, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
  400f2e:	4b0a      	ldr	r3, [pc, #40]	; (400f58 <cpu_irq_leave_critical+0x38>)
  400f30:	681b      	ldr	r3, [r3, #0]
  400f32:	2b00      	cmp	r3, #0
  400f34:	d10a      	bne.n	400f4c <cpu_irq_leave_critical+0x2c>
  400f36:	4b09      	ldr	r3, [pc, #36]	; (400f5c <cpu_irq_leave_critical+0x3c>)
  400f38:	781b      	ldrb	r3, [r3, #0]
  400f3a:	b2db      	uxtb	r3, r3
  400f3c:	2b00      	cmp	r3, #0
  400f3e:	d005      	beq.n	400f4c <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
  400f40:	4b07      	ldr	r3, [pc, #28]	; (400f60 <cpu_irq_leave_critical+0x40>)
  400f42:	2201      	movs	r2, #1
  400f44:	701a      	strb	r2, [r3, #0]
  400f46:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  400f4a:	b662      	cpsie	i
	}
}
  400f4c:	bf00      	nop
  400f4e:	46bd      	mov	sp, r7
  400f50:	f85d 7b04 	ldr.w	r7, [sp], #4
  400f54:	4770      	bx	lr
  400f56:	bf00      	nop
  400f58:	20000374 	.word	0x20000374
  400f5c:	20000378 	.word	0x20000378
  400f60:	20000114 	.word	0x20000114

00400f64 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  400f64:	b580      	push	{r7, lr}
  400f66:	b086      	sub	sp, #24
  400f68:	af00      	add	r7, sp, #0
  400f6a:	60f8      	str	r0, [r7, #12]
  400f6c:	60b9      	str	r1, [r7, #8]
  400f6e:	607a      	str	r2, [r7, #4]
	int nChars = 0;
  400f70:	2300      	movs	r3, #0
  400f72:	617b      	str	r3, [r7, #20]

	if (file != 0) {
  400f74:	68fb      	ldr	r3, [r7, #12]
  400f76:	2b00      	cmp	r3, #0
  400f78:	d012      	beq.n	400fa0 <_read+0x3c>
		return -1;
  400f7a:	f04f 33ff 	mov.w	r3, #4294967295
  400f7e:	e013      	b.n	400fa8 <_read+0x44>
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  400f80:	4b0b      	ldr	r3, [pc, #44]	; (400fb0 <_read+0x4c>)
  400f82:	681b      	ldr	r3, [r3, #0]
  400f84:	4a0b      	ldr	r2, [pc, #44]	; (400fb4 <_read+0x50>)
  400f86:	6812      	ldr	r2, [r2, #0]
  400f88:	68b9      	ldr	r1, [r7, #8]
  400f8a:	4610      	mov	r0, r2
  400f8c:	4798      	blx	r3
		ptr++;
  400f8e:	68bb      	ldr	r3, [r7, #8]
  400f90:	3301      	adds	r3, #1
  400f92:	60bb      	str	r3, [r7, #8]
		nChars++;
  400f94:	697b      	ldr	r3, [r7, #20]
  400f96:	3301      	adds	r3, #1
  400f98:	617b      	str	r3, [r7, #20]
	for (; len > 0; --len) {
  400f9a:	687b      	ldr	r3, [r7, #4]
  400f9c:	3b01      	subs	r3, #1
  400f9e:	607b      	str	r3, [r7, #4]
  400fa0:	687b      	ldr	r3, [r7, #4]
  400fa2:	2b00      	cmp	r3, #0
  400fa4:	dcec      	bgt.n	400f80 <_read+0x1c>
	}
	return nChars;
  400fa6:	697b      	ldr	r3, [r7, #20]
}
  400fa8:	4618      	mov	r0, r3
  400faa:	3718      	adds	r7, #24
  400fac:	46bd      	mov	sp, r7
  400fae:	bd80      	pop	{r7, pc}
  400fb0:	200028c0 	.word	0x200028c0
  400fb4:	200028c8 	.word	0x200028c8

00400fb8 <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  400fb8:	b580      	push	{r7, lr}
  400fba:	b086      	sub	sp, #24
  400fbc:	af00      	add	r7, sp, #0
  400fbe:	60f8      	str	r0, [r7, #12]
  400fc0:	60b9      	str	r1, [r7, #8]
  400fc2:	607a      	str	r2, [r7, #4]
	int nChars = 0;
  400fc4:	2300      	movs	r3, #0
  400fc6:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
  400fc8:	68fb      	ldr	r3, [r7, #12]
  400fca:	2b01      	cmp	r3, #1
  400fcc:	d01e      	beq.n	40100c <_write+0x54>
  400fce:	68fb      	ldr	r3, [r7, #12]
  400fd0:	2b02      	cmp	r3, #2
  400fd2:	d01b      	beq.n	40100c <_write+0x54>
  400fd4:	68fb      	ldr	r3, [r7, #12]
  400fd6:	2b03      	cmp	r3, #3
  400fd8:	d018      	beq.n	40100c <_write+0x54>
		return -1;
  400fda:	f04f 33ff 	mov.w	r3, #4294967295
  400fde:	e019      	b.n	401014 <_write+0x5c>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
  400fe0:	4b0e      	ldr	r3, [pc, #56]	; (40101c <_write+0x64>)
  400fe2:	681a      	ldr	r2, [r3, #0]
  400fe4:	4b0e      	ldr	r3, [pc, #56]	; (401020 <_write+0x68>)
  400fe6:	6818      	ldr	r0, [r3, #0]
  400fe8:	68bb      	ldr	r3, [r7, #8]
  400fea:	1c59      	adds	r1, r3, #1
  400fec:	60b9      	str	r1, [r7, #8]
  400fee:	781b      	ldrb	r3, [r3, #0]
  400ff0:	4619      	mov	r1, r3
  400ff2:	4790      	blx	r2
  400ff4:	4603      	mov	r3, r0
  400ff6:	2b00      	cmp	r3, #0
  400ff8:	da02      	bge.n	401000 <_write+0x48>
			return -1;
  400ffa:	f04f 33ff 	mov.w	r3, #4294967295
  400ffe:	e009      	b.n	401014 <_write+0x5c>
		}
		++nChars;
  401000:	697b      	ldr	r3, [r7, #20]
  401002:	3301      	adds	r3, #1
  401004:	617b      	str	r3, [r7, #20]
	for (; len != 0; --len) {
  401006:	687b      	ldr	r3, [r7, #4]
  401008:	3b01      	subs	r3, #1
  40100a:	607b      	str	r3, [r7, #4]
  40100c:	687b      	ldr	r3, [r7, #4]
  40100e:	2b00      	cmp	r3, #0
  401010:	d1e6      	bne.n	400fe0 <_write+0x28>
	}
	return nChars;
  401012:	697b      	ldr	r3, [r7, #20]
}
  401014:	4618      	mov	r0, r3
  401016:	3718      	adds	r7, #24
  401018:	46bd      	mov	sp, r7
  40101a:	bd80      	pop	{r7, pc}
  40101c:	200028c4 	.word	0x200028c4
  401020:	200028c8 	.word	0x200028c8

00401024 <osc_get_rate>:
{
  401024:	b480      	push	{r7}
  401026:	b083      	sub	sp, #12
  401028:	af00      	add	r7, sp, #0
  40102a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40102c:	687b      	ldr	r3, [r7, #4]
  40102e:	2b07      	cmp	r3, #7
  401030:	d825      	bhi.n	40107e <osc_get_rate+0x5a>
  401032:	a201      	add	r2, pc, #4	; (adr r2, 401038 <osc_get_rate+0x14>)
  401034:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401038:	00401059 	.word	0x00401059
  40103c:	0040105f 	.word	0x0040105f
  401040:	00401065 	.word	0x00401065
  401044:	0040106b 	.word	0x0040106b
  401048:	0040106f 	.word	0x0040106f
  40104c:	00401073 	.word	0x00401073
  401050:	00401077 	.word	0x00401077
  401054:	0040107b 	.word	0x0040107b
		return OSC_SLCK_32K_RC_HZ;
  401058:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40105c:	e010      	b.n	401080 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40105e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401062:	e00d      	b.n	401080 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401064:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401068:	e00a      	b.n	401080 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40106a:	4b08      	ldr	r3, [pc, #32]	; (40108c <osc_get_rate+0x68>)
  40106c:	e008      	b.n	401080 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  40106e:	4b08      	ldr	r3, [pc, #32]	; (401090 <osc_get_rate+0x6c>)
  401070:	e006      	b.n	401080 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  401072:	4b08      	ldr	r3, [pc, #32]	; (401094 <osc_get_rate+0x70>)
  401074:	e004      	b.n	401080 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401076:	2300      	movs	r3, #0
  401078:	e002      	b.n	401080 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40107a:	2300      	movs	r3, #0
  40107c:	e000      	b.n	401080 <osc_get_rate+0x5c>
	return 0;
  40107e:	2300      	movs	r3, #0
}
  401080:	4618      	mov	r0, r3
  401082:	370c      	adds	r7, #12
  401084:	46bd      	mov	sp, r7
  401086:	f85d 7b04 	ldr.w	r7, [sp], #4
  40108a:	4770      	bx	lr
  40108c:	007a1200 	.word	0x007a1200
  401090:	00f42400 	.word	0x00f42400
  401094:	016e3600 	.word	0x016e3600

00401098 <sysclk_get_main_hz>:
{
  401098:	b580      	push	{r7, lr}
  40109a:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  40109c:	2001      	movs	r0, #1
  40109e:	4b04      	ldr	r3, [pc, #16]	; (4010b0 <sysclk_get_main_hz+0x18>)
  4010a0:	4798      	blx	r3
  4010a2:	4602      	mov	r2, r0
  4010a4:	f640 634e 	movw	r3, #3662	; 0xe4e
  4010a8:	fb03 f302 	mul.w	r3, r3, r2
}
  4010ac:	4618      	mov	r0, r3
  4010ae:	bd80      	pop	{r7, pc}
  4010b0:	00401025 	.word	0x00401025

004010b4 <sysclk_get_cpu_hz>:
{
  4010b4:	b580      	push	{r7, lr}
  4010b6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4010b8:	4b02      	ldr	r3, [pc, #8]	; (4010c4 <sysclk_get_cpu_hz+0x10>)
  4010ba:	4798      	blx	r3
  4010bc:	4603      	mov	r3, r0
}
  4010be:	4618      	mov	r0, r3
  4010c0:	bd80      	pop	{r7, pc}
  4010c2:	bf00      	nop
  4010c4:	00401099 	.word	0x00401099

004010c8 <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  4010c8:	b480      	push	{r7}
  4010ca:	b08d      	sub	sp, #52	; 0x34
  4010cc:	af00      	add	r7, sp, #0
  4010ce:	6078      	str	r0, [r7, #4]
  4010d0:	460b      	mov	r3, r1
  4010d2:	70fb      	strb	r3, [r7, #3]
  4010d4:	687b      	ldr	r3, [r7, #4]
  4010d6:	62fb      	str	r3, [r7, #44]	; 0x2c
  4010d8:	78fb      	ldrb	r3, [r7, #3]
  4010da:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  4010de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4010e0:	627b      	str	r3, [r7, #36]	; 0x24
  4010e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4010e4:	623b      	str	r3, [r7, #32]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4010e6:	6a3b      	ldr	r3, [r7, #32]
  4010e8:	095b      	lsrs	r3, r3, #5
  4010ea:	61fb      	str	r3, [r7, #28]
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4010ec:	69fb      	ldr	r3, [r7, #28]
  4010ee:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4010f2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4010f6:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  4010f8:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  4010fa:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4010fe:	2b01      	cmp	r3, #1
  401100:	d109      	bne.n	401116 <ioport_set_pin_dir+0x4e>
  401102:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401104:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401106:	697b      	ldr	r3, [r7, #20]
  401108:	f003 031f 	and.w	r3, r3, #31
  40110c:	2201      	movs	r2, #1
  40110e:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401110:	69bb      	ldr	r3, [r7, #24]
  401112:	611a      	str	r2, [r3, #16]
  401114:	e00c      	b.n	401130 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  401116:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40111a:	2b00      	cmp	r3, #0
  40111c:	d108      	bne.n	401130 <ioport_set_pin_dir+0x68>
  40111e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401120:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  401122:	693b      	ldr	r3, [r7, #16]
  401124:	f003 031f 	and.w	r3, r3, #31
  401128:	2201      	movs	r2, #1
  40112a:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  40112c:	69bb      	ldr	r3, [r7, #24]
  40112e:	615a      	str	r2, [r3, #20]
  401130:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401132:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401134:	68fb      	ldr	r3, [r7, #12]
  401136:	f003 031f 	and.w	r3, r3, #31
  40113a:	2201      	movs	r2, #1
  40113c:	409a      	lsls	r2, r3
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40113e:	69bb      	ldr	r3, [r7, #24]
  401140:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  401144:	bf00      	nop
  401146:	3734      	adds	r7, #52	; 0x34
  401148:	46bd      	mov	sp, r7
  40114a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40114e:	4770      	bx	lr

00401150 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  401150:	b480      	push	{r7}
  401152:	b08b      	sub	sp, #44	; 0x2c
  401154:	af00      	add	r7, sp, #0
  401156:	6078      	str	r0, [r7, #4]
  401158:	460b      	mov	r3, r1
  40115a:	70fb      	strb	r3, [r7, #3]
  40115c:	687b      	ldr	r3, [r7, #4]
  40115e:	627b      	str	r3, [r7, #36]	; 0x24
  401160:	78fb      	ldrb	r3, [r7, #3]
  401162:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401166:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401168:	61fb      	str	r3, [r7, #28]
  40116a:	69fb      	ldr	r3, [r7, #28]
  40116c:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  40116e:	69bb      	ldr	r3, [r7, #24]
  401170:	095b      	lsrs	r3, r3, #5
  401172:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401174:	697b      	ldr	r3, [r7, #20]
  401176:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40117a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40117e:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401180:	613b      	str	r3, [r7, #16]

	if (level) {
  401182:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  401186:	2b00      	cmp	r3, #0
  401188:	d009      	beq.n	40119e <ioport_set_pin_level+0x4e>
  40118a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40118c:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  40118e:	68fb      	ldr	r3, [r7, #12]
  401190:	f003 031f 	and.w	r3, r3, #31
  401194:	2201      	movs	r2, #1
  401196:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401198:	693b      	ldr	r3, [r7, #16]
  40119a:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  40119c:	e008      	b.n	4011b0 <ioport_set_pin_level+0x60>
  40119e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4011a0:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  4011a2:	68bb      	ldr	r3, [r7, #8]
  4011a4:	f003 031f 	and.w	r3, r3, #31
  4011a8:	2201      	movs	r2, #1
  4011aa:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  4011ac:	693b      	ldr	r3, [r7, #16]
  4011ae:	635a      	str	r2, [r3, #52]	; 0x34
  4011b0:	bf00      	nop
  4011b2:	372c      	adds	r7, #44	; 0x2c
  4011b4:	46bd      	mov	sp, r7
  4011b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4011ba:	4770      	bx	lr

004011bc <PIOA_Handler>:
 *    the ISR must be as short as possible to ensure the INT level is set back to
 *    0 logical level before the CHx01 is ready for a new measurement. The maximum
 *    time for ISR is 8 us.
 */
void PIOA_Handler(void)
{
  4011bc:	b580      	push	{r7, lr}
  4011be:	b082      	sub	sp, #8
  4011c0:	af00      	add	r7, sp, #0
	/* Read the ISR and IMR registers to know which interrupt(s) is(are) pending */
	uint32_t status = pio_get_interrupt_status(PIOA);
  4011c2:	481b      	ldr	r0, [pc, #108]	; (401230 <PIOA_Handler+0x74>)
  4011c4:	4b1b      	ldr	r3, [pc, #108]	; (401234 <PIOA_Handler+0x78>)
  4011c6:	4798      	blx	r3
  4011c8:	6078      	str	r0, [r7, #4]
	status &= pio_get_interrupt_mask(PIOA);
  4011ca:	4819      	ldr	r0, [pc, #100]	; (401230 <PIOA_Handler+0x74>)
  4011cc:	4b1a      	ldr	r3, [pc, #104]	; (401238 <PIOA_Handler+0x7c>)
  4011ce:	4798      	blx	r3
  4011d0:	4602      	mov	r2, r0
  4011d2:	687b      	ldr	r3, [r7, #4]
  4011d4:	4013      	ands	r3, r2
  4011d6:	607b      	str	r3, [r7, #4]

	if (status & PIN_EXT_MotionINT_MASK)
  4011d8:	687b      	ldr	r3, [r7, #4]
  4011da:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  4011de:	2b00      	cmp	r3, #0
  4011e0:	d001      	beq.n	4011e6 <PIOA_Handler+0x2a>
		ext_MotionINT_handler();
  4011e2:	4b16      	ldr	r3, [pc, #88]	; (40123c <PIOA_Handler+0x80>)
  4011e4:	4798      	blx	r3
	if (status & PIN_EXT_ChirpINT0_MASK)
  4011e6:	687b      	ldr	r3, [r7, #4]
  4011e8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  4011ec:	2b00      	cmp	r3, #0
  4011ee:	d002      	beq.n	4011f6 <PIOA_Handler+0x3a>
		ext_int_handler(0);
  4011f0:	2000      	movs	r0, #0
  4011f2:	4b13      	ldr	r3, [pc, #76]	; (401240 <PIOA_Handler+0x84>)
  4011f4:	4798      	blx	r3
	if (status & PIN_EXT_ChirpINT1_MASK)
  4011f6:	687b      	ldr	r3, [r7, #4]
  4011f8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  4011fc:	2b00      	cmp	r3, #0
  4011fe:	d002      	beq.n	401206 <PIOA_Handler+0x4a>
		ext_int_handler(1);
  401200:	2001      	movs	r0, #1
  401202:	4b0f      	ldr	r3, [pc, #60]	; (401240 <PIOA_Handler+0x84>)
  401204:	4798      	blx	r3
	if (status & PIN_EXT_ChirpINT2_MASK)
  401206:	687b      	ldr	r3, [r7, #4]
  401208:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  40120c:	2b00      	cmp	r3, #0
  40120e:	d002      	beq.n	401216 <PIOA_Handler+0x5a>
		ext_int_handler(2);
  401210:	2002      	movs	r0, #2
  401212:	4b0b      	ldr	r3, [pc, #44]	; (401240 <PIOA_Handler+0x84>)
  401214:	4798      	blx	r3
	if (status & PIN_EXT_ChirpINT3_MASK)
  401216:	687b      	ldr	r3, [r7, #4]
  401218:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
  40121c:	2b00      	cmp	r3, #0
  40121e:	d002      	beq.n	401226 <PIOA_Handler+0x6a>
		ext_int_handler(3);
  401220:	2003      	movs	r0, #3
  401222:	4b07      	ldr	r3, [pc, #28]	; (401240 <PIOA_Handler+0x84>)
  401224:	4798      	blx	r3
}
  401226:	bf00      	nop
  401228:	3708      	adds	r7, #8
  40122a:	46bd      	mov	sp, r7
  40122c:	bd80      	pop	{r7, pc}
  40122e:	bf00      	nop
  401230:	400e0e00 	.word	0x400e0e00
  401234:	00403e75 	.word	0x00403e75
  401238:	00403e8d 	.word	0x00403e8d
  40123c:	00401245 	.word	0x00401245
  401240:	00401255 	.word	0x00401255

00401244 <ext_MotionINT_handler>:

void ext_MotionINT_handler(void)
{
  401244:	b480      	push	{r7}
  401246:	af00      	add	r7, sp, #0
#ifdef USE_IMU
	imu_data_ready_isr_callback();
#endif
}
  401248:	bf00      	nop
  40124a:	46bd      	mov	sp, r7
  40124c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401250:	4770      	bx	lr
	...

00401254 <ext_int_handler>:

static void ext_int_handler(uint32_t sensor_id)
{
  401254:	b580      	push	{r7, lr}
  401256:	b084      	sub	sp, #16
  401258:	af00      	add	r7, sp, #0
  40125a:	6078      	str	r0, [r7, #4]
	ch_io_int_callback_t func_ptr = sensor_group_ptr->io_int_callback;
  40125c:	4b13      	ldr	r3, [pc, #76]	; (4012ac <ext_int_handler+0x58>)
  40125e:	681b      	ldr	r3, [r3, #0]
  401260:	691b      	ldr	r3, [r3, #16]
  401262:	60fb      	str	r3, [r7, #12]
	uint32_t gpio_pin = chirp_pin_io[sensor_id];
  401264:	4a12      	ldr	r2, [pc, #72]	; (4012b0 <ext_int_handler+0x5c>)
  401266:	687b      	ldr	r3, [r7, #4]
  401268:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40126c:	60bb      	str	r3, [r7, #8]

	/* Put the line in output to stabilize it to 0V until the next trig */
	ioport_set_pin_level(gpio_pin, IOPORT_PIN_LEVEL_LOW);	// set to low level
  40126e:	2100      	movs	r1, #0
  401270:	68b8      	ldr	r0, [r7, #8]
  401272:	4b10      	ldr	r3, [pc, #64]	; (4012b4 <ext_int_handler+0x60>)
  401274:	4798      	blx	r3
	ioport_set_pin_dir(gpio_pin, IOPORT_DIR_OUTPUT);		// set pin direction as output
  401276:	2101      	movs	r1, #1
  401278:	68b8      	ldr	r0, [r7, #8]
  40127a:	4b0f      	ldr	r3, [pc, #60]	; (4012b8 <ext_int_handler+0x64>)
  40127c:	4798      	blx	r3
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, chirp_pin_io_irq[sensor_id]); // disable interrupt
  40127e:	4a0f      	ldr	r2, [pc, #60]	; (4012bc <ext_int_handler+0x68>)
  401280:	687b      	ldr	r3, [r7, #4]
  401282:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  401286:	4619      	mov	r1, r3
  401288:	480d      	ldr	r0, [pc, #52]	; (4012c0 <ext_int_handler+0x6c>)
  40128a:	4b0e      	ldr	r3, [pc, #56]	; (4012c4 <ext_int_handler+0x70>)
  40128c:	4798      	blx	r3

	if (func_ptr != NULL) {
  40128e:	68fb      	ldr	r3, [r7, #12]
  401290:	2b00      	cmp	r3, #0
  401292:	d006      	beq.n	4012a2 <ext_int_handler+0x4e>
		// Call application callback function - pass I/O index to identify interrupting device
		(*func_ptr)(sensor_group_ptr, sensor_id);
  401294:	4b05      	ldr	r3, [pc, #20]	; (4012ac <ext_int_handler+0x58>)
  401296:	681a      	ldr	r2, [r3, #0]
  401298:	687b      	ldr	r3, [r7, #4]
  40129a:	b2d9      	uxtb	r1, r3
  40129c:	68fb      	ldr	r3, [r7, #12]
  40129e:	4610      	mov	r0, r2
  4012a0:	4798      	blx	r3
	}
}
  4012a2:	bf00      	nop
  4012a4:	3710      	adds	r7, #16
  4012a6:	46bd      	mov	sp, r7
  4012a8:	bd80      	pop	{r7, pc}
  4012aa:	bf00      	nop
  4012ac:	200028dc 	.word	0x200028dc
  4012b0:	20000130 	.word	0x20000130
  4012b4:	00401151 	.word	0x00401151
  4012b8:	004010c9 	.word	0x004010c9
  4012bc:	20000140 	.word	0x20000140
  4012c0:	400e0e00 	.word	0x400e0e00
  4012c4:	00403e59 	.word	0x00403e59

004012c8 <FLEXCOM1_Handler>:

void FLEXCOM1_Handler(void)
{
  4012c8:	b580      	push	{r7, lr}
  4012ca:	af00      	add	r7, sp, #0
	flexcom_handler(1);			// call local handler with index value
  4012cc:	2001      	movs	r0, #1
  4012ce:	4b02      	ldr	r3, [pc, #8]	; (4012d8 <FLEXCOM1_Handler+0x10>)
  4012d0:	4798      	blx	r3
}
  4012d2:	bf00      	nop
  4012d4:	bd80      	pop	{r7, pc}
  4012d6:	bf00      	nop
  4012d8:	004012f1 	.word	0x004012f1

004012dc <FLEXCOM3_Handler>:

void FLEXCOM3_Handler(void)
{
  4012dc:	b580      	push	{r7, lr}
  4012de:	af00      	add	r7, sp, #0
	flexcom_handler(3);			// call local handler with index value
  4012e0:	2003      	movs	r0, #3
  4012e2:	4b02      	ldr	r3, [pc, #8]	; (4012ec <FLEXCOM3_Handler+0x10>)
  4012e4:	4798      	blx	r3
}
  4012e6:	bf00      	nop
  4012e8:	bd80      	pop	{r7, pc}
  4012ea:	bf00      	nop
  4012ec:	004012f1 	.word	0x004012f1

004012f0 <flexcom_handler>:


void flexcom_handler(uint8_t port_index) {
  4012f0:	b580      	push	{r7, lr}
  4012f2:	b08a      	sub	sp, #40	; 0x28
  4012f4:	af00      	add	r7, sp, #0
  4012f6:	4603      	mov	r3, r0
  4012f8:	71fb      	strb	r3, [r7, #7]
	Twi *twi_ptr;
	Pdc *pdc_ptr;
	uint8_t *buf_ptr;
	uint32_t num_bytes;
	uint8_t	 bus_index = 0;
  4012fa:	2300      	movs	r3, #0
  4012fc:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	uint32_t twi_status;
	uint32_t timeout_count = 0;
  401300:	2300      	movs	r3, #0
  401302:	61fb      	str	r3, [r7, #28]
	uint8_t error = 0;
  401304:	2300      	movs	r3, #0
  401306:	76fb      	strb	r3, [r7, #27]

	if (port_index == 1) {
  401308:	79fb      	ldrb	r3, [r7, #7]
  40130a:	2b01      	cmp	r3, #1
  40130c:	d105      	bne.n	40131a <flexcom_handler+0x2a>
		twi_ptr = BOARD_BASE_TWI1;
  40130e:	4b4b      	ldr	r3, [pc, #300]	; (40143c <flexcom_handler+0x14c>)
  401310:	627b      	str	r3, [r7, #36]	; 0x24
		bus_index = 0;
  401312:	2300      	movs	r3, #0
  401314:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401318:	e00b      	b.n	401332 <flexcom_handler+0x42>
	} else if (port_index == 3) {
  40131a:	79fb      	ldrb	r3, [r7, #7]
  40131c:	2b03      	cmp	r3, #3
  40131e:	d105      	bne.n	40132c <flexcom_handler+0x3c>
		twi_ptr = BOARD_BASE_TWI3;
  401320:	4b47      	ldr	r3, [pc, #284]	; (401440 <flexcom_handler+0x150>)
  401322:	627b      	str	r3, [r7, #36]	; 0x24
		bus_index = 1;
  401324:	2301      	movs	r3, #1
  401326:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  40132a:	e002      	b.n	401332 <flexcom_handler+0x42>
	} else {
		error = 1;		// bad port index
  40132c:	2301      	movs	r3, #1
  40132e:	76fb      	strb	r3, [r7, #27]
		return;
  401330:	e080      	b.n	401434 <flexcom_handler+0x144>
	}

	pdc_ptr   = twi_get_pdc_base(twi_ptr);
  401332:	6a78      	ldr	r0, [r7, #36]	; 0x24
  401334:	4b43      	ldr	r3, [pc, #268]	; (401444 <flexcom_handler+0x154>)
  401336:	4798      	blx	r3
  401338:	6178      	str	r0, [r7, #20]
	buf_ptr   = i2c_nb_transactions[bus_index].buf_ptr;
  40133a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  40133e:	4a42      	ldr	r2, [pc, #264]	; (401448 <flexcom_handler+0x158>)
  401340:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  401344:	613b      	str	r3, [r7, #16]
	num_bytes = i2c_nb_transactions[bus_index].num_bytes;
  401346:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  40134a:	4a3f      	ldr	r2, [pc, #252]	; (401448 <flexcom_handler+0x158>)
  40134c:	00db      	lsls	r3, r3, #3
  40134e:	4413      	add	r3, r2
  401350:	889b      	ldrh	r3, [r3, #4]
  401352:	60fb      	str	r3, [r7, #12]

	twi_status = twi_get_interrupt_status(twi_ptr);
  401354:	6a78      	ldr	r0, [r7, #36]	; 0x24
  401356:	4b3d      	ldr	r3, [pc, #244]	; (40144c <flexcom_handler+0x15c>)
  401358:	4798      	blx	r3
  40135a:	60b8      	str	r0, [r7, #8]
	twi_status &= twi_get_interrupt_mask(twi_ptr);
  40135c:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40135e:	4b3c      	ldr	r3, [pc, #240]	; (401450 <flexcom_handler+0x160>)
  401360:	4798      	blx	r3
  401362:	4602      	mov	r2, r0
  401364:	68bb      	ldr	r3, [r7, #8]
  401366:	4013      	ands	r3, r2
  401368:	60bb      	str	r3, [r7, #8]


	if ((!error) && (twi_status & TWI_SR_ENDRX))  {
  40136a:	7efb      	ldrb	r3, [r7, #27]
  40136c:	2b00      	cmp	r3, #0
  40136e:	d161      	bne.n	401434 <flexcom_handler+0x144>
  401370:	68bb      	ldr	r3, [r7, #8]
  401372:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  401376:	2b00      	cmp	r3, #0
  401378:	d05c      	beq.n	401434 <flexcom_handler+0x144>
		/* Disable the RX PDC transfer requests */
		pdc_disable_transfer(pdc_ptr, PERIPH_PTCR_RXTDIS);
  40137a:	2102      	movs	r1, #2
  40137c:	6978      	ldr	r0, [r7, #20]
  40137e:	4b35      	ldr	r3, [pc, #212]	; (401454 <flexcom_handler+0x164>)
  401380:	4798      	blx	r3

		/* Disable TWI interrupts */
		twi_disable_interrupt(twi_ptr, TWI_SR_ENDRX);
  401382:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  401386:	6a78      	ldr	r0, [r7, #36]	; 0x24
  401388:	4b33      	ldr	r3, [pc, #204]	; (401458 <flexcom_handler+0x168>)
  40138a:	4798      	blx	r3

		/* Wait for next-to-last byte to be read */
		timeout_count = 0;
  40138c:	2300      	movs	r3, #0
  40138e:	61fb      	str	r3, [r7, #28]
		while ((twi_ptr->TWI_SR & TWI_SR_RXRDY) == 0) {
  401390:	e007      	b.n	4013a2 <flexcom_handler+0xb2>
			if (++timeout_count >= I2C_TIMEOUT_COUNT) {
  401392:	69fb      	ldr	r3, [r7, #28]
  401394:	3301      	adds	r3, #1
  401396:	61fb      	str	r3, [r7, #28]
  401398:	69fb      	ldr	r3, [r7, #28]
  40139a:	f242 720f 	movw	r2, #9999	; 0x270f
  40139e:	4293      	cmp	r3, r2
  4013a0:	d806      	bhi.n	4013b0 <flexcom_handler+0xc0>
		while ((twi_ptr->TWI_SR & TWI_SR_RXRDY) == 0) {
  4013a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4013a4:	6a1b      	ldr	r3, [r3, #32]
  4013a6:	f003 0302 	and.w	r3, r3, #2
  4013aa:	2b00      	cmp	r3, #0
  4013ac:	d0f1      	beq.n	401392 <flexcom_handler+0xa2>
  4013ae:	e000      	b.n	4013b2 <flexcom_handler+0xc2>
				break;
  4013b0:	bf00      	nop
			}
		}

		/* Set stop command */
		twi_ptr->TWI_CR = TWI_CR_STOP;
  4013b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4013b4:	2202      	movs	r2, #2
  4013b6:	601a      	str	r2, [r3, #0]

		buf_ptr[num_bytes-2] = twi_ptr->TWI_RHR;
  4013b8:	68fb      	ldr	r3, [r7, #12]
  4013ba:	3b02      	subs	r3, #2
  4013bc:	693a      	ldr	r2, [r7, #16]
  4013be:	4413      	add	r3, r2
  4013c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4013c2:	6b12      	ldr	r2, [r2, #48]	; 0x30
  4013c4:	b2d2      	uxtb	r2, r2
  4013c6:	701a      	strb	r2, [r3, #0]

		/* Wait for last byte to be read */
		timeout_count = 0;
  4013c8:	2300      	movs	r3, #0
  4013ca:	61fb      	str	r3, [r7, #28]
		while ((twi_ptr->TWI_SR & TWI_SR_RXRDY) == 0) {
  4013cc:	e007      	b.n	4013de <flexcom_handler+0xee>
			if (++timeout_count >= I2C_TIMEOUT_COUNT) {
  4013ce:	69fb      	ldr	r3, [r7, #28]
  4013d0:	3301      	adds	r3, #1
  4013d2:	61fb      	str	r3, [r7, #28]
  4013d4:	69fb      	ldr	r3, [r7, #28]
  4013d6:	f242 720f 	movw	r2, #9999	; 0x270f
  4013da:	4293      	cmp	r3, r2
  4013dc:	d806      	bhi.n	4013ec <flexcom_handler+0xfc>
		while ((twi_ptr->TWI_SR & TWI_SR_RXRDY) == 0) {
  4013de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4013e0:	6a1b      	ldr	r3, [r3, #32]
  4013e2:	f003 0302 	and.w	r3, r3, #2
  4013e6:	2b00      	cmp	r3, #0
  4013e8:	d0f1      	beq.n	4013ce <flexcom_handler+0xde>
  4013ea:	e000      	b.n	4013ee <flexcom_handler+0xfe>
				break;
  4013ec:	bf00      	nop
			}
		}

		buf_ptr[num_bytes-1] = twi_ptr->TWI_RHR;
  4013ee:	68fb      	ldr	r3, [r7, #12]
  4013f0:	3b01      	subs	r3, #1
  4013f2:	693a      	ldr	r2, [r7, #16]
  4013f4:	4413      	add	r3, r2
  4013f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4013f8:	6b12      	ldr	r2, [r2, #48]	; 0x30
  4013fa:	b2d2      	uxtb	r2, r2
  4013fc:	701a      	strb	r2, [r3, #0]

		/* Wait for transfer to complete */
		timeout_count = 0;
  4013fe:	2300      	movs	r3, #0
  401400:	61fb      	str	r3, [r7, #28]
		while ((twi_ptr->TWI_SR & TWI_SR_TXCOMP) == 0) {
  401402:	e007      	b.n	401414 <flexcom_handler+0x124>
			if (++timeout_count >= I2C_TIMEOUT_COUNT) {
  401404:	69fb      	ldr	r3, [r7, #28]
  401406:	3301      	adds	r3, #1
  401408:	61fb      	str	r3, [r7, #28]
  40140a:	69fb      	ldr	r3, [r7, #28]
  40140c:	f242 720f 	movw	r2, #9999	; 0x270f
  401410:	4293      	cmp	r3, r2
  401412:	d806      	bhi.n	401422 <flexcom_handler+0x132>
		while ((twi_ptr->TWI_SR & TWI_SR_TXCOMP) == 0) {
  401414:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401416:	6a1b      	ldr	r3, [r3, #32]
  401418:	f003 0301 	and.w	r3, r3, #1
  40141c:	2b00      	cmp	r3, #0
  40141e:	d0f1      	beq.n	401404 <flexcom_handler+0x114>
  401420:	e000      	b.n	401424 <flexcom_handler+0x134>
				break;
  401422:	bf00      	nop
			}
		}

		/* Notify sensor driver that this transaction is complete */
		ch_io_notify(sensor_group_ptr, bus_index);
  401424:	4b0d      	ldr	r3, [pc, #52]	; (40145c <flexcom_handler+0x16c>)
  401426:	681b      	ldr	r3, [r3, #0]
  401428:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
  40142c:	4611      	mov	r1, r2
  40142e:	4618      	mov	r0, r3
  401430:	4b0b      	ldr	r3, [pc, #44]	; (401460 <flexcom_handler+0x170>)
  401432:	4798      	blx	r3
	}

}
  401434:	3728      	adds	r7, #40	; 0x28
  401436:	46bd      	mov	sp, r7
  401438:	bd80      	pop	{r7, pc}
  40143a:	bf00      	nop
  40143c:	40020600 	.word	0x40020600
  401440:	40018600 	.word	0x40018600
  401444:	00404fa5 	.word	0x00404fa5
  401448:	200028cc 	.word	0x200028cc
  40144c:	00404f55 	.word	0x00404f55
  401450:	00404f6d 	.word	0x00404f6d
  401454:	00403b11 	.word	0x00403b11
  401458:	00404f35 	.word	0x00404f35
  40145c:	200028dc 	.word	0x200028dc
  401460:	00405f79 	.word	0x00405f79

00401464 <RTT_Handler>:


void RTT_Handler(void) {
  401464:	b580      	push	{r7, lr}
  401466:	af00      	add	r7, sp, #0

	/* Get RTT status */
	rtt_get_status(RTT);
  401468:	4802      	ldr	r0, [pc, #8]	; (401474 <RTT_Handler+0x10>)
  40146a:	4b03      	ldr	r3, [pc, #12]	; (401478 <RTT_Handler+0x14>)
  40146c:	4798      	blx	r3
}
  40146e:	bf00      	nop
  401470:	bd80      	pop	{r7, pc}
  401472:	bf00      	nop
  401474:	400e1430 	.word	0x400e1430
  401478:	00404a15 	.word	0x00404a15

0040147c <TC0_Handler>:

/* Interrupt handler for TC0/Channel0 peripheral */
void TC0_Handler(void)
{
  40147c:	b580      	push	{r7, lr}
  40147e:	af00      	add	r7, sp, #0
	/* This handles the case of counter overflow on TC_CHANNEL_LSEPOCH and clears the status register */
	time_get_in_us();
  401480:	4b01      	ldr	r3, [pc, #4]	; (401488 <TC0_Handler+0xc>)
  401482:	4798      	blx	r3
}
  401484:	bf00      	nop
  401486:	bd80      	pop	{r7, pc}
  401488:	00400af9 	.word	0x00400af9

0040148c <TC1_Handler>:

/* Interrupt handler for TC0/Channel1 peripheral */
void TC1_Handler(void)
{
  40148c:	b580      	push	{r7, lr}
  40148e:	b082      	sub	sp, #8
  401490:	af00      	add	r7, sp, #0
	uint32_t status = tc_get_status(TC0, TC_CHANNEL_US);
  401492:	2101      	movs	r1, #1
  401494:	480a      	ldr	r0, [pc, #40]	; (4014c0 <TC1_Handler+0x34>)
  401496:	4b0b      	ldr	r3, [pc, #44]	; (4014c4 <TC1_Handler+0x38>)
  401498:	4798      	blx	r3
  40149a:	6078      	str	r0, [r7, #4]
	uint32_t int_mask = tc_get_interrupt_mask(TC0, TC_CHANNEL_US);
  40149c:	2101      	movs	r1, #1
  40149e:	4808      	ldr	r0, [pc, #32]	; (4014c0 <TC1_Handler+0x34>)
  4014a0:	4b09      	ldr	r3, [pc, #36]	; (4014c8 <TC1_Handler+0x3c>)
  4014a2:	4798      	blx	r3
  4014a4:	6038      	str	r0, [r7, #0]

	if (status & (int_mask & TC_IMR_CPCS)) {
  4014a6:	683a      	ldr	r2, [r7, #0]
  4014a8:	687b      	ldr	r3, [r7, #4]
  4014aa:	4013      	ands	r3, r2
  4014ac:	f003 0310 	and.w	r3, r3, #16
  4014b0:	2b00      	cmp	r3, #0
  4014b2:	d001      	beq.n	4014b8 <TC1_Handler+0x2c>
		chbsp_periodic_timer_handler();
  4014b4:	4b05      	ldr	r3, [pc, #20]	; (4014cc <TC1_Handler+0x40>)
  4014b6:	4798      	blx	r3
	}
}
  4014b8:	bf00      	nop
  4014ba:	3708      	adds	r7, #8
  4014bc:	46bd      	mov	sp, r7
  4014be:	bd80      	pop	{r7, pc}
  4014c0:	40010000 	.word	0x40010000
  4014c4:	00404b33 	.word	0x00404b33
  4014c8:	00404b0f 	.word	0x00404b0f
  4014cc:	00402f1d 	.word	0x00402f1d

004014d0 <sensor_led_on>:

void sensor_led_on(uint32_t chirp_led_pin) {
  4014d0:	b580      	push	{r7, lr}
  4014d2:	b082      	sub	sp, #8
  4014d4:	af00      	add	r7, sp, #0
  4014d6:	6078      	str	r0, [r7, #4]
	ioport_set_pin_dir(chirp_led_pin, IOPORT_DIR_OUTPUT);
  4014d8:	2101      	movs	r1, #1
  4014da:	6878      	ldr	r0, [r7, #4]
  4014dc:	4b04      	ldr	r3, [pc, #16]	; (4014f0 <sensor_led_on+0x20>)
  4014de:	4798      	blx	r3
	ioport_set_pin_level(chirp_led_pin, IOPORT_PIN_LEVEL_LOW);
  4014e0:	2100      	movs	r1, #0
  4014e2:	6878      	ldr	r0, [r7, #4]
  4014e4:	4b03      	ldr	r3, [pc, #12]	; (4014f4 <sensor_led_on+0x24>)
  4014e6:	4798      	blx	r3
}
  4014e8:	bf00      	nop
  4014ea:	3708      	adds	r7, #8
  4014ec:	46bd      	mov	sp, r7
  4014ee:	bd80      	pop	{r7, pc}
  4014f0:	004010c9 	.word	0x004010c9
  4014f4:	00401151 	.word	0x00401151

004014f8 <indicate_alive>:
void sensor_led_toggle(uint32_t chirp_led_pin)
{
	ioport_toggle_pin_level(chirp_led_pin);
}

void indicate_alive(void) {
  4014f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4014fc:	af00      	add	r7, sp, #0
	ioport_set_pin_dir(CHIRP_OK_0, IOPORT_DIR_OUTPUT); //CHIRP_OK_0=output
  4014fe:	2101      	movs	r1, #1
  401500:	2000      	movs	r0, #0
  401502:	4b35      	ldr	r3, [pc, #212]	; (4015d8 <indicate_alive+0xe0>)
  401504:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_OK_1, IOPORT_DIR_OUTPUT);
  401506:	2101      	movs	r1, #1
  401508:	2001      	movs	r0, #1
  40150a:	4b33      	ldr	r3, [pc, #204]	; (4015d8 <indicate_alive+0xe0>)
  40150c:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_OK_2, IOPORT_DIR_OUTPUT);
  40150e:	2101      	movs	r1, #1
  401510:	2005      	movs	r0, #5
  401512:	4b31      	ldr	r3, [pc, #196]	; (4015d8 <indicate_alive+0xe0>)
  401514:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_OK_3, IOPORT_DIR_OUTPUT);
  401516:	2101      	movs	r1, #1
  401518:	202f      	movs	r0, #47	; 0x2f
  40151a:	4b2f      	ldr	r3, [pc, #188]	; (4015d8 <indicate_alive+0xe0>)
  40151c:	4798      	blx	r3

	ioport_set_pin_level(CHIRP_OK_0, IOPORT_PIN_LEVEL_LOW); //CHIRP_OK_0=L LED=on
  40151e:	2100      	movs	r1, #0
  401520:	2000      	movs	r0, #0
  401522:	4b2e      	ldr	r3, [pc, #184]	; (4015dc <indicate_alive+0xe4>)
  401524:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_1, IOPORT_PIN_LEVEL_LOW);
  401526:	2100      	movs	r1, #0
  401528:	2001      	movs	r0, #1
  40152a:	4b2c      	ldr	r3, [pc, #176]	; (4015dc <indicate_alive+0xe4>)
  40152c:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_2, IOPORT_PIN_LEVEL_LOW);
  40152e:	2100      	movs	r1, #0
  401530:	2005      	movs	r0, #5
  401532:	4b2a      	ldr	r3, [pc, #168]	; (4015dc <indicate_alive+0xe4>)
  401534:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_3, IOPORT_PIN_LEVEL_LOW);
  401536:	2100      	movs	r1, #0
  401538:	202f      	movs	r0, #47	; 0x2f
  40153a:	4b28      	ldr	r3, [pc, #160]	; (4015dc <indicate_alive+0xe4>)
  40153c:	4798      	blx	r3

	delay_s(1);		//light up for 1s
  40153e:	4b28      	ldr	r3, [pc, #160]	; (4015e0 <indicate_alive+0xe8>)
  401540:	4798      	blx	r3
  401542:	4603      	mov	r3, r0
  401544:	4619      	mov	r1, r3
  401546:	f04f 0200 	mov.w	r2, #0
  40154a:	460b      	mov	r3, r1
  40154c:	4614      	mov	r4, r2
  40154e:	ea4f 1b44 	mov.w	fp, r4, lsl #5
  401552:	ea4b 6bd3 	orr.w	fp, fp, r3, lsr #27
  401556:	ea4f 1a43 	mov.w	sl, r3, lsl #5
  40155a:	4653      	mov	r3, sl
  40155c:	465c      	mov	r4, fp
  40155e:	1a5b      	subs	r3, r3, r1
  401560:	eb64 0402 	sbc.w	r4, r4, r2
  401564:	ea4f 0984 	mov.w	r9, r4, lsl #2
  401568:	ea49 7993 	orr.w	r9, r9, r3, lsr #30
  40156c:	ea4f 0883 	mov.w	r8, r3, lsl #2
  401570:	4643      	mov	r3, r8
  401572:	464c      	mov	r4, r9
  401574:	185b      	adds	r3, r3, r1
  401576:	eb44 0402 	adc.w	r4, r4, r2
  40157a:	00e6      	lsls	r6, r4, #3
  40157c:	ea46 7653 	orr.w	r6, r6, r3, lsr #29
  401580:	00dd      	lsls	r5, r3, #3
  401582:	462b      	mov	r3, r5
  401584:	4634      	mov	r4, r6
  401586:	4619      	mov	r1, r3
  401588:	4622      	mov	r2, r4
  40158a:	f243 63af 	movw	r3, #13999	; 0x36af
  40158e:	f04f 0400 	mov.w	r4, #0
  401592:	18cd      	adds	r5, r1, r3
  401594:	eb42 0604 	adc.w	r6, r2, r4
  401598:	4628      	mov	r0, r5
  40159a:	4631      	mov	r1, r6
  40159c:	4c11      	ldr	r4, [pc, #68]	; (4015e4 <indicate_alive+0xec>)
  40159e:	f243 62b0 	movw	r2, #14000	; 0x36b0
  4015a2:	f04f 0300 	mov.w	r3, #0
  4015a6:	47a0      	blx	r4
  4015a8:	4603      	mov	r3, r0
  4015aa:	460c      	mov	r4, r1
  4015ac:	4618      	mov	r0, r3
  4015ae:	4b0e      	ldr	r3, [pc, #56]	; (4015e8 <indicate_alive+0xf0>)
  4015b0:	4798      	blx	r3

	ioport_set_pin_level(CHIRP_OK_0, IOPORT_PIN_LEVEL_HIGH); //CHIRP_OK_0=H LED=off
  4015b2:	2101      	movs	r1, #1
  4015b4:	2000      	movs	r0, #0
  4015b6:	4b09      	ldr	r3, [pc, #36]	; (4015dc <indicate_alive+0xe4>)
  4015b8:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_1, IOPORT_PIN_LEVEL_HIGH);
  4015ba:	2101      	movs	r1, #1
  4015bc:	2001      	movs	r0, #1
  4015be:	4b07      	ldr	r3, [pc, #28]	; (4015dc <indicate_alive+0xe4>)
  4015c0:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_2, IOPORT_PIN_LEVEL_HIGH);
  4015c2:	2101      	movs	r1, #1
  4015c4:	2005      	movs	r0, #5
  4015c6:	4b05      	ldr	r3, [pc, #20]	; (4015dc <indicate_alive+0xe4>)
  4015c8:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_OK_3, IOPORT_PIN_LEVEL_HIGH);
  4015ca:	2101      	movs	r1, #1
  4015cc:	202f      	movs	r0, #47	; 0x2f
  4015ce:	4b03      	ldr	r3, [pc, #12]	; (4015dc <indicate_alive+0xe4>)
  4015d0:	4798      	blx	r3
}
  4015d2:	bf00      	nop
  4015d4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4015d8:	004010c9 	.word	0x004010c9
  4015dc:	00401151 	.word	0x00401151
  4015e0:	004010b5 	.word	0x004010b5
  4015e4:	0040cbad 	.word	0x0040cbad
  4015e8:	20000001 	.word	0x20000001

004015ec <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  4015ec:	b480      	push	{r7}
  4015ee:	b083      	sub	sp, #12
  4015f0:	af00      	add	r7, sp, #0
  4015f2:	4603      	mov	r3, r0
  4015f4:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4015f6:	4909      	ldr	r1, [pc, #36]	; (40161c <NVIC_EnableIRQ+0x30>)
  4015f8:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4015fc:	095b      	lsrs	r3, r3, #5
  4015fe:	79fa      	ldrb	r2, [r7, #7]
  401600:	f002 021f 	and.w	r2, r2, #31
  401604:	2001      	movs	r0, #1
  401606:	fa00 f202 	lsl.w	r2, r0, r2
  40160a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40160e:	bf00      	nop
  401610:	370c      	adds	r7, #12
  401612:	46bd      	mov	sp, r7
  401614:	f85d 7b04 	ldr.w	r7, [sp], #4
  401618:	4770      	bx	lr
  40161a:	bf00      	nop
  40161c:	e000e100 	.word	0xe000e100

00401620 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  401620:	b480      	push	{r7}
  401622:	b083      	sub	sp, #12
  401624:	af00      	add	r7, sp, #0
  401626:	4603      	mov	r3, r0
  401628:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  40162a:	4909      	ldr	r1, [pc, #36]	; (401650 <NVIC_DisableIRQ+0x30>)
  40162c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  401630:	095b      	lsrs	r3, r3, #5
  401632:	79fa      	ldrb	r2, [r7, #7]
  401634:	f002 021f 	and.w	r2, r2, #31
  401638:	2001      	movs	r0, #1
  40163a:	fa00 f202 	lsl.w	r2, r0, r2
  40163e:	3320      	adds	r3, #32
  401640:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  401644:	bf00      	nop
  401646:	370c      	adds	r7, #12
  401648:	46bd      	mov	sp, r7
  40164a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40164e:	4770      	bx	lr
  401650:	e000e100 	.word	0xe000e100

00401654 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  401654:	b480      	push	{r7}
  401656:	b083      	sub	sp, #12
  401658:	af00      	add	r7, sp, #0
  40165a:	4603      	mov	r3, r0
  40165c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40165e:	4909      	ldr	r1, [pc, #36]	; (401684 <NVIC_ClearPendingIRQ+0x30>)
  401660:	f997 3007 	ldrsb.w	r3, [r7, #7]
  401664:	095b      	lsrs	r3, r3, #5
  401666:	79fa      	ldrb	r2, [r7, #7]
  401668:	f002 021f 	and.w	r2, r2, #31
  40166c:	2001      	movs	r0, #1
  40166e:	fa00 f202 	lsl.w	r2, r0, r2
  401672:	3360      	adds	r3, #96	; 0x60
  401674:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  401678:	bf00      	nop
  40167a:	370c      	adds	r7, #12
  40167c:	46bd      	mov	sp, r7
  40167e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401682:	4770      	bx	lr
  401684:	e000e100 	.word	0xe000e100

00401688 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  401688:	b480      	push	{r7}
  40168a:	b083      	sub	sp, #12
  40168c:	af00      	add	r7, sp, #0
  40168e:	4603      	mov	r3, r0
  401690:	6039      	str	r1, [r7, #0]
  401692:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  401694:	f997 3007 	ldrsb.w	r3, [r7, #7]
  401698:	2b00      	cmp	r3, #0
  40169a:	da0b      	bge.n	4016b4 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  40169c:	490d      	ldr	r1, [pc, #52]	; (4016d4 <NVIC_SetPriority+0x4c>)
  40169e:	79fb      	ldrb	r3, [r7, #7]
  4016a0:	f003 030f 	and.w	r3, r3, #15
  4016a4:	3b04      	subs	r3, #4
  4016a6:	683a      	ldr	r2, [r7, #0]
  4016a8:	b2d2      	uxtb	r2, r2
  4016aa:	0112      	lsls	r2, r2, #4
  4016ac:	b2d2      	uxtb	r2, r2
  4016ae:	440b      	add	r3, r1
  4016b0:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
  4016b2:	e009      	b.n	4016c8 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4016b4:	4908      	ldr	r1, [pc, #32]	; (4016d8 <NVIC_SetPriority+0x50>)
  4016b6:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4016ba:	683a      	ldr	r2, [r7, #0]
  4016bc:	b2d2      	uxtb	r2, r2
  4016be:	0112      	lsls	r2, r2, #4
  4016c0:	b2d2      	uxtb	r2, r2
  4016c2:	440b      	add	r3, r1
  4016c4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  4016c8:	bf00      	nop
  4016ca:	370c      	adds	r7, #12
  4016cc:	46bd      	mov	sp, r7
  4016ce:	f85d 7b04 	ldr.w	r7, [sp], #4
  4016d2:	4770      	bx	lr
  4016d4:	e000ed00 	.word	0xe000ed00
  4016d8:	e000e100 	.word	0xe000e100

004016dc <osc_get_rate>:
{
  4016dc:	b480      	push	{r7}
  4016de:	b083      	sub	sp, #12
  4016e0:	af00      	add	r7, sp, #0
  4016e2:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4016e4:	687b      	ldr	r3, [r7, #4]
  4016e6:	2b07      	cmp	r3, #7
  4016e8:	d825      	bhi.n	401736 <osc_get_rate+0x5a>
  4016ea:	a201      	add	r2, pc, #4	; (adr r2, 4016f0 <osc_get_rate+0x14>)
  4016ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4016f0:	00401711 	.word	0x00401711
  4016f4:	00401717 	.word	0x00401717
  4016f8:	0040171d 	.word	0x0040171d
  4016fc:	00401723 	.word	0x00401723
  401700:	00401727 	.word	0x00401727
  401704:	0040172b 	.word	0x0040172b
  401708:	0040172f 	.word	0x0040172f
  40170c:	00401733 	.word	0x00401733
		return OSC_SLCK_32K_RC_HZ;
  401710:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401714:	e010      	b.n	401738 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  401716:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40171a:	e00d      	b.n	401738 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  40171c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401720:	e00a      	b.n	401738 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  401722:	4b08      	ldr	r3, [pc, #32]	; (401744 <osc_get_rate+0x68>)
  401724:	e008      	b.n	401738 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  401726:	4b08      	ldr	r3, [pc, #32]	; (401748 <osc_get_rate+0x6c>)
  401728:	e006      	b.n	401738 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  40172a:	4b08      	ldr	r3, [pc, #32]	; (40174c <osc_get_rate+0x70>)
  40172c:	e004      	b.n	401738 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  40172e:	2300      	movs	r3, #0
  401730:	e002      	b.n	401738 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  401732:	2300      	movs	r3, #0
  401734:	e000      	b.n	401738 <osc_get_rate+0x5c>
	return 0;
  401736:	2300      	movs	r3, #0
}
  401738:	4618      	mov	r0, r3
  40173a:	370c      	adds	r7, #12
  40173c:	46bd      	mov	sp, r7
  40173e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401742:	4770      	bx	lr
  401744:	007a1200 	.word	0x007a1200
  401748:	00f42400 	.word	0x00f42400
  40174c:	016e3600 	.word	0x016e3600

00401750 <sysclk_get_main_hz>:
{
  401750:	b580      	push	{r7, lr}
  401752:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  401754:	2001      	movs	r0, #1
  401756:	4b04      	ldr	r3, [pc, #16]	; (401768 <sysclk_get_main_hz+0x18>)
  401758:	4798      	blx	r3
  40175a:	4602      	mov	r2, r0
  40175c:	f640 634e 	movw	r3, #3662	; 0xe4e
  401760:	fb03 f302 	mul.w	r3, r3, r2
}
  401764:	4618      	mov	r0, r3
  401766:	bd80      	pop	{r7, pc}
  401768:	004016dd 	.word	0x004016dd

0040176c <sysclk_get_cpu_hz>:
{
  40176c:	b580      	push	{r7, lr}
  40176e:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  401770:	4b02      	ldr	r3, [pc, #8]	; (40177c <sysclk_get_cpu_hz+0x10>)
  401772:	4798      	blx	r3
  401774:	4603      	mov	r3, r0
}
  401776:	4618      	mov	r0, r3
  401778:	bd80      	pop	{r7, pc}
  40177a:	bf00      	nop
  40177c:	00401751 	.word	0x00401751

00401780 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  401780:	b580      	push	{r7, lr}
  401782:	b082      	sub	sp, #8
  401784:	af00      	add	r7, sp, #0
  401786:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  401788:	6878      	ldr	r0, [r7, #4]
  40178a:	4b03      	ldr	r3, [pc, #12]	; (401798 <sysclk_enable_peripheral_clock+0x18>)
  40178c:	4798      	blx	r3
}
  40178e:	bf00      	nop
  401790:	3708      	adds	r7, #8
  401792:	46bd      	mov	sp, r7
  401794:	bd80      	pop	{r7, pc}
  401796:	bf00      	nop
  401798:	00404459 	.word	0x00404459

0040179c <ioport_set_port_dir>:
{
  40179c:	b480      	push	{r7}
  40179e:	b08b      	sub	sp, #44	; 0x2c
  4017a0:	af00      	add	r7, sp, #0
  4017a2:	60f8      	str	r0, [r7, #12]
  4017a4:	60b9      	str	r1, [r7, #8]
  4017a6:	4613      	mov	r3, r2
  4017a8:	71fb      	strb	r3, [r7, #7]
  4017aa:	68fb      	ldr	r3, [r7, #12]
  4017ac:	627b      	str	r3, [r7, #36]	; 0x24
  4017ae:	68bb      	ldr	r3, [r7, #8]
  4017b0:	623b      	str	r3, [r7, #32]
  4017b2:	79fb      	ldrb	r3, [r7, #7]
  4017b4:	77fb      	strb	r3, [r7, #31]
  4017b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4017b8:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4017ba:	69bb      	ldr	r3, [r7, #24]
  4017bc:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4017c0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4017c4:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  4017c6:	617b      	str	r3, [r7, #20]
	if (group_direction == IOPORT_DIR_OUTPUT) {
  4017c8:	7ffb      	ldrb	r3, [r7, #31]
  4017ca:	2b01      	cmp	r3, #1
  4017cc:	d103      	bne.n	4017d6 <ioport_set_port_dir+0x3a>
		base->PIO_OER = mask;
  4017ce:	697b      	ldr	r3, [r7, #20]
  4017d0:	6a3a      	ldr	r2, [r7, #32]
  4017d2:	611a      	str	r2, [r3, #16]
  4017d4:	e005      	b.n	4017e2 <ioport_set_port_dir+0x46>
	} else if (group_direction == IOPORT_DIR_INPUT) {
  4017d6:	7ffb      	ldrb	r3, [r7, #31]
  4017d8:	2b00      	cmp	r3, #0
  4017da:	d102      	bne.n	4017e2 <ioport_set_port_dir+0x46>
		base->PIO_ODR = mask;
  4017dc:	697b      	ldr	r3, [r7, #20]
  4017de:	6a3a      	ldr	r2, [r7, #32]
  4017e0:	615a      	str	r2, [r3, #20]
	base->PIO_OWER = mask;
  4017e2:	697b      	ldr	r3, [r7, #20]
  4017e4:	6a3a      	ldr	r2, [r7, #32]
  4017e6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  4017ea:	bf00      	nop
  4017ec:	372c      	adds	r7, #44	; 0x2c
  4017ee:	46bd      	mov	sp, r7
  4017f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4017f4:	4770      	bx	lr

004017f6 <ioport_set_pin_dir>:
{
  4017f6:	b480      	push	{r7}
  4017f8:	b08d      	sub	sp, #52	; 0x34
  4017fa:	af00      	add	r7, sp, #0
  4017fc:	6078      	str	r0, [r7, #4]
  4017fe:	460b      	mov	r3, r1
  401800:	70fb      	strb	r3, [r7, #3]
  401802:	687b      	ldr	r3, [r7, #4]
  401804:	62fb      	str	r3, [r7, #44]	; 0x2c
  401806:	78fb      	ldrb	r3, [r7, #3]
  401808:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40180c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40180e:	627b      	str	r3, [r7, #36]	; 0x24
  401810:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401812:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  401814:	6a3b      	ldr	r3, [r7, #32]
  401816:	095b      	lsrs	r3, r3, #5
  401818:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40181a:	69fb      	ldr	r3, [r7, #28]
  40181c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401820:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401824:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  401826:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  401828:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40182c:	2b01      	cmp	r3, #1
  40182e:	d109      	bne.n	401844 <ioport_set_pin_dir+0x4e>
  401830:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401832:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401834:	697b      	ldr	r3, [r7, #20]
  401836:	f003 031f 	and.w	r3, r3, #31
  40183a:	2201      	movs	r2, #1
  40183c:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40183e:	69bb      	ldr	r3, [r7, #24]
  401840:	611a      	str	r2, [r3, #16]
  401842:	e00c      	b.n	40185e <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  401844:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401848:	2b00      	cmp	r3, #0
  40184a:	d108      	bne.n	40185e <ioport_set_pin_dir+0x68>
  40184c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40184e:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  401850:	693b      	ldr	r3, [r7, #16]
  401852:	f003 031f 	and.w	r3, r3, #31
  401856:	2201      	movs	r2, #1
  401858:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  40185a:	69bb      	ldr	r3, [r7, #24]
  40185c:	615a      	str	r2, [r3, #20]
  40185e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401860:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401862:	68fb      	ldr	r3, [r7, #12]
  401864:	f003 031f 	and.w	r3, r3, #31
  401868:	2201      	movs	r2, #1
  40186a:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40186c:	69bb      	ldr	r3, [r7, #24]
  40186e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  401872:	bf00      	nop
  401874:	3734      	adds	r7, #52	; 0x34
  401876:	46bd      	mov	sp, r7
  401878:	f85d 7b04 	ldr.w	r7, [sp], #4
  40187c:	4770      	bx	lr

0040187e <ioport_set_pin_level>:
{
  40187e:	b480      	push	{r7}
  401880:	b08b      	sub	sp, #44	; 0x2c
  401882:	af00      	add	r7, sp, #0
  401884:	6078      	str	r0, [r7, #4]
  401886:	460b      	mov	r3, r1
  401888:	70fb      	strb	r3, [r7, #3]
  40188a:	687b      	ldr	r3, [r7, #4]
  40188c:	627b      	str	r3, [r7, #36]	; 0x24
  40188e:	78fb      	ldrb	r3, [r7, #3]
  401890:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401894:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401896:	61fb      	str	r3, [r7, #28]
  401898:	69fb      	ldr	r3, [r7, #28]
  40189a:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  40189c:	69bb      	ldr	r3, [r7, #24]
  40189e:	095b      	lsrs	r3, r3, #5
  4018a0:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4018a2:	697b      	ldr	r3, [r7, #20]
  4018a4:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4018a8:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4018ac:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  4018ae:	613b      	str	r3, [r7, #16]
	if (level) {
  4018b0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4018b4:	2b00      	cmp	r3, #0
  4018b6:	d009      	beq.n	4018cc <ioport_set_pin_level+0x4e>
  4018b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4018ba:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4018bc:	68fb      	ldr	r3, [r7, #12]
  4018be:	f003 031f 	and.w	r3, r3, #31
  4018c2:	2201      	movs	r2, #1
  4018c4:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4018c6:	693b      	ldr	r3, [r7, #16]
  4018c8:	631a      	str	r2, [r3, #48]	; 0x30
}
  4018ca:	e008      	b.n	4018de <ioport_set_pin_level+0x60>
  4018cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4018ce:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  4018d0:	68bb      	ldr	r3, [r7, #8]
  4018d2:	f003 031f 	and.w	r3, r3, #31
  4018d6:	2201      	movs	r2, #1
  4018d8:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  4018da:	693b      	ldr	r3, [r7, #16]
  4018dc:	635a      	str	r2, [r3, #52]	; 0x34
  4018de:	bf00      	nop
  4018e0:	372c      	adds	r7, #44	; 0x2c
  4018e2:	46bd      	mov	sp, r7
  4018e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4018e8:	4770      	bx	lr

004018ea <ioport_set_port_level>:
 * \param mask Pin mask of pins to modify
 * \param level Level of the pins to be modified
 */
static inline void ioport_set_port_level(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_value level)
{
  4018ea:	b480      	push	{r7}
  4018ec:	b08b      	sub	sp, #44	; 0x2c
  4018ee:	af00      	add	r7, sp, #0
  4018f0:	60f8      	str	r0, [r7, #12]
  4018f2:	60b9      	str	r1, [r7, #8]
  4018f4:	4613      	mov	r3, r2
  4018f6:	71fb      	strb	r3, [r7, #7]
  4018f8:	68fb      	ldr	r3, [r7, #12]
  4018fa:	627b      	str	r3, [r7, #36]	; 0x24
  4018fc:	68bb      	ldr	r3, [r7, #8]
  4018fe:	623b      	str	r3, [r7, #32]
  401900:	79fb      	ldrb	r3, [r7, #7]
  401902:	77fb      	strb	r3, [r7, #31]
  401904:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401906:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401908:	69bb      	ldr	r3, [r7, #24]
  40190a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40190e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401912:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_level(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_value level)
{
	Pio *base = arch_ioport_port_to_base(port);
  401914:	617b      	str	r3, [r7, #20]

	if (level){
  401916:	7ffb      	ldrb	r3, [r7, #31]
  401918:	2b00      	cmp	r3, #0
  40191a:	d003      	beq.n	401924 <ioport_set_port_level+0x3a>
		base->PIO_SODR = mask;
  40191c:	697b      	ldr	r3, [r7, #20]
  40191e:	6a3a      	ldr	r2, [r7, #32]
  401920:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_port_level(port, mask, level);
}
  401922:	e002      	b.n	40192a <ioport_set_port_level+0x40>
	} else {
		base->PIO_CODR = mask;
  401924:	697b      	ldr	r3, [r7, #20]
  401926:	6a3a      	ldr	r2, [r7, #32]
  401928:	635a      	str	r2, [r3, #52]	; 0x34
  40192a:	bf00      	nop
  40192c:	372c      	adds	r7, #44	; 0x2c
  40192e:	46bd      	mov	sp, r7
  401930:	f85d 7b04 	ldr.w	r7, [sp], #4
  401934:	4770      	bx	lr

00401936 <ioport_pin_to_mask>:
 *
 * \param pin IOPORT pin ID to convert
 * \retval Bitmask with a bit set that corresponds to the given pin ID in its port
 */
static inline ioport_port_mask_t ioport_pin_to_mask(ioport_pin_t pin)
{
  401936:	b480      	push	{r7}
  401938:	b085      	sub	sp, #20
  40193a:	af00      	add	r7, sp, #0
  40193c:	6078      	str	r0, [r7, #4]
  40193e:	687b      	ldr	r3, [r7, #4]
  401940:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401942:	68fb      	ldr	r3, [r7, #12]
  401944:	f003 031f 	and.w	r3, r3, #31
  401948:	2201      	movs	r2, #1
  40194a:	fa02 f303 	lsl.w	r3, r2, r3
	return arch_ioport_pin_to_mask(pin);
  40194e:	bf00      	nop
}
  401950:	4618      	mov	r0, r3
  401952:	3714      	adds	r7, #20
  401954:	46bd      	mov	sp, r7
  401956:	f85d 7b04 	ldr.w	r7, [sp], #4
  40195a:	4770      	bx	lr

0040195c <adc_ch_sanity_check>:
 * \param channel  Adc channel number.
 *
 */
static inline void adc_ch_sanity_check(Adc *const adc,
		const enum adc_channel_num channel)
{
  40195c:	b480      	push	{r7}
  40195e:	b083      	sub	sp, #12
  401960:	af00      	add	r7, sp, #0
  401962:	6078      	str	r0, [r7, #4]
  401964:	460b      	mov	r3, r1
  401966:	807b      	strh	r3, [r7, #2]
#endif
				);
	}

	UNUSED(channel);
}
  401968:	bf00      	nop
  40196a:	370c      	adds	r7, #12
  40196c:	46bd      	mov	sp, r7
  40196e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401972:	4770      	bx	lr

00401974 <adc_select_clock_source_mck>:
 *
 * \param adc  Base address of the ADC.
 *
 */
static inline void adc_select_clock_source_mck(Adc *const adc)
{
  401974:	b480      	push	{r7}
  401976:	b085      	sub	sp, #20
  401978:	af00      	add	r7, sp, #0
  40197a:	6078      	str	r0, [r7, #4]
	uint32_t reg;

	reg = adc->ADC_EMR;
  40197c:	687b      	ldr	r3, [r7, #4]
  40197e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401980:	60fb      	str	r3, [r7, #12]

	reg &= ~ADC_EMR_SRCCLK_PMC_PCK;
  401982:	68fb      	ldr	r3, [r7, #12]
  401984:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  401988:	60fb      	str	r3, [r7, #12]

	adc->ADC_EMR = reg;
  40198a:	687b      	ldr	r3, [r7, #4]
  40198c:	68fa      	ldr	r2, [r7, #12]
  40198e:	641a      	str	r2, [r3, #64]	; 0x40
}
  401990:	bf00      	nop
  401992:	3714      	adds	r7, #20
  401994:	46bd      	mov	sp, r7
  401996:	f85d 7b04 	ldr.w	r7, [sp], #4
  40199a:	4770      	bx	lr

0040199c <adc_set_trigger>:
 * \param trigger Conversion trigger.
 *
 */
static inline void adc_set_trigger(Adc *const adc,
		const enum adc_trigger trigger)
{
  40199c:	b480      	push	{r7}
  40199e:	b085      	sub	sp, #20
  4019a0:	af00      	add	r7, sp, #0
  4019a2:	6078      	str	r0, [r7, #4]
  4019a4:	460b      	mov	r3, r1
  4019a6:	70fb      	strb	r3, [r7, #3]
	uint32_t reg;

	reg = adc->ADC_MR;
  4019a8:	687b      	ldr	r3, [r7, #4]
  4019aa:	685b      	ldr	r3, [r3, #4]
  4019ac:	60fb      	str	r3, [r7, #12]

	if (trigger == ADC_TRIG_FREERUN) {
  4019ae:	78fb      	ldrb	r3, [r7, #3]
  4019b0:	2bff      	cmp	r3, #255	; 0xff
  4019b2:	d104      	bne.n	4019be <adc_set_trigger+0x22>
		reg |= ADC_MR_FREERUN_ON;
  4019b4:	68fb      	ldr	r3, [r7, #12]
  4019b6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  4019ba:	60fb      	str	r3, [r7, #12]
  4019bc:	e007      	b.n	4019ce <adc_set_trigger+0x32>
	} else {
		reg &= ~(ADC_MR_TRGSEL_Msk | ADC_MR_TRGEN | ADC_MR_FREERUN_ON);
  4019be:	68fb      	ldr	r3, [r7, #12]
  4019c0:	f023 038f 	bic.w	r3, r3, #143	; 0x8f
  4019c4:	60fb      	str	r3, [r7, #12]
		reg |= trigger;
  4019c6:	78fb      	ldrb	r3, [r7, #3]
  4019c8:	68fa      	ldr	r2, [r7, #12]
  4019ca:	4313      	orrs	r3, r2
  4019cc:	60fb      	str	r3, [r7, #12]
	}

	adc->ADC_MR = reg;
  4019ce:	687b      	ldr	r3, [r7, #4]
  4019d0:	68fa      	ldr	r2, [r7, #12]
  4019d2:	605a      	str	r2, [r3, #4]
}
  4019d4:	bf00      	nop
  4019d6:	3714      	adds	r7, #20
  4019d8:	46bd      	mov	sp, r7
  4019da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4019de:	4770      	bx	lr

004019e0 <adc_set_writeprotect>:
 * \param adc  Base address of the ADC.
 * \param is_enable 1 to enable, 0 to disable.
 */
static inline void adc_set_writeprotect(Adc *const adc,
		const bool is_enable)
{
  4019e0:	b480      	push	{r7}
  4019e2:	b083      	sub	sp, #12
  4019e4:	af00      	add	r7, sp, #0
  4019e6:	6078      	str	r0, [r7, #4]
  4019e8:	460b      	mov	r3, r1
  4019ea:	70fb      	strb	r3, [r7, #3]
	if (is_enable) {
  4019ec:	78fb      	ldrb	r3, [r7, #3]
  4019ee:	2b00      	cmp	r3, #0
  4019f0:	d004      	beq.n	4019fc <adc_set_writeprotect+0x1c>
		adc->ADC_WPMR = ADC_WPMR_WPEN | ADC_WPMR_WPKEY_PASSWD;
  4019f2:	687b      	ldr	r3, [r7, #4]
  4019f4:	4a06      	ldr	r2, [pc, #24]	; (401a10 <adc_set_writeprotect+0x30>)
  4019f6:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	} else {
		adc->ADC_WPMR = ADC_WPMR_WPKEY_PASSWD;
	}
}
  4019fa:	e003      	b.n	401a04 <adc_set_writeprotect+0x24>
		adc->ADC_WPMR = ADC_WPMR_WPKEY_PASSWD;
  4019fc:	687b      	ldr	r3, [r7, #4]
  4019fe:	4a05      	ldr	r2, [pc, #20]	; (401a14 <adc_set_writeprotect+0x34>)
  401a00:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  401a04:	bf00      	nop
  401a06:	370c      	adds	r7, #12
  401a08:	46bd      	mov	sp, r7
  401a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
  401a0e:	4770      	bx	lr
  401a10:	41444301 	.word	0x41444301
  401a14:	41444300 	.word	0x41444300

00401a18 <adc_channel_enable>:
 * \param adc  Base address of the ADC.
 * \param adc_ch Adc channel number.
 */
static inline void adc_channel_enable(Adc *const adc,
		const enum adc_channel_num adc_ch)
{
  401a18:	b580      	push	{r7, lr}
  401a1a:	b082      	sub	sp, #8
  401a1c:	af00      	add	r7, sp, #0
  401a1e:	6078      	str	r0, [r7, #4]
  401a20:	460b      	mov	r3, r1
  401a22:	807b      	strh	r3, [r7, #2]
	if (adc_ch != ADC_CHANNEL_ALL) {
  401a24:	887b      	ldrh	r3, [r7, #2]
  401a26:	f64f 72ff 	movw	r2, #65535	; 0xffff
  401a2a:	4293      	cmp	r3, r2
  401a2c:	d004      	beq.n	401a38 <adc_channel_enable+0x20>
		adc_ch_sanity_check(adc, adc_ch);
  401a2e:	887b      	ldrh	r3, [r7, #2]
  401a30:	4619      	mov	r1, r3
  401a32:	6878      	ldr	r0, [r7, #4]
  401a34:	4b0a      	ldr	r3, [pc, #40]	; (401a60 <adc_channel_enable+0x48>)
  401a36:	4798      	blx	r3
	}

	adc->ADC_CHER = (adc_ch == ADC_CHANNEL_ALL) ?
			ADC_CHANNEL_ALL : 1 << adc_ch;
  401a38:	887b      	ldrh	r3, [r7, #2]
  401a3a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  401a3e:	4293      	cmp	r3, r2
  401a40:	d005      	beq.n	401a4e <adc_channel_enable+0x36>
  401a42:	887b      	ldrh	r3, [r7, #2]
  401a44:	2201      	movs	r2, #1
  401a46:	fa02 f303 	lsl.w	r3, r2, r3
  401a4a:	461a      	mov	r2, r3
  401a4c:	e001      	b.n	401a52 <adc_channel_enable+0x3a>
  401a4e:	f64f 72ff 	movw	r2, #65535	; 0xffff
	adc->ADC_CHER = (adc_ch == ADC_CHANNEL_ALL) ?
  401a52:	687b      	ldr	r3, [r7, #4]
  401a54:	611a      	str	r2, [r3, #16]
}
  401a56:	bf00      	nop
  401a58:	3708      	adds	r7, #8
  401a5a:	46bd      	mov	sp, r7
  401a5c:	bd80      	pop	{r7, pc}
  401a5e:	bf00      	nop
  401a60:	0040195d 	.word	0x0040195d

00401a64 <adc_channel_get_value>:
 *
 * \return ADC converted value of the selected channel.
 */
static inline uint32_t adc_channel_get_value(Adc *const adc,
		enum adc_channel_num adc_ch)
{
  401a64:	b580      	push	{r7, lr}
  401a66:	b082      	sub	sp, #8
  401a68:	af00      	add	r7, sp, #0
  401a6a:	6078      	str	r0, [r7, #4]
  401a6c:	460b      	mov	r3, r1
  401a6e:	807b      	strh	r3, [r7, #2]
	adc_ch_sanity_check(adc, adc_ch);
  401a70:	887b      	ldrh	r3, [r7, #2]
  401a72:	4619      	mov	r1, r3
  401a74:	6878      	ldr	r0, [r7, #4]
  401a76:	4b05      	ldr	r3, [pc, #20]	; (401a8c <adc_channel_get_value+0x28>)
  401a78:	4798      	blx	r3

	return adc->ADC_CDR[adc_ch];
  401a7a:	887a      	ldrh	r2, [r7, #2]
  401a7c:	687b      	ldr	r3, [r7, #4]
  401a7e:	3214      	adds	r2, #20
  401a80:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
  401a84:	4618      	mov	r0, r3
  401a86:	3708      	adds	r7, #8
  401a88:	46bd      	mov	sp, r7
  401a8a:	bd80      	pop	{r7, pc}
  401a8c:	0040195d 	.word	0x0040195d

00401a90 <measure_idd>:
static void ADC0_init(void);
static void ext_int_init(void);
static void find_sensors(void);

static uint32_t measure_idd(uint16_t nb_measures)
{
  401a90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401a94:	b091      	sub	sp, #68	; 0x44
  401a96:	af00      	add	r7, sp, #0
  401a98:	4603      	mov	r3, r0
  401a9a:	84fb      	strh	r3, [r7, #38]	; 0x26
	uint16_t i;
	uint64_t sum_idd = 0;
  401a9c:	f04f 0300 	mov.w	r3, #0
  401aa0:	f04f 0400 	mov.w	r4, #0
  401aa4:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30
	uint32_t average_idd;

	for (i = 0; i < nb_measures; ++i) {
  401aa8:	2300      	movs	r3, #0
  401aaa:	87fb      	strh	r3, [r7, #62]	; 0x3e
  401aac:	e082      	b.n	401bb4 <measure_idd+0x124>
		delay_us(ADC_MEASURE_WAIT_TIME_US);
  401aae:	4b76      	ldr	r3, [pc, #472]	; (401c88 <measure_idd+0x1f8>)
  401ab0:	4798      	blx	r3
  401ab2:	4603      	mov	r3, r0
  401ab4:	4619      	mov	r1, r3
  401ab6:	f04f 0200 	mov.w	r2, #0
  401aba:	460b      	mov	r3, r1
  401abc:	4614      	mov	r4, r2
  401abe:	18db      	adds	r3, r3, r3
  401ac0:	eb44 0404 	adc.w	r4, r4, r4
  401ac4:	185b      	adds	r3, r3, r1
  401ac6:	eb44 0402 	adc.w	r4, r4, r2
  401aca:	0160      	lsls	r0, r4, #5
  401acc:	61f8      	str	r0, [r7, #28]
  401ace:	69f8      	ldr	r0, [r7, #28]
  401ad0:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
  401ad4:	61f8      	str	r0, [r7, #28]
  401ad6:	015b      	lsls	r3, r3, #5
  401ad8:	61bb      	str	r3, [r7, #24]
  401ada:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
  401ade:	185b      	adds	r3, r3, r1
  401ae0:	eb44 0402 	adc.w	r4, r4, r2
  401ae4:	00a2      	lsls	r2, r4, #2
  401ae6:	617a      	str	r2, [r7, #20]
  401ae8:	697a      	ldr	r2, [r7, #20]
  401aea:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
  401aee:	617a      	str	r2, [r7, #20]
  401af0:	009a      	lsls	r2, r3, #2
  401af2:	613a      	str	r2, [r7, #16]
  401af4:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  401af8:	18c9      	adds	r1, r1, r3
  401afa:	eb42 0204 	adc.w	r2, r2, r4
  401afe:	460b      	mov	r3, r1
  401b00:	4614      	mov	r4, r2
  401b02:	18db      	adds	r3, r3, r3
  401b04:	eb44 0404 	adc.w	r4, r4, r4
  401b08:	4619      	mov	r1, r3
  401b0a:	4622      	mov	r2, r4
  401b0c:	a45a      	add	r4, pc, #360	; (adr r4, 401c78 <measure_idd+0x1e8>)
  401b0e:	e9d4 3400 	ldrd	r3, r4, [r4]
  401b12:	18cd      	adds	r5, r1, r3
  401b14:	eb42 0604 	adc.w	r6, r2, r4
  401b18:	4628      	mov	r0, r5
  401b1a:	4631      	mov	r1, r6
  401b1c:	4c5b      	ldr	r4, [pc, #364]	; (401c8c <measure_idd+0x1fc>)
  401b1e:	4a5c      	ldr	r2, [pc, #368]	; (401c90 <measure_idd+0x200>)
  401b20:	f04f 0300 	mov.w	r3, #0
  401b24:	47a0      	blx	r4
  401b26:	4603      	mov	r3, r0
  401b28:	460c      	mov	r4, r1
  401b2a:	4618      	mov	r0, r3
  401b2c:	4b59      	ldr	r3, [pc, #356]	; (401c94 <measure_idd+0x204>)
  401b2e:	4798      	blx	r3
		adc_local->ADC_CR = ADC_CR_START; /* start ADC conversion */
  401b30:	4b59      	ldr	r3, [pc, #356]	; (401c98 <measure_idd+0x208>)
  401b32:	681b      	ldr	r3, [r3, #0]
  401b34:	2202      	movs	r2, #2
  401b36:	601a      	str	r2, [r3, #0]
		delay_us(ADC_CONV_TIME_US); /* wait for ADC conversion time */
  401b38:	4b53      	ldr	r3, [pc, #332]	; (401c88 <measure_idd+0x1f8>)
  401b3a:	4798      	blx	r3
  401b3c:	4603      	mov	r3, r0
  401b3e:	4619      	mov	r1, r3
  401b40:	f04f 0200 	mov.w	r2, #0
  401b44:	460b      	mov	r3, r1
  401b46:	4614      	mov	r4, r2
  401b48:	0120      	lsls	r0, r4, #4
  401b4a:	60f8      	str	r0, [r7, #12]
  401b4c:	68f8      	ldr	r0, [r7, #12]
  401b4e:	ea40 7013 	orr.w	r0, r0, r3, lsr #28
  401b52:	60f8      	str	r0, [r7, #12]
  401b54:	011b      	lsls	r3, r3, #4
  401b56:	60bb      	str	r3, [r7, #8]
  401b58:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  401b5c:	1a5b      	subs	r3, r3, r1
  401b5e:	eb64 0402 	sbc.w	r4, r4, r2
  401b62:	18db      	adds	r3, r3, r3
  401b64:	eb44 0404 	adc.w	r4, r4, r4
  401b68:	4619      	mov	r1, r3
  401b6a:	4622      	mov	r2, r4
  401b6c:	a442      	add	r4, pc, #264	; (adr r4, 401c78 <measure_idd+0x1e8>)
  401b6e:	e9d4 3400 	ldrd	r3, r4, [r4]
  401b72:	18cd      	adds	r5, r1, r3
  401b74:	eb42 0604 	adc.w	r6, r2, r4
  401b78:	4628      	mov	r0, r5
  401b7a:	4631      	mov	r1, r6
  401b7c:	4c43      	ldr	r4, [pc, #268]	; (401c8c <measure_idd+0x1fc>)
  401b7e:	4a44      	ldr	r2, [pc, #272]	; (401c90 <measure_idd+0x200>)
  401b80:	f04f 0300 	mov.w	r3, #0
  401b84:	47a0      	blx	r4
  401b86:	4603      	mov	r3, r0
  401b88:	460c      	mov	r4, r1
  401b8a:	4618      	mov	r0, r3
  401b8c:	4b41      	ldr	r3, [pc, #260]	; (401c94 <measure_idd+0x204>)
  401b8e:	4798      	blx	r3
		sum_idd += adc_channel_get_value(ADC, ADC_CHANNEL_0);
  401b90:	2100      	movs	r1, #0
  401b92:	4842      	ldr	r0, [pc, #264]	; (401c9c <measure_idd+0x20c>)
  401b94:	4b42      	ldr	r3, [pc, #264]	; (401ca0 <measure_idd+0x210>)
  401b96:	4798      	blx	r3
  401b98:	4603      	mov	r3, r0
  401b9a:	4619      	mov	r1, r3
  401b9c:	f04f 0200 	mov.w	r2, #0
  401ba0:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
  401ba4:	185b      	adds	r3, r3, r1
  401ba6:	eb44 0402 	adc.w	r4, r4, r2
  401baa:	e9c7 340c 	strd	r3, r4, [r7, #48]	; 0x30
	for (i = 0; i < nb_measures; ++i) {
  401bae:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
  401bb0:	3301      	adds	r3, #1
  401bb2:	87fb      	strh	r3, [r7, #62]	; 0x3e
  401bb4:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
  401bb6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  401bb8:	429a      	cmp	r2, r3
  401bba:	f4ff af78 	bcc.w	401aae <measure_idd+0x1e>
	}

	average_idd = (sum_idd / nb_measures) * VOLT_REF / MAX_DIGITAL_12_BIT / ADC_MEAS_RAW_TO_UA_RATIO;
  401bbe:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  401bc0:	f04f 0400 	mov.w	r4, #0
  401bc4:	4d31      	ldr	r5, [pc, #196]	; (401c8c <measure_idd+0x1fc>)
  401bc6:	461a      	mov	r2, r3
  401bc8:	4623      	mov	r3, r4
  401bca:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
  401bce:	47a8      	blx	r5
  401bd0:	4603      	mov	r3, r0
  401bd2:	460c      	mov	r4, r1
  401bd4:	4619      	mov	r1, r3
  401bd6:	4622      	mov	r2, r4
  401bd8:	460b      	mov	r3, r1
  401bda:	4614      	mov	r4, r2
  401bdc:	18db      	adds	r3, r3, r3
  401bde:	eb44 0404 	adc.w	r4, r4, r4
  401be2:	185b      	adds	r3, r3, r1
  401be4:	eb44 0402 	adc.w	r4, r4, r2
  401be8:	00a0      	lsls	r0, r4, #2
  401bea:	6078      	str	r0, [r7, #4]
  401bec:	6878      	ldr	r0, [r7, #4]
  401bee:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
  401bf2:	6078      	str	r0, [r7, #4]
  401bf4:	009b      	lsls	r3, r3, #2
  401bf6:	603b      	str	r3, [r7, #0]
  401bf8:	e9d7 3400 	ldrd	r3, r4, [r7]
  401bfc:	185b      	adds	r3, r3, r1
  401bfe:	eb44 0402 	adc.w	r4, r4, r2
  401c02:	ea4f 1984 	mov.w	r9, r4, lsl #6
  401c06:	ea49 6993 	orr.w	r9, r9, r3, lsr #26
  401c0a:	ea4f 1883 	mov.w	r8, r3, lsl #6
  401c0e:	ebb8 0803 	subs.w	r8, r8, r3
  401c12:	eb69 0904 	sbc.w	r9, r9, r4
  401c16:	ea4f 0b89 	mov.w	fp, r9, lsl #2
  401c1a:	ea4b 7b98 	orr.w	fp, fp, r8, lsr #30
  401c1e:	ea4f 0a88 	mov.w	sl, r8, lsl #2
  401c22:	46d0      	mov	r8, sl
  401c24:	46d9      	mov	r9, fp
  401c26:	eb18 0301 	adds.w	r3, r8, r1
  401c2a:	eb49 0402 	adc.w	r4, r9, r2
  401c2e:	4618      	mov	r0, r3
  401c30:	4621      	mov	r1, r4
  401c32:	4c16      	ldr	r4, [pc, #88]	; (401c8c <measure_idd+0x1fc>)
  401c34:	f640 72ff 	movw	r2, #4095	; 0xfff
  401c38:	f04f 0300 	mov.w	r3, #0
  401c3c:	47a0      	blx	r4
  401c3e:	4603      	mov	r3, r0
  401c40:	460c      	mov	r4, r1
  401c42:	4619      	mov	r1, r3
  401c44:	4622      	mov	r2, r4
  401c46:	4b17      	ldr	r3, [pc, #92]	; (401ca4 <measure_idd+0x214>)
  401c48:	4608      	mov	r0, r1
  401c4a:	4611      	mov	r1, r2
  401c4c:	4798      	blx	r3
  401c4e:	4c16      	ldr	r4, [pc, #88]	; (401ca8 <measure_idd+0x218>)
  401c50:	a30b      	add	r3, pc, #44	; (adr r3, 401c80 <measure_idd+0x1f0>)
  401c52:	e9d3 2300 	ldrd	r2, r3, [r3]
  401c56:	47a0      	blx	r4
  401c58:	4603      	mov	r3, r0
  401c5a:	460c      	mov	r4, r1
  401c5c:	4619      	mov	r1, r3
  401c5e:	4622      	mov	r2, r4
  401c60:	4b12      	ldr	r3, [pc, #72]	; (401cac <measure_idd+0x21c>)
  401c62:	4608      	mov	r0, r1
  401c64:	4611      	mov	r1, r2
  401c66:	4798      	blx	r3
  401c68:	4603      	mov	r3, r0
  401c6a:	62fb      	str	r3, [r7, #44]	; 0x2c

	return average_idd;
  401c6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  401c6e:	4618      	mov	r0, r3
  401c70:	3744      	adds	r7, #68	; 0x44
  401c72:	46bd      	mov	sp, r7
  401c74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401c78:	00d59f7f 	.word	0x00d59f7f
  401c7c:	00000000 	.word	0x00000000
  401c80:	7fcb923a 	.word	0x7fcb923a
  401c84:	3fe3bf48 	.word	0x3fe3bf48
  401c88:	0040176d 	.word	0x0040176d
  401c8c:	0040cbad 	.word	0x0040cbad
  401c90:	00d59f80 	.word	0x00d59f80
  401c94:	20000001 	.word	0x20000001
  401c98:	20000164 	.word	0x20000164
  401c9c:	40038000 	.word	0x40038000
  401ca0:	00401a65 	.word	0x00401a65
  401ca4:	0040c551 	.word	0x0040c551
  401ca8:	0040c811 	.word	0x0040c811
  401cac:	0040cb6d 	.word	0x0040cb6d

00401cb0 <measure_power>:

static void measure_power(void)
{
  401cb0:	b580      	push	{r7, lr}
  401cb2:	b082      	sub	sp, #8
  401cb4:	af00      	add	r7, sp, #0
	uint32_t sensors_current;

	sensors_current = measure_idd(SENSORS_CURRENT_NB_MEASURE);
  401cb6:	2064      	movs	r0, #100	; 0x64
  401cb8:	4b05      	ldr	r3, [pc, #20]	; (401cd0 <measure_power+0x20>)
  401cba:	4798      	blx	r3
  401cbc:	6078      	str	r0, [r7, #4]
	printf("Chirp sensor Idd: %ld uA\n\n", sensors_current);
  401cbe:	6879      	ldr	r1, [r7, #4]
  401cc0:	4804      	ldr	r0, [pc, #16]	; (401cd4 <measure_power+0x24>)
  401cc2:	4b05      	ldr	r3, [pc, #20]	; (401cd8 <measure_power+0x28>)
  401cc4:	4798      	blx	r3
}
  401cc6:	bf00      	nop
  401cc8:	3708      	adds	r7, #8
  401cca:	46bd      	mov	sp, r7
  401ccc:	bd80      	pop	{r7, pc}
  401cce:	bf00      	nop
  401cd0:	00401a91 	.word	0x00401a91
  401cd4:	0040d258 	.word	0x0040d258
  401cd8:	00409ee9 	.word	0x00409ee9

00401cdc <find_sensors>:

static void find_sensors(void)
{
  401cdc:	b590      	push	{r4, r7, lr}
  401cde:	b083      	sub	sp, #12
  401ce0:	af00      	add	r7, sp, #0
	uint8_t sig_bytes[2];

	ioport_set_pin_dir(CHIRP_RST, IOPORT_DIR_OUTPUT); //reset=output
  401ce2:	2101      	movs	r1, #1
  401ce4:	200f      	movs	r0, #15
  401ce6:	4b5d      	ldr	r3, [pc, #372]	; (401e5c <find_sensors+0x180>)
  401ce8:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_RST, IOPORT_PIN_LEVEL_HIGH); //reset=H
  401cea:	2101      	movs	r1, #1
  401cec:	200f      	movs	r0, #15
  401cee:	4b5c      	ldr	r3, [pc, #368]	; (401e60 <find_sensors+0x184>)
  401cf0:	4798      	blx	r3

	/* Drive PROG low on all sensor ports */
	ioport_set_pin_dir(CHIRP_PROG_0, IOPORT_DIR_OUTPUT); //PROG_0=output
  401cf2:	2101      	movs	r1, #1
  401cf4:	2010      	movs	r0, #16
  401cf6:	4b59      	ldr	r3, [pc, #356]	; (401e5c <find_sensors+0x180>)
  401cf8:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_1, IOPORT_DIR_OUTPUT); //PROG_1=output
  401cfa:	2101      	movs	r1, #1
  401cfc:	2012      	movs	r0, #18
  401cfe:	4b57      	ldr	r3, [pc, #348]	; (401e5c <find_sensors+0x180>)
  401d00:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_2, IOPORT_DIR_OUTPUT); //PROG_2=output
  401d02:	2101      	movs	r1, #1
  401d04:	2013      	movs	r0, #19
  401d06:	4b55      	ldr	r3, [pc, #340]	; (401e5c <find_sensors+0x180>)
  401d08:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_3, IOPORT_DIR_OUTPUT); //PROG_3=output
  401d0a:	2101      	movs	r1, #1
  401d0c:	201f      	movs	r0, #31
  401d0e:	4b53      	ldr	r3, [pc, #332]	; (401e5c <find_sensors+0x180>)
  401d10:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_0, IOPORT_PIN_LEVEL_LOW); //PROG_0=L
  401d12:	2100      	movs	r1, #0
  401d14:	2010      	movs	r0, #16
  401d16:	4b52      	ldr	r3, [pc, #328]	; (401e60 <find_sensors+0x184>)
  401d18:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_1, IOPORT_PIN_LEVEL_LOW); //PROG_1=L
  401d1a:	2100      	movs	r1, #0
  401d1c:	2012      	movs	r0, #18
  401d1e:	4b50      	ldr	r3, [pc, #320]	; (401e60 <find_sensors+0x184>)
  401d20:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_2, IOPORT_PIN_LEVEL_LOW); //PROG_2=L
  401d22:	2100      	movs	r1, #0
  401d24:	2013      	movs	r0, #19
  401d26:	4b4e      	ldr	r3, [pc, #312]	; (401e60 <find_sensors+0x184>)
  401d28:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_3, IOPORT_PIN_LEVEL_LOW); //PROG_3=L
  401d2a:	2100      	movs	r1, #0
  401d2c:	201f      	movs	r0, #31
  401d2e:	4b4c      	ldr	r3, [pc, #304]	; (401e60 <find_sensors+0x184>)
  401d30:	4798      	blx	r3

	/* check sensor 0 (on board chip or J6) */
	ioport_set_pin_level(CHIRP_PROG_0, IOPORT_PIN_LEVEL_HIGH);
  401d32:	2101      	movs	r1, #1
  401d34:	2010      	movs	r0, #16
  401d36:	4b4a      	ldr	r3, [pc, #296]	; (401e60 <find_sensors+0x184>)
  401d38:	4798      	blx	r3
	i2c_master_initialize1();
  401d3a:	4b4a      	ldr	r3, [pc, #296]	; (401e64 <find_sensors+0x188>)
  401d3c:	4798      	blx	r3
	sig_bytes[0] = 0;
  401d3e:	2300      	movs	r3, #0
  401d40:	713b      	strb	r3, [r7, #4]
	sig_bytes[1] = 0;
  401d42:	2300      	movs	r3, #0
  401d44:	717b      	strb	r3, [r7, #5]
	i2c_master_read_register1(CH_I2C_ADDR_PROG, 0x00, 2, sig_bytes);
  401d46:	1d3b      	adds	r3, r7, #4
  401d48:	2202      	movs	r2, #2
  401d4a:	2100      	movs	r1, #0
  401d4c:	2045      	movs	r0, #69	; 0x45
  401d4e:	4c46      	ldr	r4, [pc, #280]	; (401e68 <find_sensors+0x18c>)
  401d50:	47a0      	blx	r4
	printf("Chirp sensor 0 ");
  401d52:	4846      	ldr	r0, [pc, #280]	; (401e6c <find_sensors+0x190>)
  401d54:	4b46      	ldr	r3, [pc, #280]	; (401e70 <find_sensors+0x194>)
  401d56:	4798      	blx	r3
	if ((sig_bytes[0] == CH_SIG_BYTE_0) && (sig_bytes[1] == CH_SIG_BYTE_1)) {
  401d58:	793b      	ldrb	r3, [r7, #4]
  401d5a:	2b0a      	cmp	r3, #10
  401d5c:	d106      	bne.n	401d6c <find_sensors+0x90>
  401d5e:	797b      	ldrb	r3, [r7, #5]
  401d60:	2b02      	cmp	r3, #2
  401d62:	d103      	bne.n	401d6c <find_sensors+0x90>
		printf("found\n");
  401d64:	4843      	ldr	r0, [pc, #268]	; (401e74 <find_sensors+0x198>)
  401d66:	4b42      	ldr	r3, [pc, #264]	; (401e70 <find_sensors+0x194>)
  401d68:	4798      	blx	r3
  401d6a:	e002      	b.n	401d72 <find_sensors+0x96>
		} else {
		printf("not found\n");
  401d6c:	4842      	ldr	r0, [pc, #264]	; (401e78 <find_sensors+0x19c>)
  401d6e:	4b40      	ldr	r3, [pc, #256]	; (401e70 <find_sensors+0x194>)
  401d70:	4798      	blx	r3
	}
	ioport_set_pin_level(CHIRP_PROG_0, IOPORT_PIN_LEVEL_LOW);
  401d72:	2100      	movs	r1, #0
  401d74:	2010      	movs	r0, #16
  401d76:	4b3a      	ldr	r3, [pc, #232]	; (401e60 <find_sensors+0x184>)
  401d78:	4798      	blx	r3

	/* check sensor 1 (J7) */
	ioport_set_pin_level(CHIRP_PROG_1, IOPORT_PIN_LEVEL_HIGH);
  401d7a:	2101      	movs	r1, #1
  401d7c:	2012      	movs	r0, #18
  401d7e:	4b38      	ldr	r3, [pc, #224]	; (401e60 <find_sensors+0x184>)
  401d80:	4798      	blx	r3
	i2c_master_initialize1();
  401d82:	4b38      	ldr	r3, [pc, #224]	; (401e64 <find_sensors+0x188>)
  401d84:	4798      	blx	r3
	sig_bytes[0] = 0;
  401d86:	2300      	movs	r3, #0
  401d88:	713b      	strb	r3, [r7, #4]
	sig_bytes[1] = 0;
  401d8a:	2300      	movs	r3, #0
  401d8c:	717b      	strb	r3, [r7, #5]
	i2c_master_read_register1(CH_I2C_ADDR_PROG, 0x00, 2, sig_bytes);
  401d8e:	1d3b      	adds	r3, r7, #4
  401d90:	2202      	movs	r2, #2
  401d92:	2100      	movs	r1, #0
  401d94:	2045      	movs	r0, #69	; 0x45
  401d96:	4c34      	ldr	r4, [pc, #208]	; (401e68 <find_sensors+0x18c>)
  401d98:	47a0      	blx	r4
	printf("Chirp sensor 1 ");
  401d9a:	4838      	ldr	r0, [pc, #224]	; (401e7c <find_sensors+0x1a0>)
  401d9c:	4b34      	ldr	r3, [pc, #208]	; (401e70 <find_sensors+0x194>)
  401d9e:	4798      	blx	r3
	if ((sig_bytes[0] == CH_SIG_BYTE_0) && (sig_bytes[1] == CH_SIG_BYTE_1)) {
  401da0:	793b      	ldrb	r3, [r7, #4]
  401da2:	2b0a      	cmp	r3, #10
  401da4:	d106      	bne.n	401db4 <find_sensors+0xd8>
  401da6:	797b      	ldrb	r3, [r7, #5]
  401da8:	2b02      	cmp	r3, #2
  401daa:	d103      	bne.n	401db4 <find_sensors+0xd8>
		printf("found\n");
  401dac:	4831      	ldr	r0, [pc, #196]	; (401e74 <find_sensors+0x198>)
  401dae:	4b30      	ldr	r3, [pc, #192]	; (401e70 <find_sensors+0x194>)
  401db0:	4798      	blx	r3
  401db2:	e002      	b.n	401dba <find_sensors+0xde>
		} else {
		printf("not found\n");
  401db4:	4830      	ldr	r0, [pc, #192]	; (401e78 <find_sensors+0x19c>)
  401db6:	4b2e      	ldr	r3, [pc, #184]	; (401e70 <find_sensors+0x194>)
  401db8:	4798      	blx	r3
	}
	ioport_set_pin_level(CHIRP_PROG_1, IOPORT_PIN_LEVEL_LOW);
  401dba:	2100      	movs	r1, #0
  401dbc:	2012      	movs	r0, #18
  401dbe:	4b28      	ldr	r3, [pc, #160]	; (401e60 <find_sensors+0x184>)
  401dc0:	4798      	blx	r3

	/* check sensor 2 (J8) */
	ioport_set_pin_level(CHIRP_PROG_2, IOPORT_PIN_LEVEL_HIGH);
  401dc2:	2101      	movs	r1, #1
  401dc4:	2013      	movs	r0, #19
  401dc6:	4b26      	ldr	r3, [pc, #152]	; (401e60 <find_sensors+0x184>)
  401dc8:	4798      	blx	r3
	i2c_master_initialize3();
  401dca:	4b2d      	ldr	r3, [pc, #180]	; (401e80 <find_sensors+0x1a4>)
  401dcc:	4798      	blx	r3
	sig_bytes[0] = 0;
  401dce:	2300      	movs	r3, #0
  401dd0:	713b      	strb	r3, [r7, #4]
	sig_bytes[1] = 0;
  401dd2:	2300      	movs	r3, #0
  401dd4:	717b      	strb	r3, [r7, #5]
	i2c_master_read_register3(CH_I2C_ADDR_PROG, 0x00, 2, sig_bytes);
  401dd6:	1d3b      	adds	r3, r7, #4
  401dd8:	2202      	movs	r2, #2
  401dda:	2100      	movs	r1, #0
  401ddc:	2045      	movs	r0, #69	; 0x45
  401dde:	4c29      	ldr	r4, [pc, #164]	; (401e84 <find_sensors+0x1a8>)
  401de0:	47a0      	blx	r4
	printf("Chirp sensor 2 ");
  401de2:	4829      	ldr	r0, [pc, #164]	; (401e88 <find_sensors+0x1ac>)
  401de4:	4b22      	ldr	r3, [pc, #136]	; (401e70 <find_sensors+0x194>)
  401de6:	4798      	blx	r3
	if ((sig_bytes[0] == CH_SIG_BYTE_0) && (sig_bytes[1] == CH_SIG_BYTE_1)) {
  401de8:	793b      	ldrb	r3, [r7, #4]
  401dea:	2b0a      	cmp	r3, #10
  401dec:	d106      	bne.n	401dfc <find_sensors+0x120>
  401dee:	797b      	ldrb	r3, [r7, #5]
  401df0:	2b02      	cmp	r3, #2
  401df2:	d103      	bne.n	401dfc <find_sensors+0x120>
		printf("found\n");
  401df4:	481f      	ldr	r0, [pc, #124]	; (401e74 <find_sensors+0x198>)
  401df6:	4b1e      	ldr	r3, [pc, #120]	; (401e70 <find_sensors+0x194>)
  401df8:	4798      	blx	r3
  401dfa:	e002      	b.n	401e02 <find_sensors+0x126>
		} else {
		printf("not found\n");
  401dfc:	481e      	ldr	r0, [pc, #120]	; (401e78 <find_sensors+0x19c>)
  401dfe:	4b1c      	ldr	r3, [pc, #112]	; (401e70 <find_sensors+0x194>)
  401e00:	4798      	blx	r3
	}
	ioport_set_pin_level(CHIRP_PROG_2, IOPORT_PIN_LEVEL_LOW);
  401e02:	2100      	movs	r1, #0
  401e04:	2013      	movs	r0, #19
  401e06:	4b16      	ldr	r3, [pc, #88]	; (401e60 <find_sensors+0x184>)
  401e08:	4798      	blx	r3

	/* check sensor 3 (J9) */
	ioport_set_pin_level(CHIRP_PROG_3, IOPORT_PIN_LEVEL_HIGH);
  401e0a:	2101      	movs	r1, #1
  401e0c:	201f      	movs	r0, #31
  401e0e:	4b14      	ldr	r3, [pc, #80]	; (401e60 <find_sensors+0x184>)
  401e10:	4798      	blx	r3
	i2c_master_initialize3();
  401e12:	4b1b      	ldr	r3, [pc, #108]	; (401e80 <find_sensors+0x1a4>)
  401e14:	4798      	blx	r3
	sig_bytes[0] = 0;
  401e16:	2300      	movs	r3, #0
  401e18:	713b      	strb	r3, [r7, #4]
	sig_bytes[1] = 0;
  401e1a:	2300      	movs	r3, #0
  401e1c:	717b      	strb	r3, [r7, #5]
	i2c_master_read_register3(CH_I2C_ADDR_PROG, 0x00, 2, sig_bytes);
  401e1e:	1d3b      	adds	r3, r7, #4
  401e20:	2202      	movs	r2, #2
  401e22:	2100      	movs	r1, #0
  401e24:	2045      	movs	r0, #69	; 0x45
  401e26:	4c17      	ldr	r4, [pc, #92]	; (401e84 <find_sensors+0x1a8>)
  401e28:	47a0      	blx	r4
	printf("Chirp sensor 3 ");
  401e2a:	4818      	ldr	r0, [pc, #96]	; (401e8c <find_sensors+0x1b0>)
  401e2c:	4b10      	ldr	r3, [pc, #64]	; (401e70 <find_sensors+0x194>)
  401e2e:	4798      	blx	r3
	if ((sig_bytes[0] == CH_SIG_BYTE_0) && (sig_bytes[1] == CH_SIG_BYTE_1)) {
  401e30:	793b      	ldrb	r3, [r7, #4]
  401e32:	2b0a      	cmp	r3, #10
  401e34:	d106      	bne.n	401e44 <find_sensors+0x168>
  401e36:	797b      	ldrb	r3, [r7, #5]
  401e38:	2b02      	cmp	r3, #2
  401e3a:	d103      	bne.n	401e44 <find_sensors+0x168>
		printf("found\n");
  401e3c:	480d      	ldr	r0, [pc, #52]	; (401e74 <find_sensors+0x198>)
  401e3e:	4b0c      	ldr	r3, [pc, #48]	; (401e70 <find_sensors+0x194>)
  401e40:	4798      	blx	r3
  401e42:	e002      	b.n	401e4a <find_sensors+0x16e>
		} else {
		printf("not found\n");
  401e44:	480c      	ldr	r0, [pc, #48]	; (401e78 <find_sensors+0x19c>)
  401e46:	4b0a      	ldr	r3, [pc, #40]	; (401e70 <find_sensors+0x194>)
  401e48:	4798      	blx	r3
	}
	ioport_set_pin_level(CHIRP_PROG_3, IOPORT_PIN_LEVEL_LOW);
  401e4a:	2100      	movs	r1, #0
  401e4c:	201f      	movs	r0, #31
  401e4e:	4b04      	ldr	r3, [pc, #16]	; (401e60 <find_sensors+0x184>)
  401e50:	4798      	blx	r3
}
  401e52:	bf00      	nop
  401e54:	370c      	adds	r7, #12
  401e56:	46bd      	mov	sp, r7
  401e58:	bd90      	pop	{r4, r7, pc}
  401e5a:	bf00      	nop
  401e5c:	004017f7 	.word	0x004017f7
  401e60:	0040187f 	.word	0x0040187f
  401e64:	004088d1 	.word	0x004088d1
  401e68:	00408a11 	.word	0x00408a11
  401e6c:	0040d274 	.word	0x0040d274
  401e70:	00409ee9 	.word	0x00409ee9
  401e74:	0040d284 	.word	0x0040d284
  401e78:	0040d28c 	.word	0x0040d28c
  401e7c:	0040d298 	.word	0x0040d298
  401e80:	00408949 	.word	0x00408949
  401e84:	00408aa9 	.word	0x00408aa9
  401e88:	0040d2a8 	.word	0x0040d2a8
  401e8c:	0040d2b8 	.word	0x0040d2b8

00401e90 <ADC0_init>:

void ADC0_init(void) {
  401e90:	b580      	push	{r7, lr}
  401e92:	af00      	add	r7, sp, #0
	adc_enable();
  401e94:	4b12      	ldr	r3, [pc, #72]	; (401ee0 <ADC0_init+0x50>)
  401e96:	4798      	blx	r3
	adc_select_clock_source_mck(ADC);
  401e98:	4812      	ldr	r0, [pc, #72]	; (401ee4 <ADC0_init+0x54>)
  401e9a:	4b13      	ldr	r3, [pc, #76]	; (401ee8 <ADC0_init+0x58>)
  401e9c:	4798      	blx	r3
	adc_get_config_defaults(&adc_cfg);
  401e9e:	4813      	ldr	r0, [pc, #76]	; (401eec <ADC0_init+0x5c>)
  401ea0:	4b13      	ldr	r3, [pc, #76]	; (401ef0 <ADC0_init+0x60>)
  401ea2:	4798      	blx	r3
	adc_init(ADC, &adc_cfg);
  401ea4:	4911      	ldr	r1, [pc, #68]	; (401eec <ADC0_init+0x5c>)
  401ea6:	480f      	ldr	r0, [pc, #60]	; (401ee4 <ADC0_init+0x54>)
  401ea8:	4b12      	ldr	r3, [pc, #72]	; (401ef4 <ADC0_init+0x64>)
  401eaa:	4798      	blx	r3
	adc_channel_enable(ADC, ADC_CHANNEL_0);
  401eac:	2100      	movs	r1, #0
  401eae:	480d      	ldr	r0, [pc, #52]	; (401ee4 <ADC0_init+0x54>)
  401eb0:	4b11      	ldr	r3, [pc, #68]	; (401ef8 <ADC0_init+0x68>)
  401eb2:	4798      	blx	r3
	adc_set_trigger(ADC, ADC_TRIG_FREERUN);
  401eb4:	21ff      	movs	r1, #255	; 0xff
  401eb6:	480b      	ldr	r0, [pc, #44]	; (401ee4 <ADC0_init+0x54>)
  401eb8:	4b10      	ldr	r3, [pc, #64]	; (401efc <ADC0_init+0x6c>)
  401eba:	4798      	blx	r3

	adc_set_resolution(ADC, ADC_12_BITS);
  401ebc:	2100      	movs	r1, #0
  401ebe:	4809      	ldr	r0, [pc, #36]	; (401ee4 <ADC0_init+0x54>)
  401ec0:	4b0f      	ldr	r3, [pc, #60]	; (401f00 <ADC0_init+0x70>)
  401ec2:	4798      	blx	r3

	adc_set_writeprotect(ADC, 0);
  401ec4:	2100      	movs	r1, #0
  401ec6:	4807      	ldr	r0, [pc, #28]	; (401ee4 <ADC0_init+0x54>)
  401ec8:	4b0e      	ldr	r3, [pc, #56]	; (401f04 <ADC0_init+0x74>)
  401eca:	4798      	blx	r3
	*adc_reg = ADC_MODE_NO_AUTOTEST;// Set ADC converter to normal operation
  401ecc:	4b0e      	ldr	r3, [pc, #56]	; (401f08 <ADC0_init+0x78>)
  401ece:	681b      	ldr	r3, [r3, #0]
  401ed0:	2200      	movs	r2, #0
  401ed2:	601a      	str	r2, [r3, #0]
	adc_set_writeprotect(ADC, 1);
  401ed4:	2101      	movs	r1, #1
  401ed6:	4803      	ldr	r0, [pc, #12]	; (401ee4 <ADC0_init+0x54>)
  401ed8:	4b0a      	ldr	r3, [pc, #40]	; (401f04 <ADC0_init+0x74>)
  401eda:	4798      	blx	r3
}
  401edc:	bf00      	nop
  401ede:	bd80      	pop	{r7, pc}
  401ee0:	00403821 	.word	0x00403821
  401ee4:	40038000 	.word	0x40038000
  401ee8:	00401975 	.word	0x00401975
  401eec:	20000388 	.word	0x20000388
  401ef0:	0040361d 	.word	0x0040361d
  401ef4:	00403709 	.word	0x00403709
  401ef8:	00401a19 	.word	0x00401a19
  401efc:	0040199d 	.word	0x0040199d
  401f00:	00403769 	.word	0x00403769
  401f04:	004019e1 	.word	0x004019e1
  401f08:	20000168 	.word	0x20000168

00401f0c <ext_int_init>:

void ext_int_init(void)
{
  401f0c:	b590      	push	{r4, r7, lr}
  401f0e:	b083      	sub	sp, #12
  401f10:	af02      	add	r7, sp, #8
	/* Enable the peripheral clock for the MAG extension board interrupt pin. */
	pmc_enable_periph_clk(PIN_EXT_INTERRUPT_ID);
  401f12:	200b      	movs	r0, #11
  401f14:	4b41      	ldr	r3, [pc, #260]	; (40201c <ext_int_init+0x110>)
  401f16:	4798      	blx	r3

	// Enable pull-downs on the INT pins
	pio_pull_up(PIN_EXT_INTERRUPT_PIO, 1 << CHIRP_INT_0 | 1 << CHIRP_INT_1 | 1 << CHIRP_INT_2 | 1 << CHIRP_INT_3, 0);
  401f18:	2200      	movs	r2, #0
  401f1a:	4941      	ldr	r1, [pc, #260]	; (402020 <ext_int_init+0x114>)
  401f1c:	4841      	ldr	r0, [pc, #260]	; (402024 <ext_int_init+0x118>)
  401f1e:	4b42      	ldr	r3, [pc, #264]	; (402028 <ext_int_init+0x11c>)
  401f20:	4798      	blx	r3
	pio_pull_down(PIN_EXT_INTERRUPT_PIO, 1 << CHIRP_INT_0 | 1 << CHIRP_INT_1 | 1 << CHIRP_INT_2 | 1 << CHIRP_INT_3, 1);
  401f22:	2201      	movs	r2, #1
  401f24:	493e      	ldr	r1, [pc, #248]	; (402020 <ext_int_init+0x114>)
  401f26:	483f      	ldr	r0, [pc, #252]	; (402024 <ext_int_init+0x118>)
  401f28:	4b40      	ldr	r3, [pc, #256]	; (40202c <ext_int_init+0x120>)
  401f2a:	4798      	blx	r3

	/* Configure PIOs as input pins. */
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_MotionINT_MASK, PIN_EXT_INTERRUPT_ATTR);
  401f2c:	2370      	movs	r3, #112	; 0x70
  401f2e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  401f32:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  401f36:	483b      	ldr	r0, [pc, #236]	; (402024 <ext_int_init+0x118>)
  401f38:	4c3d      	ldr	r4, [pc, #244]	; (402030 <ext_int_init+0x124>)
  401f3a:	47a0      	blx	r4
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_ChirpINT0_MASK, PIN_EXT_INTERRUPT_ATTR);
  401f3c:	2370      	movs	r3, #112	; 0x70
  401f3e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  401f42:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  401f46:	4837      	ldr	r0, [pc, #220]	; (402024 <ext_int_init+0x118>)
  401f48:	4c39      	ldr	r4, [pc, #228]	; (402030 <ext_int_init+0x124>)
  401f4a:	47a0      	blx	r4
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_ChirpINT1_MASK, PIN_EXT_INTERRUPT_ATTR);
  401f4c:	2370      	movs	r3, #112	; 0x70
  401f4e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  401f52:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  401f56:	4833      	ldr	r0, [pc, #204]	; (402024 <ext_int_init+0x118>)
  401f58:	4c35      	ldr	r4, [pc, #212]	; (402030 <ext_int_init+0x124>)
  401f5a:	47a0      	blx	r4
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_ChirpINT2_MASK, PIN_EXT_INTERRUPT_ATTR);
  401f5c:	2370      	movs	r3, #112	; 0x70
  401f5e:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  401f62:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  401f66:	482f      	ldr	r0, [pc, #188]	; (402024 <ext_int_init+0x118>)
  401f68:	4c31      	ldr	r4, [pc, #196]	; (402030 <ext_int_init+0x124>)
  401f6a:	47a0      	blx	r4
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_ChirpINT3_MASK, PIN_EXT_INTERRUPT_ATTR);
  401f6c:	2370      	movs	r3, #112	; 0x70
  401f6e:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401f72:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  401f76:	482b      	ldr	r0, [pc, #172]	; (402024 <ext_int_init+0x118>)
  401f78:	4c2d      	ldr	r4, [pc, #180]	; (402030 <ext_int_init+0x124>)
  401f7a:	47a0      	blx	r4

	/* Initialize PIO interrupt handler, interrupt on rising edge. */
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_MotionINT_MASK,
  401f7c:	2300      	movs	r3, #0
  401f7e:	9300      	str	r3, [sp, #0]
  401f80:	2370      	movs	r3, #112	; 0x70
  401f82:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  401f86:	210b      	movs	r1, #11
  401f88:	4826      	ldr	r0, [pc, #152]	; (402024 <ext_int_init+0x118>)
  401f8a:	4c2a      	ldr	r4, [pc, #168]	; (402034 <ext_int_init+0x128>)
  401f8c:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, NULL);
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_ChirpINT0_MASK,
  401f8e:	2300      	movs	r3, #0
  401f90:	9300      	str	r3, [sp, #0]
  401f92:	2370      	movs	r3, #112	; 0x70
  401f94:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  401f98:	210b      	movs	r1, #11
  401f9a:	4822      	ldr	r0, [pc, #136]	; (402024 <ext_int_init+0x118>)
  401f9c:	4c25      	ldr	r4, [pc, #148]	; (402034 <ext_int_init+0x128>)
  401f9e:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, NULL);
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_ChirpINT1_MASK,
  401fa0:	2300      	movs	r3, #0
  401fa2:	9300      	str	r3, [sp, #0]
  401fa4:	2370      	movs	r3, #112	; 0x70
  401fa6:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  401faa:	210b      	movs	r1, #11
  401fac:	481d      	ldr	r0, [pc, #116]	; (402024 <ext_int_init+0x118>)
  401fae:	4c21      	ldr	r4, [pc, #132]	; (402034 <ext_int_init+0x128>)
  401fb0:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, NULL);
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_ChirpINT2_MASK,
  401fb2:	2300      	movs	r3, #0
  401fb4:	9300      	str	r3, [sp, #0]
  401fb6:	2370      	movs	r3, #112	; 0x70
  401fb8:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  401fbc:	210b      	movs	r1, #11
  401fbe:	4819      	ldr	r0, [pc, #100]	; (402024 <ext_int_init+0x118>)
  401fc0:	4c1c      	ldr	r4, [pc, #112]	; (402034 <ext_int_init+0x128>)
  401fc2:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, NULL);
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_ChirpINT3_MASK,
  401fc4:	2300      	movs	r3, #0
  401fc6:	9300      	str	r3, [sp, #0]
  401fc8:	2370      	movs	r3, #112	; 0x70
  401fca:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401fce:	210b      	movs	r1, #11
  401fd0:	4814      	ldr	r0, [pc, #80]	; (402024 <ext_int_init+0x118>)
  401fd2:	4c18      	ldr	r4, [pc, #96]	; (402034 <ext_int_init+0x128>)
  401fd4:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, NULL);

	/* Initialize and enable push button (PIO) interrupt. */
	pio_handler_set_priority(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_IRQn, 0);
  401fd6:	2200      	movs	r2, #0
  401fd8:	210b      	movs	r1, #11
  401fda:	4812      	ldr	r0, [pc, #72]	; (402024 <ext_int_init+0x118>)
  401fdc:	4b16      	ldr	r3, [pc, #88]	; (402038 <ext_int_init+0x12c>)
  401fde:	4798      	blx	r3

	/* Disable Motion interrupt before IMU initialization */
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_MotionINT_MASK);
  401fe0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  401fe4:	480f      	ldr	r0, [pc, #60]	; (402024 <ext_int_init+0x118>)
  401fe6:	4b15      	ldr	r3, [pc, #84]	; (40203c <ext_int_init+0x130>)
  401fe8:	4798      	blx	r3
	/* Disable all CHx01 interrupts */
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_ChirpINT0_MASK);
  401fea:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  401fee:	480d      	ldr	r0, [pc, #52]	; (402024 <ext_int_init+0x118>)
  401ff0:	4b12      	ldr	r3, [pc, #72]	; (40203c <ext_int_init+0x130>)
  401ff2:	4798      	blx	r3
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_ChirpINT1_MASK);
  401ff4:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  401ff8:	480a      	ldr	r0, [pc, #40]	; (402024 <ext_int_init+0x118>)
  401ffa:	4b10      	ldr	r3, [pc, #64]	; (40203c <ext_int_init+0x130>)
  401ffc:	4798      	blx	r3
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_ChirpINT2_MASK);
  401ffe:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
  402002:	4808      	ldr	r0, [pc, #32]	; (402024 <ext_int_init+0x118>)
  402004:	4b0d      	ldr	r3, [pc, #52]	; (40203c <ext_int_init+0x130>)
  402006:	4798      	blx	r3
	pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_ChirpINT3_MASK);
  402008:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  40200c:	4805      	ldr	r0, [pc, #20]	; (402024 <ext_int_init+0x118>)
  40200e:	4b0b      	ldr	r3, [pc, #44]	; (40203c <ext_int_init+0x130>)
  402010:	4798      	blx	r3
}
  402012:	bf00      	nop
  402014:	3704      	adds	r7, #4
  402016:	46bd      	mov	sp, r7
  402018:	bd90      	pop	{r4, r7, pc}
  40201a:	bf00      	nop
  40201c:	00404459 	.word	0x00404459
  402020:	20e00000 	.word	0x20e00000
  402024:	400e0e00 	.word	0x400e0e00
  402028:	00403b33 	.word	0x00403b33
  40202c:	00403da1 	.word	0x00403da1
  402030:	00403ce1 	.word	0x00403ce1
  402034:	00404049 	.word	0x00404049
  402038:	00404105 	.word	0x00404105
  40203c:	00403e59 	.word	0x00403e59

00402040 <chbsp_board_init>:
/*!
 * \brief Initialize board hardware
 *
 * \note This function performs all necessary initialization on the board.
 */
void chbsp_board_init(ch_group_t *grp_ptr) {
  402040:	b580      	push	{r7, lr}
  402042:	b082      	sub	sp, #8
  402044:	af00      	add	r7, sp, #0
  402046:	6078      	str	r0, [r7, #4]

	/* Make local copy of group pointer */
	sensor_group_ptr = grp_ptr;
  402048:	4a0f      	ldr	r2, [pc, #60]	; (402088 <chbsp_board_init+0x48>)
  40204a:	687b      	ldr	r3, [r7, #4]
  40204c:	6013      	str	r3, [r2, #0]

	/* Initialize group descriptor */
	grp_ptr->num_ports = CHBSP_MAX_DEVICES;
  40204e:	687b      	ldr	r3, [r7, #4]
  402050:	2204      	movs	r2, #4
  402052:	701a      	strb	r2, [r3, #0]
	grp_ptr->num_i2c_buses = CHBSP_NUM_I2C_BUSES;
  402054:	687b      	ldr	r3, [r7, #4]
  402056:	2202      	movs	r2, #2
  402058:	705a      	strb	r2, [r3, #1]
	grp_ptr->rtc_cal_pulse_ms = CHBSP_RTC_CAL_PULSE_MS;
  40205a:	687b      	ldr	r3, [r7, #4]
  40205c:	2264      	movs	r2, #100	; 0x64
  40205e:	80da      	strh	r2, [r3, #6]

	/* Initialize the SAM system. */
	sysclk_init();
  402060:	4b0a      	ldr	r3, [pc, #40]	; (40208c <chbsp_board_init+0x4c>)
  402062:	4798      	blx	r3
	board_init_I2C();
  402064:	4b0a      	ldr	r3, [pc, #40]	; (402090 <chbsp_board_init+0x50>)
  402066:	4798      	blx	r3

	configure_console();
  402068:	4b0a      	ldr	r3, [pc, #40]	; (402094 <chbsp_board_init+0x54>)
  40206a:	4798      	blx	r3
	

	ADC0_init();
  40206c:	4b0a      	ldr	r3, [pc, #40]	; (402098 <chbsp_board_init+0x58>)
  40206e:	4798      	blx	r3
	ext_int_init();
  402070:	4b0a      	ldr	r3, [pc, #40]	; (40209c <chbsp_board_init+0x5c>)
  402072:	4798      	blx	r3

	/* Probe I2C bus to find connected sensor(s) */
	find_sensors();
  402074:	4b0a      	ldr	r3, [pc, #40]	; (4020a0 <chbsp_board_init+0x60>)
  402076:	4798      	blx	r3
	measure_power();
  402078:	4b0a      	ldr	r3, [pc, #40]	; (4020a4 <chbsp_board_init+0x64>)
  40207a:	4798      	blx	r3

	indicate_alive();
  40207c:	4b0a      	ldr	r3, [pc, #40]	; (4020a8 <chbsp_board_init+0x68>)
  40207e:	4798      	blx	r3
}
  402080:	bf00      	nop
  402082:	3708      	adds	r7, #8
  402084:	46bd      	mov	sp, r7
  402086:	bd80      	pop	{r7, pc}
  402088:	200028dc 	.word	0x200028dc
  40208c:	00400e01 	.word	0x00400e01
  402090:	00403371 	.word	0x00403371
  402094:	00409521 	.word	0x00409521
  402098:	00401e91 	.word	0x00401e91
  40209c:	00401f0d 	.word	0x00401f0d
  4020a0:	00401cdd 	.word	0x00401cdd
  4020a4:	00401cb1 	.word	0x00401cb1
  4020a8:	004014f9 	.word	0x004014f9

004020ac <chbsp_reset_assert>:
/*!
 * \brief Assert the reset pin
 *
 * This function drives the sensor reset pin low.
 */
void chbsp_reset_assert(void) {
  4020ac:	b580      	push	{r7, lr}
  4020ae:	af00      	add	r7, sp, #0

	ioport_set_pin_level(CHIRP_RST, IOPORT_PIN_LEVEL_LOW); //reset=L
  4020b0:	2100      	movs	r1, #0
  4020b2:	200f      	movs	r0, #15
  4020b4:	4b01      	ldr	r3, [pc, #4]	; (4020bc <chbsp_reset_assert+0x10>)
  4020b6:	4798      	blx	r3
}
  4020b8:	bf00      	nop
  4020ba:	bd80      	pop	{r7, pc}
  4020bc:	0040187f 	.word	0x0040187f

004020c0 <chbsp_reset_release>:
/*!
 * \brief Deassert the reset pin
 *
 * This function drives the sensor reset pin high.
 */
void chbsp_reset_release(void) {
  4020c0:	b580      	push	{r7, lr}
  4020c2:	af00      	add	r7, sp, #0

	ioport_set_pin_level(CHIRP_RST, IOPORT_PIN_LEVEL_HIGH); //reset=H
  4020c4:	2101      	movs	r1, #1
  4020c6:	200f      	movs	r0, #15
  4020c8:	4b01      	ldr	r3, [pc, #4]	; (4020d0 <chbsp_reset_release+0x10>)
  4020ca:	4798      	blx	r3
}
  4020cc:	bf00      	nop
  4020ce:	bd80      	pop	{r7, pc}
  4020d0:	0040187f 	.word	0x0040187f

004020d4 <chbsp_program_enable>:
 *
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function drives the sensor PROG pin high on the specified port.
 */
void chbsp_program_enable(ch_dev_t *dev_ptr) {
  4020d4:	b580      	push	{r7, lr}
  4020d6:	b084      	sub	sp, #16
  4020d8:	af00      	add	r7, sp, #0
  4020da:	6078      	str	r0, [r7, #4]
	uint8_t dev_num = ch_get_dev_num(dev_ptr);
  4020dc:	6878      	ldr	r0, [r7, #4]
  4020de:	4b08      	ldr	r3, [pc, #32]	; (402100 <chbsp_program_enable+0x2c>)
  4020e0:	4798      	blx	r3
  4020e2:	4603      	mov	r3, r0
  4020e4:	73fb      	strb	r3, [r7, #15]

	// select Chirp chip PROGRAM line on Atmel board according to chip number
	ioport_set_pin_level(chirp_pin_prog[dev_num], IOPORT_PIN_LEVEL_HIGH); //PROG_0=H
  4020e6:	7bfb      	ldrb	r3, [r7, #15]
  4020e8:	4a06      	ldr	r2, [pc, #24]	; (402104 <chbsp_program_enable+0x30>)
  4020ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4020ee:	2101      	movs	r1, #1
  4020f0:	4618      	mov	r0, r3
  4020f2:	4b05      	ldr	r3, [pc, #20]	; (402108 <chbsp_program_enable+0x34>)
  4020f4:	4798      	blx	r3
}
  4020f6:	bf00      	nop
  4020f8:	3710      	adds	r7, #16
  4020fa:	46bd      	mov	sp, r7
  4020fc:	bd80      	pop	{r7, pc}
  4020fe:	bf00      	nop
  402100:	00405b01 	.word	0x00405b01
  402104:	20000120 	.word	0x20000120
  402108:	0040187f 	.word	0x0040187f

0040210c <chbsp_program_disable>:
 *
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function drives the sensor PROG pin low on the specified port.
 */
void chbsp_program_disable(ch_dev_t *dev_ptr) {
  40210c:	b580      	push	{r7, lr}
  40210e:	b084      	sub	sp, #16
  402110:	af00      	add	r7, sp, #0
  402112:	6078      	str	r0, [r7, #4]
	uint8_t dev_num = ch_get_dev_num(dev_ptr);
  402114:	6878      	ldr	r0, [r7, #4]
  402116:	4b08      	ldr	r3, [pc, #32]	; (402138 <chbsp_program_disable+0x2c>)
  402118:	4798      	blx	r3
  40211a:	4603      	mov	r3, r0
  40211c:	73fb      	strb	r3, [r7, #15]

	// select Chirp chip PROGRAM line on Atmel board according to chip number
	ioport_set_pin_level(chirp_pin_prog[dev_num], IOPORT_PIN_LEVEL_LOW); //PROG_0=L
  40211e:	7bfb      	ldrb	r3, [r7, #15]
  402120:	4a06      	ldr	r2, [pc, #24]	; (40213c <chbsp_program_disable+0x30>)
  402122:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  402126:	2100      	movs	r1, #0
  402128:	4618      	mov	r0, r3
  40212a:	4b05      	ldr	r3, [pc, #20]	; (402140 <chbsp_program_disable+0x34>)
  40212c:	4798      	blx	r3
}
  40212e:	bf00      	nop
  402130:	3710      	adds	r7, #16
  402132:	46bd      	mov	sp, r7
  402134:	bd80      	pop	{r7, pc}
  402136:	bf00      	nop
  402138:	00405b01 	.word	0x00405b01
  40213c:	20000120 	.word	0x20000120
  402140:	0040187f 	.word	0x0040187f

00402144 <chbsp_set_io_dir_in>:
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function configures the Chirp sensor INT pin as an input (from the perspective of
 * the host system).
 */
void chbsp_set_io_dir_in(ch_dev_t *dev_ptr) {
  402144:	b580      	push	{r7, lr}
  402146:	b084      	sub	sp, #16
  402148:	af00      	add	r7, sp, #0
  40214a:	6078      	str	r0, [r7, #4]
	uint8_t dev_num = ch_get_dev_num(dev_ptr);
  40214c:	6878      	ldr	r0, [r7, #4]
  40214e:	4b08      	ldr	r3, [pc, #32]	; (402170 <chbsp_set_io_dir_in+0x2c>)
  402150:	4798      	blx	r3
  402152:	4603      	mov	r3, r0
  402154:	73fb      	strb	r3, [r7, #15]

	ioport_set_pin_dir(chirp_pin_io[dev_num], IOPORT_DIR_INPUT);
  402156:	7bfb      	ldrb	r3, [r7, #15]
  402158:	4a06      	ldr	r2, [pc, #24]	; (402174 <chbsp_set_io_dir_in+0x30>)
  40215a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40215e:	2100      	movs	r1, #0
  402160:	4618      	mov	r0, r3
  402162:	4b05      	ldr	r3, [pc, #20]	; (402178 <chbsp_set_io_dir_in+0x34>)
  402164:	4798      	blx	r3
}
  402166:	bf00      	nop
  402168:	3710      	adds	r7, #16
  40216a:	46bd      	mov	sp, r7
  40216c:	bd80      	pop	{r7, pc}
  40216e:	bf00      	nop
  402170:	00405b01 	.word	0x00405b01
  402174:	20000130 	.word	0x20000130
  402178:	004017f7 	.word	0x004017f7

0040217c <chbsp_group_set_io_dir_out>:
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * This function configures each Chirp sensor's INT pin as an output (from the perspective
 * of the host system).
 */
void chbsp_group_set_io_dir_out(ch_group_t *grp_ptr) {
  40217c:	b580      	push	{r7, lr}
  40217e:	b086      	sub	sp, #24
  402180:	af00      	add	r7, sp, #0
  402182:	6078      	str	r0, [r7, #4]
	ioport_port_mask_t mask = 0;
  402184:	2300      	movs	r3, #0
  402186:	617b      	str	r3, [r7, #20]
	uint8_t dev_num;

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++)
  402188:	2300      	movs	r3, #0
  40218a:	74fb      	strb	r3, [r7, #19]
  40218c:	e019      	b.n	4021c2 <chbsp_group_set_io_dir_out+0x46>
	{
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  40218e:	7cfb      	ldrb	r3, [r7, #19]
  402190:	4619      	mov	r1, r3
  402192:	6878      	ldr	r0, [r7, #4]
  402194:	4b13      	ldr	r3, [pc, #76]	; (4021e4 <chbsp_group_set_io_dir_out+0x68>)
  402196:	4798      	blx	r3
  402198:	60f8      	str	r0, [r7, #12]

		if (ch_sensor_is_connected(dev_ptr))
  40219a:	68f8      	ldr	r0, [r7, #12]
  40219c:	4b12      	ldr	r3, [pc, #72]	; (4021e8 <chbsp_group_set_io_dir_out+0x6c>)
  40219e:	4798      	blx	r3
  4021a0:	4603      	mov	r3, r0
  4021a2:	2b00      	cmp	r3, #0
  4021a4:	d00a      	beq.n	4021bc <chbsp_group_set_io_dir_out+0x40>
			mask |= ioport_pin_to_mask(chirp_pin_io[dev_num]);
  4021a6:	7cfb      	ldrb	r3, [r7, #19]
  4021a8:	4a10      	ldr	r2, [pc, #64]	; (4021ec <chbsp_group_set_io_dir_out+0x70>)
  4021aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4021ae:	4618      	mov	r0, r3
  4021b0:	4b0f      	ldr	r3, [pc, #60]	; (4021f0 <chbsp_group_set_io_dir_out+0x74>)
  4021b2:	4798      	blx	r3
  4021b4:	4602      	mov	r2, r0
  4021b6:	697b      	ldr	r3, [r7, #20]
  4021b8:	4313      	orrs	r3, r2
  4021ba:	617b      	str	r3, [r7, #20]
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++)
  4021bc:	7cfb      	ldrb	r3, [r7, #19]
  4021be:	3301      	adds	r3, #1
  4021c0:	74fb      	strb	r3, [r7, #19]
  4021c2:	6878      	ldr	r0, [r7, #4]
  4021c4:	4b0b      	ldr	r3, [pc, #44]	; (4021f4 <chbsp_group_set_io_dir_out+0x78>)
  4021c6:	4798      	blx	r3
  4021c8:	4603      	mov	r3, r0
  4021ca:	461a      	mov	r2, r3
  4021cc:	7cfb      	ldrb	r3, [r7, #19]
  4021ce:	4293      	cmp	r3, r2
  4021d0:	d3dd      	bcc.n	40218e <chbsp_group_set_io_dir_out+0x12>
	}

	ioport_set_port_dir(IOPORT_PIOA, mask, IOPORT_DIR_OUTPUT);
  4021d2:	2201      	movs	r2, #1
  4021d4:	6979      	ldr	r1, [r7, #20]
  4021d6:	2000      	movs	r0, #0
  4021d8:	4b07      	ldr	r3, [pc, #28]	; (4021f8 <chbsp_group_set_io_dir_out+0x7c>)
  4021da:	4798      	blx	r3
}
  4021dc:	bf00      	nop
  4021de:	3718      	adds	r7, #24
  4021e0:	46bd      	mov	sp, r7
  4021e2:	bd80      	pop	{r7, pc}
  4021e4:	00405b1b 	.word	0x00405b1b
  4021e8:	00405ad1 	.word	0x00405ad1
  4021ec:	20000130 	.word	0x20000130
  4021f0:	00401937 	.word	0x00401937
  4021f4:	00405b6f 	.word	0x00405b6f
  4021f8:	0040179d 	.word	0x0040179d

004021fc <chbsp_group_set_io_dir_in>:
 *
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * \note This function assumes a bidirectional level shifter is interfacing the ICs.
 */
void chbsp_group_set_io_dir_in(ch_group_t *grp_ptr) {
  4021fc:	b580      	push	{r7, lr}
  4021fe:	b086      	sub	sp, #24
  402200:	af00      	add	r7, sp, #0
  402202:	6078      	str	r0, [r7, #4]
	ioport_port_mask_t mask = 0;
  402204:	2300      	movs	r3, #0
  402206:	617b      	str	r3, [r7, #20]
	uint8_t dev_num;

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  402208:	2300      	movs	r3, #0
  40220a:	74fb      	strb	r3, [r7, #19]
  40220c:	e019      	b.n	402242 <chbsp_group_set_io_dir_in+0x46>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  40220e:	7cfb      	ldrb	r3, [r7, #19]
  402210:	4619      	mov	r1, r3
  402212:	6878      	ldr	r0, [r7, #4]
  402214:	4b13      	ldr	r3, [pc, #76]	; (402264 <chbsp_group_set_io_dir_in+0x68>)
  402216:	4798      	blx	r3
  402218:	60f8      	str	r0, [r7, #12]

		if (ch_sensor_is_connected(dev_ptr)) {
  40221a:	68f8      	ldr	r0, [r7, #12]
  40221c:	4b12      	ldr	r3, [pc, #72]	; (402268 <chbsp_group_set_io_dir_in+0x6c>)
  40221e:	4798      	blx	r3
  402220:	4603      	mov	r3, r0
  402222:	2b00      	cmp	r3, #0
  402224:	d00a      	beq.n	40223c <chbsp_group_set_io_dir_in+0x40>
			mask |= ioport_pin_to_mask(chirp_pin_io[dev_num]);
  402226:	7cfb      	ldrb	r3, [r7, #19]
  402228:	4a10      	ldr	r2, [pc, #64]	; (40226c <chbsp_group_set_io_dir_in+0x70>)
  40222a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40222e:	4618      	mov	r0, r3
  402230:	4b0f      	ldr	r3, [pc, #60]	; (402270 <chbsp_group_set_io_dir_in+0x74>)
  402232:	4798      	blx	r3
  402234:	4602      	mov	r2, r0
  402236:	697b      	ldr	r3, [r7, #20]
  402238:	4313      	orrs	r3, r2
  40223a:	617b      	str	r3, [r7, #20]
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  40223c:	7cfb      	ldrb	r3, [r7, #19]
  40223e:	3301      	adds	r3, #1
  402240:	74fb      	strb	r3, [r7, #19]
  402242:	6878      	ldr	r0, [r7, #4]
  402244:	4b0b      	ldr	r3, [pc, #44]	; (402274 <chbsp_group_set_io_dir_in+0x78>)
  402246:	4798      	blx	r3
  402248:	4603      	mov	r3, r0
  40224a:	461a      	mov	r2, r3
  40224c:	7cfb      	ldrb	r3, [r7, #19]
  40224e:	4293      	cmp	r3, r2
  402250:	d3dd      	bcc.n	40220e <chbsp_group_set_io_dir_in+0x12>
		}
	}

	ioport_set_port_dir(IOPORT_PIOA, mask, IOPORT_DIR_INPUT);
  402252:	2200      	movs	r2, #0
  402254:	6979      	ldr	r1, [r7, #20]
  402256:	2000      	movs	r0, #0
  402258:	4b07      	ldr	r3, [pc, #28]	; (402278 <chbsp_group_set_io_dir_in+0x7c>)
  40225a:	4798      	blx	r3
}
  40225c:	bf00      	nop
  40225e:	3718      	adds	r7, #24
  402260:	46bd      	mov	sp, r7
  402262:	bd80      	pop	{r7, pc}
  402264:	00405b1b 	.word	0x00405b1b
  402268:	00405ad1 	.word	0x00405ad1
  40226c:	20000130 	.word	0x20000130
  402270:	00401937 	.word	0x00401937
  402274:	00405b6f 	.word	0x00405b6f
  402278:	0040179d 	.word	0x0040179d

0040227c <chbsp_group_pin_init>:
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * Configure reset and program pins as outputs. Assert reset and program. Configure
 * sensor INT pin as input.
 */
void chbsp_group_pin_init(ch_group_t *grp_ptr) {
  40227c:	b590      	push	{r4, r7, lr}
  40227e:	b087      	sub	sp, #28
  402280:	af02      	add	r7, sp, #8
  402282:	6078      	str	r0, [r7, #4]
	uint8_t dev_num;
	uint8_t port_num;

	ioport_set_pin_dir(CHIRP_PROG_0, IOPORT_DIR_OUTPUT); //PROG_0=output
  402284:	2101      	movs	r1, #1
  402286:	2010      	movs	r0, #16
  402288:	4b3a      	ldr	r3, [pc, #232]	; (402374 <chbsp_group_pin_init+0xf8>)
  40228a:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_1, IOPORT_DIR_OUTPUT); //PROG_1=output
  40228c:	2101      	movs	r1, #1
  40228e:	2012      	movs	r0, #18
  402290:	4b38      	ldr	r3, [pc, #224]	; (402374 <chbsp_group_pin_init+0xf8>)
  402292:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_2, IOPORT_DIR_OUTPUT); //PROG_2=output
  402294:	2101      	movs	r1, #1
  402296:	2013      	movs	r0, #19
  402298:	4b36      	ldr	r3, [pc, #216]	; (402374 <chbsp_group_pin_init+0xf8>)
  40229a:	4798      	blx	r3
	ioport_set_pin_dir(CHIRP_PROG_3, IOPORT_DIR_OUTPUT); //PROG_3=output
  40229c:	2101      	movs	r1, #1
  40229e:	201f      	movs	r0, #31
  4022a0:	4b34      	ldr	r3, [pc, #208]	; (402374 <chbsp_group_pin_init+0xf8>)
  4022a2:	4798      	blx	r3

	ioport_set_pin_level(CHIRP_PROG_0, IOPORT_PIN_LEVEL_LOW); //PROG_0=L
  4022a4:	2100      	movs	r1, #0
  4022a6:	2010      	movs	r0, #16
  4022a8:	4b33      	ldr	r3, [pc, #204]	; (402378 <chbsp_group_pin_init+0xfc>)
  4022aa:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_1, IOPORT_PIN_LEVEL_LOW); //PROG_1=L
  4022ac:	2100      	movs	r1, #0
  4022ae:	2012      	movs	r0, #18
  4022b0:	4b31      	ldr	r3, [pc, #196]	; (402378 <chbsp_group_pin_init+0xfc>)
  4022b2:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_2, IOPORT_PIN_LEVEL_LOW); //PROG_2=L
  4022b4:	2100      	movs	r1, #0
  4022b6:	2013      	movs	r0, #19
  4022b8:	4b2f      	ldr	r3, [pc, #188]	; (402378 <chbsp_group_pin_init+0xfc>)
  4022ba:	4798      	blx	r3
	ioport_set_pin_level(CHIRP_PROG_3, IOPORT_PIN_LEVEL_LOW); //PROG_3=L
  4022bc:	2100      	movs	r1, #0
  4022be:	201f      	movs	r0, #31
  4022c0:	4b2d      	ldr	r3, [pc, #180]	; (402378 <chbsp_group_pin_init+0xfc>)
  4022c2:	4798      	blx	r3

	ioport_set_pin_dir(CHIRP_RST, IOPORT_DIR_OUTPUT); //reset=output
  4022c4:	2101      	movs	r1, #1
  4022c6:	200f      	movs	r0, #15
  4022c8:	4b2a      	ldr	r3, [pc, #168]	; (402374 <chbsp_group_pin_init+0xf8>)
  4022ca:	4798      	blx	r3
	chbsp_reset_assert();
  4022cc:	4b2b      	ldr	r3, [pc, #172]	; (40237c <chbsp_group_pin_init+0x100>)
  4022ce:	4798      	blx	r3


	for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  4022d0:	2300      	movs	r3, #0
  4022d2:	73fb      	strb	r3, [r7, #15]
  4022d4:	e00b      	b.n	4022ee <chbsp_group_pin_init+0x72>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  4022d6:	7bfb      	ldrb	r3, [r7, #15]
  4022d8:	4619      	mov	r1, r3
  4022da:	6878      	ldr	r0, [r7, #4]
  4022dc:	4b28      	ldr	r3, [pc, #160]	; (402380 <chbsp_group_pin_init+0x104>)
  4022de:	4798      	blx	r3
  4022e0:	60b8      	str	r0, [r7, #8]

		chbsp_program_enable(dev_ptr);
  4022e2:	68b8      	ldr	r0, [r7, #8]
  4022e4:	4b27      	ldr	r3, [pc, #156]	; (402384 <chbsp_group_pin_init+0x108>)
  4022e6:	4798      	blx	r3
	for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  4022e8:	7bfb      	ldrb	r3, [r7, #15]
  4022ea:	3301      	adds	r3, #1
  4022ec:	73fb      	strb	r3, [r7, #15]
  4022ee:	687b      	ldr	r3, [r7, #4]
  4022f0:	781b      	ldrb	r3, [r3, #0]
  4022f2:	7bfa      	ldrb	r2, [r7, #15]
  4022f4:	429a      	cmp	r2, r3
  4022f6:	d3ee      	bcc.n	4022d6 <chbsp_group_pin_init+0x5a>
	}

	/* Initialize IO pins */
	chbsp_group_set_io_dir_in(grp_ptr);
  4022f8:	6878      	ldr	r0, [r7, #4]
  4022fa:	4b23      	ldr	r3, [pc, #140]	; (402388 <chbsp_group_pin_init+0x10c>)
  4022fc:	4798      	blx	r3

	/* Enable the peripheral clock for the MAG extension board interrupt pin. */
	pmc_enable_periph_clk(PIN_EXT_INTERRUPT_ID);
  4022fe:	200b      	movs	r0, #11
  402300:	4b22      	ldr	r3, [pc, #136]	; (40238c <chbsp_group_pin_init+0x110>)
  402302:	4798      	blx	r3

	/* Configure PIOs as input pins. */
	for(port_num = 0; port_num < grp_ptr->num_ports; port_num++ ) {
  402304:	2300      	movs	r3, #0
  402306:	73bb      	strb	r3, [r7, #14]
  402308:	e00c      	b.n	402324 <chbsp_group_pin_init+0xa8>
		pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, chirp_pin_io_irq[port_num],
  40230a:	7bbb      	ldrb	r3, [r7, #14]
  40230c:	4a20      	ldr	r2, [pc, #128]	; (402390 <chbsp_group_pin_init+0x114>)
  40230e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  402312:	2370      	movs	r3, #112	; 0x70
  402314:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  402318:	481e      	ldr	r0, [pc, #120]	; (402394 <chbsp_group_pin_init+0x118>)
  40231a:	4c1f      	ldr	r4, [pc, #124]	; (402398 <chbsp_group_pin_init+0x11c>)
  40231c:	47a0      	blx	r4
	for(port_num = 0; port_num < grp_ptr->num_ports; port_num++ ) {
  40231e:	7bbb      	ldrb	r3, [r7, #14]
  402320:	3301      	adds	r3, #1
  402322:	73bb      	strb	r3, [r7, #14]
  402324:	687b      	ldr	r3, [r7, #4]
  402326:	781b      	ldrb	r3, [r3, #0]
  402328:	7bba      	ldrb	r2, [r7, #14]
  40232a:	429a      	cmp	r2, r3
  40232c:	d3ed      	bcc.n	40230a <chbsp_group_pin_init+0x8e>
				      PIN_EXT_INTERRUPT_ATTR);
	}

	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_MotionINT_MASK,
  40232e:	2370      	movs	r3, #112	; 0x70
  402330:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  402334:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  402338:	4816      	ldr	r0, [pc, #88]	; (402394 <chbsp_group_pin_init+0x118>)
  40233a:	4c17      	ldr	r4, [pc, #92]	; (402398 <chbsp_group_pin_init+0x11c>)
  40233c:	47a0      	blx	r4
			      PIN_EXT_INTERRUPT_ATTR);		//configure motionINT pin (although not used)

	/* Initialize PIO interrupt handler, interrupt on rising edge. */
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, chirp_pin_io_irq[0],
  40233e:	4b14      	ldr	r3, [pc, #80]	; (402390 <chbsp_group_pin_init+0x114>)
  402340:	681a      	ldr	r2, [r3, #0]
  402342:	2300      	movs	r3, #0
  402344:	9300      	str	r3, [sp, #0]
  402346:	2370      	movs	r3, #112	; 0x70
  402348:	210b      	movs	r1, #11
  40234a:	4812      	ldr	r0, [pc, #72]	; (402394 <chbsp_group_pin_init+0x118>)
  40234c:	4c13      	ldr	r4, [pc, #76]	; (40239c <chbsp_group_pin_init+0x120>)
  40234e:	47a0      	blx	r4
						PIN_EXT_INTERRUPT_ATTR, NULL);

	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_MotionINT_MASK,
  402350:	4b13      	ldr	r3, [pc, #76]	; (4023a0 <chbsp_group_pin_init+0x124>)
  402352:	9300      	str	r3, [sp, #0]
  402354:	2370      	movs	r3, #112	; 0x70
  402356:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40235a:	210b      	movs	r1, #11
  40235c:	480d      	ldr	r0, [pc, #52]	; (402394 <chbsp_group_pin_init+0x118>)
  40235e:	4c0f      	ldr	r4, [pc, #60]	; (40239c <chbsp_group_pin_init+0x120>)
  402360:	47a0      	blx	r4
						PIN_EXT_INTERRUPT_ATTR, (void (*) (uint32_t, uint32_t))ext_MotionINT_handler);

	/* Initialize and enable push button (PIO) interrupt. */
	pio_handler_set_priority(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_IRQn, 0);
  402362:	2200      	movs	r2, #0
  402364:	210b      	movs	r1, #11
  402366:	480b      	ldr	r0, [pc, #44]	; (402394 <chbsp_group_pin_init+0x118>)
  402368:	4b0e      	ldr	r3, [pc, #56]	; (4023a4 <chbsp_group_pin_init+0x128>)
  40236a:	4798      	blx	r3

}
  40236c:	bf00      	nop
  40236e:	3714      	adds	r7, #20
  402370:	46bd      	mov	sp, r7
  402372:	bd90      	pop	{r4, r7, pc}
  402374:	004017f7 	.word	0x004017f7
  402378:	0040187f 	.word	0x0040187f
  40237c:	004020ad 	.word	0x004020ad
  402380:	00405b1b 	.word	0x00405b1b
  402384:	004020d5 	.word	0x004020d5
  402388:	004021fd 	.word	0x004021fd
  40238c:	00404459 	.word	0x00404459
  402390:	20000140 	.word	0x20000140
  402394:	400e0e00 	.word	0x400e0e00
  402398:	00403ce1 	.word	0x00403ce1
  40239c:	00404049 	.word	0x00404049
  4023a0:	00401245 	.word	0x00401245
  4023a4:	00404105 	.word	0x00404105

004023a8 <chbsp_group_io_clear>:
 *
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * This function drives the INT line low for each sensor in the group.
 */
void chbsp_group_io_clear(ch_group_t *grp_ptr) {
  4023a8:	b580      	push	{r7, lr}
  4023aa:	b086      	sub	sp, #24
  4023ac:	af00      	add	r7, sp, #0
  4023ae:	6078      	str	r0, [r7, #4]
	ioport_port_mask_t mask = 0;
  4023b0:	2300      	movs	r3, #0
  4023b2:	617b      	str	r3, [r7, #20]
	uint8_t dev_num;

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  4023b4:	2300      	movs	r3, #0
  4023b6:	74fb      	strb	r3, [r7, #19]
  4023b8:	e019      	b.n	4023ee <chbsp_group_io_clear+0x46>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  4023ba:	7cfb      	ldrb	r3, [r7, #19]
  4023bc:	4619      	mov	r1, r3
  4023be:	6878      	ldr	r0, [r7, #4]
  4023c0:	4b13      	ldr	r3, [pc, #76]	; (402410 <chbsp_group_io_clear+0x68>)
  4023c2:	4798      	blx	r3
  4023c4:	60f8      	str	r0, [r7, #12]

		if (ch_sensor_is_connected(dev_ptr)) {
  4023c6:	68f8      	ldr	r0, [r7, #12]
  4023c8:	4b12      	ldr	r3, [pc, #72]	; (402414 <chbsp_group_io_clear+0x6c>)
  4023ca:	4798      	blx	r3
  4023cc:	4603      	mov	r3, r0
  4023ce:	2b00      	cmp	r3, #0
  4023d0:	d00a      	beq.n	4023e8 <chbsp_group_io_clear+0x40>
			mask |= ioport_pin_to_mask(chirp_pin_io[dev_num]);
  4023d2:	7cfb      	ldrb	r3, [r7, #19]
  4023d4:	4a10      	ldr	r2, [pc, #64]	; (402418 <chbsp_group_io_clear+0x70>)
  4023d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4023da:	4618      	mov	r0, r3
  4023dc:	4b0f      	ldr	r3, [pc, #60]	; (40241c <chbsp_group_io_clear+0x74>)
  4023de:	4798      	blx	r3
  4023e0:	4602      	mov	r2, r0
  4023e2:	697b      	ldr	r3, [r7, #20]
  4023e4:	4313      	orrs	r3, r2
  4023e6:	617b      	str	r3, [r7, #20]
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  4023e8:	7cfb      	ldrb	r3, [r7, #19]
  4023ea:	3301      	adds	r3, #1
  4023ec:	74fb      	strb	r3, [r7, #19]
  4023ee:	6878      	ldr	r0, [r7, #4]
  4023f0:	4b0b      	ldr	r3, [pc, #44]	; (402420 <chbsp_group_io_clear+0x78>)
  4023f2:	4798      	blx	r3
  4023f4:	4603      	mov	r3, r0
  4023f6:	461a      	mov	r2, r3
  4023f8:	7cfb      	ldrb	r3, [r7, #19]
  4023fa:	4293      	cmp	r3, r2
  4023fc:	d3dd      	bcc.n	4023ba <chbsp_group_io_clear+0x12>
		}
	}

	ioport_set_port_level(IOPORT_PIOA, mask, IOPORT_PIN_LEVEL_LOW);
  4023fe:	2200      	movs	r2, #0
  402400:	6979      	ldr	r1, [r7, #20]
  402402:	2000      	movs	r0, #0
  402404:	4b07      	ldr	r3, [pc, #28]	; (402424 <chbsp_group_io_clear+0x7c>)
  402406:	4798      	blx	r3
}
  402408:	bf00      	nop
  40240a:	3718      	adds	r7, #24
  40240c:	46bd      	mov	sp, r7
  40240e:	bd80      	pop	{r7, pc}
  402410:	00405b1b 	.word	0x00405b1b
  402414:	00405ad1 	.word	0x00405ad1
  402418:	20000130 	.word	0x20000130
  40241c:	00401937 	.word	0x00401937
  402420:	00405b6f 	.word	0x00405b6f
  402424:	004018eb 	.word	0x004018eb

00402428 <chbsp_group_io_set>:
 *
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * This function drives the INT line high for each sensor in the group.
 */
void chbsp_group_io_set(ch_group_t *grp_ptr) {
  402428:	b580      	push	{r7, lr}
  40242a:	b086      	sub	sp, #24
  40242c:	af00      	add	r7, sp, #0
  40242e:	6078      	str	r0, [r7, #4]
	uint8_t dev_num;
	ioport_port_mask_t mask = 0;
  402430:	2300      	movs	r3, #0
  402432:	613b      	str	r3, [r7, #16]

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  402434:	2300      	movs	r3, #0
  402436:	75fb      	strb	r3, [r7, #23]
  402438:	e019      	b.n	40246e <chbsp_group_io_set+0x46>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  40243a:	7dfb      	ldrb	r3, [r7, #23]
  40243c:	4619      	mov	r1, r3
  40243e:	6878      	ldr	r0, [r7, #4]
  402440:	4b13      	ldr	r3, [pc, #76]	; (402490 <chbsp_group_io_set+0x68>)
  402442:	4798      	blx	r3
  402444:	60f8      	str	r0, [r7, #12]

		if (ch_sensor_is_connected(dev_ptr)) {
  402446:	68f8      	ldr	r0, [r7, #12]
  402448:	4b12      	ldr	r3, [pc, #72]	; (402494 <chbsp_group_io_set+0x6c>)
  40244a:	4798      	blx	r3
  40244c:	4603      	mov	r3, r0
  40244e:	2b00      	cmp	r3, #0
  402450:	d00a      	beq.n	402468 <chbsp_group_io_set+0x40>
			mask |= ioport_pin_to_mask(chirp_pin_io[dev_num]);
  402452:	7dfb      	ldrb	r3, [r7, #23]
  402454:	4a10      	ldr	r2, [pc, #64]	; (402498 <chbsp_group_io_set+0x70>)
  402456:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40245a:	4618      	mov	r0, r3
  40245c:	4b0f      	ldr	r3, [pc, #60]	; (40249c <chbsp_group_io_set+0x74>)
  40245e:	4798      	blx	r3
  402460:	4602      	mov	r2, r0
  402462:	693b      	ldr	r3, [r7, #16]
  402464:	4313      	orrs	r3, r2
  402466:	613b      	str	r3, [r7, #16]
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  402468:	7dfb      	ldrb	r3, [r7, #23]
  40246a:	3301      	adds	r3, #1
  40246c:	75fb      	strb	r3, [r7, #23]
  40246e:	6878      	ldr	r0, [r7, #4]
  402470:	4b0b      	ldr	r3, [pc, #44]	; (4024a0 <chbsp_group_io_set+0x78>)
  402472:	4798      	blx	r3
  402474:	4603      	mov	r3, r0
  402476:	461a      	mov	r2, r3
  402478:	7dfb      	ldrb	r3, [r7, #23]
  40247a:	4293      	cmp	r3, r2
  40247c:	d3dd      	bcc.n	40243a <chbsp_group_io_set+0x12>
		}
	}

	ioport_set_port_level(IOPORT_PIOA, mask, IOPORT_PIN_LEVEL_HIGH);
  40247e:	2201      	movs	r2, #1
  402480:	6939      	ldr	r1, [r7, #16]
  402482:	2000      	movs	r0, #0
  402484:	4b07      	ldr	r3, [pc, #28]	; (4024a4 <chbsp_group_io_set+0x7c>)
  402486:	4798      	blx	r3
}
  402488:	bf00      	nop
  40248a:	3718      	adds	r7, #24
  40248c:	46bd      	mov	sp, r7
  40248e:	bd80      	pop	{r7, pc}
  402490:	00405b1b 	.word	0x00405b1b
  402494:	00405ad1 	.word	0x00405ad1
  402498:	20000130 	.word	0x20000130
  40249c:	00401937 	.word	0x00401937
  4024a0:	00405b6f 	.word	0x00405b6f
  4024a4:	004018eb 	.word	0x004018eb

004024a8 <chbsp_group_io_interrupt_enable>:
 * \param grp_ptr 	pointer to the ch_group_t config structure for a group of sensors
 *
 * For each sensor in the group, this function disables the host interrupt associated
 * with the Chirp sensor device's INT line.
 */
void chbsp_group_io_interrupt_enable(ch_group_t *grp_ptr) {
  4024a8:	b580      	push	{r7, lr}
  4024aa:	b084      	sub	sp, #16
  4024ac:	af00      	add	r7, sp, #0
  4024ae:	6078      	str	r0, [r7, #4]
	uint8_t dev_num;

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  4024b0:	2300      	movs	r3, #0
  4024b2:	73fb      	strb	r3, [r7, #15]
  4024b4:	e00b      	b.n	4024ce <chbsp_group_io_interrupt_enable+0x26>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  4024b6:	7bfb      	ldrb	r3, [r7, #15]
  4024b8:	4619      	mov	r1, r3
  4024ba:	6878      	ldr	r0, [r7, #4]
  4024bc:	4b0a      	ldr	r3, [pc, #40]	; (4024e8 <chbsp_group_io_interrupt_enable+0x40>)
  4024be:	4798      	blx	r3
  4024c0:	60b8      	str	r0, [r7, #8]

		chbsp_io_interrupt_enable(dev_ptr);
  4024c2:	68b8      	ldr	r0, [r7, #8]
  4024c4:	4b09      	ldr	r3, [pc, #36]	; (4024ec <chbsp_group_io_interrupt_enable+0x44>)
  4024c6:	4798      	blx	r3
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  4024c8:	7bfb      	ldrb	r3, [r7, #15]
  4024ca:	3301      	adds	r3, #1
  4024cc:	73fb      	strb	r3, [r7, #15]
  4024ce:	6878      	ldr	r0, [r7, #4]
  4024d0:	4b07      	ldr	r3, [pc, #28]	; (4024f0 <chbsp_group_io_interrupt_enable+0x48>)
  4024d2:	4798      	blx	r3
  4024d4:	4603      	mov	r3, r0
  4024d6:	461a      	mov	r2, r3
  4024d8:	7bfb      	ldrb	r3, [r7, #15]
  4024da:	4293      	cmp	r3, r2
  4024dc:	d3eb      	bcc.n	4024b6 <chbsp_group_io_interrupt_enable+0xe>
	}
}
  4024de:	bf00      	nop
  4024e0:	3710      	adds	r7, #16
  4024e2:	46bd      	mov	sp, r7
  4024e4:	bd80      	pop	{r7, pc}
  4024e6:	bf00      	nop
  4024e8:	00405b1b 	.word	0x00405b1b
  4024ec:	004024f5 	.word	0x004024f5
  4024f0:	00405b6f 	.word	0x00405b6f

004024f4 <chbsp_io_interrupt_enable>:
 * \param dev_ptr	pointer to the ch_dev_t config structure for a sensor
 *
 * This function enables the host interrupt associated with the Chirp sensor device's
 * INT line.
 */
void chbsp_io_interrupt_enable(ch_dev_t *dev_ptr) {
  4024f4:	b580      	push	{r7, lr}
  4024f6:	b084      	sub	sp, #16
  4024f8:	af00      	add	r7, sp, #0
  4024fa:	6078      	str	r0, [r7, #4]
	uint8_t dev_num = ch_get_dev_num(dev_ptr);
  4024fc:	6878      	ldr	r0, [r7, #4]
  4024fe:	4b0f      	ldr	r3, [pc, #60]	; (40253c <chbsp_io_interrupt_enable+0x48>)
  402500:	4798      	blx	r3
  402502:	4603      	mov	r3, r0
  402504:	73fb      	strb	r3, [r7, #15]

	if (ch_sensor_is_connected(dev_ptr)) {
  402506:	6878      	ldr	r0, [r7, #4]
  402508:	4b0d      	ldr	r3, [pc, #52]	; (402540 <chbsp_io_interrupt_enable+0x4c>)
  40250a:	4798      	blx	r3
  40250c:	4603      	mov	r3, r0
  40250e:	2b00      	cmp	r3, #0
  402510:	d010      	beq.n	402534 <chbsp_io_interrupt_enable+0x40>
		pio_handler_clear_pending_IRQ(PIN_EXT_INTERRUPT_PIO, chirp_pin_io_irq[dev_num]);
  402512:	7bfb      	ldrb	r3, [r7, #15]
  402514:	4a0b      	ldr	r2, [pc, #44]	; (402544 <chbsp_io_interrupt_enable+0x50>)
  402516:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40251a:	b25b      	sxtb	r3, r3
  40251c:	4619      	mov	r1, r3
  40251e:	480a      	ldr	r0, [pc, #40]	; (402548 <chbsp_io_interrupt_enable+0x54>)
  402520:	4b0a      	ldr	r3, [pc, #40]	; (40254c <chbsp_io_interrupt_enable+0x58>)
  402522:	4798      	blx	r3
		pio_enable_interrupt(PIN_EXT_INTERRUPT_PIO, chirp_pin_io_irq[dev_num]);
  402524:	7bfb      	ldrb	r3, [r7, #15]
  402526:	4a07      	ldr	r2, [pc, #28]	; (402544 <chbsp_io_interrupt_enable+0x50>)
  402528:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40252c:	4619      	mov	r1, r3
  40252e:	4806      	ldr	r0, [pc, #24]	; (402548 <chbsp_io_interrupt_enable+0x54>)
  402530:	4b07      	ldr	r3, [pc, #28]	; (402550 <chbsp_io_interrupt_enable+0x5c>)
  402532:	4798      	blx	r3
	}
}
  402534:	bf00      	nop
  402536:	3710      	adds	r7, #16
  402538:	46bd      	mov	sp, r7
  40253a:	bd80      	pop	{r7, pc}
  40253c:	00405b01 	.word	0x00405b01
  402540:	00405ad1 	.word	0x00405ad1
  402544:	20000140 	.word	0x20000140
  402548:	400e0e00 	.word	0x400e0e00
  40254c:	00404189 	.word	0x00404189
  402550:	00403e3d 	.word	0x00403e3d

00402554 <chbsp_group_io_interrupt_disable>:
 * \param grp_ptr 		pointer to the ch_group_t config structure for a group of sensors
 *
 * For each sensor in the group, this function disables the host interrupt associated
 * with the Chirp sensor device's INT line.
 */
void chbsp_group_io_interrupt_disable(ch_group_t *grp_ptr) {
  402554:	b580      	push	{r7, lr}
  402556:	b084      	sub	sp, #16
  402558:	af00      	add	r7, sp, #0
  40255a:	6078      	str	r0, [r7, #4]
	uint8_t dev_num;

	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  40255c:	2300      	movs	r3, #0
  40255e:	73fb      	strb	r3, [r7, #15]
  402560:	e00b      	b.n	40257a <chbsp_group_io_interrupt_disable+0x26>
		ch_dev_t *dev_ptr = ch_get_dev_ptr(grp_ptr, dev_num);
  402562:	7bfb      	ldrb	r3, [r7, #15]
  402564:	4619      	mov	r1, r3
  402566:	6878      	ldr	r0, [r7, #4]
  402568:	4b0a      	ldr	r3, [pc, #40]	; (402594 <chbsp_group_io_interrupt_disable+0x40>)
  40256a:	4798      	blx	r3
  40256c:	60b8      	str	r0, [r7, #8]

		chbsp_io_interrupt_disable(dev_ptr);
  40256e:	68b8      	ldr	r0, [r7, #8]
  402570:	4b09      	ldr	r3, [pc, #36]	; (402598 <chbsp_group_io_interrupt_disable+0x44>)
  402572:	4798      	blx	r3
	for (dev_num = 0; dev_num < ch_get_num_ports(grp_ptr); dev_num++) {
  402574:	7bfb      	ldrb	r3, [r7, #15]
  402576:	3301      	adds	r3, #1
  402578:	73fb      	strb	r3, [r7, #15]
  40257a:	6878      	ldr	r0, [r7, #4]
  40257c:	4b07      	ldr	r3, [pc, #28]	; (40259c <chbsp_group_io_interrupt_disable+0x48>)
  40257e:	4798      	blx	r3
  402580:	4603      	mov	r3, r0
  402582:	461a      	mov	r2, r3
  402584:	7bfb      	ldrb	r3, [r7, #15]
  402586:	4293      	cmp	r3, r2
  402588:	d3eb      	bcc.n	402562 <chbsp_group_io_interrupt_disable+0xe>
	}
}
  40258a:	bf00      	nop
  40258c:	3710      	adds	r7, #16
  40258e:	46bd      	mov	sp, r7
  402590:	bd80      	pop	{r7, pc}
  402592:	bf00      	nop
  402594:	00405b1b 	.word	0x00405b1b
  402598:	004025a1 	.word	0x004025a1
  40259c:	00405b6f 	.word	0x00405b6f

004025a0 <chbsp_io_interrupt_disable>:
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function disables the host interrupt associated with the Chirp sensor device's
 * INT line.
 */
void chbsp_io_interrupt_disable(ch_dev_t *dev_ptr) {
  4025a0:	b580      	push	{r7, lr}
  4025a2:	b082      	sub	sp, #8
  4025a4:	af00      	add	r7, sp, #0
  4025a6:	6078      	str	r0, [r7, #4]

	if (dev_ptr->sensor_connected) {
  4025a8:	687b      	ldr	r3, [r7, #4]
  4025aa:	7fdb      	ldrb	r3, [r3, #31]
  4025ac:	2b00      	cmp	r3, #0
  4025ae:	d00a      	beq.n	4025c6 <chbsp_io_interrupt_disable+0x26>
		pio_disable_interrupt(PIN_EXT_INTERRUPT_PIO, chirp_pin_io_irq[dev_ptr->io_index]);
  4025b0:	687b      	ldr	r3, [r7, #4]
  4025b2:	f893 3020 	ldrb.w	r3, [r3, #32]
  4025b6:	461a      	mov	r2, r3
  4025b8:	4b05      	ldr	r3, [pc, #20]	; (4025d0 <chbsp_io_interrupt_disable+0x30>)
  4025ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4025be:	4619      	mov	r1, r3
  4025c0:	4804      	ldr	r0, [pc, #16]	; (4025d4 <chbsp_io_interrupt_disable+0x34>)
  4025c2:	4b05      	ldr	r3, [pc, #20]	; (4025d8 <chbsp_io_interrupt_disable+0x38>)
  4025c4:	4798      	blx	r3
	}
}
  4025c6:	bf00      	nop
  4025c8:	3708      	adds	r7, #8
  4025ca:	46bd      	mov	sp, r7
  4025cc:	bd80      	pop	{r7, pc}
  4025ce:	bf00      	nop
  4025d0:	20000140 	.word	0x20000140
  4025d4:	400e0e00 	.word	0x400e0e00
  4025d8:	00403e59 	.word	0x00403e59

004025dc <chbsp_io_set>:
 *
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function drives the INT line high for one sensor.
 */
void chbsp_io_set(ch_dev_t *dev_ptr) {
  4025dc:	b580      	push	{r7, lr}
  4025de:	b082      	sub	sp, #8
  4025e0:	af00      	add	r7, sp, #0
  4025e2:	6078      	str	r0, [r7, #4]
	ioport_set_pin_level(chirp_pin_io[dev_ptr->io_index], IOPORT_PIN_LEVEL_HIGH);
  4025e4:	687b      	ldr	r3, [r7, #4]
  4025e6:	f893 3020 	ldrb.w	r3, [r3, #32]
  4025ea:	461a      	mov	r2, r3
  4025ec:	4b05      	ldr	r3, [pc, #20]	; (402604 <chbsp_io_set+0x28>)
  4025ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4025f2:	2101      	movs	r1, #1
  4025f4:	4618      	mov	r0, r3
  4025f6:	4b04      	ldr	r3, [pc, #16]	; (402608 <chbsp_io_set+0x2c>)
  4025f8:	4798      	blx	r3
}
  4025fa:	bf00      	nop
  4025fc:	3708      	adds	r7, #8
  4025fe:	46bd      	mov	sp, r7
  402600:	bd80      	pop	{r7, pc}
  402602:	bf00      	nop
  402604:	20000130 	.word	0x20000130
  402608:	0040187f 	.word	0x0040187f
  40260c:	00000000 	.word	0x00000000

00402610 <chbsp_delay_us>:
 * \param us  	number of microseconds to delay before returning
 *
 * This function waits for the specified number of microseconds before returning to
 * the caller.
 */
void chbsp_delay_us(uint32_t us) {
  402610:	b5f0      	push	{r4, r5, r6, r7, lr}
  402612:	b083      	sub	sp, #12
  402614:	af00      	add	r7, sp, #0
  402616:	6078      	str	r0, [r7, #4]

	delay_us(us);
  402618:	687b      	ldr	r3, [r7, #4]
  40261a:	2b00      	cmp	r3, #0
  40261c:	d024      	beq.n	402668 <chbsp_delay_us+0x58>
  40261e:	687b      	ldr	r3, [r7, #4]
  402620:	461d      	mov	r5, r3
  402622:	f04f 0600 	mov.w	r6, #0
  402626:	4b20      	ldr	r3, [pc, #128]	; (4026a8 <chbsp_delay_us+0x98>)
  402628:	4798      	blx	r3
  40262a:	4603      	mov	r3, r0
  40262c:	f04f 0400 	mov.w	r4, #0
  402630:	fb03 f106 	mul.w	r1, r3, r6
  402634:	fb05 f204 	mul.w	r2, r5, r4
  402638:	440a      	add	r2, r1
  40263a:	fba5 3403 	umull	r3, r4, r5, r3
  40263e:	4422      	add	r2, r4
  402640:	4614      	mov	r4, r2
  402642:	a217      	add	r2, pc, #92	; (adr r2, 4026a0 <chbsp_delay_us+0x90>)
  402644:	e9d2 1200 	ldrd	r1, r2, [r2]
  402648:	185d      	adds	r5, r3, r1
  40264a:	eb44 0602 	adc.w	r6, r4, r2
  40264e:	4628      	mov	r0, r5
  402650:	4631      	mov	r1, r6
  402652:	4c16      	ldr	r4, [pc, #88]	; (4026ac <chbsp_delay_us+0x9c>)
  402654:	4a16      	ldr	r2, [pc, #88]	; (4026b0 <chbsp_delay_us+0xa0>)
  402656:	f04f 0300 	mov.w	r3, #0
  40265a:	47a0      	blx	r4
  40265c:	4603      	mov	r3, r0
  40265e:	460c      	mov	r4, r1
  402660:	4618      	mov	r0, r3
  402662:	4b14      	ldr	r3, [pc, #80]	; (4026b4 <chbsp_delay_us+0xa4>)
  402664:	4798      	blx	r3
}
  402666:	e016      	b.n	402696 <chbsp_delay_us+0x86>
	delay_us(us);
  402668:	4b0f      	ldr	r3, [pc, #60]	; (4026a8 <chbsp_delay_us+0x98>)
  40266a:	4798      	blx	r3
  40266c:	4603      	mov	r3, r0
  40266e:	f04f 0400 	mov.w	r4, #0
  402672:	a20b      	add	r2, pc, #44	; (adr r2, 4026a0 <chbsp_delay_us+0x90>)
  402674:	e9d2 1200 	ldrd	r1, r2, [r2]
  402678:	185d      	adds	r5, r3, r1
  40267a:	eb44 0602 	adc.w	r6, r4, r2
  40267e:	4628      	mov	r0, r5
  402680:	4631      	mov	r1, r6
  402682:	4c0a      	ldr	r4, [pc, #40]	; (4026ac <chbsp_delay_us+0x9c>)
  402684:	4a0a      	ldr	r2, [pc, #40]	; (4026b0 <chbsp_delay_us+0xa0>)
  402686:	f04f 0300 	mov.w	r3, #0
  40268a:	47a0      	blx	r4
  40268c:	4603      	mov	r3, r0
  40268e:	460c      	mov	r4, r1
  402690:	4618      	mov	r0, r3
  402692:	4b08      	ldr	r3, [pc, #32]	; (4026b4 <chbsp_delay_us+0xa4>)
  402694:	4798      	blx	r3
}
  402696:	bf00      	nop
  402698:	370c      	adds	r7, #12
  40269a:	46bd      	mov	sp, r7
  40269c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40269e:	bf00      	nop
  4026a0:	00d59f7f 	.word	0x00d59f7f
  4026a4:	00000000 	.word	0x00000000
  4026a8:	0040176d 	.word	0x0040176d
  4026ac:	0040cbad 	.word	0x0040cbad
  4026b0:	00d59f80 	.word	0x00d59f80
  4026b4:	20000001 	.word	0x20000001

004026b8 <chbsp_delay_ms>:
 * \param ms 	number of milliseconds to delay before returning
 *
 * This function waits for the specified number of milliseconds before returning to
 * the caller.
 */
void chbsp_delay_ms(uint32_t ms) {
  4026b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4026ba:	b083      	sub	sp, #12
  4026bc:	af00      	add	r7, sp, #0
  4026be:	6078      	str	r0, [r7, #4]

	delay_us(ms*1000);
  4026c0:	687b      	ldr	r3, [r7, #4]
  4026c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4026c6:	fb02 f303 	mul.w	r3, r2, r3
  4026ca:	2b00      	cmp	r3, #0
  4026cc:	d028      	beq.n	402720 <chbsp_delay_ms+0x68>
  4026ce:	687b      	ldr	r3, [r7, #4]
  4026d0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4026d4:	fb02 f303 	mul.w	r3, r2, r3
  4026d8:	461d      	mov	r5, r3
  4026da:	f04f 0600 	mov.w	r6, #0
  4026de:	4b20      	ldr	r3, [pc, #128]	; (402760 <chbsp_delay_ms+0xa8>)
  4026e0:	4798      	blx	r3
  4026e2:	4603      	mov	r3, r0
  4026e4:	f04f 0400 	mov.w	r4, #0
  4026e8:	fb03 f106 	mul.w	r1, r3, r6
  4026ec:	fb05 f204 	mul.w	r2, r5, r4
  4026f0:	440a      	add	r2, r1
  4026f2:	fba5 3403 	umull	r3, r4, r5, r3
  4026f6:	4422      	add	r2, r4
  4026f8:	4614      	mov	r4, r2
  4026fa:	a217      	add	r2, pc, #92	; (adr r2, 402758 <chbsp_delay_ms+0xa0>)
  4026fc:	e9d2 1200 	ldrd	r1, r2, [r2]
  402700:	185d      	adds	r5, r3, r1
  402702:	eb44 0602 	adc.w	r6, r4, r2
  402706:	4628      	mov	r0, r5
  402708:	4631      	mov	r1, r6
  40270a:	4c16      	ldr	r4, [pc, #88]	; (402764 <chbsp_delay_ms+0xac>)
  40270c:	4a16      	ldr	r2, [pc, #88]	; (402768 <chbsp_delay_ms+0xb0>)
  40270e:	f04f 0300 	mov.w	r3, #0
  402712:	47a0      	blx	r4
  402714:	4603      	mov	r3, r0
  402716:	460c      	mov	r4, r1
  402718:	4618      	mov	r0, r3
  40271a:	4b14      	ldr	r3, [pc, #80]	; (40276c <chbsp_delay_ms+0xb4>)
  40271c:	4798      	blx	r3
}
  40271e:	e016      	b.n	40274e <chbsp_delay_ms+0x96>
	delay_us(ms*1000);
  402720:	4b0f      	ldr	r3, [pc, #60]	; (402760 <chbsp_delay_ms+0xa8>)
  402722:	4798      	blx	r3
  402724:	4603      	mov	r3, r0
  402726:	f04f 0400 	mov.w	r4, #0
  40272a:	a20b      	add	r2, pc, #44	; (adr r2, 402758 <chbsp_delay_ms+0xa0>)
  40272c:	e9d2 1200 	ldrd	r1, r2, [r2]
  402730:	185d      	adds	r5, r3, r1
  402732:	eb44 0602 	adc.w	r6, r4, r2
  402736:	4628      	mov	r0, r5
  402738:	4631      	mov	r1, r6
  40273a:	4c0a      	ldr	r4, [pc, #40]	; (402764 <chbsp_delay_ms+0xac>)
  40273c:	4a0a      	ldr	r2, [pc, #40]	; (402768 <chbsp_delay_ms+0xb0>)
  40273e:	f04f 0300 	mov.w	r3, #0
  402742:	47a0      	blx	r4
  402744:	4603      	mov	r3, r0
  402746:	460c      	mov	r4, r1
  402748:	4618      	mov	r0, r3
  40274a:	4b08      	ldr	r3, [pc, #32]	; (40276c <chbsp_delay_ms+0xb4>)
  40274c:	4798      	blx	r3
}
  40274e:	bf00      	nop
  402750:	370c      	adds	r7, #12
  402752:	46bd      	mov	sp, r7
  402754:	bdf0      	pop	{r4, r5, r6, r7, pc}
  402756:	bf00      	nop
  402758:	00d59f7f 	.word	0x00d59f7f
  40275c:	00000000 	.word	0x00000000
  402760:	0040176d 	.word	0x0040176d
  402764:	0040cbad 	.word	0x0040cbad
  402768:	00d59f80 	.word	0x00d59f80
  40276c:	20000001 	.word	0x20000001

00402770 <chbsp_i2c_init>:
 *
 * \return 0 if successful, 1 on error
 *
 * This function performs general I2C initialization on the host system.
 */
int chbsp_i2c_init(void) {
  402770:	b580      	push	{r7, lr}
  402772:	af00      	add	r7, sp, #0

	i2c_master_init();
  402774:	4b02      	ldr	r3, [pc, #8]	; (402780 <chbsp_i2c_init+0x10>)
  402776:	4798      	blx	r3
	return 0;
  402778:	2300      	movs	r3, #0

}
  40277a:	4618      	mov	r0, r3
  40277c:	bd80      	pop	{r7, pc}
  40277e:	bf00      	nop
  402780:	004089c1 	.word	0x004089c1

00402784 <chbsp_i2c_get_info>:
 *  - The \a address field contains the I2C address for the sensor.
 *  - The \a bus_num field contains the I2C bus number (index).
 *  - The \a drv_flags field contains various bit flags through which the BSP can inform
 *  SonicLib driver functions to perform specific actions during I2C I/O operations.
 */
uint8_t chbsp_i2c_get_info(ch_group_t __attribute__((unused)) *grp_ptr, uint8_t io_index, ch_i2c_info_t *info_ptr) {
  402784:	b480      	push	{r7}
  402786:	b087      	sub	sp, #28
  402788:	af00      	add	r7, sp, #0
  40278a:	60f8      	str	r0, [r7, #12]
  40278c:	460b      	mov	r3, r1
  40278e:	607a      	str	r2, [r7, #4]
  402790:	72fb      	strb	r3, [r7, #11]
	uint8_t ret_val = 1;
  402792:	2301      	movs	r3, #1
  402794:	75fb      	strb	r3, [r7, #23]

	if (io_index <= CHBSP_MAX_DEVICES) {
  402796:	7afb      	ldrb	r3, [r7, #11]
  402798:	2b04      	cmp	r3, #4
  40279a:	d80e      	bhi.n	4027ba <chbsp_i2c_get_info+0x36>
		info_ptr->address = chirp_i2c_addrs[io_index];
  40279c:	7afb      	ldrb	r3, [r7, #11]
  40279e:	4a0a      	ldr	r2, [pc, #40]	; (4027c8 <chbsp_i2c_get_info+0x44>)
  4027a0:	5cd2      	ldrb	r2, [r2, r3]
  4027a2:	687b      	ldr	r3, [r7, #4]
  4027a4:	701a      	strb	r2, [r3, #0]
		info_ptr->bus_num = chirp_i2c_buses[io_index];
  4027a6:	7afb      	ldrb	r3, [r7, #11]
  4027a8:	4a08      	ldr	r2, [pc, #32]	; (4027cc <chbsp_i2c_get_info+0x48>)
  4027aa:	5cd2      	ldrb	r2, [r2, r3]
  4027ac:	687b      	ldr	r3, [r7, #4]
  4027ae:	705a      	strb	r2, [r3, #1]

		info_ptr->drv_flags = 0;	// no special I2C handling by SonicLib driver is needed
  4027b0:	687b      	ldr	r3, [r7, #4]
  4027b2:	2200      	movs	r2, #0
  4027b4:	805a      	strh	r2, [r3, #2]

		ret_val = 0;
  4027b6:	2300      	movs	r3, #0
  4027b8:	75fb      	strb	r3, [r7, #23]
	}

	return ret_val;
  4027ba:	7dfb      	ldrb	r3, [r7, #23]
}
  4027bc:	4618      	mov	r0, r3
  4027be:	371c      	adds	r7, #28
  4027c0:	46bd      	mov	sp, r7
  4027c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027c6:	4770      	bx	lr
  4027c8:	20000118 	.word	0x20000118
  4027cc:	2000011c 	.word	0x2000011c

004027d0 <chbsp_i2c_write>:
 * \return 0 if successful, 1 on error or NACK
 *
 * This function writes one or more bytes of data to an I2C slave device.
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_write(ch_dev_t *dev_ptr, uint8_t *data, uint16_t num_bytes) {
  4027d0:	b580      	push	{r7, lr}
  4027d2:	b086      	sub	sp, #24
  4027d4:	af00      	add	r7, sp, #0
  4027d6:	60f8      	str	r0, [r7, #12]
  4027d8:	60b9      	str	r1, [r7, #8]
  4027da:	4613      	mov	r3, r2
  4027dc:	80fb      	strh	r3, [r7, #6]
	int error = 0;
  4027de:	2300      	movs	r3, #0
  4027e0:	617b      	str	r3, [r7, #20]

	if (dev_ptr->i2c_bus_index == 0) {
  4027e2:	68fb      	ldr	r3, [r7, #12]
  4027e4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  4027e8:	2b00      	cmp	r3, #0
  4027ea:	d109      	bne.n	402800 <chbsp_i2c_write+0x30>
		error = i2c_master_write_register1_raw(dev_ptr->i2c_address, num_bytes, data); //I2C bus 0 (TWI1)
  4027ec:	68fb      	ldr	r3, [r7, #12]
  4027ee:	7e1b      	ldrb	r3, [r3, #24]
  4027f0:	88f9      	ldrh	r1, [r7, #6]
  4027f2:	68ba      	ldr	r2, [r7, #8]
  4027f4:	4618      	mov	r0, r3
  4027f6:	4b0c      	ldr	r3, [pc, #48]	; (402828 <chbsp_i2c_write+0x58>)
  4027f8:	4798      	blx	r3
  4027fa:	4603      	mov	r3, r0
  4027fc:	617b      	str	r3, [r7, #20]
  4027fe:	e00d      	b.n	40281c <chbsp_i2c_write+0x4c>

	} else if (dev_ptr->i2c_bus_index == 1) {
  402800:	68fb      	ldr	r3, [r7, #12]
  402802:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  402806:	2b01      	cmp	r3, #1
  402808:	d108      	bne.n	40281c <chbsp_i2c_write+0x4c>
		error = i2c_master_write_register3_raw(dev_ptr->i2c_address, num_bytes, data); //I2C bus 1 (TWI3)
  40280a:	68fb      	ldr	r3, [r7, #12]
  40280c:	7e1b      	ldrb	r3, [r3, #24]
  40280e:	88f9      	ldrh	r1, [r7, #6]
  402810:	68ba      	ldr	r2, [r7, #8]
  402812:	4618      	mov	r0, r3
  402814:	4b05      	ldr	r3, [pc, #20]	; (40282c <chbsp_i2c_write+0x5c>)
  402816:	4798      	blx	r3
  402818:	4603      	mov	r3, r0
  40281a:	617b      	str	r3, [r7, #20]
	}

	return error;
  40281c:	697b      	ldr	r3, [r7, #20]
}
  40281e:	4618      	mov	r0, r3
  402820:	3718      	adds	r7, #24
  402822:	46bd      	mov	sp, r7
  402824:	bd80      	pop	{r7, pc}
  402826:	bf00      	nop
  402828:	00408b89 	.word	0x00408b89
  40282c:	00408c11 	.word	0x00408c11

00402830 <chbsp_i2c_mem_write>:
 * This function writes one or more bytes of data to an I2C slave device using an internal
 * memory or register address.  The remote device will write \a num_bytes bytes of
 * data starting at internal memory/register address \a mem_addr.
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_mem_write(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t *data, uint16_t num_bytes) {
  402830:	b590      	push	{r4, r7, lr}
  402832:	b087      	sub	sp, #28
  402834:	af00      	add	r7, sp, #0
  402836:	60f8      	str	r0, [r7, #12]
  402838:	607a      	str	r2, [r7, #4]
  40283a:	461a      	mov	r2, r3
  40283c:	460b      	mov	r3, r1
  40283e:	817b      	strh	r3, [r7, #10]
  402840:	4613      	mov	r3, r2
  402842:	813b      	strh	r3, [r7, #8]
	int error=0;
  402844:	2300      	movs	r3, #0
  402846:	617b      	str	r3, [r7, #20]
	if (dev_ptr->i2c_bus_index == 0) {
  402848:	68fb      	ldr	r3, [r7, #12]
  40284a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  40284e:	2b00      	cmp	r3, #0
  402850:	d10a      	bne.n	402868 <chbsp_i2c_mem_write+0x38>
		// I2C bus 0 (TWI1)
		error = i2c_master_write_register1(dev_ptr->i2c_address, mem_addr, num_bytes, data);
  402852:	68fb      	ldr	r3, [r7, #12]
  402854:	7e18      	ldrb	r0, [r3, #24]
  402856:	897b      	ldrh	r3, [r7, #10]
  402858:	b2d9      	uxtb	r1, r3
  40285a:	893a      	ldrh	r2, [r7, #8]
  40285c:	687b      	ldr	r3, [r7, #4]
  40285e:	4c0c      	ldr	r4, [pc, #48]	; (402890 <chbsp_i2c_mem_write+0x60>)
  402860:	47a0      	blx	r4
  402862:	4603      	mov	r3, r0
  402864:	617b      	str	r3, [r7, #20]
  402866:	e00e      	b.n	402886 <chbsp_i2c_mem_write+0x56>

		} else if (dev_ptr->i2c_bus_index == 1) {
  402868:	68fb      	ldr	r3, [r7, #12]
  40286a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  40286e:	2b01      	cmp	r3, #1
  402870:	d109      	bne.n	402886 <chbsp_i2c_mem_write+0x56>
		// I2C bus 1 (TWI3)
		error = i2c_master_write_register3(dev_ptr->i2c_address, mem_addr, num_bytes, data);
  402872:	68fb      	ldr	r3, [r7, #12]
  402874:	7e18      	ldrb	r0, [r3, #24]
  402876:	897b      	ldrh	r3, [r7, #10]
  402878:	b2d9      	uxtb	r1, r3
  40287a:	893a      	ldrh	r2, [r7, #8]
  40287c:	687b      	ldr	r3, [r7, #4]
  40287e:	4c05      	ldr	r4, [pc, #20]	; (402894 <chbsp_i2c_mem_write+0x64>)
  402880:	47a0      	blx	r4
  402882:	4603      	mov	r3, r0
  402884:	617b      	str	r3, [r7, #20]
	}
	return error;
  402886:	697b      	ldr	r3, [r7, #20]
}
  402888:	4618      	mov	r0, r3
  40288a:	371c      	adds	r7, #28
  40288c:	46bd      	mov	sp, r7
  40288e:	bd90      	pop	{r4, r7, pc}
  402890:	00408b41 	.word	0x00408b41
  402894:	00408bc9 	.word	0x00408bc9

00402898 <chbsp_i2c_mem_write_nb>:
 * I2C slave device, using an internal memory or register address.  The remote device will write
 * \a num_bytes bytes of data starting at internal memory/register address \a mem_addr.
 *
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_mem_write_nb(ch_dev_t __attribute__((unused)) *dev_ptr, uint16_t __attribute__((unused)) mem_addr, uint8_t __attribute__((unused)) *data, uint16_t __attribute__((unused)) num_bytes) {
  402898:	b480      	push	{r7}
  40289a:	b085      	sub	sp, #20
  40289c:	af00      	add	r7, sp, #0
  40289e:	60f8      	str	r0, [r7, #12]
  4028a0:	607a      	str	r2, [r7, #4]
  4028a2:	461a      	mov	r2, r3
  4028a4:	460b      	mov	r3, r1
  4028a6:	817b      	strh	r3, [r7, #10]
  4028a8:	4613      	mov	r3, r2
  4028aa:	813b      	strh	r3, [r7, #8]

	// XXX not implemented
	return 1;
  4028ac:	2301      	movs	r3, #1
}
  4028ae:	4618      	mov	r0, r3
  4028b0:	3714      	adds	r7, #20
  4028b2:	46bd      	mov	sp, r7
  4028b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4028b8:	4770      	bx	lr
	...

004028bc <chbsp_i2c_read>:
 * \return 0 if successful, 1 on error or NACK
 *
 * This function reads the specified number of bytes from an I2C slave device.
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_read(ch_dev_t *dev_ptr, uint8_t *data, uint16_t num_bytes) {
  4028bc:	b580      	push	{r7, lr}
  4028be:	b086      	sub	sp, #24
  4028c0:	af00      	add	r7, sp, #0
  4028c2:	60f8      	str	r0, [r7, #12]
  4028c4:	60b9      	str	r1, [r7, #8]
  4028c6:	4613      	mov	r3, r2
  4028c8:	80fb      	strh	r3, [r7, #6]
	int error = 1;		// default is error return
  4028ca:	2301      	movs	r3, #1
  4028cc:	617b      	str	r3, [r7, #20]
	uint8_t i2c_addr = ch_get_i2c_address(dev_ptr);
  4028ce:	68f8      	ldr	r0, [r7, #12]
  4028d0:	4b12      	ldr	r3, [pc, #72]	; (40291c <chbsp_i2c_read+0x60>)
  4028d2:	4798      	blx	r3
  4028d4:	4603      	mov	r3, r0
  4028d6:	74fb      	strb	r3, [r7, #19]
	uint8_t bus_num  = ch_get_i2c_bus(dev_ptr);
  4028d8:	68f8      	ldr	r0, [r7, #12]
  4028da:	4b11      	ldr	r3, [pc, #68]	; (402920 <chbsp_i2c_read+0x64>)
  4028dc:	4798      	blx	r3
  4028de:	4603      	mov	r3, r0
  4028e0:	74bb      	strb	r3, [r7, #18]

	if (bus_num == 0) {
  4028e2:	7cbb      	ldrb	r3, [r7, #18]
  4028e4:	2b00      	cmp	r3, #0
  4028e6:	d108      	bne.n	4028fa <chbsp_i2c_read+0x3e>
		// I2C bus 0 (TWI1)
		error = i2c_master_read_register1_raw(i2c_addr, num_bytes, data);
  4028e8:	88f9      	ldrh	r1, [r7, #6]
  4028ea:	7cfb      	ldrb	r3, [r7, #19]
  4028ec:	68ba      	ldr	r2, [r7, #8]
  4028ee:	4618      	mov	r0, r3
  4028f0:	4b0c      	ldr	r3, [pc, #48]	; (402924 <chbsp_i2c_read+0x68>)
  4028f2:	4798      	blx	r3
  4028f4:	4603      	mov	r3, r0
  4028f6:	617b      	str	r3, [r7, #20]
  4028f8:	e00a      	b.n	402910 <chbsp_i2c_read+0x54>

	} else if (bus_num == 1) {
  4028fa:	7cbb      	ldrb	r3, [r7, #18]
  4028fc:	2b01      	cmp	r3, #1
  4028fe:	d107      	bne.n	402910 <chbsp_i2c_read+0x54>
		// I2C bus 1 (TWI3)
		error = i2c_master_read_register3_raw(i2c_addr, num_bytes, data);
  402900:	88f9      	ldrh	r1, [r7, #6]
  402902:	7cfb      	ldrb	r3, [r7, #19]
  402904:	68ba      	ldr	r2, [r7, #8]
  402906:	4618      	mov	r0, r3
  402908:	4b07      	ldr	r3, [pc, #28]	; (402928 <chbsp_i2c_read+0x6c>)
  40290a:	4798      	blx	r3
  40290c:	4603      	mov	r3, r0
  40290e:	617b      	str	r3, [r7, #20]
	}
	return error;
  402910:	697b      	ldr	r3, [r7, #20]
}
  402912:	4618      	mov	r0, r3
  402914:	3718      	adds	r7, #24
  402916:	46bd      	mov	sp, r7
  402918:	bd80      	pop	{r7, pc}
  40291a:	bf00      	nop
  40291c:	00405b3d 	.word	0x00405b3d
  402920:	00405b55 	.word	0x00405b55
  402924:	00408a61 	.word	0x00408a61
  402928:	00408af9 	.word	0x00408af9

0040292c <chbsp_i2c_mem_read>:
 * an internal memory or register address.  The remote device will return \a num_bytes bytes
 * starting at internal memory/register address \a mem_addr.
 *
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_mem_read(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t *data, uint16_t num_bytes) {
  40292c:	b590      	push	{r4, r7, lr}
  40292e:	b087      	sub	sp, #28
  402930:	af00      	add	r7, sp, #0
  402932:	60f8      	str	r0, [r7, #12]
  402934:	607a      	str	r2, [r7, #4]
  402936:	461a      	mov	r2, r3
  402938:	460b      	mov	r3, r1
  40293a:	817b      	strh	r3, [r7, #10]
  40293c:	4613      	mov	r3, r2
  40293e:	813b      	strh	r3, [r7, #8]
	int error = 1;		// default is error return
  402940:	2301      	movs	r3, #1
  402942:	617b      	str	r3, [r7, #20]
	uint8_t i2c_addr = ch_get_i2c_address(dev_ptr);
  402944:	68f8      	ldr	r0, [r7, #12]
  402946:	4b13      	ldr	r3, [pc, #76]	; (402994 <chbsp_i2c_mem_read+0x68>)
  402948:	4798      	blx	r3
  40294a:	4603      	mov	r3, r0
  40294c:	74fb      	strb	r3, [r7, #19]
	uint8_t bus_num  = ch_get_i2c_bus(dev_ptr);
  40294e:	68f8      	ldr	r0, [r7, #12]
  402950:	4b11      	ldr	r3, [pc, #68]	; (402998 <chbsp_i2c_mem_read+0x6c>)
  402952:	4798      	blx	r3
  402954:	4603      	mov	r3, r0
  402956:	74bb      	strb	r3, [r7, #18]

	if (bus_num == 0) {
  402958:	7cbb      	ldrb	r3, [r7, #18]
  40295a:	2b00      	cmp	r3, #0
  40295c:	d109      	bne.n	402972 <chbsp_i2c_mem_read+0x46>
		// I2C bus 0 (TWI1)
		error = i2c_master_read_register1(i2c_addr, mem_addr, num_bytes, data);
  40295e:	897b      	ldrh	r3, [r7, #10]
  402960:	b2d9      	uxtb	r1, r3
  402962:	893a      	ldrh	r2, [r7, #8]
  402964:	7cf8      	ldrb	r0, [r7, #19]
  402966:	687b      	ldr	r3, [r7, #4]
  402968:	4c0c      	ldr	r4, [pc, #48]	; (40299c <chbsp_i2c_mem_read+0x70>)
  40296a:	47a0      	blx	r4
  40296c:	4603      	mov	r3, r0
  40296e:	617b      	str	r3, [r7, #20]
  402970:	e00b      	b.n	40298a <chbsp_i2c_mem_read+0x5e>

		} else if (bus_num == 1) {
  402972:	7cbb      	ldrb	r3, [r7, #18]
  402974:	2b01      	cmp	r3, #1
  402976:	d108      	bne.n	40298a <chbsp_i2c_mem_read+0x5e>
		// I2C bus 1 (TWI3)
		error = i2c_master_read_register3(i2c_addr, mem_addr, num_bytes, data);
  402978:	897b      	ldrh	r3, [r7, #10]
  40297a:	b2d9      	uxtb	r1, r3
  40297c:	893a      	ldrh	r2, [r7, #8]
  40297e:	7cf8      	ldrb	r0, [r7, #19]
  402980:	687b      	ldr	r3, [r7, #4]
  402982:	4c07      	ldr	r4, [pc, #28]	; (4029a0 <chbsp_i2c_mem_read+0x74>)
  402984:	47a0      	blx	r4
  402986:	4603      	mov	r3, r0
  402988:	617b      	str	r3, [r7, #20]
	}
	return error;
  40298a:	697b      	ldr	r3, [r7, #20]
}
  40298c:	4618      	mov	r0, r3
  40298e:	371c      	adds	r7, #28
  402990:	46bd      	mov	sp, r7
  402992:	bd90      	pop	{r4, r7, pc}
  402994:	00405b3d 	.word	0x00405b3d
  402998:	00405b55 	.word	0x00405b55
  40299c:	00408a11 	.word	0x00408a11
  4029a0:	00408aa9 	.word	0x00408aa9

004029a4 <chbsp_i2c_read_nb>:
 * This function initiates a non-blocking read of the specified number of bytes from
 * an I2C slave.
 *
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_read_nb(ch_dev_t *dev_ptr, uint8_t *data, uint16_t num_bytes) {
  4029a4:	b580      	push	{r7, lr}
  4029a6:	b090      	sub	sp, #64	; 0x40
  4029a8:	af00      	add	r7, sp, #0
  4029aa:	60f8      	str	r0, [r7, #12]
  4029ac:	60b9      	str	r1, [r7, #8]
  4029ae:	4613      	mov	r3, r2
  4029b0:	80fb      	strh	r3, [r7, #6]
	Twi *twi_ptr;		// pointer to Atmel TWI (I2C) control struct
	Pdc *pdc_ptr;		// pointer to Atmel peripheral DMA controller struct
	pdc_packet_t pdc_packet;
	uint8_t  i2c_addr = ch_get_i2c_address(dev_ptr);
  4029b2:	68f8      	ldr	r0, [r7, #12]
  4029b4:	4b3f      	ldr	r3, [pc, #252]	; (402ab4 <chbsp_i2c_read_nb+0x110>)
  4029b6:	4798      	blx	r3
  4029b8:	4603      	mov	r3, r0
  4029ba:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	uint8_t  bus_num  = ch_get_i2c_bus(dev_ptr);
  4029be:	68f8      	ldr	r0, [r7, #12]
  4029c0:	4b3d      	ldr	r3, [pc, #244]	; (402ab8 <chbsp_i2c_read_nb+0x114>)
  4029c2:	4798      	blx	r3
  4029c4:	4603      	mov	r3, r0
  4029c6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
	int error = 0;
  4029ca:	2300      	movs	r3, #0
  4029cc:	637b      	str	r3, [r7, #52]	; 0x34

	if (bus_num == 0) {
  4029ce:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  4029d2:	2b00      	cmp	r3, #0
  4029d4:	d106      	bne.n	4029e4 <chbsp_i2c_read_nb+0x40>
		twi_ptr = BOARD_BASE_TWI1;
  4029d6:	4b39      	ldr	r3, [pc, #228]	; (402abc <chbsp_i2c_read_nb+0x118>)
  4029d8:	63fb      	str	r3, [r7, #60]	; 0x3c
		pdc_ptr = twi_get_pdc_base(BOARD_BASE_TWI1);
  4029da:	4838      	ldr	r0, [pc, #224]	; (402abc <chbsp_i2c_read_nb+0x118>)
  4029dc:	4b38      	ldr	r3, [pc, #224]	; (402ac0 <chbsp_i2c_read_nb+0x11c>)
  4029de:	4798      	blx	r3
  4029e0:	63b8      	str	r0, [r7, #56]	; 0x38
  4029e2:	e00c      	b.n	4029fe <chbsp_i2c_read_nb+0x5a>
	} else if (bus_num == 1) {
  4029e4:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  4029e8:	2b01      	cmp	r3, #1
  4029ea:	d106      	bne.n	4029fa <chbsp_i2c_read_nb+0x56>
		twi_ptr = BOARD_BASE_TWI3;
  4029ec:	4b35      	ldr	r3, [pc, #212]	; (402ac4 <chbsp_i2c_read_nb+0x120>)
  4029ee:	63fb      	str	r3, [r7, #60]	; 0x3c
		pdc_ptr = twi_get_pdc_base(BOARD_BASE_TWI3);
  4029f0:	4834      	ldr	r0, [pc, #208]	; (402ac4 <chbsp_i2c_read_nb+0x120>)
  4029f2:	4b33      	ldr	r3, [pc, #204]	; (402ac0 <chbsp_i2c_read_nb+0x11c>)
  4029f4:	4798      	blx	r3
  4029f6:	63b8      	str	r0, [r7, #56]	; 0x38
  4029f8:	e001      	b.n	4029fe <chbsp_i2c_read_nb+0x5a>
	} else {
		error = 1;
  4029fa:	2301      	movs	r3, #1
  4029fc:	637b      	str	r3, [r7, #52]	; 0x34
	}

	/* Save buffer pointer and transfer length - it will be needed when reading final 2 bytes
	 * in DMA interrupt handler
	 */
	if ((!error) && (data != NULL)) {
  4029fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402a00:	2b00      	cmp	r3, #0
  402a02:	d110      	bne.n	402a26 <chbsp_i2c_read_nb+0x82>
  402a04:	68bb      	ldr	r3, [r7, #8]
  402a06:	2b00      	cmp	r3, #0
  402a08:	d00d      	beq.n	402a26 <chbsp_i2c_read_nb+0x82>
		i2c_nb_transactions[bus_num].buf_ptr = data;
  402a0a:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402a0e:	492e      	ldr	r1, [pc, #184]	; (402ac8 <chbsp_i2c_read_nb+0x124>)
  402a10:	68ba      	ldr	r2, [r7, #8]
  402a12:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
		i2c_nb_transactions[bus_num].num_bytes = num_bytes;
  402a16:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402a1a:	4a2b      	ldr	r2, [pc, #172]	; (402ac8 <chbsp_i2c_read_nb+0x124>)
  402a1c:	00db      	lsls	r3, r3, #3
  402a1e:	4413      	add	r3, r2
  402a20:	88fa      	ldrh	r2, [r7, #6]
  402a22:	809a      	strh	r2, [r3, #4]
  402a24:	e001      	b.n	402a2a <chbsp_i2c_read_nb+0x86>
	} else {
		error = 1;
  402a26:	2301      	movs	r3, #1
  402a28:	637b      	str	r3, [r7, #52]	; 0x34
	}

	if (!error) {
  402a2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402a2c:	2b00      	cmp	r3, #0
  402a2e:	d13c      	bne.n	402aaa <chbsp_i2c_read_nb+0x106>
		/* Construct transfer packet */
	 	twi_packet_t twi_packet;

	 	twi_packet.chip = i2c_addr;		 	//address of I2C device to be accessed
  402a30:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
  402a34:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
		twi_packet.addr[0] = 0;
  402a38:	2300      	movs	r3, #0
  402a3a:	753b      	strb	r3, [r7, #20]
		twi_packet.addr_length = 0;			// no internal mem/reg address
  402a3c:	2300      	movs	r3, #0
  402a3e:	61bb      	str	r3, [r7, #24]
	 	twi_packet.buffer = data;
  402a40:	68bb      	ldr	r3, [r7, #8]
  402a42:	61fb      	str	r3, [r7, #28]
	 	twi_packet.length = num_bytes;
  402a44:	88fb      	ldrh	r3, [r7, #6]
  402a46:	623b      	str	r3, [r7, #32]

		pdc_disable_transfer(pdc_ptr, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  402a48:	f240 2102 	movw	r1, #514	; 0x202
  402a4c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402a4e:	4b1f      	ldr	r3, [pc, #124]	; (402acc <chbsp_i2c_read_nb+0x128>)
  402a50:	4798      	blx	r3

		pdc_packet.ul_addr = (uint32_t) data;
  402a52:	68bb      	ldr	r3, [r7, #8]
  402a54:	62bb      	str	r3, [r7, #40]	; 0x28
    	pdc_packet.ul_size = (num_bytes - 2);
  402a56:	88fb      	ldrh	r3, [r7, #6]
  402a58:	3b02      	subs	r3, #2
  402a5a:	62fb      	str	r3, [r7, #44]	; 0x2c

		pdc_rx_init(pdc_ptr, &pdc_packet, NULL);
  402a5c:	f107 0328 	add.w	r3, r7, #40	; 0x28
  402a60:	2200      	movs	r2, #0
  402a62:	4619      	mov	r1, r3
  402a64:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402a66:	4b1a      	ldr	r3, [pc, #104]	; (402ad0 <chbsp_i2c_read_nb+0x12c>)
  402a68:	4798      	blx	r3

		/* Set read mode, slave address, and internal address length */
		twi_ptr->TWI_MMR = 0;
  402a6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402a6c:	2200      	movs	r2, #0
  402a6e:	605a      	str	r2, [r3, #4]
		twi_ptr->TWI_MMR = TWI_MMR_MREAD |
						   TWI_MMR_DADR(twi_packet.chip) |
  402a70:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
  402a74:	041b      	lsls	r3, r3, #16
  402a76:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
						   ((twi_packet.addr_length << TWI_MMR_IADRSZ_Pos) & TWI_MMR_IADRSZ_Msk);
  402a7a:	69bb      	ldr	r3, [r7, #24]
  402a7c:	021b      	lsls	r3, r3, #8
  402a7e:	f403 7340 	and.w	r3, r3, #768	; 0x300
						   TWI_MMR_DADR(twi_packet.chip) |
  402a82:	4313      	orrs	r3, r2
  402a84:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
		twi_ptr->TWI_MMR = TWI_MMR_MREAD |
  402a88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402a8a:	605a      	str	r2, [r3, #4]

		/* No internal memory (register) address within remote device */
		twi_ptr->TWI_IADR = 0;
  402a8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402a8e:	2200      	movs	r2, #0
  402a90:	60da      	str	r2, [r3, #12]

		/* Enable the RX PDC transfer requests */
		pdc_enable_transfer(pdc_ptr, PERIPH_PTCR_RXTEN);
  402a92:	2101      	movs	r1, #1
  402a94:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402a96:	4b0f      	ldr	r3, [pc, #60]	; (402ad4 <chbsp_i2c_read_nb+0x130>)
  402a98:	4798      	blx	r3

		/* Start the transfer */
		twi_ptr->TWI_CR = TWI_CR_START;
  402a9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402a9c:	2201      	movs	r2, #1
  402a9e:	601a      	str	r2, [r3, #0]

		/* Enable end-of-receive interrupt */
		twi_enable_interrupt(twi_ptr, TWI_IER_ENDRX);
  402aa0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  402aa4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
  402aa6:	4b0c      	ldr	r3, [pc, #48]	; (402ad8 <chbsp_i2c_read_nb+0x134>)
  402aa8:	4798      	blx	r3

	}
	return error;
  402aaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  402aac:	4618      	mov	r0, r3
  402aae:	3740      	adds	r7, #64	; 0x40
  402ab0:	46bd      	mov	sp, r7
  402ab2:	bd80      	pop	{r7, pc}
  402ab4:	00405b3d 	.word	0x00405b3d
  402ab8:	00405b55 	.word	0x00405b55
  402abc:	40020600 	.word	0x40020600
  402ac0:	00404fa5 	.word	0x00404fa5
  402ac4:	40018600 	.word	0x40018600
  402ac8:	200028cc 	.word	0x200028cc
  402acc:	00403b11 	.word	0x00403b11
  402ad0:	00403aab 	.word	0x00403aab
  402ad4:	00403aef 	.word	0x00403aef
  402ad8:	00404f19 	.word	0x00404f19

00402adc <chbsp_i2c_mem_read_nb>:
 *
 * This function initiates a non-blocking read of the specified number of bytes from an I2C slave.
 *
 * The I2C interface must have already been initialized using \a chbsp_i2c_init().
 */
int chbsp_i2c_mem_read_nb(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t *data, uint16_t num_bytes) {
  402adc:	b580      	push	{r7, lr}
  402ade:	b090      	sub	sp, #64	; 0x40
  402ae0:	af00      	add	r7, sp, #0
  402ae2:	60f8      	str	r0, [r7, #12]
  402ae4:	607a      	str	r2, [r7, #4]
  402ae6:	461a      	mov	r2, r3
  402ae8:	460b      	mov	r3, r1
  402aea:	817b      	strh	r3, [r7, #10]
  402aec:	4613      	mov	r3, r2
  402aee:	813b      	strh	r3, [r7, #8]
	Twi *twi_ptr;		// pointer to Atmel TWI (I2C) control struct
	Pdc *pdc_ptr;		// pointer to Atmel peripheral DMA controller struct
	pdc_packet_t pdc_packet;
	uint8_t  i2c_addr = ch_get_i2c_address(dev_ptr);
  402af0:	68f8      	ldr	r0, [r7, #12]
  402af2:	4b46      	ldr	r3, [pc, #280]	; (402c0c <chbsp_i2c_mem_read_nb+0x130>)
  402af4:	4798      	blx	r3
  402af6:	4603      	mov	r3, r0
  402af8:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	uint8_t  bus_num  = ch_get_i2c_bus(dev_ptr);
  402afc:	68f8      	ldr	r0, [r7, #12]
  402afe:	4b44      	ldr	r3, [pc, #272]	; (402c10 <chbsp_i2c_mem_read_nb+0x134>)
  402b00:	4798      	blx	r3
  402b02:	4603      	mov	r3, r0
  402b04:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
	int error=0;;
  402b08:	2300      	movs	r3, #0
  402b0a:	637b      	str	r3, [r7, #52]	; 0x34

	if (bus_num == 0) {
  402b0c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402b10:	2b00      	cmp	r3, #0
  402b12:	d106      	bne.n	402b22 <chbsp_i2c_mem_read_nb+0x46>
		twi_ptr = BOARD_BASE_TWI1;
  402b14:	4b3f      	ldr	r3, [pc, #252]	; (402c14 <chbsp_i2c_mem_read_nb+0x138>)
  402b16:	63fb      	str	r3, [r7, #60]	; 0x3c
		pdc_ptr = twi_get_pdc_base(BOARD_BASE_TWI1);
  402b18:	483e      	ldr	r0, [pc, #248]	; (402c14 <chbsp_i2c_mem_read_nb+0x138>)
  402b1a:	4b3f      	ldr	r3, [pc, #252]	; (402c18 <chbsp_i2c_mem_read_nb+0x13c>)
  402b1c:	4798      	blx	r3
  402b1e:	63b8      	str	r0, [r7, #56]	; 0x38
  402b20:	e00c      	b.n	402b3c <chbsp_i2c_mem_read_nb+0x60>
	} else if (bus_num == 1) {
  402b22:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402b26:	2b01      	cmp	r3, #1
  402b28:	d106      	bne.n	402b38 <chbsp_i2c_mem_read_nb+0x5c>
		twi_ptr = BOARD_BASE_TWI3;
  402b2a:	4b3c      	ldr	r3, [pc, #240]	; (402c1c <chbsp_i2c_mem_read_nb+0x140>)
  402b2c:	63fb      	str	r3, [r7, #60]	; 0x3c
		pdc_ptr = twi_get_pdc_base(BOARD_BASE_TWI3);
  402b2e:	483b      	ldr	r0, [pc, #236]	; (402c1c <chbsp_i2c_mem_read_nb+0x140>)
  402b30:	4b39      	ldr	r3, [pc, #228]	; (402c18 <chbsp_i2c_mem_read_nb+0x13c>)
  402b32:	4798      	blx	r3
  402b34:	63b8      	str	r0, [r7, #56]	; 0x38
  402b36:	e001      	b.n	402b3c <chbsp_i2c_mem_read_nb+0x60>
	} else {
		error = 1;
  402b38:	2301      	movs	r3, #1
  402b3a:	637b      	str	r3, [r7, #52]	; 0x34
	}

	/* Save buffer pointer and transfer length - it will be needed when reading final 2 bytes
	 * in DMA interrupt handler
	 */
	if ((!error) && (data != NULL)) {
  402b3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402b3e:	2b00      	cmp	r3, #0
  402b40:	d110      	bne.n	402b64 <chbsp_i2c_mem_read_nb+0x88>
  402b42:	687b      	ldr	r3, [r7, #4]
  402b44:	2b00      	cmp	r3, #0
  402b46:	d00d      	beq.n	402b64 <chbsp_i2c_mem_read_nb+0x88>
		i2c_nb_transactions[bus_num].buf_ptr = data;
  402b48:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402b4c:	4934      	ldr	r1, [pc, #208]	; (402c20 <chbsp_i2c_mem_read_nb+0x144>)
  402b4e:	687a      	ldr	r2, [r7, #4]
  402b50:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
		i2c_nb_transactions[bus_num].num_bytes = num_bytes;
  402b54:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
  402b58:	4a31      	ldr	r2, [pc, #196]	; (402c20 <chbsp_i2c_mem_read_nb+0x144>)
  402b5a:	00db      	lsls	r3, r3, #3
  402b5c:	4413      	add	r3, r2
  402b5e:	893a      	ldrh	r2, [r7, #8]
  402b60:	809a      	strh	r2, [r3, #4]
  402b62:	e001      	b.n	402b68 <chbsp_i2c_mem_read_nb+0x8c>
	} else {
		error = 1;
  402b64:	2301      	movs	r3, #1
  402b66:	637b      	str	r3, [r7, #52]	; 0x34
	}

	if (!error) {
  402b68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  402b6a:	2b00      	cmp	r3, #0
  402b6c:	d148      	bne.n	402c00 <chbsp_i2c_mem_read_nb+0x124>
		/* Construct transfer packet */
	 	twi_packet_t twi_packet;

	 	twi_packet.chip = i2c_addr; 			// address of I2C device to be accessed
  402b6e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
  402b72:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
		twi_packet.addr[0] = mem_addr;			// internal mem address
  402b76:	897b      	ldrh	r3, [r7, #10]
  402b78:	b2db      	uxtb	r3, r3
  402b7a:	753b      	strb	r3, [r7, #20]
		twi_packet.addr_length = 1;				// mem address is single byte
  402b7c:	2301      	movs	r3, #1
  402b7e:	61bb      	str	r3, [r7, #24]
	 	twi_packet.buffer = data;
  402b80:	687b      	ldr	r3, [r7, #4]
  402b82:	61fb      	str	r3, [r7, #28]
	 	twi_packet.length = num_bytes;
  402b84:	893b      	ldrh	r3, [r7, #8]
  402b86:	623b      	str	r3, [r7, #32]

		pdc_disable_transfer(pdc_ptr, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  402b88:	f240 2102 	movw	r1, #514	; 0x202
  402b8c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402b8e:	4b25      	ldr	r3, [pc, #148]	; (402c24 <chbsp_i2c_mem_read_nb+0x148>)
  402b90:	4798      	blx	r3

		pdc_packet.ul_addr = (uint32_t) data;
  402b92:	687b      	ldr	r3, [r7, #4]
  402b94:	62bb      	str	r3, [r7, #40]	; 0x28
		pdc_packet.ul_size = (num_bytes - 2);
  402b96:	893b      	ldrh	r3, [r7, #8]
  402b98:	3b02      	subs	r3, #2
  402b9a:	62fb      	str	r3, [r7, #44]	; 0x2c

		pdc_rx_init(pdc_ptr, &pdc_packet, NULL);
  402b9c:	f107 0328 	add.w	r3, r7, #40	; 0x28
  402ba0:	2200      	movs	r2, #0
  402ba2:	4619      	mov	r1, r3
  402ba4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402ba6:	4b20      	ldr	r3, [pc, #128]	; (402c28 <chbsp_i2c_mem_read_nb+0x14c>)
  402ba8:	4798      	blx	r3

		/* Set read mode, slave address, and internal address length */
		twi_ptr->TWI_MMR = 0;
  402baa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402bac:	2200      	movs	r2, #0
  402bae:	605a      	str	r2, [r3, #4]
		twi_ptr->TWI_MMR = TWI_MMR_MREAD |
						   TWI_MMR_DADR(twi_packet.chip) |
  402bb0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
  402bb4:	041b      	lsls	r3, r3, #16
  402bb6:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
						   ((twi_packet.addr_length << TWI_MMR_IADRSZ_Pos) & TWI_MMR_IADRSZ_Msk);
  402bba:	69bb      	ldr	r3, [r7, #24]
  402bbc:	021b      	lsls	r3, r3, #8
  402bbe:	f403 7340 	and.w	r3, r3, #768	; 0x300
						   TWI_MMR_DADR(twi_packet.chip) |
  402bc2:	4313      	orrs	r3, r2
  402bc4:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
		twi_ptr->TWI_MMR = TWI_MMR_MREAD |
  402bc8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402bca:	605a      	str	r2, [r3, #4]

		/* Set internal memory (register) address within remote device */
		twi_ptr->TWI_IADR = 0;
  402bcc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402bce:	2200      	movs	r2, #0
  402bd0:	60da      	str	r2, [r3, #12]
		twi_ptr->TWI_IADR = twi_mk_addr(twi_packet.addr, twi_packet.addr_length);
  402bd2:	69bb      	ldr	r3, [r7, #24]
  402bd4:	461a      	mov	r2, r3
  402bd6:	f107 0314 	add.w	r3, r7, #20
  402bda:	4611      	mov	r1, r2
  402bdc:	4618      	mov	r0, r3
  402bde:	4b13      	ldr	r3, [pc, #76]	; (402c2c <chbsp_i2c_mem_read_nb+0x150>)
  402be0:	4798      	blx	r3
  402be2:	4602      	mov	r2, r0
  402be4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402be6:	60da      	str	r2, [r3, #12]

		/* Enable the RX PDC transfer requests */
		pdc_enable_transfer(pdc_ptr, PERIPH_PTCR_RXTEN);
  402be8:	2101      	movs	r1, #1
  402bea:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  402bec:	4b10      	ldr	r3, [pc, #64]	; (402c30 <chbsp_i2c_mem_read_nb+0x154>)
  402bee:	4798      	blx	r3

		/* Start the transfer */
		twi_ptr->TWI_CR = TWI_CR_START;
  402bf0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  402bf2:	2201      	movs	r2, #1
  402bf4:	601a      	str	r2, [r3, #0]

		/* Enable end-of-receive interrupt */
		twi_enable_interrupt(twi_ptr, TWI_IER_ENDRX);
  402bf6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  402bfa:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
  402bfc:	4b0d      	ldr	r3, [pc, #52]	; (402c34 <chbsp_i2c_mem_read_nb+0x158>)
  402bfe:	4798      	blx	r3

	}
	return error;
  402c00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  402c02:	4618      	mov	r0, r3
  402c04:	3740      	adds	r7, #64	; 0x40
  402c06:	46bd      	mov	sp, r7
  402c08:	bd80      	pop	{r7, pc}
  402c0a:	bf00      	nop
  402c0c:	00405b3d 	.word	0x00405b3d
  402c10:	00405b55 	.word	0x00405b55
  402c14:	40020600 	.word	0x40020600
  402c18:	00404fa5 	.word	0x00404fa5
  402c1c:	40018600 	.word	0x40018600
  402c20:	200028cc 	.word	0x200028cc
  402c24:	00403b11 	.word	0x00403b11
  402c28:	00403aab 	.word	0x00403aab
  402c2c:	00404cd5 	.word	0x00404cd5
  402c30:	00403aef 	.word	0x00403aef
  402c34:	00404f19 	.word	0x00404f19

00402c38 <chbsp_i2c_reset>:
 *
 * \param dev_ptr 		pointer to the ch_dev_t config structure for a sensor
 *
 * This function performs a reset of the I2C interface for the specified device.
 */
void chbsp_i2c_reset(ch_dev_t * dev_ptr) {
  402c38:	b580      	push	{r7, lr}
  402c3a:	b084      	sub	sp, #16
  402c3c:	af00      	add	r7, sp, #0
  402c3e:	6078      	str	r0, [r7, #4]
	uint8_t  bus_num  = ch_get_i2c_bus(dev_ptr);
  402c40:	6878      	ldr	r0, [r7, #4]
  402c42:	4b09      	ldr	r3, [pc, #36]	; (402c68 <chbsp_i2c_reset+0x30>)
  402c44:	4798      	blx	r3
  402c46:	4603      	mov	r3, r0
  402c48:	73fb      	strb	r3, [r7, #15]

	if (bus_num == 0) {					 // I2C bus 0 (TWI1)
  402c4a:	7bfb      	ldrb	r3, [r7, #15]
  402c4c:	2b00      	cmp	r3, #0
  402c4e:	d102      	bne.n	402c56 <chbsp_i2c_reset+0x1e>
		i2c_master_initialize1();
  402c50:	4b06      	ldr	r3, [pc, #24]	; (402c6c <chbsp_i2c_reset+0x34>)
  402c52:	4798      	blx	r3
	} else if (bus_num == 1) {			 // I2C bus 1 (TWI3)
		i2c_master_initialize3();
	}
}
  402c54:	e004      	b.n	402c60 <chbsp_i2c_reset+0x28>
	} else if (bus_num == 1) {			 // I2C bus 1 (TWI3)
  402c56:	7bfb      	ldrb	r3, [r7, #15]
  402c58:	2b01      	cmp	r3, #1
  402c5a:	d101      	bne.n	402c60 <chbsp_i2c_reset+0x28>
		i2c_master_initialize3();
  402c5c:	4b04      	ldr	r3, [pc, #16]	; (402c70 <chbsp_i2c_reset+0x38>)
  402c5e:	4798      	blx	r3
}
  402c60:	bf00      	nop
  402c62:	3710      	adds	r7, #16
  402c64:	46bd      	mov	sp, r7
  402c66:	bd80      	pop	{r7, pc}
  402c68:	00405b55 	.word	0x00405b55
  402c6c:	004088d1 	.word	0x004088d1
  402c70:	00408949 	.word	0x00408949

00402c74 <chbsp_periodic_timer_init>:
 *
 * The \a callback_func_ptr parameter specifies a callback routine that will be called when the
 * timer expires (and interrupt occurs).  The \a chbsp_periodic_timer_handler function
 * will call this function.
 */
uint8_t chbsp_periodic_timer_init(uint16_t interval_ms, ch_timer_callback_t callback_func_ptr) {
  402c74:	b580      	push	{r7, lr}
  402c76:	b082      	sub	sp, #8
  402c78:	af00      	add	r7, sp, #0
  402c7a:	4603      	mov	r3, r0
  402c7c:	6039      	str	r1, [r7, #0]
  402c7e:	80fb      	strh	r3, [r7, #6]
	static bool is_hw_init_done = false;

	/* Save timer interval and callback function */
	periodic_timer_interval_ms = interval_ms;
  402c80:	4a32      	ldr	r2, [pc, #200]	; (402d4c <chbsp_periodic_timer_init+0xd8>)
  402c82:	88fb      	ldrh	r3, [r7, #6]
  402c84:	8013      	strh	r3, [r2, #0]
	periodic_timer_callback_ptr = callback_func_ptr;
  402c86:	4a32      	ldr	r2, [pc, #200]	; (402d50 <chbsp_periodic_timer_init+0xdc>)
  402c88:	683b      	ldr	r3, [r7, #0]
  402c8a:	6013      	str	r3, [r2, #0]

	/* Initialize the HW only 1 time at startup. Skip the init on subsequent calls. */
	if (!is_hw_init_done) {
  402c8c:	4b31      	ldr	r3, [pc, #196]	; (402d54 <chbsp_periodic_timer_init+0xe0>)
  402c8e:	781b      	ldrb	r3, [r3, #0]
  402c90:	f083 0301 	eor.w	r3, r3, #1
  402c94:	b2db      	uxtb	r3, r3
  402c96:	2b00      	cmp	r3, #0
  402c98:	d043      	beq.n	402d22 <chbsp_periodic_timer_init+0xae>
		/* Configure the PMC to enable the TC module and channels */
		sysclk_enable_peripheral_clock(ID_TC0);
  402c9a:	2017      	movs	r0, #23
  402c9c:	4b2e      	ldr	r3, [pc, #184]	; (402d58 <chbsp_periodic_timer_init+0xe4>)
  402c9e:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_TC1);
  402ca0:	2018      	movs	r0, #24
  402ca2:	4b2d      	ldr	r3, [pc, #180]	; (402d58 <chbsp_periodic_timer_init+0xe4>)
  402ca4:	4798      	blx	r3
		/* Create on PCK3 a 499985 Hz clock from the PLLA clock. */
		pmc_disable_pck(PMC_PCK_3);
  402ca6:	2003      	movs	r0, #3
  402ca8:	4b2c      	ldr	r3, [pc, #176]	; (402d5c <chbsp_periodic_timer_init+0xe8>)
  402caa:	4798      	blx	r3
		pmc_switch_pck_to_pllack(PMC_PCK_3, PMC_PCK_PRES(240 - 1));
  402cac:	f44f 616f 	mov.w	r1, #3824	; 0xef0
  402cb0:	2003      	movs	r0, #3
  402cb2:	4b2b      	ldr	r3, [pc, #172]	; (402d60 <chbsp_periodic_timer_init+0xec>)
  402cb4:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_3);
  402cb6:	2003      	movs	r0, #3
  402cb8:	4b2a      	ldr	r3, [pc, #168]	; (402d64 <chbsp_periodic_timer_init+0xf0>)
  402cba:	4798      	blx	r3

		/* Reset all TC0 counters */
		TC0->TC_BCR = TC_BCR_SYNC;
  402cbc:	4b2a      	ldr	r3, [pc, #168]	; (402d68 <chbsp_periodic_timer_init+0xf4>)
  402cbe:	2201      	movs	r2, #1
  402cc0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

		/* Enable TC0 - Channel 0 interrupt */
		NVIC_DisableIRQ(TC0_IRQn);
  402cc4:	2017      	movs	r0, #23
  402cc6:	4b29      	ldr	r3, [pc, #164]	; (402d6c <chbsp_periodic_timer_init+0xf8>)
  402cc8:	4798      	blx	r3
		NVIC_ClearPendingIRQ(TC0_IRQn);
  402cca:	2017      	movs	r0, #23
  402ccc:	4b28      	ldr	r3, [pc, #160]	; (402d70 <chbsp_periodic_timer_init+0xfc>)
  402cce:	4798      	blx	r3
		NVIC_SetPriority(TC0_IRQn, 1);
  402cd0:	2101      	movs	r1, #1
  402cd2:	2017      	movs	r0, #23
  402cd4:	4b27      	ldr	r3, [pc, #156]	; (402d74 <chbsp_periodic_timer_init+0x100>)
  402cd6:	4798      	blx	r3
		NVIC_EnableIRQ(TC0_IRQn);
  402cd8:	2017      	movs	r0, #23
  402cda:	4b27      	ldr	r3, [pc, #156]	; (402d78 <chbsp_periodic_timer_init+0x104>)
  402cdc:	4798      	blx	r3

		/* Enable TC0 - Channel 1 interrupt */
		NVIC_DisableIRQ(TC1_IRQn);
  402cde:	2018      	movs	r0, #24
  402ce0:	4b22      	ldr	r3, [pc, #136]	; (402d6c <chbsp_periodic_timer_init+0xf8>)
  402ce2:	4798      	blx	r3
		NVIC_ClearPendingIRQ(TC1_IRQn);
  402ce4:	2018      	movs	r0, #24
  402ce6:	4b22      	ldr	r3, [pc, #136]	; (402d70 <chbsp_periodic_timer_init+0xfc>)
  402ce8:	4798      	blx	r3
		NVIC_SetPriority(TC1_IRQn, 1);
  402cea:	2101      	movs	r1, #1
  402cec:	2018      	movs	r0, #24
  402cee:	4b21      	ldr	r3, [pc, #132]	; (402d74 <chbsp_periodic_timer_init+0x100>)
  402cf0:	4798      	blx	r3
		NVIC_EnableIRQ(TC1_IRQn);
  402cf2:	2018      	movs	r0, #24
  402cf4:	4b20      	ldr	r3, [pc, #128]	; (402d78 <chbsp_periodic_timer_init+0x104>)
  402cf6:	4798      	blx	r3

		/* Create the lsepoch timer running on PCK3 and start it immediately */
		tc_init(TC0, TC_CHANNEL_LSEPOCH,
  402cf8:	f248 0204 	movw	r2, #32772	; 0x8004
  402cfc:	2100      	movs	r1, #0
  402cfe:	481a      	ldr	r0, [pc, #104]	; (402d68 <chbsp_periodic_timer_init+0xf4>)
  402d00:	4b1e      	ldr	r3, [pc, #120]	; (402d7c <chbsp_periodic_timer_init+0x108>)
  402d02:	4798      	blx	r3
			TC_CMR_TCCLKS_TIMER_CLOCK5 | TC_CMR_WAVE | TC_CMR_WAVSEL_UP);
		tc_enable_interrupt(TC0, TC_CHANNEL_LSEPOCH, TC_IER_COVFS);
  402d04:	2201      	movs	r2, #1
  402d06:	2100      	movs	r1, #0
  402d08:	4817      	ldr	r0, [pc, #92]	; (402d68 <chbsp_periodic_timer_init+0xf4>)
  402d0a:	4b1d      	ldr	r3, [pc, #116]	; (402d80 <chbsp_periodic_timer_init+0x10c>)
  402d0c:	4798      	blx	r3
		tc_start(TC0, TC_CHANNEL_LSEPOCH);
  402d0e:	2100      	movs	r1, #0
  402d10:	4815      	ldr	r0, [pc, #84]	; (402d68 <chbsp_periodic_timer_init+0xf4>)
  402d12:	4b1c      	ldr	r3, [pc, #112]	; (402d84 <chbsp_periodic_timer_init+0x110>)
  402d14:	4798      	blx	r3

		/* Create the ultrasound periodic timer. */
		tc_init(TC0, TC_CHANNEL_US,
  402d16:	f248 0204 	movw	r2, #32772	; 0x8004
  402d1a:	2101      	movs	r1, #1
  402d1c:	4812      	ldr	r0, [pc, #72]	; (402d68 <chbsp_periodic_timer_init+0xf4>)
  402d1e:	4b17      	ldr	r3, [pc, #92]	; (402d7c <chbsp_periodic_timer_init+0x108>)
  402d20:	4798      	blx	r3
			TC_CMR_TCCLKS_TIMER_CLOCK5 | TC_CMR_WAVE | TC_CMR_WAVSEL_UP);
	}

	/* Mark the HW init as done */
	is_hw_init_done = true;
  402d22:	4b0c      	ldr	r3, [pc, #48]	; (402d54 <chbsp_periodic_timer_init+0xe0>)
  402d24:	2201      	movs	r2, #1
  402d26:	701a      	strb	r2, [r3, #0]

	/* Convert the ODR in ms to ticks */
	ultrasound_timer_period_in_tick = get_period_in_tick(interval_ms * 1000);
  402d28:	88fb      	ldrh	r3, [r7, #6]
  402d2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402d2e:	fb02 f303 	mul.w	r3, r2, r3
  402d32:	4618      	mov	r0, r3
  402d34:	4b14      	ldr	r3, [pc, #80]	; (402d88 <chbsp_periodic_timer_init+0x114>)
  402d36:	4798      	blx	r3
  402d38:	4603      	mov	r3, r0
  402d3a:	b29a      	uxth	r2, r3
  402d3c:	4b13      	ldr	r3, [pc, #76]	; (402d8c <chbsp_periodic_timer_init+0x118>)
  402d3e:	801a      	strh	r2, [r3, #0]

	return 0;
  402d40:	2300      	movs	r3, #0
}
  402d42:	4618      	mov	r0, r3
  402d44:	3708      	adds	r7, #8
  402d46:	46bd      	mov	sp, r7
  402d48:	bd80      	pop	{r7, pc}
  402d4a:	bf00      	nop
  402d4c:	20000380 	.word	0x20000380
  402d50:	2000037c 	.word	0x2000037c
  402d54:	200003a0 	.word	0x200003a0
  402d58:	00401781 	.word	0x00401781
  402d5c:	004045b5 	.word	0x004045b5
  402d60:	004044dd 	.word	0x004044dd
  402d64:	0040458d 	.word	0x0040458d
  402d68:	40010000 	.word	0x40010000
  402d6c:	00401621 	.word	0x00401621
  402d70:	00401655 	.word	0x00401655
  402d74:	00401689 	.word	0x00401689
  402d78:	004015ed 	.word	0x004015ed
  402d7c:	00404a65 	.word	0x00404a65
  402d80:	00404ae7 	.word	0x00404ae7
  402d84:	00404a9f 	.word	0x00404a9f
  402d88:	00402d91 	.word	0x00402d91
  402d8c:	20000160 	.word	0x20000160

00402d90 <get_period_in_tick>:
    ultrasound_prev_period_end_in_tick = prev_expiration;

    program_next_period();
}

uint32_t get_period_in_tick(uint32_t interval_us) {
  402d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d94:	b087      	sub	sp, #28
  402d96:	af00      	add	r7, sp, #0
  402d98:	60f8      	str	r0, [r7, #12]
	uint64_t timer_period_in_tick = (uint64_t) ULTRASOUND_TIMER_FREQUENCY * interval_us / 1000000;
  402d9a:	68fa      	ldr	r2, [r7, #12]
  402d9c:	4615      	mov	r5, r2
  402d9e:	f04f 0600 	mov.w	r6, #0
  402da2:	4629      	mov	r1, r5
  402da4:	4632      	mov	r2, r6
  402da6:	0150      	lsls	r0, r2, #5
  402da8:	6078      	str	r0, [r7, #4]
  402daa:	6878      	ldr	r0, [r7, #4]
  402dac:	ea40 60d1 	orr.w	r0, r0, r1, lsr #27
  402db0:	6078      	str	r0, [r7, #4]
  402db2:	014a      	lsls	r2, r1, #5
  402db4:	603a      	str	r2, [r7, #0]
  402db6:	e9d7 1200 	ldrd	r1, r2, [r7]
  402dba:	1b49      	subs	r1, r1, r5
  402dbc:	eb62 0206 	sbc.w	r2, r2, r6
  402dc0:	0194      	lsls	r4, r2, #6
  402dc2:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
  402dc6:	018b      	lsls	r3, r1, #6
  402dc8:	1a5b      	subs	r3, r3, r1
  402dca:	eb64 0402 	sbc.w	r4, r4, r2
  402dce:	ea4f 1b04 	mov.w	fp, r4, lsl #4
  402dd2:	ea4b 7b13 	orr.w	fp, fp, r3, lsr #28
  402dd6:	ea4f 1a03 	mov.w	sl, r3, lsl #4
  402dda:	4653      	mov	r3, sl
  402ddc:	465c      	mov	r4, fp
  402dde:	195b      	adds	r3, r3, r5
  402de0:	eb44 0406 	adc.w	r4, r4, r6
  402de4:	ea4f 1904 	mov.w	r9, r4, lsl #4
  402de8:	ea49 7913 	orr.w	r9, r9, r3, lsr #28
  402dec:	ea4f 1803 	mov.w	r8, r3, lsl #4
  402df0:	4643      	mov	r3, r8
  402df2:	464c      	mov	r4, r9
  402df4:	1958      	adds	r0, r3, r5
  402df6:	eb44 0106 	adc.w	r1, r4, r6
  402dfa:	4c1c      	ldr	r4, [pc, #112]	; (402e6c <get_period_in_tick+0xdc>)
  402dfc:	4a1c      	ldr	r2, [pc, #112]	; (402e70 <get_period_in_tick+0xe0>)
  402dfe:	f04f 0300 	mov.w	r3, #0
  402e02:	47a0      	blx	r4
  402e04:	4603      	mov	r3, r0
  402e06:	460c      	mov	r4, r1
  402e08:	e9c7 3404 	strd	r3, r4, [r7, #16]

	/* If the ODR is too slow to be handled then program a faster interrupt and decimate it */
	if (timer_period_in_tick > UINT16_MAX)
  402e0c:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
  402e10:	f64f 71ff 	movw	r1, #65535	; 0xffff
  402e14:	f04f 0200 	mov.w	r2, #0
  402e18:	42a2      	cmp	r2, r4
  402e1a:	bf08      	it	eq
  402e1c:	4299      	cmpeq	r1, r3
  402e1e:	d20f      	bcs.n	402e40 <get_period_in_tick+0xb0>
		decimation_factor = timer_period_in_tick / UINT16_MAX + 1;
  402e20:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
  402e24:	4c11      	ldr	r4, [pc, #68]	; (402e6c <get_period_in_tick+0xdc>)
  402e26:	f64f 72ff 	movw	r2, #65535	; 0xffff
  402e2a:	f04f 0300 	mov.w	r3, #0
  402e2e:	47a0      	blx	r4
  402e30:	4603      	mov	r3, r0
  402e32:	460c      	mov	r4, r1
  402e34:	b2db      	uxtb	r3, r3
  402e36:	3301      	adds	r3, #1
  402e38:	b2da      	uxtb	r2, r3
  402e3a:	4b0e      	ldr	r3, [pc, #56]	; (402e74 <get_period_in_tick+0xe4>)
  402e3c:	701a      	strb	r2, [r3, #0]
  402e3e:	e002      	b.n	402e46 <get_period_in_tick+0xb6>
	else
		decimation_factor = 1;
  402e40:	4b0c      	ldr	r3, [pc, #48]	; (402e74 <get_period_in_tick+0xe4>)
  402e42:	2201      	movs	r2, #1
  402e44:	701a      	strb	r2, [r3, #0]

	/* Calculate the final tick in case a decimation is needed */
	return (uint32_t) (timer_period_in_tick / decimation_factor);
  402e46:	4b0b      	ldr	r3, [pc, #44]	; (402e74 <get_period_in_tick+0xe4>)
  402e48:	781b      	ldrb	r3, [r3, #0]
  402e4a:	b2db      	uxtb	r3, r3
  402e4c:	f04f 0400 	mov.w	r4, #0
  402e50:	4d06      	ldr	r5, [pc, #24]	; (402e6c <get_period_in_tick+0xdc>)
  402e52:	461a      	mov	r2, r3
  402e54:	4623      	mov	r3, r4
  402e56:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
  402e5a:	47a8      	blx	r5
  402e5c:	4603      	mov	r3, r0
  402e5e:	460c      	mov	r4, r1
}
  402e60:	4618      	mov	r0, r3
  402e62:	371c      	adds	r7, #28
  402e64:	46bd      	mov	sp, r7
  402e66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402e6a:	bf00      	nop
  402e6c:	0040cbad 	.word	0x0040cbad
  402e70:	000f4240 	.word	0x000f4240
  402e74:	20000385 	.word	0x20000385

00402e78 <program_next_period>:

void program_next_period(void)
{
  402e78:	b580      	push	{r7, lr}
  402e7a:	b082      	sub	sp, #8
  402e7c:	af00      	add	r7, sp, #0
	uint32_t time = ultrasound_prev_period_end_in_tick + ultrasound_timer_period_in_tick;
  402e7e:	4b0b      	ldr	r3, [pc, #44]	; (402eac <program_next_period+0x34>)
  402e80:	881b      	ldrh	r3, [r3, #0]
  402e82:	461a      	mov	r2, r3
  402e84:	4b0a      	ldr	r3, [pc, #40]	; (402eb0 <program_next_period+0x38>)
  402e86:	881b      	ldrh	r3, [r3, #0]
  402e88:	4413      	add	r3, r2
  402e8a:	607b      	str	r3, [r7, #4]
	ultrasound_prev_period_end_in_tick = time;
  402e8c:	687b      	ldr	r3, [r7, #4]
  402e8e:	b29a      	uxth	r2, r3
  402e90:	4b06      	ldr	r3, [pc, #24]	; (402eac <program_next_period+0x34>)
  402e92:	801a      	strh	r2, [r3, #0]
	tc_write_rc(TC0, TC_CHANNEL_US, (uint16_t) (time & 0xFFFF));
  402e94:	687b      	ldr	r3, [r7, #4]
  402e96:	b29b      	uxth	r3, r3
  402e98:	461a      	mov	r2, r3
  402e9a:	2101      	movs	r1, #1
  402e9c:	4805      	ldr	r0, [pc, #20]	; (402eb4 <program_next_period+0x3c>)
  402e9e:	4b06      	ldr	r3, [pc, #24]	; (402eb8 <program_next_period+0x40>)
  402ea0:	4798      	blx	r3
}
  402ea2:	bf00      	nop
  402ea4:	3708      	adds	r7, #8
  402ea6:	46bd      	mov	sp, r7
  402ea8:	bd80      	pop	{r7, pc}
  402eaa:	bf00      	nop
  402eac:	20000382 	.word	0x20000382
  402eb0:	20000160 	.word	0x20000160
  402eb4:	40010000 	.word	0x40010000
  402eb8:	00404ac1 	.word	0x00404ac1

00402ebc <chbsp_periodic_timer_irq_enable>:
 * \brief Enable periodic timer interrupt.
 *
 * This function enables the interrupt associated with the periodic timer initialized by
 * \a chbsp_periodic_timer_init().
 */
void chbsp_periodic_timer_irq_enable(void) {
  402ebc:	b580      	push	{r7, lr}
  402ebe:	af00      	add	r7, sp, #0

	/* Clear any pending CPCS before enabling it */
	tc_get_status(TC0, TC_CHANNEL_US);
  402ec0:	2101      	movs	r1, #1
  402ec2:	4805      	ldr	r0, [pc, #20]	; (402ed8 <chbsp_periodic_timer_irq_enable+0x1c>)
  402ec4:	4b05      	ldr	r3, [pc, #20]	; (402edc <chbsp_periodic_timer_irq_enable+0x20>)
  402ec6:	4798      	blx	r3
	tc_enable_interrupt(TC0, TC_CHANNEL_US, TC_IER_CPCS);
  402ec8:	2210      	movs	r2, #16
  402eca:	2101      	movs	r1, #1
  402ecc:	4802      	ldr	r0, [pc, #8]	; (402ed8 <chbsp_periodic_timer_irq_enable+0x1c>)
  402ece:	4b04      	ldr	r3, [pc, #16]	; (402ee0 <chbsp_periodic_timer_irq_enable+0x24>)
  402ed0:	4798      	blx	r3
}
  402ed2:	bf00      	nop
  402ed4:	bd80      	pop	{r7, pc}
  402ed6:	bf00      	nop
  402ed8:	40010000 	.word	0x40010000
  402edc:	00404b33 	.word	0x00404b33
  402ee0:	00404ae7 	.word	0x00404ae7

00402ee4 <chbsp_periodic_timer_start>:
 *
 * \return 0 if successful, 1 if error
 *
 * This function starts the periodic timer initialized by \a chbsp_periodic_timer_init().
 */
uint8_t chbsp_periodic_timer_start(void) {
  402ee4:	b580      	push	{r7, lr}
  402ee6:	af00      	add	r7, sp, #0

	decimation_counter = 0;
  402ee8:	4b07      	ldr	r3, [pc, #28]	; (402f08 <chbsp_periodic_timer_start+0x24>)
  402eea:	2200      	movs	r2, #0
  402eec:	701a      	strb	r2, [r3, #0]
	/* The timer start done at the very end is resetting the counter */
	ultrasound_prev_period_end_in_tick = 0;
  402eee:	4b07      	ldr	r3, [pc, #28]	; (402f0c <chbsp_periodic_timer_start+0x28>)
  402ef0:	2200      	movs	r2, #0
  402ef2:	801a      	strh	r2, [r3, #0]
	program_next_period();
  402ef4:	4b06      	ldr	r3, [pc, #24]	; (402f10 <chbsp_periodic_timer_start+0x2c>)
  402ef6:	4798      	blx	r3

	/* Start the HW counter (this resets the counter */
	tc_start(TC0, TC_CHANNEL_US);
  402ef8:	2101      	movs	r1, #1
  402efa:	4806      	ldr	r0, [pc, #24]	; (402f14 <chbsp_periodic_timer_start+0x30>)
  402efc:	4b06      	ldr	r3, [pc, #24]	; (402f18 <chbsp_periodic_timer_start+0x34>)
  402efe:	4798      	blx	r3

	return 0;
  402f00:	2300      	movs	r3, #0
}
  402f02:	4618      	mov	r0, r3
  402f04:	bd80      	pop	{r7, pc}
  402f06:	bf00      	nop
  402f08:	20000384 	.word	0x20000384
  402f0c:	20000382 	.word	0x20000382
  402f10:	00402e79 	.word	0x00402e79
  402f14:	40010000 	.word	0x40010000
  402f18:	00404a9f 	.word	0x00404a9f

00402f1c <chbsp_periodic_timer_handler>:
 *
 * This function handles the expiration of the periodic timer, re-arms it and any associated
 * interrupts for the next interval, and calls the callback routine that was registered using
 * \a chbsp_periodic_timer_init().
 */
void chbsp_periodic_timer_handler(void) {
  402f1c:	b580      	push	{r7, lr}
  402f1e:	b082      	sub	sp, #8
  402f20:	af00      	add	r7, sp, #0
	ch_timer_callback_t func_ptr = periodic_timer_callback_ptr;
  402f22:	4b0e      	ldr	r3, [pc, #56]	; (402f5c <chbsp_periodic_timer_handler+0x40>)
  402f24:	681b      	ldr	r3, [r3, #0]
  402f26:	607b      	str	r3, [r7, #4]

	decimation_counter++;
  402f28:	4b0d      	ldr	r3, [pc, #52]	; (402f60 <chbsp_periodic_timer_handler+0x44>)
  402f2a:	781b      	ldrb	r3, [r3, #0]
  402f2c:	3301      	adds	r3, #1
  402f2e:	b2da      	uxtb	r2, r3
  402f30:	4b0b      	ldr	r3, [pc, #44]	; (402f60 <chbsp_periodic_timer_handler+0x44>)
  402f32:	701a      	strb	r2, [r3, #0]
	program_next_period();
  402f34:	4b0b      	ldr	r3, [pc, #44]	; (402f64 <chbsp_periodic_timer_handler+0x48>)
  402f36:	4798      	blx	r3
	if (decimation_counter >= decimation_factor) {
  402f38:	4b09      	ldr	r3, [pc, #36]	; (402f60 <chbsp_periodic_timer_handler+0x44>)
  402f3a:	781a      	ldrb	r2, [r3, #0]
  402f3c:	4b0a      	ldr	r3, [pc, #40]	; (402f68 <chbsp_periodic_timer_handler+0x4c>)
  402f3e:	781b      	ldrb	r3, [r3, #0]
  402f40:	429a      	cmp	r2, r3
  402f42:	d307      	bcc.n	402f54 <chbsp_periodic_timer_handler+0x38>
		decimation_counter = 0;
  402f44:	4b06      	ldr	r3, [pc, #24]	; (402f60 <chbsp_periodic_timer_handler+0x44>)
  402f46:	2200      	movs	r2, #0
  402f48:	701a      	strb	r2, [r3, #0]
		if (func_ptr != NULL) {
  402f4a:	687b      	ldr	r3, [r7, #4]
  402f4c:	2b00      	cmp	r3, #0
  402f4e:	d001      	beq.n	402f54 <chbsp_periodic_timer_handler+0x38>
			(*func_ptr)();			// call application timer callback routine
  402f50:	687b      	ldr	r3, [r7, #4]
  402f52:	4798      	blx	r3
		}
	}
}
  402f54:	bf00      	nop
  402f56:	3708      	adds	r7, #8
  402f58:	46bd      	mov	sp, r7
  402f5a:	bd80      	pop	{r7, pc}
  402f5c:	2000037c 	.word	0x2000037c
  402f60:	20000384 	.word	0x20000384
  402f64:	00402e79 	.word	0x00402e79
  402f68:	20000385 	.word	0x20000385

00402f6c <chbsp_proc_sleep>:
 *
 * This function puts the host processor (MCU) into a low-power sleep mode, to conserve energy.
 * The sleep state should be selected such that interrupts associated with the I2C, external
 * GPIO pins, and the periodic timer (if used) are able to wake up the device.
 */
void chbsp_proc_sleep(void) {
  402f6c:	b580      	push	{r7, lr}
  402f6e:	af00      	add	r7, sp, #0

	pmc_sleep(PROC_SLEEP_MODE);			// use sleep mode defined in chirp_smartsonic.h
  402f70:	2002      	movs	r0, #2
  402f72:	4b02      	ldr	r3, [pc, #8]	; (402f7c <chbsp_proc_sleep+0x10>)
  402f74:	4798      	blx	r3
}
  402f76:	bf00      	nop
  402f78:	bd80      	pop	{r7, pc}
  402f7a:	bf00      	nop
  402f7c:	00404679 	.word	0x00404679

00402f80 <chbsp_led_on>:
 *
 * The \a dev_num parameter contains the device number of a specific sensor.  This routine
 * will turn on the LED on the Chirp sensor daughterboard that is next to the specified
 * sensor.
 */
void chbsp_led_on(uint8_t led_num) {
  402f80:	b580      	push	{r7, lr}
  402f82:	b082      	sub	sp, #8
  402f84:	af00      	add	r7, sp, #0
  402f86:	4603      	mov	r3, r0
  402f88:	71fb      	strb	r3, [r7, #7]

	sensor_led_on(chirp_led_pins[led_num]);
  402f8a:	79fb      	ldrb	r3, [r7, #7]
  402f8c:	4a04      	ldr	r2, [pc, #16]	; (402fa0 <chbsp_led_on+0x20>)
  402f8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  402f92:	4618      	mov	r0, r3
  402f94:	4b03      	ldr	r3, [pc, #12]	; (402fa4 <chbsp_led_on+0x24>)
  402f96:	4798      	blx	r3
}
  402f98:	bf00      	nop
  402f9a:	3708      	adds	r7, #8
  402f9c:	46bd      	mov	sp, r7
  402f9e:	bd80      	pop	{r7, pc}
  402fa0:	20000150 	.word	0x20000150
  402fa4:	004014d1 	.word	0x004014d1

00402fa8 <chbsp_print_str>:
 *
 * \param str	pointer to a string of characters to be output
 *
 * This function prints debug information to the console.
 */
void chbsp_print_str(char *str) {
  402fa8:	b580      	push	{r7, lr}
  402faa:	b082      	sub	sp, #8
  402fac:	af00      	add	r7, sp, #0
  402fae:	6078      	str	r0, [r7, #4]
	printf(str);
  402fb0:	6878      	ldr	r0, [r7, #4]
  402fb2:	4b03      	ldr	r3, [pc, #12]	; (402fc0 <chbsp_print_str+0x18>)
  402fb4:	4798      	blx	r3
}
  402fb6:	bf00      	nop
  402fb8:	3708      	adds	r7, #8
  402fba:	46bd      	mov	sp, r7
  402fbc:	bd80      	pop	{r7, pc}
  402fbe:	bf00      	nop
  402fc0:	00409ee9 	.word	0x00409ee9

00402fc4 <chbsp_timestamp_ms>:
/*!
 * \brief Return the current time in ms
 *
 * This function returns the system current time in ms.
 */
uint32_t chbsp_timestamp_ms(void) {
  402fc4:	b590      	push	{r4, r7, lr}
  402fc6:	b083      	sub	sp, #12
  402fc8:	af00      	add	r7, sp, #0
	uint32_t time = time_get_in_us();
  402fca:	4b07      	ldr	r3, [pc, #28]	; (402fe8 <chbsp_timestamp_ms+0x24>)
  402fcc:	4798      	blx	r3
  402fce:	4603      	mov	r3, r0
  402fd0:	460c      	mov	r4, r1
  402fd2:	607b      	str	r3, [r7, #4]
	return (time / 1000);
  402fd4:	687b      	ldr	r3, [r7, #4]
  402fd6:	4a05      	ldr	r2, [pc, #20]	; (402fec <chbsp_timestamp_ms+0x28>)
  402fd8:	fba2 2303 	umull	r2, r3, r2, r3
  402fdc:	099b      	lsrs	r3, r3, #6
}
  402fde:	4618      	mov	r0, r3
  402fe0:	370c      	adds	r7, #12
  402fe2:	46bd      	mov	sp, r7
  402fe4:	bd90      	pop	{r4, r7, pc}
  402fe6:	bf00      	nop
  402fe8:	00400af9 	.word	0x00400af9
  402fec:	10624dd3 	.word	0x10624dd3

00402ff0 <time_hal_get_in_us>:
#include "time_hal.h"
#include "tc.h"
#include "chirp_smartsonic.h"

uint64_t time_hal_get_in_us(void)
{
  402ff0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402ff4:	b085      	sub	sp, #20
  402ff6:	af00      	add	r7, sp, #0
	static uint64_t lsepoch_overflow_counter_in_tick = 0;

	cpu_irq_enter_critical();
  402ff8:	4b33      	ldr	r3, [pc, #204]	; (4030c8 <time_hal_get_in_us+0xd8>)
  402ffa:	4798      	blx	r3
	/* Check if a counter overflow occurs since last call and ensure no ovf occurs during the read */
	if (TC0->TC_CHANNEL[TC_CHANNEL_LSEPOCH].TC_SR & TC_SR_COVFS)
  402ffc:	4b33      	ldr	r3, [pc, #204]	; (4030cc <time_hal_get_in_us+0xdc>)
  402ffe:	6a1b      	ldr	r3, [r3, #32]
  403000:	f003 0301 	and.w	r3, r3, #1
  403004:	2b00      	cmp	r3, #0
  403006:	d009      	beq.n	40301c <time_hal_get_in_us+0x2c>
		lsepoch_overflow_counter_in_tick += 65536;
  403008:	4b31      	ldr	r3, [pc, #196]	; (4030d0 <time_hal_get_in_us+0xe0>)
  40300a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40300e:	f513 3380 	adds.w	r3, r3, #65536	; 0x10000
  403012:	f144 0400 	adc.w	r4, r4, #0
  403016:	4a2e      	ldr	r2, [pc, #184]	; (4030d0 <time_hal_get_in_us+0xe0>)
  403018:	e9c2 3400 	strd	r3, r4, [r2]

	uint16_t timer_counter = TC0->TC_CHANNEL[TC_CHANNEL_LSEPOCH].TC_CV;
  40301c:	4b2b      	ldr	r3, [pc, #172]	; (4030cc <time_hal_get_in_us+0xdc>)
  40301e:	691b      	ldr	r3, [r3, #16]
  403020:	81fb      	strh	r3, [r7, #14]

	if (TC0->TC_CHANNEL[TC_CHANNEL_LSEPOCH].TC_SR & TC_SR_COVFS) {
  403022:	4b2a      	ldr	r3, [pc, #168]	; (4030cc <time_hal_get_in_us+0xdc>)
  403024:	6a1b      	ldr	r3, [r3, #32]
  403026:	f003 0301 	and.w	r3, r3, #1
  40302a:	2b00      	cmp	r3, #0
  40302c:	d00b      	beq.n	403046 <time_hal_get_in_us+0x56>
		lsepoch_overflow_counter_in_tick += 65536;
  40302e:	4b28      	ldr	r3, [pc, #160]	; (4030d0 <time_hal_get_in_us+0xe0>)
  403030:	e9d3 3400 	ldrd	r3, r4, [r3]
  403034:	f513 3380 	adds.w	r3, r3, #65536	; 0x10000
  403038:	f144 0400 	adc.w	r4, r4, #0
  40303c:	4a24      	ldr	r2, [pc, #144]	; (4030d0 <time_hal_get_in_us+0xe0>)
  40303e:	e9c2 3400 	strd	r3, r4, [r2]
		/* Overflow occurred during the reading */
		timer_counter = 0;
  403042:	2300      	movs	r3, #0
  403044:	81fb      	strh	r3, [r7, #14]
	}

	cpu_irq_leave_critical();
  403046:	4b23      	ldr	r3, [pc, #140]	; (4030d4 <time_hal_get_in_us+0xe4>)
  403048:	4798      	blx	r3

	/* Convert to us */
	uint64_t curr_time = ((lsepoch_overflow_counter_in_tick + timer_counter) * 1000000)
  40304a:	89f9      	ldrh	r1, [r7, #14]
  40304c:	f04f 0200 	mov.w	r2, #0
  403050:	4b1f      	ldr	r3, [pc, #124]	; (4030d0 <time_hal_get_in_us+0xe0>)
  403052:	e9d3 3400 	ldrd	r3, r4, [r3]
  403056:	18c9      	adds	r1, r1, r3
  403058:	eb42 0204 	adc.w	r2, r2, r4
  40305c:	460b      	mov	r3, r1
  40305e:	4614      	mov	r4, r2
  403060:	ea4f 1b44 	mov.w	fp, r4, lsl #5
  403064:	ea4b 6bd3 	orr.w	fp, fp, r3, lsr #27
  403068:	ea4f 1a43 	mov.w	sl, r3, lsl #5
  40306c:	4653      	mov	r3, sl
  40306e:	465c      	mov	r4, fp
  403070:	1a5b      	subs	r3, r3, r1
  403072:	eb64 0402 	sbc.w	r4, r4, r2
  403076:	ea4f 2944 	mov.w	r9, r4, lsl #9
  40307a:	ea49 59d3 	orr.w	r9, r9, r3, lsr #23
  40307e:	ea4f 2843 	mov.w	r8, r3, lsl #9
  403082:	4643      	mov	r3, r8
  403084:	464c      	mov	r4, r9
  403086:	185b      	adds	r3, r3, r1
  403088:	eb44 0402 	adc.w	r4, r4, r2
  40308c:	01a6      	lsls	r6, r4, #6
  40308e:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
  403092:	019d      	lsls	r5, r3, #6
  403094:	1aed      	subs	r5, r5, r3
  403096:	eb66 0604 	sbc.w	r6, r6, r4
  40309a:	186b      	adds	r3, r5, r1
  40309c:	eb46 0402 	adc.w	r4, r6, r2
  4030a0:	4618      	mov	r0, r3
  4030a2:	4621      	mov	r1, r4
  4030a4:	4c0c      	ldr	r4, [pc, #48]	; (4030d8 <time_hal_get_in_us+0xe8>)
  4030a6:	4a0d      	ldr	r2, [pc, #52]	; (4030dc <time_hal_get_in_us+0xec>)
  4030a8:	f04f 0300 	mov.w	r3, #0
  4030ac:	47a0      	blx	r4
  4030ae:	4603      	mov	r3, r0
  4030b0:	460c      	mov	r4, r1
  4030b2:	e9c7 3400 	strd	r3, r4, [r7]
		/ ULTRASOUND_TIMER_FREQUENCY;

	return (curr_time);
  4030b6:	e9d7 3400 	ldrd	r3, r4, [r7]
  4030ba:	4618      	mov	r0, r3
  4030bc:	4621      	mov	r1, r4
  4030be:	3714      	adds	r7, #20
  4030c0:	46bd      	mov	sp, r7
  4030c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4030c6:	bf00      	nop
  4030c8:	00400ec9 	.word	0x00400ec9
  4030cc:	40010000 	.word	0x40010000
  4030d0:	200003a8 	.word	0x200003a8
  4030d4:	00400f21 	.word	0x00400f21
  4030d8:	0040cbad 	.word	0x0040cbad
  4030dc:	0007a111 	.word	0x0007a111

004030e0 <sysclk_enable_peripheral_clock>:
{
  4030e0:	b580      	push	{r7, lr}
  4030e2:	b082      	sub	sp, #8
  4030e4:	af00      	add	r7, sp, #0
  4030e6:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4030e8:	6878      	ldr	r0, [r7, #4]
  4030ea:	4b03      	ldr	r3, [pc, #12]	; (4030f8 <sysclk_enable_peripheral_clock+0x18>)
  4030ec:	4798      	blx	r3
}
  4030ee:	bf00      	nop
  4030f0:	3708      	adds	r7, #8
  4030f2:	46bd      	mov	sp, r7
  4030f4:	bd80      	pop	{r7, pc}
  4030f6:	bf00      	nop
  4030f8:	00404459 	.word	0x00404459

004030fc <ioport_init>:
{
  4030fc:	b580      	push	{r7, lr}
  4030fe:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  403100:	200b      	movs	r0, #11
  403102:	4b03      	ldr	r3, [pc, #12]	; (403110 <ioport_init+0x14>)
  403104:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  403106:	200c      	movs	r0, #12
  403108:	4b01      	ldr	r3, [pc, #4]	; (403110 <ioport_init+0x14>)
  40310a:	4798      	blx	r3
}
  40310c:	bf00      	nop
  40310e:	bd80      	pop	{r7, pc}
  403110:	004030e1 	.word	0x004030e1

00403114 <ioport_disable_pin>:
{
  403114:	b480      	push	{r7}
  403116:	b089      	sub	sp, #36	; 0x24
  403118:	af00      	add	r7, sp, #0
  40311a:	6078      	str	r0, [r7, #4]
  40311c:	687b      	ldr	r3, [r7, #4]
  40311e:	61fb      	str	r3, [r7, #28]
  403120:	69fb      	ldr	r3, [r7, #28]
  403122:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403124:	69bb      	ldr	r3, [r7, #24]
  403126:	095a      	lsrs	r2, r3, #5
  403128:	69fb      	ldr	r3, [r7, #28]
  40312a:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  40312c:	697b      	ldr	r3, [r7, #20]
  40312e:	f003 031f 	and.w	r3, r3, #31
  403132:	2101      	movs	r1, #1
  403134:	fa01 f303 	lsl.w	r3, r1, r3
  403138:	613a      	str	r2, [r7, #16]
  40313a:	60fb      	str	r3, [r7, #12]
  40313c:	693b      	ldr	r3, [r7, #16]
  40313e:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403140:	68bb      	ldr	r3, [r7, #8]
  403142:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403146:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40314a:	025b      	lsls	r3, r3, #9
  40314c:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40314e:	68fb      	ldr	r3, [r7, #12]
  403150:	6053      	str	r3, [r2, #4]
}
  403152:	bf00      	nop
  403154:	3724      	adds	r7, #36	; 0x24
  403156:	46bd      	mov	sp, r7
  403158:	f85d 7b04 	ldr.w	r7, [sp], #4
  40315c:	4770      	bx	lr

0040315e <ioport_set_pin_mode>:
{
  40315e:	b480      	push	{r7}
  403160:	b08d      	sub	sp, #52	; 0x34
  403162:	af00      	add	r7, sp, #0
  403164:	6078      	str	r0, [r7, #4]
  403166:	6039      	str	r1, [r7, #0]
  403168:	687b      	ldr	r3, [r7, #4]
  40316a:	62fb      	str	r3, [r7, #44]	; 0x2c
  40316c:	683b      	ldr	r3, [r7, #0]
  40316e:	62bb      	str	r3, [r7, #40]	; 0x28
  403170:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403172:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  403174:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403176:	095a      	lsrs	r2, r3, #5
  403178:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40317a:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  40317c:	6a3b      	ldr	r3, [r7, #32]
  40317e:	f003 031f 	and.w	r3, r3, #31
  403182:	2101      	movs	r1, #1
  403184:	fa01 f303 	lsl.w	r3, r1, r3
  403188:	61fa      	str	r2, [r7, #28]
  40318a:	61bb      	str	r3, [r7, #24]
  40318c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40318e:	617b      	str	r3, [r7, #20]
  403190:	69fb      	ldr	r3, [r7, #28]
  403192:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403194:	693b      	ldr	r3, [r7, #16]
  403196:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40319a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40319e:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  4031a0:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  4031a2:	697b      	ldr	r3, [r7, #20]
  4031a4:	f003 0308 	and.w	r3, r3, #8
  4031a8:	2b00      	cmp	r3, #0
  4031aa:	d003      	beq.n	4031b4 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  4031ac:	68fb      	ldr	r3, [r7, #12]
  4031ae:	69ba      	ldr	r2, [r7, #24]
  4031b0:	665a      	str	r2, [r3, #100]	; 0x64
  4031b2:	e002      	b.n	4031ba <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  4031b4:	68fb      	ldr	r3, [r7, #12]
  4031b6:	69ba      	ldr	r2, [r7, #24]
  4031b8:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  4031ba:	697b      	ldr	r3, [r7, #20]
  4031bc:	f003 0310 	and.w	r3, r3, #16
  4031c0:	2b00      	cmp	r3, #0
  4031c2:	d004      	beq.n	4031ce <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  4031c4:	68fb      	ldr	r3, [r7, #12]
  4031c6:	69ba      	ldr	r2, [r7, #24]
  4031c8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  4031cc:	e003      	b.n	4031d6 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  4031ce:	68fb      	ldr	r3, [r7, #12]
  4031d0:	69ba      	ldr	r2, [r7, #24]
  4031d2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  4031d6:	697b      	ldr	r3, [r7, #20]
  4031d8:	f003 0320 	and.w	r3, r3, #32
  4031dc:	2b00      	cmp	r3, #0
  4031de:	d003      	beq.n	4031e8 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  4031e0:	68fb      	ldr	r3, [r7, #12]
  4031e2:	69ba      	ldr	r2, [r7, #24]
  4031e4:	651a      	str	r2, [r3, #80]	; 0x50
  4031e6:	e002      	b.n	4031ee <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  4031e8:	68fb      	ldr	r3, [r7, #12]
  4031ea:	69ba      	ldr	r2, [r7, #24]
  4031ec:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  4031ee:	697b      	ldr	r3, [r7, #20]
  4031f0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  4031f4:	2b00      	cmp	r3, #0
  4031f6:	d003      	beq.n	403200 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  4031f8:	68fb      	ldr	r3, [r7, #12]
  4031fa:	69ba      	ldr	r2, [r7, #24]
  4031fc:	621a      	str	r2, [r3, #32]
  4031fe:	e002      	b.n	403206 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  403200:	68fb      	ldr	r3, [r7, #12]
  403202:	69ba      	ldr	r2, [r7, #24]
  403204:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  403206:	697b      	ldr	r3, [r7, #20]
  403208:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40320c:	2b00      	cmp	r3, #0
  40320e:	d004      	beq.n	40321a <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  403210:	68fb      	ldr	r3, [r7, #12]
  403212:	69ba      	ldr	r2, [r7, #24]
  403214:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  403218:	e003      	b.n	403222 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  40321a:	68fb      	ldr	r3, [r7, #12]
  40321c:	69ba      	ldr	r2, [r7, #24]
  40321e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  403222:	697b      	ldr	r3, [r7, #20]
  403224:	f003 0301 	and.w	r3, r3, #1
  403228:	2b00      	cmp	r3, #0
  40322a:	d006      	beq.n	40323a <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  40322c:	68fb      	ldr	r3, [r7, #12]
  40322e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403230:	69bb      	ldr	r3, [r7, #24]
  403232:	431a      	orrs	r2, r3
  403234:	68fb      	ldr	r3, [r7, #12]
  403236:	671a      	str	r2, [r3, #112]	; 0x70
  403238:	e006      	b.n	403248 <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  40323a:	68fb      	ldr	r3, [r7, #12]
  40323c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40323e:	69bb      	ldr	r3, [r7, #24]
  403240:	43db      	mvns	r3, r3
  403242:	401a      	ands	r2, r3
  403244:	68fb      	ldr	r3, [r7, #12]
  403246:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  403248:	697b      	ldr	r3, [r7, #20]
  40324a:	f003 0302 	and.w	r3, r3, #2
  40324e:	2b00      	cmp	r3, #0
  403250:	d006      	beq.n	403260 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  403252:	68fb      	ldr	r3, [r7, #12]
  403254:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403256:	69bb      	ldr	r3, [r7, #24]
  403258:	431a      	orrs	r2, r3
  40325a:	68fb      	ldr	r3, [r7, #12]
  40325c:	675a      	str	r2, [r3, #116]	; 0x74
}
  40325e:	e006      	b.n	40326e <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  403260:	68fb      	ldr	r3, [r7, #12]
  403262:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403264:	69bb      	ldr	r3, [r7, #24]
  403266:	43db      	mvns	r3, r3
  403268:	401a      	ands	r2, r3
  40326a:	68fb      	ldr	r3, [r7, #12]
  40326c:	675a      	str	r2, [r3, #116]	; 0x74
  40326e:	bf00      	nop
  403270:	3734      	adds	r7, #52	; 0x34
  403272:	46bd      	mov	sp, r7
  403274:	f85d 7b04 	ldr.w	r7, [sp], #4
  403278:	4770      	bx	lr

0040327a <ioport_set_pin_dir>:
{
  40327a:	b480      	push	{r7}
  40327c:	b08d      	sub	sp, #52	; 0x34
  40327e:	af00      	add	r7, sp, #0
  403280:	6078      	str	r0, [r7, #4]
  403282:	460b      	mov	r3, r1
  403284:	70fb      	strb	r3, [r7, #3]
  403286:	687b      	ldr	r3, [r7, #4]
  403288:	62fb      	str	r3, [r7, #44]	; 0x2c
  40328a:	78fb      	ldrb	r3, [r7, #3]
  40328c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  403290:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403292:	627b      	str	r3, [r7, #36]	; 0x24
  403294:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403296:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  403298:	6a3b      	ldr	r3, [r7, #32]
  40329a:	095b      	lsrs	r3, r3, #5
  40329c:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40329e:	69fb      	ldr	r3, [r7, #28]
  4032a0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4032a4:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4032a8:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  4032aa:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  4032ac:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4032b0:	2b01      	cmp	r3, #1
  4032b2:	d109      	bne.n	4032c8 <ioport_set_pin_dir+0x4e>
  4032b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4032b6:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  4032b8:	697b      	ldr	r3, [r7, #20]
  4032ba:	f003 031f 	and.w	r3, r3, #31
  4032be:	2201      	movs	r2, #1
  4032c0:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4032c2:	69bb      	ldr	r3, [r7, #24]
  4032c4:	611a      	str	r2, [r3, #16]
  4032c6:	e00c      	b.n	4032e2 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  4032c8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4032cc:	2b00      	cmp	r3, #0
  4032ce:	d108      	bne.n	4032e2 <ioport_set_pin_dir+0x68>
  4032d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4032d2:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  4032d4:	693b      	ldr	r3, [r7, #16]
  4032d6:	f003 031f 	and.w	r3, r3, #31
  4032da:	2201      	movs	r2, #1
  4032dc:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  4032de:	69bb      	ldr	r3, [r7, #24]
  4032e0:	615a      	str	r2, [r3, #20]
  4032e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4032e4:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4032e6:	68fb      	ldr	r3, [r7, #12]
  4032e8:	f003 031f 	and.w	r3, r3, #31
  4032ec:	2201      	movs	r2, #1
  4032ee:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4032f0:	69bb      	ldr	r3, [r7, #24]
  4032f2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  4032f6:	bf00      	nop
  4032f8:	3734      	adds	r7, #52	; 0x34
  4032fa:	46bd      	mov	sp, r7
  4032fc:	f85d 7b04 	ldr.w	r7, [sp], #4
  403300:	4770      	bx	lr

00403302 <ioport_set_pin_level>:
{
  403302:	b480      	push	{r7}
  403304:	b08b      	sub	sp, #44	; 0x2c
  403306:	af00      	add	r7, sp, #0
  403308:	6078      	str	r0, [r7, #4]
  40330a:	460b      	mov	r3, r1
  40330c:	70fb      	strb	r3, [r7, #3]
  40330e:	687b      	ldr	r3, [r7, #4]
  403310:	627b      	str	r3, [r7, #36]	; 0x24
  403312:	78fb      	ldrb	r3, [r7, #3]
  403314:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  403318:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40331a:	61fb      	str	r3, [r7, #28]
  40331c:	69fb      	ldr	r3, [r7, #28]
  40331e:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403320:	69bb      	ldr	r3, [r7, #24]
  403322:	095b      	lsrs	r3, r3, #5
  403324:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403326:	697b      	ldr	r3, [r7, #20]
  403328:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40332c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403330:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  403332:	613b      	str	r3, [r7, #16]
	if (level) {
  403334:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  403338:	2b00      	cmp	r3, #0
  40333a:	d009      	beq.n	403350 <ioport_set_pin_level+0x4e>
  40333c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40333e:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  403340:	68fb      	ldr	r3, [r7, #12]
  403342:	f003 031f 	and.w	r3, r3, #31
  403346:	2201      	movs	r2, #1
  403348:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40334a:	693b      	ldr	r3, [r7, #16]
  40334c:	631a      	str	r2, [r3, #48]	; 0x30
}
  40334e:	e008      	b.n	403362 <ioport_set_pin_level+0x60>
  403350:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403352:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  403354:	68bb      	ldr	r3, [r7, #8]
  403356:	f003 031f 	and.w	r3, r3, #31
  40335a:	2201      	movs	r2, #1
  40335c:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40335e:	693b      	ldr	r3, [r7, #16]
  403360:	635a      	str	r2, [r3, #52]	; 0x34
  403362:	bf00      	nop
  403364:	372c      	adds	r7, #44	; 0x2c
  403366:	46bd      	mov	sp, r7
  403368:	f85d 7b04 	ldr.w	r7, [sp], #4
  40336c:	4770      	bx	lr
	...

00403370 <system_board_init_I2C>:
void board_init_I2C(void);
#  pragma weak board_init_I2C=system_board_init_I2C
#endif

void system_board_init_I2C(void)
{
  403370:	b580      	push	{r7, lr}
  403372:	af00      	add	r7, sp, #0

	#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	WDT->WDT_MR = WDT_MR_WDDIS;
  403374:	4b41      	ldr	r3, [pc, #260]	; (40347c <system_board_init_I2C+0x10c>)
  403376:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40337a:	605a      	str	r2, [r3, #4]
	#endif
	ioport_init();	
  40337c:	4b40      	ldr	r3, [pc, #256]	; (403480 <system_board_init_I2C+0x110>)
  40337e:	4798      	blx	r3
    
	/* Initialize LED0, turned off */
	ioport_set_pin_dir(LED_0_PIN, IOPORT_DIR_OUTPUT);
  403380:	2101      	movs	r1, #1
  403382:	202a      	movs	r0, #42	; 0x2a
  403384:	4b3f      	ldr	r3, [pc, #252]	; (403484 <system_board_init_I2C+0x114>)
  403386:	4798      	blx	r3
	ioport_set_pin_level(LED_0_PIN, IOPORT_PIN_LEVEL_HIGH);
  403388:	2101      	movs	r1, #1
  40338a:	202a      	movs	r0, #42	; 0x2a
  40338c:	4b3e      	ldr	r3, [pc, #248]	; (403488 <system_board_init_I2C+0x118>)
  40338e:	4798      	blx	r3

	/* Initialize SW0 */
	ioport_set_pin_dir(BUTTON_0_PIN, IOPORT_DIR_INPUT);
  403390:	2100      	movs	r1, #0
  403392:	2002      	movs	r0, #2
  403394:	4b3b      	ldr	r3, [pc, #236]	; (403484 <system_board_init_I2C+0x114>)
  403396:	4798      	blx	r3
	ioport_set_pin_mode(BUTTON_0_PIN, IOPORT_MODE_PULLUP);
  403398:	2108      	movs	r1, #8
  40339a:	2002      	movs	r0, #2
  40339c:	4b3b      	ldr	r3, [pc, #236]	; (40348c <system_board_init_I2C+0x11c>)
  40339e:	4798      	blx	r3

	/* Initialize EXT3 LED0, LED1 & LED2, turned off */
	ioport_set_pin_level(OLED1_LED1_PIN, !OLED1_LED1_ACTIVE);
  4033a0:	2101      	movs	r1, #1
  4033a2:	2001      	movs	r0, #1
  4033a4:	4b38      	ldr	r3, [pc, #224]	; (403488 <system_board_init_I2C+0x118>)
  4033a6:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED1_PIN, IOPORT_DIR_OUTPUT);
  4033a8:	2101      	movs	r1, #1
  4033aa:	2001      	movs	r0, #1
  4033ac:	4b35      	ldr	r3, [pc, #212]	; (403484 <system_board_init_I2C+0x114>)
  4033ae:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED2_PIN, !OLED1_LED2_ACTIVE);
  4033b0:	2101      	movs	r1, #1
  4033b2:	202d      	movs	r0, #45	; 0x2d
  4033b4:	4b34      	ldr	r3, [pc, #208]	; (403488 <system_board_init_I2C+0x118>)
  4033b6:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED2_PIN, IOPORT_DIR_OUTPUT);
  4033b8:	2101      	movs	r1, #1
  4033ba:	202d      	movs	r0, #45	; 0x2d
  4033bc:	4b31      	ldr	r3, [pc, #196]	; (403484 <system_board_init_I2C+0x114>)
  4033be:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED3_PIN, !OLED1_LED3_ACTIVE);
  4033c0:	2101      	movs	r1, #1
  4033c2:	202f      	movs	r0, #47	; 0x2f
  4033c4:	4b30      	ldr	r3, [pc, #192]	; (403488 <system_board_init_I2C+0x118>)
  4033c6:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED3_PIN, IOPORT_DIR_OUTPUT);
  4033c8:	2101      	movs	r1, #1
  4033ca:	202f      	movs	r0, #47	; 0x2f
  4033cc:	4b2d      	ldr	r3, [pc, #180]	; (403484 <system_board_init_I2C+0x114>)
  4033ce:	4798      	blx	r3
	ioport_set_pin_dir(SD_MMC_0_CD_GPIO, IOPORT_DIR_INPUT);
	ioport_set_pin_mode(SD_MMC_0_CD_GPIO, IOPORT_MODE_PULLUP);
	#endif

	#ifdef CONF_BOARD_SPI_NPCS0
	ioport_set_pin_peripheral_mode(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);
  4033d0:	2100      	movs	r1, #0
  4033d2:	200b      	movs	r0, #11
  4033d4:	4b2d      	ldr	r3, [pc, #180]	; (40348c <system_board_init_I2C+0x11c>)
  4033d6:	4798      	blx	r3
  4033d8:	200b      	movs	r0, #11
  4033da:	4b2d      	ldr	r3, [pc, #180]	; (403490 <system_board_init_I2C+0x120>)
  4033dc:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
	#endif

	#ifdef CONF_BOARD_TWI1
	ioport_set_pin_peripheral_mode(TWI1_DATA_GPIO, TWI1_DATA_FLAGS);
  4033de:	2100      	movs	r1, #0
  4033e0:	2022      	movs	r0, #34	; 0x22
  4033e2:	4b2a      	ldr	r3, [pc, #168]	; (40348c <system_board_init_I2C+0x11c>)
  4033e4:	4798      	blx	r3
  4033e6:	2022      	movs	r0, #34	; 0x22
  4033e8:	4b29      	ldr	r3, [pc, #164]	; (403490 <system_board_init_I2C+0x120>)
  4033ea:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI1_CLK_GPIO, TWI1_CLK_FLAGS);
  4033ec:	2100      	movs	r1, #0
  4033ee:	2023      	movs	r0, #35	; 0x23
  4033f0:	4b26      	ldr	r3, [pc, #152]	; (40348c <system_board_init_I2C+0x11c>)
  4033f2:	4798      	blx	r3
  4033f4:	2023      	movs	r0, #35	; 0x23
  4033f6:	4b26      	ldr	r3, [pc, #152]	; (403490 <system_board_init_I2C+0x120>)
  4033f8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI2_DATA_GPIO, TWI2_DATA_FLAGS);
	ioport_set_pin_peripheral_mode(TWI2_CLK_GPIO, TWI2_CLK_FLAGS);
	#endif
	
	#ifdef CONF_BOARD_TWI3
	ioport_set_pin_peripheral_mode(TWI3_DATA_GPIO, TWI3_DATA_FLAGS);
  4033fa:	2100      	movs	r1, #0
  4033fc:	2003      	movs	r0, #3
  4033fe:	4b23      	ldr	r3, [pc, #140]	; (40348c <system_board_init_I2C+0x11c>)
  403400:	4798      	blx	r3
  403402:	2003      	movs	r0, #3
  403404:	4b22      	ldr	r3, [pc, #136]	; (403490 <system_board_init_I2C+0x120>)
  403406:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI3_CLK_GPIO, TWI3_CLK_FLAGS);
  403408:	2100      	movs	r1, #0
  40340a:	2004      	movs	r0, #4
  40340c:	4b1f      	ldr	r3, [pc, #124]	; (40348c <system_board_init_I2C+0x11c>)
  40340e:	4798      	blx	r3
  403410:	2004      	movs	r0, #4
  403412:	4b1f      	ldr	r3, [pc, #124]	; (403490 <system_board_init_I2C+0x120>)
  403414:	4798      	blx	r3
	#endif

	#if defined(CONF_BOARD_TWI4) ||defined(CONF_BOARD_AT30TSE)
	ioport_set_pin_peripheral_mode(TWI4_DATA_GPIO, TWI4_DATA_FLAGS);
  403416:	2100      	movs	r1, #0
  403418:	2028      	movs	r0, #40	; 0x28
  40341a:	4b1c      	ldr	r3, [pc, #112]	; (40348c <system_board_init_I2C+0x11c>)
  40341c:	4798      	blx	r3
  40341e:	2028      	movs	r0, #40	; 0x28
  403420:	4b1b      	ldr	r3, [pc, #108]	; (403490 <system_board_init_I2C+0x120>)
  403422:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI4_CLK_GPIO, TWI4_CLK_FLAGS);
  403424:	2100      	movs	r1, #0
  403426:	2029      	movs	r0, #41	; 0x29
  403428:	4b18      	ldr	r3, [pc, #96]	; (40348c <system_board_init_I2C+0x11c>)
  40342a:	4798      	blx	r3
  40342c:	2029      	movs	r0, #41	; 0x29
  40342e:	4b18      	ldr	r3, [pc, #96]	; (403490 <system_board_init_I2C+0x120>)
  403430:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PDM_CLK_GPIO, PDM_CLK_FLAGS);
	ioport_set_pin_peripheral_mode(PDM_DAT_GPIO, PDM_DAT_FLAGS);
	#endif

	#ifdef CONF_BOARD_USART0
	ioport_set_pin_peripheral_mode(USART0_RXD_GPIO, USART0_RXD_FLAGS);
  403432:	2100      	movs	r1, #0
  403434:	2009      	movs	r0, #9
  403436:	4b15      	ldr	r3, [pc, #84]	; (40348c <system_board_init_I2C+0x11c>)
  403438:	4798      	blx	r3
  40343a:	2009      	movs	r0, #9
  40343c:	4b14      	ldr	r3, [pc, #80]	; (403490 <system_board_init_I2C+0x120>)
  40343e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_TXD_GPIO, USART0_TXD_FLAGS);
  403440:	2100      	movs	r1, #0
  403442:	200a      	movs	r0, #10
  403444:	4b11      	ldr	r3, [pc, #68]	; (40348c <system_board_init_I2C+0x11c>)
  403446:	4798      	blx	r3
  403448:	200a      	movs	r0, #10
  40344a:	4b11      	ldr	r3, [pc, #68]	; (403490 <system_board_init_I2C+0x120>)
  40344c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_SCK_GPIO, USART0_SCK_FLAGS);
  40344e:	2100      	movs	r1, #0
  403450:	2020      	movs	r0, #32
  403452:	4b0e      	ldr	r3, [pc, #56]	; (40348c <system_board_init_I2C+0x11c>)
  403454:	4798      	blx	r3
  403456:	2020      	movs	r0, #32
  403458:	4b0d      	ldr	r3, [pc, #52]	; (403490 <system_board_init_I2C+0x120>)
  40345a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_CTS_GPIO, USART0_CTS_FLAGS);
  40345c:	2100      	movs	r1, #0
  40345e:	2019      	movs	r0, #25
  403460:	4b0a      	ldr	r3, [pc, #40]	; (40348c <system_board_init_I2C+0x11c>)
  403462:	4798      	blx	r3
  403464:	2019      	movs	r0, #25
  403466:	4b0a      	ldr	r3, [pc, #40]	; (403490 <system_board_init_I2C+0x120>)
  403468:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_RTS_GPIO, USART0_RTS_FLAGS);
  40346a:	2100      	movs	r1, #0
  40346c:	201a      	movs	r0, #26
  40346e:	4b07      	ldr	r3, [pc, #28]	; (40348c <system_board_init_I2C+0x11c>)
  403470:	4798      	blx	r3
  403472:	201a      	movs	r0, #26
  403474:	4b06      	ldr	r3, [pc, #24]	; (403490 <system_board_init_I2C+0x120>)
  403476:	4798      	blx	r3
	#if defined(CONF_BOARD_USB_PORT)
	#  if defined(CONF_BOARD_USB_VBUS_DETECT)
	gpio_configure_pin(USB_VBUS_PIN, USB_VBUS_FLAGS);
	#  endif
	#endif
}
  403478:	bf00      	nop
  40347a:	bd80      	pop	{r7, pc}
  40347c:	400e1450 	.word	0x400e1450
  403480:	004030fd 	.word	0x004030fd
  403484:	0040327b 	.word	0x0040327b
  403488:	00403303 	.word	0x00403303
  40348c:	0040315f 	.word	0x0040315f
  403490:	00403115 	.word	0x00403115

00403494 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  403494:	b480      	push	{r7}
  403496:	b083      	sub	sp, #12
  403498:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40349a:	f3ef 8310 	mrs	r3, PRIMASK
  40349e:	607b      	str	r3, [r7, #4]
  return(result);
  4034a0:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4034a2:	2b00      	cmp	r3, #0
  4034a4:	bf0c      	ite	eq
  4034a6:	2301      	moveq	r3, #1
  4034a8:	2300      	movne	r3, #0
  4034aa:	b2db      	uxtb	r3, r3
  4034ac:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4034ae:	b672      	cpsid	i
  4034b0:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4034b4:	4b04      	ldr	r3, [pc, #16]	; (4034c8 <cpu_irq_save+0x34>)
  4034b6:	2200      	movs	r2, #0
  4034b8:	701a      	strb	r2, [r3, #0]
	return flags;
  4034ba:	683b      	ldr	r3, [r7, #0]
}
  4034bc:	4618      	mov	r0, r3
  4034be:	370c      	adds	r7, #12
  4034c0:	46bd      	mov	sp, r7
  4034c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034c6:	4770      	bx	lr
  4034c8:	20000114 	.word	0x20000114

004034cc <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  4034cc:	b480      	push	{r7}
  4034ce:	b083      	sub	sp, #12
  4034d0:	af00      	add	r7, sp, #0
  4034d2:	6078      	str	r0, [r7, #4]
	return (flags);
  4034d4:	687b      	ldr	r3, [r7, #4]
  4034d6:	2b00      	cmp	r3, #0
  4034d8:	bf14      	ite	ne
  4034da:	2301      	movne	r3, #1
  4034dc:	2300      	moveq	r3, #0
  4034de:	b2db      	uxtb	r3, r3
}
  4034e0:	4618      	mov	r0, r3
  4034e2:	370c      	adds	r7, #12
  4034e4:	46bd      	mov	sp, r7
  4034e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034ea:	4770      	bx	lr

004034ec <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  4034ec:	b580      	push	{r7, lr}
  4034ee:	b082      	sub	sp, #8
  4034f0:	af00      	add	r7, sp, #0
  4034f2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4034f4:	6878      	ldr	r0, [r7, #4]
  4034f6:	4b07      	ldr	r3, [pc, #28]	; (403514 <cpu_irq_restore+0x28>)
  4034f8:	4798      	blx	r3
  4034fa:	4603      	mov	r3, r0
  4034fc:	2b00      	cmp	r3, #0
  4034fe:	d005      	beq.n	40350c <cpu_irq_restore+0x20>
		cpu_irq_enable();
  403500:	4b05      	ldr	r3, [pc, #20]	; (403518 <cpu_irq_restore+0x2c>)
  403502:	2201      	movs	r2, #1
  403504:	701a      	strb	r2, [r3, #0]
  403506:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40350a:	b662      	cpsie	i
}
  40350c:	bf00      	nop
  40350e:	3708      	adds	r7, #8
  403510:	46bd      	mov	sp, r7
  403512:	bd80      	pop	{r7, pc}
  403514:	004034cd 	.word	0x004034cd
  403518:	20000114 	.word	0x20000114

0040351c <adc_get_interrupt_status>:
 * \param adc  Base address of the ADC.
 *
 * \return The interrupt status value.
 */
static inline uint32_t adc_get_interrupt_status(Adc *const adc)
{
  40351c:	b480      	push	{r7}
  40351e:	b083      	sub	sp, #12
  403520:	af00      	add	r7, sp, #0
  403522:	6078      	str	r0, [r7, #4]
	return adc->ADC_ISR;
  403524:	687b      	ldr	r3, [r7, #4]
  403526:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  403528:	4618      	mov	r0, r3
  40352a:	370c      	adds	r7, #12
  40352c:	46bd      	mov	sp, r7
  40352e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403532:	4770      	bx	lr

00403534 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
  403534:	b580      	push	{r7, lr}
  403536:	b084      	sub	sp, #16
  403538:	af00      	add	r7, sp, #0
  40353a:	4603      	mov	r3, r0
  40353c:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  40353e:	79fb      	ldrb	r3, [r7, #7]
  403540:	4a0a      	ldr	r2, [pc, #40]	; (40356c <sleepmgr_lock_mode+0x38>)
  403542:	5cd3      	ldrb	r3, [r2, r3]
  403544:	2bff      	cmp	r3, #255	; 0xff
  403546:	d100      	bne.n	40354a <sleepmgr_lock_mode+0x16>
		while (true) {
  403548:	e7fe      	b.n	403548 <sleepmgr_lock_mode+0x14>
			// Check APP or change the data type to uint16_t.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  40354a:	4b09      	ldr	r3, [pc, #36]	; (403570 <sleepmgr_lock_mode+0x3c>)
  40354c:	4798      	blx	r3
  40354e:	60f8      	str	r0, [r7, #12]

	++sleepmgr_locks[mode];
  403550:	79fb      	ldrb	r3, [r7, #7]
  403552:	4a06      	ldr	r2, [pc, #24]	; (40356c <sleepmgr_lock_mode+0x38>)
  403554:	5cd2      	ldrb	r2, [r2, r3]
  403556:	3201      	adds	r2, #1
  403558:	b2d1      	uxtb	r1, r2
  40355a:	4a04      	ldr	r2, [pc, #16]	; (40356c <sleepmgr_lock_mode+0x38>)
  40355c:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  40355e:	68f8      	ldr	r0, [r7, #12]
  403560:	4b04      	ldr	r3, [pc, #16]	; (403574 <sleepmgr_lock_mode+0x40>)
  403562:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  403564:	bf00      	nop
  403566:	3710      	adds	r7, #16
  403568:	46bd      	mov	sp, r7
  40356a:	bd80      	pop	{r7, pc}
  40356c:	200028b8 	.word	0x200028b8
  403570:	00403495 	.word	0x00403495
  403574:	004034ed 	.word	0x004034ed

00403578 <osc_get_rate>:
{
  403578:	b480      	push	{r7}
  40357a:	b083      	sub	sp, #12
  40357c:	af00      	add	r7, sp, #0
  40357e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  403580:	687b      	ldr	r3, [r7, #4]
  403582:	2b07      	cmp	r3, #7
  403584:	d825      	bhi.n	4035d2 <osc_get_rate+0x5a>
  403586:	a201      	add	r2, pc, #4	; (adr r2, 40358c <osc_get_rate+0x14>)
  403588:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40358c:	004035ad 	.word	0x004035ad
  403590:	004035b3 	.word	0x004035b3
  403594:	004035b9 	.word	0x004035b9
  403598:	004035bf 	.word	0x004035bf
  40359c:	004035c3 	.word	0x004035c3
  4035a0:	004035c7 	.word	0x004035c7
  4035a4:	004035cb 	.word	0x004035cb
  4035a8:	004035cf 	.word	0x004035cf
		return OSC_SLCK_32K_RC_HZ;
  4035ac:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  4035b0:	e010      	b.n	4035d4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  4035b2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4035b6:	e00d      	b.n	4035d4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  4035b8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4035bc:	e00a      	b.n	4035d4 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  4035be:	4b08      	ldr	r3, [pc, #32]	; (4035e0 <osc_get_rate+0x68>)
  4035c0:	e008      	b.n	4035d4 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  4035c2:	4b08      	ldr	r3, [pc, #32]	; (4035e4 <osc_get_rate+0x6c>)
  4035c4:	e006      	b.n	4035d4 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  4035c6:	4b08      	ldr	r3, [pc, #32]	; (4035e8 <osc_get_rate+0x70>)
  4035c8:	e004      	b.n	4035d4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  4035ca:	2300      	movs	r3, #0
  4035cc:	e002      	b.n	4035d4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  4035ce:	2300      	movs	r3, #0
  4035d0:	e000      	b.n	4035d4 <osc_get_rate+0x5c>
	return 0;
  4035d2:	2300      	movs	r3, #0
}
  4035d4:	4618      	mov	r0, r3
  4035d6:	370c      	adds	r7, #12
  4035d8:	46bd      	mov	sp, r7
  4035da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4035de:	4770      	bx	lr
  4035e0:	007a1200 	.word	0x007a1200
  4035e4:	00f42400 	.word	0x00f42400
  4035e8:	016e3600 	.word	0x016e3600

004035ec <sysclk_get_main_hz>:
{
  4035ec:	b580      	push	{r7, lr}
  4035ee:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4035f0:	2001      	movs	r0, #1
  4035f2:	4b04      	ldr	r3, [pc, #16]	; (403604 <sysclk_get_main_hz+0x18>)
  4035f4:	4798      	blx	r3
  4035f6:	4602      	mov	r2, r0
  4035f8:	f640 634e 	movw	r3, #3662	; 0xe4e
  4035fc:	fb03 f302 	mul.w	r3, r3, r2
}
  403600:	4618      	mov	r0, r3
  403602:	bd80      	pop	{r7, pc}
  403604:	00403579 	.word	0x00403579

00403608 <sysclk_get_cpu_hz>:
{
  403608:	b580      	push	{r7, lr}
  40360a:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  40360c:	4b02      	ldr	r3, [pc, #8]	; (403618 <sysclk_get_cpu_hz+0x10>)
  40360e:	4798      	blx	r3
  403610:	4603      	mov	r3, r0
}
  403612:	4618      	mov	r0, r3
  403614:	bd80      	pop	{r7, pc}
  403616:	bf00      	nop
  403618:	004035ed 	.word	0x004035ed

0040361c <adc_get_config_defaults>:
 * - Only a Single Trigger is required to get an averaged value
 *
 * \param cfg Pointer to configuration structure to be initiated.
 */
void adc_get_config_defaults(struct adc_config *const cfg)
{
  40361c:	b580      	push	{r7, lr}
  40361e:	b082      	sub	sp, #8
  403620:	af00      	add	r7, sp, #0
  403622:	6078      	str	r0, [r7, #4]
	/* Sanity check argument. */
	Assert(cfg);

#if SAMG55
	cfg->resolution = ADC_12_BITS;
  403624:	687b      	ldr	r3, [r7, #4]
  403626:	2200      	movs	r2, #0
  403628:	601a      	str	r2, [r3, #0]
#else
	cfg->resolution = ADC_10_BITS;
#endif
	cfg->mck = sysclk_get_cpu_hz();
  40362a:	4b0f      	ldr	r3, [pc, #60]	; (403668 <adc_get_config_defaults+0x4c>)
  40362c:	4798      	blx	r3
  40362e:	4602      	mov	r2, r0
  403630:	687b      	ldr	r3, [r7, #4]
  403632:	605a      	str	r2, [r3, #4]
	cfg->adc_clock = 6000000UL;
  403634:	687b      	ldr	r3, [r7, #4]
  403636:	4a0d      	ldr	r2, [pc, #52]	; (40366c <adc_get_config_defaults+0x50>)
  403638:	609a      	str	r2, [r3, #8]
	cfg->startup_time = ADC_STARTUP_TIME_4;
  40363a:	687b      	ldr	r3, [r7, #4]
  40363c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  403640:	60da      	str	r2, [r3, #12]
	cfg->tracktim = 2;
  403642:	687b      	ldr	r3, [r7, #4]
  403644:	2202      	movs	r2, #2
  403646:	741a      	strb	r2, [r3, #16]
	cfg->transfer = 2;
  403648:	687b      	ldr	r3, [r7, #4]
  40364a:	2202      	movs	r2, #2
  40364c:	745a      	strb	r2, [r3, #17]
	cfg->useq = false;
  40364e:	687b      	ldr	r3, [r7, #4]
  403650:	2200      	movs	r2, #0
  403652:	749a      	strb	r2, [r3, #18]
	cfg->tag = false;
  403654:	687b      	ldr	r3, [r7, #4]
  403656:	2200      	movs	r2, #0
  403658:	74da      	strb	r2, [r3, #19]
	cfg->aste = false;
  40365a:	687b      	ldr	r3, [r7, #4]
  40365c:	2200      	movs	r2, #0
  40365e:	751a      	strb	r2, [r3, #20]
}
  403660:	bf00      	nop
  403662:	3708      	adds	r7, #8
  403664:	46bd      	mov	sp, r7
  403666:	bd80      	pop	{r7, pc}
  403668:	00403609 	.word	0x00403609
  40366c:	005b8d80 	.word	0x005b8d80

00403670 <adc_set_config>:
 *
 * \param adc  Base address of the ADC
 * \param config   Configuration for the ADC
 */
static void adc_set_config(Adc *const adc, struct adc_config *config)
{
  403670:	b580      	push	{r7, lr}
  403672:	b084      	sub	sp, #16
  403674:	af00      	add	r7, sp, #0
  403676:	6078      	str	r0, [r7, #4]
  403678:	6039      	str	r1, [r7, #0]
	uint32_t reg = 0;
  40367a:	2300      	movs	r3, #0
  40367c:	60fb      	str	r3, [r7, #12]

	reg =  (config->useq ? ADC_MR_USEQ_REG_ORDER : 0) |
  40367e:	683b      	ldr	r3, [r7, #0]
  403680:	7c9b      	ldrb	r3, [r3, #18]
  403682:	2b00      	cmp	r3, #0
  403684:	d002      	beq.n	40368c <adc_set_config+0x1c>
  403686:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  40368a:	e000      	b.n	40368e <adc_set_config+0x1e>
  40368c:	2200      	movs	r2, #0
			ADC_MR_PRESCAL(config->mck /
  40368e:	683b      	ldr	r3, [r7, #0]
  403690:	6859      	ldr	r1, [r3, #4]
  403692:	683b      	ldr	r3, [r7, #0]
  403694:	689b      	ldr	r3, [r3, #8]
  403696:	005b      	lsls	r3, r3, #1
  403698:	fbb1 f3f3 	udiv	r3, r1, r3
  40369c:	3b01      	subs	r3, #1
  40369e:	021b      	lsls	r3, r3, #8
  4036a0:	b29b      	uxth	r3, r3
	reg =  (config->useq ? ADC_MR_USEQ_REG_ORDER : 0) |
  4036a2:	431a      	orrs	r2, r3
			(2 * config->adc_clock) - 1) |
			ADC_MR_TRACKTIM(config->tracktim) |
  4036a4:	683b      	ldr	r3, [r7, #0]
  4036a6:	7c1b      	ldrb	r3, [r3, #16]
  4036a8:	061b      	lsls	r3, r3, #24
  4036aa:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
			(2 * config->adc_clock) - 1) |
  4036ae:	431a      	orrs	r2, r3
			ADC_MR_TRANSFER(config->transfer) |
  4036b0:	683b      	ldr	r3, [r7, #0]
  4036b2:	7c5b      	ldrb	r3, [r3, #17]
  4036b4:	071b      	lsls	r3, r3, #28
  4036b6:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
			ADC_MR_TRACKTIM(config->tracktim) |
  4036ba:	431a      	orrs	r2, r3
			(config->startup_time);
  4036bc:	683b      	ldr	r3, [r7, #0]
  4036be:	68db      	ldr	r3, [r3, #12]
	reg =  (config->useq ? ADC_MR_USEQ_REG_ORDER : 0) |
  4036c0:	4313      	orrs	r3, r2
  4036c2:	60fb      	str	r3, [r7, #12]

	adc->ADC_MR = reg;
  4036c4:	687b      	ldr	r3, [r7, #4]
  4036c6:	68fa      	ldr	r2, [r7, #12]
  4036c8:	605a      	str	r2, [r3, #4]

	adc->ADC_EMR = (config->tag ? ADC_EMR_TAG : 0) |
  4036ca:	683b      	ldr	r3, [r7, #0]
  4036cc:	7cdb      	ldrb	r3, [r3, #19]
  4036ce:	2b00      	cmp	r3, #0
  4036d0:	d002      	beq.n	4036d8 <adc_set_config+0x68>
  4036d2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  4036d6:	e000      	b.n	4036da <adc_set_config+0x6a>
  4036d8:	2200      	movs	r2, #0
			(config->aste ? ADC_EMR_ASTE_SINGLE_TRIG_AVERAGE : 0);
  4036da:	683b      	ldr	r3, [r7, #0]
  4036dc:	7d1b      	ldrb	r3, [r3, #20]
  4036de:	2b00      	cmp	r3, #0
  4036e0:	d002      	beq.n	4036e8 <adc_set_config+0x78>
  4036e2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  4036e6:	e000      	b.n	4036ea <adc_set_config+0x7a>
  4036e8:	2300      	movs	r3, #0
	adc->ADC_EMR = (config->tag ? ADC_EMR_TAG : 0) |
  4036ea:	431a      	orrs	r2, r3
  4036ec:	687b      	ldr	r3, [r7, #4]
  4036ee:	641a      	str	r2, [r3, #64]	; 0x40

	adc_set_resolution(adc, config->resolution);
  4036f0:	683b      	ldr	r3, [r7, #0]
  4036f2:	681b      	ldr	r3, [r3, #0]
  4036f4:	4619      	mov	r1, r3
  4036f6:	6878      	ldr	r0, [r7, #4]
  4036f8:	4b02      	ldr	r3, [pc, #8]	; (403704 <adc_set_config+0x94>)
  4036fa:	4798      	blx	r3
}
  4036fc:	bf00      	nop
  4036fe:	3710      	adds	r7, #16
  403700:	46bd      	mov	sp, r7
  403702:	bd80      	pop	{r7, pc}
  403704:	00403769 	.word	0x00403769

00403708 <adc_init>:
 *
 * \retval STATUS_OK  Initialization is finished.
 * \retval STATUS_ERR_BUSY  Initialization failed.
 */
enum status_code adc_init(Adc *const adc, struct adc_config *config)
{
  403708:	b580      	push	{r7, lr}
  40370a:	b084      	sub	sp, #16
  40370c:	af00      	add	r7, sp, #0
  40370e:	6078      	str	r0, [r7, #4]
  403710:	6039      	str	r1, [r7, #0]
	Assert(adc);
	Assert(config);

	if ((adc_get_interrupt_status(adc) & ADC_ISR_DRDY) == ADC_ISR_DRDY) {
  403712:	6878      	ldr	r0, [r7, #4]
  403714:	4b11      	ldr	r3, [pc, #68]	; (40375c <adc_init+0x54>)
  403716:	4798      	blx	r3
  403718:	4603      	mov	r3, r0
  40371a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  40371e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  403722:	d101      	bne.n	403728 <adc_init+0x20>
		return STATUS_ERR_BUSY;
  403724:	2319      	movs	r3, #25
  403726:	e015      	b.n	403754 <adc_init+0x4c>
	}

	/* Reset and configure the ADC module */
	adc->ADC_CR = ADC_CR_SWRST;
  403728:	687b      	ldr	r3, [r7, #4]
  40372a:	2201      	movs	r2, #1
  40372c:	601a      	str	r2, [r3, #0]
	adc_set_config(adc, config);
  40372e:	6839      	ldr	r1, [r7, #0]
  403730:	6878      	ldr	r0, [r7, #4]
  403732:	4b0b      	ldr	r3, [pc, #44]	; (403760 <adc_init+0x58>)
  403734:	4798      	blx	r3

	uint32_t i;
	for (i = 0; i < ADC_NUM_OF_INTERRUPT_SOURCE; i++) {
  403736:	2300      	movs	r3, #0
  403738:	60fb      	str	r3, [r7, #12]
  40373a:	e007      	b.n	40374c <adc_init+0x44>
		adc_callback_pointer[i] = 0;
  40373c:	4a09      	ldr	r2, [pc, #36]	; (403764 <adc_init+0x5c>)
  40373e:	68fb      	ldr	r3, [r7, #12]
  403740:	2100      	movs	r1, #0
  403742:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	for (i = 0; i < ADC_NUM_OF_INTERRUPT_SOURCE; i++) {
  403746:	68fb      	ldr	r3, [r7, #12]
  403748:	3301      	adds	r3, #1
  40374a:	60fb      	str	r3, [r7, #12]
  40374c:	68fb      	ldr	r3, [r7, #12]
  40374e:	2b17      	cmp	r3, #23
  403750:	d9f4      	bls.n	40373c <adc_init+0x34>
	}

	return STATUS_OK;
  403752:	2300      	movs	r3, #0
}
  403754:	4618      	mov	r0, r3
  403756:	3710      	adds	r7, #16
  403758:	46bd      	mov	sp, r7
  40375a:	bd80      	pop	{r7, pc}
  40375c:	0040351d 	.word	0x0040351d
  403760:	00403671 	.word	0x00403671
  403764:	200028e0 	.word	0x200028e0

00403768 <adc_set_resolution>:
 * \param res Conversion resolution.
 *
 */
void adc_set_resolution(Adc *const adc,
		const enum adc_resolution res)
{
  403768:	b480      	push	{r7}
  40376a:	b083      	sub	sp, #12
  40376c:	af00      	add	r7, sp, #0
  40376e:	6078      	str	r0, [r7, #4]
  403770:	6039      	str	r1, [r7, #0]
#if SAMG55
	adc->ADC_EMR |= res;
  403772:	687b      	ldr	r3, [r7, #4]
  403774:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  403776:	683b      	ldr	r3, [r7, #0]
  403778:	431a      	orrs	r2, r3
  40377a:	687b      	ldr	r3, [r7, #4]
  40377c:	641a      	str	r2, [r3, #64]	; 0x40
	} else {
		adc->ADC_MR |= res;
		adc->ADC_EMR &= ~ADC_EMR_OSR_Msk;
	}
#endif
}
  40377e:	bf00      	nop
  403780:	370c      	adds	r7, #12
  403782:	46bd      	mov	sp, r7
  403784:	f85d 7b04 	ldr.w	r7, [sp], #4
  403788:	4770      	bx	lr
	...

0040378c <adc_interrupt>:
 *
 * \param inst_num ADC instance number to handle interrupt for
 * \param source   Interrupt source number
 */
static void adc_interrupt(enum adc_interrupt_source source)
{
  40378c:	b580      	push	{r7, lr}
  40378e:	b082      	sub	sp, #8
  403790:	af00      	add	r7, sp, #0
  403792:	6078      	str	r0, [r7, #4]
	if (adc_callback_pointer[source]) {
  403794:	4a07      	ldr	r2, [pc, #28]	; (4037b4 <adc_interrupt+0x28>)
  403796:	687b      	ldr	r3, [r7, #4]
  403798:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40379c:	2b00      	cmp	r3, #0
  40379e:	d004      	beq.n	4037aa <adc_interrupt+0x1e>
		adc_callback_pointer[source]();
  4037a0:	4a04      	ldr	r2, [pc, #16]	; (4037b4 <adc_interrupt+0x28>)
  4037a2:	687b      	ldr	r3, [r7, #4]
  4037a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4037a8:	4798      	blx	r3
	}
}
  4037aa:	bf00      	nop
  4037ac:	3708      	adds	r7, #8
  4037ae:	46bd      	mov	sp, r7
  4037b0:	bd80      	pop	{r7, pc}
  4037b2:	bf00      	nop
  4037b4:	200028e0 	.word	0x200028e0

004037b8 <adc_process_callback>:
 * \brief Call the callback function if the corresponding interrupt is asserted
 *
 * \param adc  Base address of the ADC.
 */
static void adc_process_callback(Adc *const adc)
{
  4037b8:	b580      	push	{r7, lr}
  4037ba:	b084      	sub	sp, #16
  4037bc:	af00      	add	r7, sp, #0
  4037be:	6078      	str	r0, [r7, #4]
	volatile uint32_t status;
	uint32_t cnt;

	status = adc_get_interrupt_status(adc);
  4037c0:	6878      	ldr	r0, [r7, #4]
  4037c2:	4b0e      	ldr	r3, [pc, #56]	; (4037fc <adc_process_callback+0x44>)
  4037c4:	4798      	blx	r3
  4037c6:	4603      	mov	r3, r0
  4037c8:	60bb      	str	r3, [r7, #8]

	for (cnt = 0; cnt < ADC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  4037ca:	2300      	movs	r3, #0
  4037cc:	60fb      	str	r3, [r7, #12]
  4037ce:	e00d      	b.n	4037ec <adc_process_callback+0x34>
		if (status & adc_interrupt_mask[cnt]) {
  4037d0:	4a0b      	ldr	r2, [pc, #44]	; (403800 <adc_process_callback+0x48>)
  4037d2:	68fb      	ldr	r3, [r7, #12]
  4037d4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  4037d8:	68bb      	ldr	r3, [r7, #8]
  4037da:	4013      	ands	r3, r2
  4037dc:	2b00      	cmp	r3, #0
  4037de:	d002      	beq.n	4037e6 <adc_process_callback+0x2e>
			adc_interrupt((enum adc_interrupt_source)cnt);
  4037e0:	68f8      	ldr	r0, [r7, #12]
  4037e2:	4b08      	ldr	r3, [pc, #32]	; (403804 <adc_process_callback+0x4c>)
  4037e4:	4798      	blx	r3
	for (cnt = 0; cnt < ADC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  4037e6:	68fb      	ldr	r3, [r7, #12]
  4037e8:	3301      	adds	r3, #1
  4037ea:	60fb      	str	r3, [r7, #12]
  4037ec:	68fb      	ldr	r3, [r7, #12]
  4037ee:	2b17      	cmp	r3, #23
  4037f0:	d9ee      	bls.n	4037d0 <adc_process_callback+0x18>
		}
	}
}
  4037f2:	bf00      	nop
  4037f4:	3710      	adds	r7, #16
  4037f6:	46bd      	mov	sp, r7
  4037f8:	bd80      	pop	{r7, pc}
  4037fa:	bf00      	nop
  4037fc:	0040351d 	.word	0x0040351d
  403800:	0040d2c8 	.word	0x0040d2c8
  403804:	0040378d 	.word	0x0040378d

00403808 <ADC_Handler>:

/**
 * \brief Interrupt handler for ADC.
 */
void ADC_Handler(void)
{
  403808:	b580      	push	{r7, lr}
  40380a:	af00      	add	r7, sp, #0
	adc_process_callback(ADC);
  40380c:	4802      	ldr	r0, [pc, #8]	; (403818 <ADC_Handler+0x10>)
  40380e:	4b03      	ldr	r3, [pc, #12]	; (40381c <ADC_Handler+0x14>)
  403810:	4798      	blx	r3
}
  403812:	bf00      	nop
  403814:	bd80      	pop	{r7, pc}
  403816:	bf00      	nop
  403818:	40038000 	.word	0x40038000
  40381c:	004037b9 	.word	0x004037b9

00403820 <adc_enable>:
/**
 * \brief Enable ADC Module.
 *
 */
void adc_enable(void)
{
  403820:	b580      	push	{r7, lr}
  403822:	af00      	add	r7, sp, #0
	/* Enable peripheral clock. */
	pmc_enable_periph_clk(ID_ADC);
  403824:	201d      	movs	r0, #29
  403826:	4b03      	ldr	r3, [pc, #12]	; (403834 <adc_enable+0x14>)
  403828:	4798      	blx	r3
	sleepmgr_lock_mode(SLEEP_MODE_ADC);
  40382a:	2000      	movs	r0, #0
  40382c:	4b02      	ldr	r3, [pc, #8]	; (403838 <adc_enable+0x18>)
  40382e:	4798      	blx	r3
}
  403830:	bf00      	nop
  403832:	bd80      	pop	{r7, pc}
  403834:	00404459 	.word	0x00404459
  403838:	00403535 	.word	0x00403535

0040383c <cpu_irq_save>:
{
  40383c:	b480      	push	{r7}
  40383e:	b083      	sub	sp, #12
  403840:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403842:	f3ef 8310 	mrs	r3, PRIMASK
  403846:	607b      	str	r3, [r7, #4]
  return(result);
  403848:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  40384a:	2b00      	cmp	r3, #0
  40384c:	bf0c      	ite	eq
  40384e:	2301      	moveq	r3, #1
  403850:	2300      	movne	r3, #0
  403852:	b2db      	uxtb	r3, r3
  403854:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  403856:	b672      	cpsid	i
  403858:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  40385c:	4b04      	ldr	r3, [pc, #16]	; (403870 <cpu_irq_save+0x34>)
  40385e:	2200      	movs	r2, #0
  403860:	701a      	strb	r2, [r3, #0]
	return flags;
  403862:	683b      	ldr	r3, [r7, #0]
}
  403864:	4618      	mov	r0, r3
  403866:	370c      	adds	r7, #12
  403868:	46bd      	mov	sp, r7
  40386a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40386e:	4770      	bx	lr
  403870:	20000114 	.word	0x20000114

00403874 <cpu_irq_is_enabled_flags>:
{
  403874:	b480      	push	{r7}
  403876:	b083      	sub	sp, #12
  403878:	af00      	add	r7, sp, #0
  40387a:	6078      	str	r0, [r7, #4]
	return (flags);
  40387c:	687b      	ldr	r3, [r7, #4]
  40387e:	2b00      	cmp	r3, #0
  403880:	bf14      	ite	ne
  403882:	2301      	movne	r3, #1
  403884:	2300      	moveq	r3, #0
  403886:	b2db      	uxtb	r3, r3
}
  403888:	4618      	mov	r0, r3
  40388a:	370c      	adds	r7, #12
  40388c:	46bd      	mov	sp, r7
  40388e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403892:	4770      	bx	lr

00403894 <cpu_irq_restore>:
{
  403894:	b580      	push	{r7, lr}
  403896:	b082      	sub	sp, #8
  403898:	af00      	add	r7, sp, #0
  40389a:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  40389c:	6878      	ldr	r0, [r7, #4]
  40389e:	4b07      	ldr	r3, [pc, #28]	; (4038bc <cpu_irq_restore+0x28>)
  4038a0:	4798      	blx	r3
  4038a2:	4603      	mov	r3, r0
  4038a4:	2b00      	cmp	r3, #0
  4038a6:	d005      	beq.n	4038b4 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4038a8:	4b05      	ldr	r3, [pc, #20]	; (4038c0 <cpu_irq_restore+0x2c>)
  4038aa:	2201      	movs	r2, #1
  4038ac:	701a      	strb	r2, [r3, #0]
  4038ae:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4038b2:	b662      	cpsie	i
}
  4038b4:	bf00      	nop
  4038b6:	3708      	adds	r7, #8
  4038b8:	46bd      	mov	sp, r7
  4038ba:	bd80      	pop	{r7, pc}
  4038bc:	00403875 	.word	0x00403875
  4038c0:	20000114 	.word	0x20000114

004038c4 <sysclk_enable_peripheral_clock>:
{
  4038c4:	b580      	push	{r7, lr}
  4038c6:	b082      	sub	sp, #8
  4038c8:	af00      	add	r7, sp, #0
  4038ca:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4038cc:	6878      	ldr	r0, [r7, #4]
  4038ce:	4b03      	ldr	r3, [pc, #12]	; (4038dc <sysclk_enable_peripheral_clock+0x18>)
  4038d0:	4798      	blx	r3
}
  4038d2:	bf00      	nop
  4038d4:	3708      	adds	r7, #8
  4038d6:	46bd      	mov	sp, r7
  4038d8:	bd80      	pop	{r7, pc}
  4038da:	bf00      	nop
  4038dc:	00404459 	.word	0x00404459

004038e0 <sleepmgr_lock_mode>:
{
  4038e0:	b580      	push	{r7, lr}
  4038e2:	b084      	sub	sp, #16
  4038e4:	af00      	add	r7, sp, #0
  4038e6:	4603      	mov	r3, r0
  4038e8:	71fb      	strb	r3, [r7, #7]
	if(sleepmgr_locks[mode] >= 0xff) {
  4038ea:	79fb      	ldrb	r3, [r7, #7]
  4038ec:	4a0a      	ldr	r2, [pc, #40]	; (403918 <sleepmgr_lock_mode+0x38>)
  4038ee:	5cd3      	ldrb	r3, [r2, r3]
  4038f0:	2bff      	cmp	r3, #255	; 0xff
  4038f2:	d100      	bne.n	4038f6 <sleepmgr_lock_mode+0x16>
		while (true) {
  4038f4:	e7fe      	b.n	4038f4 <sleepmgr_lock_mode+0x14>
	flags = cpu_irq_save();
  4038f6:	4b09      	ldr	r3, [pc, #36]	; (40391c <sleepmgr_lock_mode+0x3c>)
  4038f8:	4798      	blx	r3
  4038fa:	60f8      	str	r0, [r7, #12]
	++sleepmgr_locks[mode];
  4038fc:	79fb      	ldrb	r3, [r7, #7]
  4038fe:	4a06      	ldr	r2, [pc, #24]	; (403918 <sleepmgr_lock_mode+0x38>)
  403900:	5cd2      	ldrb	r2, [r2, r3]
  403902:	3201      	adds	r2, #1
  403904:	b2d1      	uxtb	r1, r2
  403906:	4a04      	ldr	r2, [pc, #16]	; (403918 <sleepmgr_lock_mode+0x38>)
  403908:	54d1      	strb	r1, [r2, r3]
	cpu_irq_restore(flags);
  40390a:	68f8      	ldr	r0, [r7, #12]
  40390c:	4b04      	ldr	r3, [pc, #16]	; (403920 <sleepmgr_lock_mode+0x40>)
  40390e:	4798      	blx	r3
}
  403910:	bf00      	nop
  403912:	3710      	adds	r7, #16
  403914:	46bd      	mov	sp, r7
  403916:	bd80      	pop	{r7, pc}
  403918:	200028b8 	.word	0x200028b8
  40391c:	0040383d 	.word	0x0040383d
  403920:	00403895 	.word	0x00403895

00403924 <flexcom_enable>:
 *
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 *
 */
void flexcom_enable(Flexcom *p_flexcom)
{
  403924:	b580      	push	{r7, lr}
  403926:	b082      	sub	sp, #8
  403928:	af00      	add	r7, sp, #0
  40392a:	6078      	str	r0, [r7, #4]
#if SAMG55
    #define PMC_PCK_PRES_CLK_1  PMC_PCK_PRES(0)
#endif

	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);
  40392c:	2000      	movs	r0, #0
  40392e:	4b4a      	ldr	r3, [pc, #296]	; (403a58 <flexcom_enable+0x134>)
  403930:	4798      	blx	r3
	/* Enable PMC clock for FLEXCOM */
#ifdef ID_FLEXCOM7
	 if (p_flexcom == FLEXCOM7) {
  403932:	687b      	ldr	r3, [r7, #4]
  403934:	4a49      	ldr	r2, [pc, #292]	; (403a5c <flexcom_enable+0x138>)
  403936:	4293      	cmp	r3, r2
  403938:	d10d      	bne.n	403956 <flexcom_enable+0x32>
		sysclk_enable_peripheral_clock(ID_FLEXCOM7);
  40393a:	2007      	movs	r0, #7
  40393c:	4b48      	ldr	r3, [pc, #288]	; (403a60 <flexcom_enable+0x13c>)
  40393e:	4798      	blx	r3
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  403940:	2007      	movs	r0, #7
  403942:	4b48      	ldr	r3, [pc, #288]	; (403a64 <flexcom_enable+0x140>)
  403944:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  403946:	2100      	movs	r1, #0
  403948:	2007      	movs	r0, #7
  40394a:	4b47      	ldr	r3, [pc, #284]	; (403a68 <flexcom_enable+0x144>)
  40394c:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  40394e:	2007      	movs	r0, #7
  403950:	4b46      	ldr	r3, [pc, #280]	; (403a6c <flexcom_enable+0x148>)
  403952:	4798      	blx	r3
	} else
#endif
	{
		Assert(false);
	}
}
  403954:	e07c      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM6) {
  403956:	687b      	ldr	r3, [r7, #4]
  403958:	4a45      	ldr	r2, [pc, #276]	; (403a70 <flexcom_enable+0x14c>)
  40395a:	4293      	cmp	r3, r2
  40395c:	d10d      	bne.n	40397a <flexcom_enable+0x56>
		sysclk_enable_peripheral_clock(ID_FLEXCOM6);
  40395e:	2016      	movs	r0, #22
  403960:	4b3f      	ldr	r3, [pc, #252]	; (403a60 <flexcom_enable+0x13c>)
  403962:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  403964:	2007      	movs	r0, #7
  403966:	4b3f      	ldr	r3, [pc, #252]	; (403a64 <flexcom_enable+0x140>)
  403968:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40396a:	2100      	movs	r1, #0
  40396c:	2007      	movs	r0, #7
  40396e:	4b3e      	ldr	r3, [pc, #248]	; (403a68 <flexcom_enable+0x144>)
  403970:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403972:	2007      	movs	r0, #7
  403974:	4b3d      	ldr	r3, [pc, #244]	; (403a6c <flexcom_enable+0x148>)
  403976:	4798      	blx	r3
}
  403978:	e06a      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM5) {
  40397a:	687b      	ldr	r3, [r7, #4]
  40397c:	4a3d      	ldr	r2, [pc, #244]	; (403a74 <flexcom_enable+0x150>)
  40397e:	4293      	cmp	r3, r2
  403980:	d10d      	bne.n	40399e <flexcom_enable+0x7a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM5);
  403982:	2015      	movs	r0, #21
  403984:	4b36      	ldr	r3, [pc, #216]	; (403a60 <flexcom_enable+0x13c>)
  403986:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  403988:	2007      	movs	r0, #7
  40398a:	4b36      	ldr	r3, [pc, #216]	; (403a64 <flexcom_enable+0x140>)
  40398c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40398e:	2100      	movs	r1, #0
  403990:	2007      	movs	r0, #7
  403992:	4b35      	ldr	r3, [pc, #212]	; (403a68 <flexcom_enable+0x144>)
  403994:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403996:	2007      	movs	r0, #7
  403998:	4b34      	ldr	r3, [pc, #208]	; (403a6c <flexcom_enable+0x148>)
  40399a:	4798      	blx	r3
}
  40399c:	e058      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM4) {
  40399e:	687b      	ldr	r3, [r7, #4]
  4039a0:	4a35      	ldr	r2, [pc, #212]	; (403a78 <flexcom_enable+0x154>)
  4039a2:	4293      	cmp	r3, r2
  4039a4:	d10d      	bne.n	4039c2 <flexcom_enable+0x9e>
		sysclk_enable_peripheral_clock(ID_FLEXCOM4);
  4039a6:	2014      	movs	r0, #20
  4039a8:	4b2d      	ldr	r3, [pc, #180]	; (403a60 <flexcom_enable+0x13c>)
  4039aa:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  4039ac:	2007      	movs	r0, #7
  4039ae:	4b2d      	ldr	r3, [pc, #180]	; (403a64 <flexcom_enable+0x140>)
  4039b0:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4039b2:	2100      	movs	r1, #0
  4039b4:	2007      	movs	r0, #7
  4039b6:	4b2c      	ldr	r3, [pc, #176]	; (403a68 <flexcom_enable+0x144>)
  4039b8:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4039ba:	2007      	movs	r0, #7
  4039bc:	4b2b      	ldr	r3, [pc, #172]	; (403a6c <flexcom_enable+0x148>)
  4039be:	4798      	blx	r3
}
  4039c0:	e046      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM3) {
  4039c2:	687b      	ldr	r3, [r7, #4]
  4039c4:	4a2d      	ldr	r2, [pc, #180]	; (403a7c <flexcom_enable+0x158>)
  4039c6:	4293      	cmp	r3, r2
  4039c8:	d10d      	bne.n	4039e6 <flexcom_enable+0xc2>
		sysclk_enable_peripheral_clock(ID_FLEXCOM3);
  4039ca:	2013      	movs	r0, #19
  4039cc:	4b24      	ldr	r3, [pc, #144]	; (403a60 <flexcom_enable+0x13c>)
  4039ce:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  4039d0:	2006      	movs	r0, #6
  4039d2:	4b24      	ldr	r3, [pc, #144]	; (403a64 <flexcom_enable+0x140>)
  4039d4:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4039d6:	2100      	movs	r1, #0
  4039d8:	2006      	movs	r0, #6
  4039da:	4b23      	ldr	r3, [pc, #140]	; (403a68 <flexcom_enable+0x144>)
  4039dc:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4039de:	2006      	movs	r0, #6
  4039e0:	4b22      	ldr	r3, [pc, #136]	; (403a6c <flexcom_enable+0x148>)
  4039e2:	4798      	blx	r3
}
  4039e4:	e034      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM2) {
  4039e6:	687b      	ldr	r3, [r7, #4]
  4039e8:	4a25      	ldr	r2, [pc, #148]	; (403a80 <flexcom_enable+0x15c>)
  4039ea:	4293      	cmp	r3, r2
  4039ec:	d10d      	bne.n	403a0a <flexcom_enable+0xe6>
		sysclk_enable_peripheral_clock(ID_FLEXCOM2);
  4039ee:	200e      	movs	r0, #14
  4039f0:	4b1b      	ldr	r3, [pc, #108]	; (403a60 <flexcom_enable+0x13c>)
  4039f2:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  4039f4:	2006      	movs	r0, #6
  4039f6:	4b1b      	ldr	r3, [pc, #108]	; (403a64 <flexcom_enable+0x140>)
  4039f8:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4039fa:	2100      	movs	r1, #0
  4039fc:	2006      	movs	r0, #6
  4039fe:	4b1a      	ldr	r3, [pc, #104]	; (403a68 <flexcom_enable+0x144>)
  403a00:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  403a02:	2006      	movs	r0, #6
  403a04:	4b19      	ldr	r3, [pc, #100]	; (403a6c <flexcom_enable+0x148>)
  403a06:	4798      	blx	r3
}
  403a08:	e022      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM1) {
  403a0a:	687b      	ldr	r3, [r7, #4]
  403a0c:	4a1d      	ldr	r2, [pc, #116]	; (403a84 <flexcom_enable+0x160>)
  403a0e:	4293      	cmp	r3, r2
  403a10:	d10d      	bne.n	403a2e <flexcom_enable+0x10a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM1);
  403a12:	2009      	movs	r0, #9
  403a14:	4b12      	ldr	r3, [pc, #72]	; (403a60 <flexcom_enable+0x13c>)
  403a16:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403a18:	2006      	movs	r0, #6
  403a1a:	4b12      	ldr	r3, [pc, #72]	; (403a64 <flexcom_enable+0x140>)
  403a1c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403a1e:	2100      	movs	r1, #0
  403a20:	2006      	movs	r0, #6
  403a22:	4b11      	ldr	r3, [pc, #68]	; (403a68 <flexcom_enable+0x144>)
  403a24:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  403a26:	2006      	movs	r0, #6
  403a28:	4b10      	ldr	r3, [pc, #64]	; (403a6c <flexcom_enable+0x148>)
  403a2a:	4798      	blx	r3
}
  403a2c:	e010      	b.n	403a50 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM0) {
  403a2e:	687b      	ldr	r3, [r7, #4]
  403a30:	4a15      	ldr	r2, [pc, #84]	; (403a88 <flexcom_enable+0x164>)
  403a32:	4293      	cmp	r3, r2
  403a34:	d10c      	bne.n	403a50 <flexcom_enable+0x12c>
		sysclk_enable_peripheral_clock(ID_FLEXCOM0);
  403a36:	2008      	movs	r0, #8
  403a38:	4b09      	ldr	r3, [pc, #36]	; (403a60 <flexcom_enable+0x13c>)
  403a3a:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403a3c:	2006      	movs	r0, #6
  403a3e:	4b09      	ldr	r3, [pc, #36]	; (403a64 <flexcom_enable+0x140>)
  403a40:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403a42:	2100      	movs	r1, #0
  403a44:	2006      	movs	r0, #6
  403a46:	4b08      	ldr	r3, [pc, #32]	; (403a68 <flexcom_enable+0x144>)
  403a48:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  403a4a:	2006      	movs	r0, #6
  403a4c:	4b07      	ldr	r3, [pc, #28]	; (403a6c <flexcom_enable+0x148>)
  403a4e:	4798      	blx	r3
}
  403a50:	bf00      	nop
  403a52:	3708      	adds	r7, #8
  403a54:	46bd      	mov	sp, r7
  403a56:	bd80      	pop	{r7, pc}
  403a58:	004038e1 	.word	0x004038e1
  403a5c:	40034000 	.word	0x40034000
  403a60:	004038c5 	.word	0x004038c5
  403a64:	004045b5 	.word	0x004045b5
  403a68:	00404535 	.word	0x00404535
  403a6c:	0040458d 	.word	0x0040458d
  403a70:	40040000 	.word	0x40040000
  403a74:	40008000 	.word	0x40008000
  403a78:	4001c000 	.word	0x4001c000
  403a7c:	40018000 	.word	0x40018000
  403a80:	40024000 	.word	0x40024000
  403a84:	40020000 	.word	0x40020000
  403a88:	4000c000 	.word	0x4000c000

00403a8c <flexcom_set_opmode>:
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 * \param opmode  Opration mode.
 *
 */
void flexcom_set_opmode(Flexcom *p_flexcom, enum flexcom_opmode opmode)
{
  403a8c:	b480      	push	{r7}
  403a8e:	b083      	sub	sp, #12
  403a90:	af00      	add	r7, sp, #0
  403a92:	6078      	str	r0, [r7, #4]
  403a94:	460b      	mov	r3, r1
  403a96:	70fb      	strb	r3, [r7, #3]
	p_flexcom->FLEXCOM_MR = opmode;
  403a98:	78fa      	ldrb	r2, [r7, #3]
  403a9a:	687b      	ldr	r3, [r7, #4]
  403a9c:	601a      	str	r2, [r3, #0]
}
  403a9e:	bf00      	nop
  403aa0:	370c      	adds	r7, #12
  403aa2:	46bd      	mov	sp, r7
  403aa4:	f85d 7b04 	ldr.w	r7, [sp], #4
  403aa8:	4770      	bx	lr

00403aaa <pdc_rx_init>:
 */
void pdc_rx_init(
		Pdc *p_pdc,
		pdc_packet_t *p_packet,
		pdc_packet_t *p_next_packet)
{
  403aaa:	b480      	push	{r7}
  403aac:	b085      	sub	sp, #20
  403aae:	af00      	add	r7, sp, #0
  403ab0:	60f8      	str	r0, [r7, #12]
  403ab2:	60b9      	str	r1, [r7, #8]
  403ab4:	607a      	str	r2, [r7, #4]
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  403ab6:	68bb      	ldr	r3, [r7, #8]
  403ab8:	2b00      	cmp	r3, #0
  403aba:	d007      	beq.n	403acc <pdc_rx_init+0x22>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
  403abc:	68bb      	ldr	r3, [r7, #8]
  403abe:	681a      	ldr	r2, [r3, #0]
  403ac0:	68fb      	ldr	r3, [r7, #12]
  403ac2:	601a      	str	r2, [r3, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
  403ac4:	68bb      	ldr	r3, [r7, #8]
  403ac6:	685a      	ldr	r2, [r3, #4]
  403ac8:	68fb      	ldr	r3, [r7, #12]
  403aca:	605a      	str	r2, [r3, #4]
	}
	if (p_next_packet) {
  403acc:	687b      	ldr	r3, [r7, #4]
  403ace:	2b00      	cmp	r3, #0
  403ad0:	d007      	beq.n	403ae2 <pdc_rx_init+0x38>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
  403ad2:	687b      	ldr	r3, [r7, #4]
  403ad4:	681a      	ldr	r2, [r3, #0]
  403ad6:	68fb      	ldr	r3, [r7, #12]
  403ad8:	611a      	str	r2, [r3, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
  403ada:	687b      	ldr	r3, [r7, #4]
  403adc:	685a      	ldr	r2, [r3, #4]
  403ade:	68fb      	ldr	r3, [r7, #12]
  403ae0:	615a      	str	r2, [r3, #20]
	}
}
  403ae2:	bf00      	nop
  403ae4:	3714      	adds	r7, #20
  403ae6:	46bd      	mov	sp, r7
  403ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
  403aec:	4770      	bx	lr

00403aee <pdc_enable_transfer>:
 *                        (bit PERIPH_PTCR_RXTEN and bit PERIPH_PTCR_TXTEN)
 */
void pdc_enable_transfer(
		Pdc *p_pdc,
		uint32_t ul_controls)
{
  403aee:	b480      	push	{r7}
  403af0:	b083      	sub	sp, #12
  403af2:	af00      	add	r7, sp, #0
  403af4:	6078      	str	r0, [r7, #4]
  403af6:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
  403af8:	683a      	ldr	r2, [r7, #0]
  403afa:	f240 1301 	movw	r3, #257	; 0x101
  403afe:	4013      	ands	r3, r2
	p_pdc->PERIPH_PTCR =
  403b00:	687a      	ldr	r2, [r7, #4]
  403b02:	6213      	str	r3, [r2, #32]
}
  403b04:	bf00      	nop
  403b06:	370c      	adds	r7, #12
  403b08:	46bd      	mov	sp, r7
  403b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b0e:	4770      	bx	lr

00403b10 <pdc_disable_transfer>:
 *                        (bit PERIPH_PTCR_TXTDIS, bit PERIPH_PTCR_TXTDIS)
 */
void pdc_disable_transfer(
		Pdc *p_pdc,
		uint32_t ul_controls)
{
  403b10:	b480      	push	{r7}
  403b12:	b083      	sub	sp, #12
  403b14:	af00      	add	r7, sp, #0
  403b16:	6078      	str	r0, [r7, #4]
  403b18:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  403b1a:	683a      	ldr	r2, [r7, #0]
  403b1c:	f240 2302 	movw	r3, #514	; 0x202
  403b20:	4013      	ands	r3, r2
	p_pdc->PERIPH_PTCR =
  403b22:	687a      	ldr	r2, [r7, #4]
  403b24:	6213      	str	r3, [r2, #32]
}
  403b26:	bf00      	nop
  403b28:	370c      	adds	r7, #12
  403b2a:	46bd      	mov	sp, r7
  403b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b30:	4770      	bx	lr

00403b32 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  403b32:	b480      	push	{r7}
  403b34:	b085      	sub	sp, #20
  403b36:	af00      	add	r7, sp, #0
  403b38:	60f8      	str	r0, [r7, #12]
  403b3a:	60b9      	str	r1, [r7, #8]
  403b3c:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  403b3e:	687b      	ldr	r3, [r7, #4]
  403b40:	2b00      	cmp	r3, #0
  403b42:	d003      	beq.n	403b4c <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  403b44:	68fb      	ldr	r3, [r7, #12]
  403b46:	68ba      	ldr	r2, [r7, #8]
  403b48:	665a      	str	r2, [r3, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
	}
}
  403b4a:	e002      	b.n	403b52 <pio_pull_up+0x20>
		p_pio->PIO_PUDR = ul_mask;
  403b4c:	68fb      	ldr	r3, [r7, #12]
  403b4e:	68ba      	ldr	r2, [r7, #8]
  403b50:	661a      	str	r2, [r3, #96]	; 0x60
}
  403b52:	bf00      	nop
  403b54:	3714      	adds	r7, #20
  403b56:	46bd      	mov	sp, r7
  403b58:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b5c:	4770      	bx	lr

00403b5e <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  403b5e:	b480      	push	{r7}
  403b60:	b087      	sub	sp, #28
  403b62:	af00      	add	r7, sp, #0
  403b64:	60f8      	str	r0, [r7, #12]
  403b66:	60b9      	str	r1, [r7, #8]
  403b68:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  403b6a:	68fb      	ldr	r3, [r7, #12]
  403b6c:	687a      	ldr	r2, [r7, #4]
  403b6e:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  403b70:	68bb      	ldr	r3, [r7, #8]
  403b72:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403b76:	d02b      	beq.n	403bd0 <pio_set_peripheral+0x72>
  403b78:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403b7c:	d805      	bhi.n	403b8a <pio_set_peripheral+0x2c>
  403b7e:	2b00      	cmp	r3, #0
  403b80:	d03f      	beq.n	403c02 <pio_set_peripheral+0xa4>
  403b82:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  403b86:	d00a      	beq.n	403b9e <pio_set_peripheral+0x40>
  403b88:	e037      	b.n	403bfa <pio_set_peripheral+0x9c>
  403b8a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  403b8e:	d038      	beq.n	403c02 <pio_set_peripheral+0xa4>
  403b90:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403b94:	d035      	beq.n	403c02 <pio_set_peripheral+0xa4>
  403b96:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403b9a:	d032      	beq.n	403c02 <pio_set_peripheral+0xa4>
  403b9c:	e02d      	b.n	403bfa <pio_set_peripheral+0x9c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403b9e:	68fb      	ldr	r3, [r7, #12]
  403ba0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403ba2:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  403ba4:	68fb      	ldr	r3, [r7, #12]
  403ba6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403ba8:	687b      	ldr	r3, [r7, #4]
  403baa:	43d9      	mvns	r1, r3
  403bac:	697b      	ldr	r3, [r7, #20]
  403bae:	400b      	ands	r3, r1
  403bb0:	401a      	ands	r2, r3
  403bb2:	68fb      	ldr	r3, [r7, #12]
  403bb4:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403bb6:	68fb      	ldr	r3, [r7, #12]
  403bb8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403bba:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403bbc:	68fb      	ldr	r3, [r7, #12]
  403bbe:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403bc0:	687b      	ldr	r3, [r7, #4]
  403bc2:	43d9      	mvns	r1, r3
  403bc4:	697b      	ldr	r3, [r7, #20]
  403bc6:	400b      	ands	r3, r1
  403bc8:	401a      	ands	r2, r3
  403bca:	68fb      	ldr	r3, [r7, #12]
  403bcc:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403bce:	e014      	b.n	403bfa <pio_set_peripheral+0x9c>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403bd0:	68fb      	ldr	r3, [r7, #12]
  403bd2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403bd4:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  403bd6:	687a      	ldr	r2, [r7, #4]
  403bd8:	697b      	ldr	r3, [r7, #20]
  403bda:	431a      	orrs	r2, r3
  403bdc:	68fb      	ldr	r3, [r7, #12]
  403bde:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403be0:	68fb      	ldr	r3, [r7, #12]
  403be2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403be4:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403be6:	68fb      	ldr	r3, [r7, #12]
  403be8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403bea:	687b      	ldr	r3, [r7, #4]
  403bec:	43d9      	mvns	r1, r3
  403bee:	697b      	ldr	r3, [r7, #20]
  403bf0:	400b      	ands	r3, r1
  403bf2:	401a      	ands	r2, r3
  403bf4:	68fb      	ldr	r3, [r7, #12]
  403bf6:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403bf8:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  403bfa:	68fb      	ldr	r3, [r7, #12]
  403bfc:	687a      	ldr	r2, [r7, #4]
  403bfe:	605a      	str	r2, [r3, #4]
  403c00:	e000      	b.n	403c04 <pio_set_peripheral+0xa6>
		return;
  403c02:	bf00      	nop
}
  403c04:	371c      	adds	r7, #28
  403c06:	46bd      	mov	sp, r7
  403c08:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c0c:	4770      	bx	lr
	...

00403c10 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  403c10:	b580      	push	{r7, lr}
  403c12:	b084      	sub	sp, #16
  403c14:	af00      	add	r7, sp, #0
  403c16:	60f8      	str	r0, [r7, #12]
  403c18:	60b9      	str	r1, [r7, #8]
  403c1a:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  403c1c:	68b9      	ldr	r1, [r7, #8]
  403c1e:	68f8      	ldr	r0, [r7, #12]
  403c20:	4b15      	ldr	r3, [pc, #84]	; (403c78 <pio_set_input+0x68>)
  403c22:	4798      	blx	r3
	//--yd pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  403c24:	687b      	ldr	r3, [r7, #4]
  403c26:	f003 030a 	and.w	r3, r3, #10
  403c2a:	2b00      	cmp	r3, #0
  403c2c:	d003      	beq.n	403c36 <pio_set_input+0x26>
		p_pio->PIO_IFER = ul_mask;
  403c2e:	68fb      	ldr	r3, [r7, #12]
  403c30:	68ba      	ldr	r2, [r7, #8]
  403c32:	621a      	str	r2, [r3, #32]
  403c34:	e002      	b.n	403c3c <pio_set_input+0x2c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  403c36:	68fb      	ldr	r3, [r7, #12]
  403c38:	68ba      	ldr	r2, [r7, #8]
  403c3a:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  403c3c:	687b      	ldr	r3, [r7, #4]
  403c3e:	f003 0302 	and.w	r3, r3, #2
  403c42:	2b00      	cmp	r3, #0
  403c44:	d004      	beq.n	403c50 <pio_set_input+0x40>
		p_pio->PIO_IFSCDR = ul_mask;
  403c46:	68fb      	ldr	r3, [r7, #12]
  403c48:	68ba      	ldr	r2, [r7, #8]
  403c4a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  403c4e:	e008      	b.n	403c62 <pio_set_input+0x52>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  403c50:	687b      	ldr	r3, [r7, #4]
  403c52:	f003 0308 	and.w	r3, r3, #8
  403c56:	2b00      	cmp	r3, #0
  403c58:	d003      	beq.n	403c62 <pio_set_input+0x52>
			p_pio->PIO_IFSCER = ul_mask;
  403c5a:	68fb      	ldr	r3, [r7, #12]
  403c5c:	68ba      	ldr	r2, [r7, #8]
  403c5e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  403c62:	68fb      	ldr	r3, [r7, #12]
  403c64:	68ba      	ldr	r2, [r7, #8]
  403c66:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  403c68:	68fb      	ldr	r3, [r7, #12]
  403c6a:	68ba      	ldr	r2, [r7, #8]
  403c6c:	601a      	str	r2, [r3, #0]
}
  403c6e:	bf00      	nop
  403c70:	3710      	adds	r7, #16
  403c72:	46bd      	mov	sp, r7
  403c74:	bd80      	pop	{r7, pc}
  403c76:	bf00      	nop
  403c78:	00403e59 	.word	0x00403e59

00403c7c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  403c7c:	b580      	push	{r7, lr}
  403c7e:	b084      	sub	sp, #16
  403c80:	af00      	add	r7, sp, #0
  403c82:	60f8      	str	r0, [r7, #12]
  403c84:	60b9      	str	r1, [r7, #8]
  403c86:	607a      	str	r2, [r7, #4]
  403c88:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  403c8a:	68b9      	ldr	r1, [r7, #8]
  403c8c:	68f8      	ldr	r0, [r7, #12]
  403c8e:	4b12      	ldr	r3, [pc, #72]	; (403cd8 <pio_set_output+0x5c>)
  403c90:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  403c92:	69ba      	ldr	r2, [r7, #24]
  403c94:	68b9      	ldr	r1, [r7, #8]
  403c96:	68f8      	ldr	r0, [r7, #12]
  403c98:	4b10      	ldr	r3, [pc, #64]	; (403cdc <pio_set_output+0x60>)
  403c9a:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  403c9c:	683b      	ldr	r3, [r7, #0]
  403c9e:	2b00      	cmp	r3, #0
  403ca0:	d003      	beq.n	403caa <pio_set_output+0x2e>
		p_pio->PIO_MDER = ul_mask;
  403ca2:	68fb      	ldr	r3, [r7, #12]
  403ca4:	68ba      	ldr	r2, [r7, #8]
  403ca6:	651a      	str	r2, [r3, #80]	; 0x50
  403ca8:	e002      	b.n	403cb0 <pio_set_output+0x34>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  403caa:	68fb      	ldr	r3, [r7, #12]
  403cac:	68ba      	ldr	r2, [r7, #8]
  403cae:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  403cb0:	687b      	ldr	r3, [r7, #4]
  403cb2:	2b00      	cmp	r3, #0
  403cb4:	d003      	beq.n	403cbe <pio_set_output+0x42>
		p_pio->PIO_SODR = ul_mask;
  403cb6:	68fb      	ldr	r3, [r7, #12]
  403cb8:	68ba      	ldr	r2, [r7, #8]
  403cba:	631a      	str	r2, [r3, #48]	; 0x30
  403cbc:	e002      	b.n	403cc4 <pio_set_output+0x48>
	} else {
		p_pio->PIO_CODR = ul_mask;
  403cbe:	68fb      	ldr	r3, [r7, #12]
  403cc0:	68ba      	ldr	r2, [r7, #8]
  403cc2:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  403cc4:	68fb      	ldr	r3, [r7, #12]
  403cc6:	68ba      	ldr	r2, [r7, #8]
  403cc8:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  403cca:	68fb      	ldr	r3, [r7, #12]
  403ccc:	68ba      	ldr	r2, [r7, #8]
  403cce:	601a      	str	r2, [r3, #0]
}
  403cd0:	bf00      	nop
  403cd2:	3710      	adds	r7, #16
  403cd4:	46bd      	mov	sp, r7
  403cd6:	bd80      	pop	{r7, pc}
  403cd8:	00403e59 	.word	0x00403e59
  403cdc:	00403b33 	.word	0x00403b33

00403ce0 <pio_configure>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask, const uint32_t ul_attribute)
{
  403ce0:	b590      	push	{r4, r7, lr}
  403ce2:	b087      	sub	sp, #28
  403ce4:	af02      	add	r7, sp, #8
  403ce6:	60f8      	str	r0, [r7, #12]
  403ce8:	60b9      	str	r1, [r7, #8]
  403cea:	607a      	str	r2, [r7, #4]
  403cec:	603b      	str	r3, [r7, #0]
	/* Configure pins */
	switch (ul_type) {
  403cee:	68bb      	ldr	r3, [r7, #8]
  403cf0:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403cf4:	d01e      	beq.n	403d34 <pio_configure+0x54>
  403cf6:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  403cfa:	d806      	bhi.n	403d0a <pio_configure+0x2a>
  403cfc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  403d00:	d00a      	beq.n	403d18 <pio_configure+0x38>
  403d02:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403d06:	d007      	beq.n	403d18 <pio_configure+0x38>
  403d08:	e03a      	b.n	403d80 <pio_configure+0xa0>
  403d0a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  403d0e:	d017      	beq.n	403d40 <pio_configure+0x60>
  403d10:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403d14:	d014      	beq.n	403d40 <pio_configure+0x60>
  403d16:	e033      	b.n	403d80 <pio_configure+0xa0>
	case PIO_PERIPH_B:
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	case PIO_PERIPH_C:
	case PIO_PERIPH_D:
#endif
		pio_set_peripheral(p_pio, ul_type, ul_mask);
  403d18:	687a      	ldr	r2, [r7, #4]
  403d1a:	68b9      	ldr	r1, [r7, #8]
  403d1c:	68f8      	ldr	r0, [r7, #12]
  403d1e:	4b1c      	ldr	r3, [pc, #112]	; (403d90 <pio_configure+0xb0>)
  403d20:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_attribute & PIO_PULLUP));
  403d22:	683b      	ldr	r3, [r7, #0]
  403d24:	f003 0301 	and.w	r3, r3, #1
  403d28:	461a      	mov	r2, r3
  403d2a:	6879      	ldr	r1, [r7, #4]
  403d2c:	68f8      	ldr	r0, [r7, #12]
  403d2e:	4b19      	ldr	r3, [pc, #100]	; (403d94 <pio_configure+0xb4>)
  403d30:	4798      	blx	r3
		break;
  403d32:	e027      	b.n	403d84 <pio_configure+0xa4>

	case PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_attribute);
  403d34:	683a      	ldr	r2, [r7, #0]
  403d36:	6879      	ldr	r1, [r7, #4]
  403d38:	68f8      	ldr	r0, [r7, #12]
  403d3a:	4b17      	ldr	r3, [pc, #92]	; (403d98 <pio_configure+0xb8>)
  403d3c:	4798      	blx	r3
		break;
  403d3e:	e021      	b.n	403d84 <pio_configure+0xa4>

	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  403d40:	68bb      	ldr	r3, [r7, #8]
  403d42:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  403d46:	bf0c      	ite	eq
  403d48:	2301      	moveq	r3, #1
  403d4a:	2300      	movne	r3, #0
  403d4c:	b2db      	uxtb	r3, r3
  403d4e:	461a      	mov	r2, r3
				(ul_attribute & PIO_OPENDRAIN) ? 1 : 0,
  403d50:	683b      	ldr	r3, [r7, #0]
  403d52:	f003 0304 	and.w	r3, r3, #4
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  403d56:	2b00      	cmp	r3, #0
  403d58:	bf14      	ite	ne
  403d5a:	2301      	movne	r3, #1
  403d5c:	2300      	moveq	r3, #0
  403d5e:	b2db      	uxtb	r3, r3
  403d60:	4619      	mov	r1, r3
				(ul_attribute & PIO_PULLUP) ? 1 : 0);
  403d62:	683b      	ldr	r3, [r7, #0]
  403d64:	f003 0301 	and.w	r3, r3, #1
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  403d68:	2b00      	cmp	r3, #0
  403d6a:	bf14      	ite	ne
  403d6c:	2301      	movne	r3, #1
  403d6e:	2300      	moveq	r3, #0
  403d70:	b2db      	uxtb	r3, r3
  403d72:	9300      	str	r3, [sp, #0]
  403d74:	460b      	mov	r3, r1
  403d76:	6879      	ldr	r1, [r7, #4]
  403d78:	68f8      	ldr	r0, [r7, #12]
  403d7a:	4c08      	ldr	r4, [pc, #32]	; (403d9c <pio_configure+0xbc>)
  403d7c:	47a0      	blx	r4
		break;
  403d7e:	e001      	b.n	403d84 <pio_configure+0xa4>

	default:
		return 0;
  403d80:	2300      	movs	r3, #0
  403d82:	e000      	b.n	403d86 <pio_configure+0xa6>
	}

	return 1;
  403d84:	2301      	movs	r3, #1
}
  403d86:	4618      	mov	r0, r3
  403d88:	3714      	adds	r7, #20
  403d8a:	46bd      	mov	sp, r7
  403d8c:	bd90      	pop	{r4, r7, pc}
  403d8e:	bf00      	nop
  403d90:	00403b5f 	.word	0x00403b5f
  403d94:	00403b33 	.word	0x00403b33
  403d98:	00403c11 	.word	0x00403c11
  403d9c:	00403c7d 	.word	0x00403c7d

00403da0 <pio_pull_down>:
 * \param ul_pull_down_enable Indicates if the pin(s) internal pull-down shall
 * be configured.
 */
void pio_pull_down(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_down_enable)
{
  403da0:	b480      	push	{r7}
  403da2:	b085      	sub	sp, #20
  403da4:	af00      	add	r7, sp, #0
  403da6:	60f8      	str	r0, [r7, #12]
  403da8:	60b9      	str	r1, [r7, #8]
  403daa:	607a      	str	r2, [r7, #4]
	/* Enable the pull-down if necessary */
	if (ul_pull_down_enable) {
  403dac:	687b      	ldr	r3, [r7, #4]
  403dae:	2b00      	cmp	r3, #0
  403db0:	d004      	beq.n	403dbc <pio_pull_down+0x1c>
		p_pio->PIO_PPDER = ul_mask;
  403db2:	68fb      	ldr	r3, [r7, #12]
  403db4:	68ba      	ldr	r2, [r7, #8]
  403db6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	} else {
		p_pio->PIO_PPDDR = ul_mask;
	}
}
  403dba:	e003      	b.n	403dc4 <pio_pull_down+0x24>
		p_pio->PIO_PPDDR = ul_mask;
  403dbc:	68fb      	ldr	r3, [r7, #12]
  403dbe:	68ba      	ldr	r2, [r7, #8]
  403dc0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
  403dc4:	bf00      	nop
  403dc6:	3714      	adds	r7, #20
  403dc8:	46bd      	mov	sp, r7
  403dca:	f85d 7b04 	ldr.w	r7, [sp], #4
  403dce:	4770      	bx	lr

00403dd0 <pio_configure_interrupt>:
 * \param ul_mask Interrupt source bit map.
 * \param ul_attr Interrupt source attributes.
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
  403dd0:	b480      	push	{r7}
  403dd2:	b085      	sub	sp, #20
  403dd4:	af00      	add	r7, sp, #0
  403dd6:	60f8      	str	r0, [r7, #12]
  403dd8:	60b9      	str	r1, [r7, #8]
  403dda:	607a      	str	r2, [r7, #4]
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  403ddc:	687b      	ldr	r3, [r7, #4]
  403dde:	f003 0310 	and.w	r3, r3, #16
  403de2:	2b00      	cmp	r3, #0
  403de4:	d020      	beq.n	403e28 <pio_configure_interrupt+0x58>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  403de6:	68fb      	ldr	r3, [r7, #12]
  403de8:	68ba      	ldr	r2, [r7, #8]
  403dea:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  403dee:	687b      	ldr	r3, [r7, #4]
  403df0:	f003 0320 	and.w	r3, r3, #32
  403df4:	2b00      	cmp	r3, #0
  403df6:	d004      	beq.n	403e02 <pio_configure_interrupt+0x32>
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  403df8:	68fb      	ldr	r3, [r7, #12]
  403dfa:	68ba      	ldr	r2, [r7, #8]
  403dfc:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  403e00:	e003      	b.n	403e0a <pio_configure_interrupt+0x3a>
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  403e02:	68fb      	ldr	r3, [r7, #12]
  403e04:	68ba      	ldr	r2, [r7, #8]
  403e06:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  403e0a:	687b      	ldr	r3, [r7, #4]
  403e0c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  403e10:	2b00      	cmp	r3, #0
  403e12:	d004      	beq.n	403e1e <pio_configure_interrupt+0x4e>
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  403e14:	68fb      	ldr	r3, [r7, #12]
  403e16:	68ba      	ldr	r2, [r7, #8]
  403e18:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
	}
}
  403e1c:	e008      	b.n	403e30 <pio_configure_interrupt+0x60>
			p_pio->PIO_LSR = ul_mask;
  403e1e:	68fb      	ldr	r3, [r7, #12]
  403e20:	68ba      	ldr	r2, [r7, #8]
  403e22:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
  403e26:	e003      	b.n	403e30 <pio_configure_interrupt+0x60>
		p_pio->PIO_AIMDR = ul_mask;
  403e28:	68fb      	ldr	r3, [r7, #12]
  403e2a:	68ba      	ldr	r2, [r7, #8]
  403e2c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  403e30:	bf00      	nop
  403e32:	3714      	adds	r7, #20
  403e34:	46bd      	mov	sp, r7
  403e36:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e3a:	4770      	bx	lr

00403e3c <pio_enable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  403e3c:	b480      	push	{r7}
  403e3e:	b083      	sub	sp, #12
  403e40:	af00      	add	r7, sp, #0
  403e42:	6078      	str	r0, [r7, #4]
  403e44:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IER = ul_mask;
  403e46:	687b      	ldr	r3, [r7, #4]
  403e48:	683a      	ldr	r2, [r7, #0]
  403e4a:	641a      	str	r2, [r3, #64]	; 0x40
}
  403e4c:	bf00      	nop
  403e4e:	370c      	adds	r7, #12
  403e50:	46bd      	mov	sp, r7
  403e52:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e56:	4770      	bx	lr

00403e58 <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  403e58:	b480      	push	{r7}
  403e5a:	b083      	sub	sp, #12
  403e5c:	af00      	add	r7, sp, #0
  403e5e:	6078      	str	r0, [r7, #4]
  403e60:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  403e62:	687b      	ldr	r3, [r7, #4]
  403e64:	683a      	ldr	r2, [r7, #0]
  403e66:	645a      	str	r2, [r3, #68]	; 0x44
}
  403e68:	bf00      	nop
  403e6a:	370c      	adds	r7, #12
  403e6c:	46bd      	mov	sp, r7
  403e6e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e72:	4770      	bx	lr

00403e74 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  403e74:	b480      	push	{r7}
  403e76:	b083      	sub	sp, #12
  403e78:	af00      	add	r7, sp, #0
  403e7a:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  403e7c:	687b      	ldr	r3, [r7, #4]
  403e7e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  403e80:	4618      	mov	r0, r3
  403e82:	370c      	adds	r7, #12
  403e84:	46bd      	mov	sp, r7
  403e86:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e8a:	4770      	bx	lr

00403e8c <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  403e8c:	b480      	push	{r7}
  403e8e:	b083      	sub	sp, #12
  403e90:	af00      	add	r7, sp, #0
  403e92:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  403e94:	687b      	ldr	r3, [r7, #4]
  403e96:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  403e98:	4618      	mov	r0, r3
  403e9a:	370c      	adds	r7, #12
  403e9c:	46bd      	mov	sp, r7
  403e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ea2:	4770      	bx	lr

00403ea4 <NVIC_EnableIRQ>:
{
  403ea4:	b480      	push	{r7}
  403ea6:	b083      	sub	sp, #12
  403ea8:	af00      	add	r7, sp, #0
  403eaa:	4603      	mov	r3, r0
  403eac:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  403eae:	4909      	ldr	r1, [pc, #36]	; (403ed4 <NVIC_EnableIRQ+0x30>)
  403eb0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403eb4:	095b      	lsrs	r3, r3, #5
  403eb6:	79fa      	ldrb	r2, [r7, #7]
  403eb8:	f002 021f 	and.w	r2, r2, #31
  403ebc:	2001      	movs	r0, #1
  403ebe:	fa00 f202 	lsl.w	r2, r0, r2
  403ec2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  403ec6:	bf00      	nop
  403ec8:	370c      	adds	r7, #12
  403eca:	46bd      	mov	sp, r7
  403ecc:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ed0:	4770      	bx	lr
  403ed2:	bf00      	nop
  403ed4:	e000e100 	.word	0xe000e100

00403ed8 <NVIC_DisableIRQ>:
{
  403ed8:	b480      	push	{r7}
  403eda:	b083      	sub	sp, #12
  403edc:	af00      	add	r7, sp, #0
  403ede:	4603      	mov	r3, r0
  403ee0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  403ee2:	4909      	ldr	r1, [pc, #36]	; (403f08 <NVIC_DisableIRQ+0x30>)
  403ee4:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403ee8:	095b      	lsrs	r3, r3, #5
  403eea:	79fa      	ldrb	r2, [r7, #7]
  403eec:	f002 021f 	and.w	r2, r2, #31
  403ef0:	2001      	movs	r0, #1
  403ef2:	fa00 f202 	lsl.w	r2, r0, r2
  403ef6:	3320      	adds	r3, #32
  403ef8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  403efc:	bf00      	nop
  403efe:	370c      	adds	r7, #12
  403f00:	46bd      	mov	sp, r7
  403f02:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f06:	4770      	bx	lr
  403f08:	e000e100 	.word	0xe000e100

00403f0c <NVIC_ClearPendingIRQ>:
{
  403f0c:	b480      	push	{r7}
  403f0e:	b083      	sub	sp, #12
  403f10:	af00      	add	r7, sp, #0
  403f12:	4603      	mov	r3, r0
  403f14:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  403f16:	4909      	ldr	r1, [pc, #36]	; (403f3c <NVIC_ClearPendingIRQ+0x30>)
  403f18:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403f1c:	095b      	lsrs	r3, r3, #5
  403f1e:	79fa      	ldrb	r2, [r7, #7]
  403f20:	f002 021f 	and.w	r2, r2, #31
  403f24:	2001      	movs	r0, #1
  403f26:	fa00 f202 	lsl.w	r2, r0, r2
  403f2a:	3360      	adds	r3, #96	; 0x60
  403f2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  403f30:	bf00      	nop
  403f32:	370c      	adds	r7, #12
  403f34:	46bd      	mov	sp, r7
  403f36:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f3a:	4770      	bx	lr
  403f3c:	e000e100 	.word	0xe000e100

00403f40 <NVIC_SetPriority>:
{
  403f40:	b480      	push	{r7}
  403f42:	b083      	sub	sp, #12
  403f44:	af00      	add	r7, sp, #0
  403f46:	4603      	mov	r3, r0
  403f48:	6039      	str	r1, [r7, #0]
  403f4a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  403f4c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403f50:	2b00      	cmp	r3, #0
  403f52:	da0b      	bge.n	403f6c <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  403f54:	490d      	ldr	r1, [pc, #52]	; (403f8c <NVIC_SetPriority+0x4c>)
  403f56:	79fb      	ldrb	r3, [r7, #7]
  403f58:	f003 030f 	and.w	r3, r3, #15
  403f5c:	3b04      	subs	r3, #4
  403f5e:	683a      	ldr	r2, [r7, #0]
  403f60:	b2d2      	uxtb	r2, r2
  403f62:	0112      	lsls	r2, r2, #4
  403f64:	b2d2      	uxtb	r2, r2
  403f66:	440b      	add	r3, r1
  403f68:	761a      	strb	r2, [r3, #24]
}
  403f6a:	e009      	b.n	403f80 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  403f6c:	4908      	ldr	r1, [pc, #32]	; (403f90 <NVIC_SetPriority+0x50>)
  403f6e:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403f72:	683a      	ldr	r2, [r7, #0]
  403f74:	b2d2      	uxtb	r2, r2
  403f76:	0112      	lsls	r2, r2, #4
  403f78:	b2d2      	uxtb	r2, r2
  403f7a:	440b      	add	r3, r1
  403f7c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  403f80:	bf00      	nop
  403f82:	370c      	adds	r7, #12
  403f84:	46bd      	mov	sp, r7
  403f86:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f8a:	4770      	bx	lr
  403f8c:	e000ed00 	.word	0xe000ed00
  403f90:	e000e100 	.word	0xe000e100

00403f94 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  403f94:	b580      	push	{r7, lr}
  403f96:	b084      	sub	sp, #16
  403f98:	af00      	add	r7, sp, #0
  403f9a:	6078      	str	r0, [r7, #4]
  403f9c:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;
	
	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  403f9e:	6878      	ldr	r0, [r7, #4]
  403fa0:	4b26      	ldr	r3, [pc, #152]	; (40403c <pio_handler_process+0xa8>)
  403fa2:	4798      	blx	r3
  403fa4:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  403fa6:	6878      	ldr	r0, [r7, #4]
  403fa8:	4b25      	ldr	r3, [pc, #148]	; (404040 <pio_handler_process+0xac>)
  403faa:	4798      	blx	r3
  403fac:	4602      	mov	r2, r0
  403fae:	68fb      	ldr	r3, [r7, #12]
  403fb0:	4013      	ands	r3, r2
  403fb2:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  403fb4:	68fb      	ldr	r3, [r7, #12]
  403fb6:	2b00      	cmp	r3, #0
  403fb8:	d03c      	beq.n	404034 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  403fba:	2300      	movs	r3, #0
  403fbc:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  403fbe:	e034      	b.n	40402a <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  403fc0:	4a20      	ldr	r2, [pc, #128]	; (404044 <pio_handler_process+0xb0>)
  403fc2:	68bb      	ldr	r3, [r7, #8]
  403fc4:	011b      	lsls	r3, r3, #4
  403fc6:	4413      	add	r3, r2
  403fc8:	681a      	ldr	r2, [r3, #0]
  403fca:	683b      	ldr	r3, [r7, #0]
  403fcc:	429a      	cmp	r2, r3
  403fce:	d126      	bne.n	40401e <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  403fd0:	4a1c      	ldr	r2, [pc, #112]	; (404044 <pio_handler_process+0xb0>)
  403fd2:	68bb      	ldr	r3, [r7, #8]
  403fd4:	011b      	lsls	r3, r3, #4
  403fd6:	4413      	add	r3, r2
  403fd8:	3304      	adds	r3, #4
  403fda:	681a      	ldr	r2, [r3, #0]
  403fdc:	68fb      	ldr	r3, [r7, #12]
  403fde:	4013      	ands	r3, r2
  403fe0:	2b00      	cmp	r3, #0
  403fe2:	d01c      	beq.n	40401e <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  403fe4:	4a17      	ldr	r2, [pc, #92]	; (404044 <pio_handler_process+0xb0>)
  403fe6:	68bb      	ldr	r3, [r7, #8]
  403fe8:	011b      	lsls	r3, r3, #4
  403fea:	4413      	add	r3, r2
  403fec:	330c      	adds	r3, #12
  403fee:	681b      	ldr	r3, [r3, #0]
  403ff0:	4914      	ldr	r1, [pc, #80]	; (404044 <pio_handler_process+0xb0>)
  403ff2:	68ba      	ldr	r2, [r7, #8]
  403ff4:	0112      	lsls	r2, r2, #4
  403ff6:	440a      	add	r2, r1
  403ff8:	6810      	ldr	r0, [r2, #0]
  403ffa:	4912      	ldr	r1, [pc, #72]	; (404044 <pio_handler_process+0xb0>)
  403ffc:	68ba      	ldr	r2, [r7, #8]
  403ffe:	0112      	lsls	r2, r2, #4
  404000:	440a      	add	r2, r1
  404002:	3204      	adds	r2, #4
  404004:	6812      	ldr	r2, [r2, #0]
  404006:	4611      	mov	r1, r2
  404008:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40400a:	4a0e      	ldr	r2, [pc, #56]	; (404044 <pio_handler_process+0xb0>)
  40400c:	68bb      	ldr	r3, [r7, #8]
  40400e:	011b      	lsls	r3, r3, #4
  404010:	4413      	add	r3, r2
  404012:	3304      	adds	r3, #4
  404014:	681b      	ldr	r3, [r3, #0]
  404016:	43db      	mvns	r3, r3
  404018:	68fa      	ldr	r2, [r7, #12]
  40401a:	4013      	ands	r3, r2
  40401c:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  40401e:	68bb      	ldr	r3, [r7, #8]
  404020:	3301      	adds	r3, #1
  404022:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  404024:	68bb      	ldr	r3, [r7, #8]
  404026:	2b06      	cmp	r3, #6
  404028:	d803      	bhi.n	404032 <pio_handler_process+0x9e>
		while (status != 0) {
  40402a:	68fb      	ldr	r3, [r7, #12]
  40402c:	2b00      	cmp	r3, #0
  40402e:	d1c7      	bne.n	403fc0 <pio_handler_process+0x2c>
		if (pio_capture_handler) {
			pio_capture_handler(p_pio);
		}
	}
#endif
}
  404030:	e000      	b.n	404034 <pio_handler_process+0xa0>
				break;
  404032:	bf00      	nop
}
  404034:	bf00      	nop
  404036:	3710      	adds	r7, #16
  404038:	46bd      	mov	sp, r7
  40403a:	bd80      	pop	{r7, pc}
  40403c:	00403e75 	.word	0x00403e75
  404040:	00403e8d 	.word	0x00403e8d
  404044:	200003b0 	.word	0x200003b0

00404048 <pio_handler_set>:
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
//uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
//		uint32_t ul_attr, void (*p_handler) (void*, int))
{
  404048:	b580      	push	{r7, lr}
  40404a:	b086      	sub	sp, #24
  40404c:	af00      	add	r7, sp, #0
  40404e:	60f8      	str	r0, [r7, #12]
  404050:	60b9      	str	r1, [r7, #8]
  404052:	607a      	str	r2, [r7, #4]
  404054:	603b      	str	r3, [r7, #0]
    uint8_t i;
	struct s_interrupt_source *pSource = &gs_interrupt_sources[0];
  404056:	4b22      	ldr	r3, [pc, #136]	; (4040e0 <pio_handler_set+0x98>)
  404058:	613b      	str	r3, [r7, #16]

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  40405a:	4b22      	ldr	r3, [pc, #136]	; (4040e4 <pio_handler_set+0x9c>)
  40405c:	681b      	ldr	r3, [r3, #0]
  40405e:	2b06      	cmp	r3, #6
  404060:	d901      	bls.n	404066 <pio_handler_set+0x1e>
		return 1;
  404062:	2301      	movs	r3, #1
  404064:	e038      	b.n	4040d8 <pio_handler_set+0x90>

    /* Check interrupt for this pin, if already defined, redefine it. */
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  404066:	2300      	movs	r3, #0
  404068:	75fb      	strb	r3, [r7, #23]
  40406a:	e011      	b.n	404090 <pio_handler_set+0x48>
		pSource = &(gs_interrupt_sources[i]);
  40406c:	7dfb      	ldrb	r3, [r7, #23]
  40406e:	011b      	lsls	r3, r3, #4
  404070:	4a1b      	ldr	r2, [pc, #108]	; (4040e0 <pio_handler_set+0x98>)
  404072:	4413      	add	r3, r2
  404074:	613b      	str	r3, [r7, #16]
		if (pSource->id == ul_id && pSource->mask == ul_mask) {
  404076:	693b      	ldr	r3, [r7, #16]
  404078:	681a      	ldr	r2, [r3, #0]
  40407a:	68bb      	ldr	r3, [r7, #8]
  40407c:	429a      	cmp	r2, r3
  40407e:	d104      	bne.n	40408a <pio_handler_set+0x42>
  404080:	693b      	ldr	r3, [r7, #16]
  404082:	685a      	ldr	r2, [r3, #4]
  404084:	687b      	ldr	r3, [r7, #4]
  404086:	429a      	cmp	r2, r3
  404088:	d008      	beq.n	40409c <pio_handler_set+0x54>
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  40408a:	7dfb      	ldrb	r3, [r7, #23]
  40408c:	3301      	adds	r3, #1
  40408e:	75fb      	strb	r3, [r7, #23]
  404090:	7dfa      	ldrb	r2, [r7, #23]
  404092:	4b14      	ldr	r3, [pc, #80]	; (4040e4 <pio_handler_set+0x9c>)
  404094:	681b      	ldr	r3, [r3, #0]
  404096:	429a      	cmp	r2, r3
  404098:	d9e8      	bls.n	40406c <pio_handler_set+0x24>
  40409a:	e000      	b.n	40409e <pio_handler_set+0x56>
			break;
  40409c:	bf00      	nop
		}
	}

	/* Define new source */
	pSource->id = ul_id;
  40409e:	693b      	ldr	r3, [r7, #16]
  4040a0:	68ba      	ldr	r2, [r7, #8]
  4040a2:	601a      	str	r2, [r3, #0]
	pSource->mask = ul_mask;
  4040a4:	693b      	ldr	r3, [r7, #16]
  4040a6:	687a      	ldr	r2, [r7, #4]
  4040a8:	605a      	str	r2, [r3, #4]
	pSource->attr = ul_attr;
  4040aa:	693b      	ldr	r3, [r7, #16]
  4040ac:	683a      	ldr	r2, [r7, #0]
  4040ae:	609a      	str	r2, [r3, #8]
	pSource->handler = p_handler;
  4040b0:	693b      	ldr	r3, [r7, #16]
  4040b2:	6a3a      	ldr	r2, [r7, #32]
  4040b4:	60da      	str	r2, [r3, #12]
	if (i == gs_ul_nb_sources + 1) {
  4040b6:	7dfa      	ldrb	r2, [r7, #23]
  4040b8:	4b0a      	ldr	r3, [pc, #40]	; (4040e4 <pio_handler_set+0x9c>)
  4040ba:	681b      	ldr	r3, [r3, #0]
  4040bc:	3301      	adds	r3, #1
  4040be:	429a      	cmp	r2, r3
  4040c0:	d104      	bne.n	4040cc <pio_handler_set+0x84>
		gs_ul_nb_sources++;
  4040c2:	4b08      	ldr	r3, [pc, #32]	; (4040e4 <pio_handler_set+0x9c>)
  4040c4:	681b      	ldr	r3, [r3, #0]
  4040c6:	3301      	adds	r3, #1
  4040c8:	4a06      	ldr	r2, [pc, #24]	; (4040e4 <pio_handler_set+0x9c>)
  4040ca:	6013      	str	r3, [r2, #0]
	}

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4040cc:	683a      	ldr	r2, [r7, #0]
  4040ce:	6879      	ldr	r1, [r7, #4]
  4040d0:	68f8      	ldr	r0, [r7, #12]
  4040d2:	4b05      	ldr	r3, [pc, #20]	; (4040e8 <pio_handler_set+0xa0>)
  4040d4:	4798      	blx	r3

	return 0;
  4040d6:	2300      	movs	r3, #0
}
  4040d8:	4618      	mov	r0, r3
  4040da:	3718      	adds	r7, #24
  4040dc:	46bd      	mov	sp, r7
  4040de:	bd80      	pop	{r7, pc}
  4040e0:	200003b0 	.word	0x200003b0
  4040e4:	20000420 	.word	0x20000420
  4040e8:	00403dd1 	.word	0x00403dd1

004040ec <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4040ec:	b580      	push	{r7, lr}
  4040ee:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  4040f0:	210c      	movs	r1, #12
  4040f2:	4802      	ldr	r0, [pc, #8]	; (4040fc <PIOB_Handler+0x10>)
  4040f4:	4b02      	ldr	r3, [pc, #8]	; (404100 <PIOB_Handler+0x14>)
  4040f6:	4798      	blx	r3
}
  4040f8:	bf00      	nop
  4040fa:	bd80      	pop	{r7, pc}
  4040fc:	400e1000 	.word	0x400e1000
  404100:	00403f95 	.word	0x00403f95

00404104 <pio_handler_set_priority>:
 * \param p_pio PIO controller base address.
 * \param ul_irqn NVIC line number.
 * \param ul_priority PIO controller interrupts priority.
 */
void pio_handler_set_priority(Pio *p_pio, IRQn_Type ul_irqn, uint32_t ul_priority)
{
  404104:	b580      	push	{r7, lr}
  404106:	b086      	sub	sp, #24
  404108:	af00      	add	r7, sp, #0
  40410a:	60f8      	str	r0, [r7, #12]
  40410c:	460b      	mov	r3, r1
  40410e:	607a      	str	r2, [r7, #4]
  404110:	72fb      	strb	r3, [r7, #11]
	uint32_t bitmask = 0;
  404112:	2300      	movs	r3, #0
  404114:	617b      	str	r3, [r7, #20]

	bitmask = pio_get_interrupt_mask(p_pio);
  404116:	68f8      	ldr	r0, [r7, #12]
  404118:	4b13      	ldr	r3, [pc, #76]	; (404168 <pio_handler_set_priority+0x64>)
  40411a:	4798      	blx	r3
  40411c:	6178      	str	r0, [r7, #20]
	pio_disable_interrupt(p_pio, 0xFFFFFFFF);
  40411e:	f04f 31ff 	mov.w	r1, #4294967295
  404122:	68f8      	ldr	r0, [r7, #12]
  404124:	4b11      	ldr	r3, [pc, #68]	; (40416c <pio_handler_set_priority+0x68>)
  404126:	4798      	blx	r3
	pio_get_interrupt_status(p_pio);
  404128:	68f8      	ldr	r0, [r7, #12]
  40412a:	4b11      	ldr	r3, [pc, #68]	; (404170 <pio_handler_set_priority+0x6c>)
  40412c:	4798      	blx	r3
	NVIC_DisableIRQ(ul_irqn);
  40412e:	f997 300b 	ldrsb.w	r3, [r7, #11]
  404132:	4618      	mov	r0, r3
  404134:	4b0f      	ldr	r3, [pc, #60]	; (404174 <pio_handler_set_priority+0x70>)
  404136:	4798      	blx	r3
	NVIC_ClearPendingIRQ(ul_irqn);
  404138:	f997 300b 	ldrsb.w	r3, [r7, #11]
  40413c:	4618      	mov	r0, r3
  40413e:	4b0e      	ldr	r3, [pc, #56]	; (404178 <pio_handler_set_priority+0x74>)
  404140:	4798      	blx	r3
	NVIC_SetPriority(ul_irqn, ul_priority);
  404142:	f997 300b 	ldrsb.w	r3, [r7, #11]
  404146:	6879      	ldr	r1, [r7, #4]
  404148:	4618      	mov	r0, r3
  40414a:	4b0c      	ldr	r3, [pc, #48]	; (40417c <pio_handler_set_priority+0x78>)
  40414c:	4798      	blx	r3
	NVIC_EnableIRQ(ul_irqn);
  40414e:	f997 300b 	ldrsb.w	r3, [r7, #11]
  404152:	4618      	mov	r0, r3
  404154:	4b0a      	ldr	r3, [pc, #40]	; (404180 <pio_handler_set_priority+0x7c>)
  404156:	4798      	blx	r3
	pio_enable_interrupt(p_pio, bitmask);
  404158:	6979      	ldr	r1, [r7, #20]
  40415a:	68f8      	ldr	r0, [r7, #12]
  40415c:	4b09      	ldr	r3, [pc, #36]	; (404184 <pio_handler_set_priority+0x80>)
  40415e:	4798      	blx	r3
}
  404160:	bf00      	nop
  404162:	3718      	adds	r7, #24
  404164:	46bd      	mov	sp, r7
  404166:	bd80      	pop	{r7, pc}
  404168:	00403e8d 	.word	0x00403e8d
  40416c:	00403e59 	.word	0x00403e59
  404170:	00403e75 	.word	0x00403e75
  404174:	00403ed9 	.word	0x00403ed9
  404178:	00403f0d 	.word	0x00403f0d
  40417c:	00403f41 	.word	0x00403f41
  404180:	00403ea5 	.word	0x00403ea5
  404184:	00403e3d 	.word	0x00403e3d

00404188 <pio_handler_clear_pending_IRQ>:
void pio_handler_clear_pending_IRQ(Pio *p_pio, IRQn_Type ul_irqn)
{
  404188:	b580      	push	{r7, lr}
  40418a:	b084      	sub	sp, #16
  40418c:	af00      	add	r7, sp, #0
  40418e:	6078      	str	r0, [r7, #4]
  404190:	460b      	mov	r3, r1
  404192:	70fb      	strb	r3, [r7, #3]
	uint32_t bitmask = 0;
  404194:	2300      	movs	r3, #0
  404196:	60fb      	str	r3, [r7, #12]

	bitmask = pio_get_interrupt_mask(p_pio);
  404198:	6878      	ldr	r0, [r7, #4]
  40419a:	4b11      	ldr	r3, [pc, #68]	; (4041e0 <pio_handler_clear_pending_IRQ+0x58>)
  40419c:	4798      	blx	r3
  40419e:	60f8      	str	r0, [r7, #12]
	pio_disable_interrupt(p_pio, 0xFFFFFFFF);
  4041a0:	f04f 31ff 	mov.w	r1, #4294967295
  4041a4:	6878      	ldr	r0, [r7, #4]
  4041a6:	4b0f      	ldr	r3, [pc, #60]	; (4041e4 <pio_handler_clear_pending_IRQ+0x5c>)
  4041a8:	4798      	blx	r3
	pio_get_interrupt_status(p_pio);
  4041aa:	6878      	ldr	r0, [r7, #4]
  4041ac:	4b0e      	ldr	r3, [pc, #56]	; (4041e8 <pio_handler_clear_pending_IRQ+0x60>)
  4041ae:	4798      	blx	r3
	NVIC_DisableIRQ(ul_irqn);
  4041b0:	f997 3003 	ldrsb.w	r3, [r7, #3]
  4041b4:	4618      	mov	r0, r3
  4041b6:	4b0d      	ldr	r3, [pc, #52]	; (4041ec <pio_handler_clear_pending_IRQ+0x64>)
  4041b8:	4798      	blx	r3
	NVIC_ClearPendingIRQ(ul_irqn);
  4041ba:	f997 3003 	ldrsb.w	r3, [r7, #3]
  4041be:	4618      	mov	r0, r3
  4041c0:	4b0b      	ldr	r3, [pc, #44]	; (4041f0 <pio_handler_clear_pending_IRQ+0x68>)
  4041c2:	4798      	blx	r3
	//NVIC_SetPriority(ul_irqn, ul_priority);
	NVIC_EnableIRQ(ul_irqn);
  4041c4:	f997 3003 	ldrsb.w	r3, [r7, #3]
  4041c8:	4618      	mov	r0, r3
  4041ca:	4b0a      	ldr	r3, [pc, #40]	; (4041f4 <pio_handler_clear_pending_IRQ+0x6c>)
  4041cc:	4798      	blx	r3
	pio_enable_interrupt(p_pio, bitmask);
  4041ce:	68f9      	ldr	r1, [r7, #12]
  4041d0:	6878      	ldr	r0, [r7, #4]
  4041d2:	4b09      	ldr	r3, [pc, #36]	; (4041f8 <pio_handler_clear_pending_IRQ+0x70>)
  4041d4:	4798      	blx	r3
}
  4041d6:	bf00      	nop
  4041d8:	3710      	adds	r7, #16
  4041da:	46bd      	mov	sp, r7
  4041dc:	bd80      	pop	{r7, pc}
  4041de:	bf00      	nop
  4041e0:	00403e8d 	.word	0x00403e8d
  4041e4:	00403e59 	.word	0x00403e59
  4041e8:	00403e75 	.word	0x00403e75
  4041ec:	00403ed9 	.word	0x00403ed9
  4041f0:	00403f0d 	.word	0x00403f0d
  4041f4:	00403ea5 	.word	0x00403ea5
  4041f8:	00403e3d 	.word	0x00403e3d

004041fc <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4041fc:	b480      	push	{r7}
  4041fe:	b085      	sub	sp, #20
  404200:	af00      	add	r7, sp, #0
  404202:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  404204:	491d      	ldr	r1, [pc, #116]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  404206:	4b1d      	ldr	r3, [pc, #116]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  404208:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40420a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  40420e:	687b      	ldr	r3, [r7, #4]
  404210:	4313      	orrs	r3, r2
  404212:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404214:	f44f 6300 	mov.w	r3, #2048	; 0x800
  404218:	60fb      	str	r3, [r7, #12]
  40421a:	e007      	b.n	40422c <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40421c:	68fb      	ldr	r3, [r7, #12]
  40421e:	2b00      	cmp	r3, #0
  404220:	d101      	bne.n	404226 <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  404222:	2301      	movs	r3, #1
  404224:	e023      	b.n	40426e <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  404226:	68fb      	ldr	r3, [r7, #12]
  404228:	3b01      	subs	r3, #1
  40422a:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40422c:	4b13      	ldr	r3, [pc, #76]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  40422e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404230:	f003 0308 	and.w	r3, r3, #8
  404234:	2b00      	cmp	r3, #0
  404236:	d0f1      	beq.n	40421c <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  404238:	4a10      	ldr	r2, [pc, #64]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  40423a:	4b10      	ldr	r3, [pc, #64]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  40423c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40423e:	f023 0303 	bic.w	r3, r3, #3
  404242:	f043 0302 	orr.w	r3, r3, #2
  404246:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404248:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40424c:	60fb      	str	r3, [r7, #12]
  40424e:	e007      	b.n	404260 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404250:	68fb      	ldr	r3, [r7, #12]
  404252:	2b00      	cmp	r3, #0
  404254:	d101      	bne.n	40425a <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  404256:	2301      	movs	r3, #1
  404258:	e009      	b.n	40426e <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40425a:	68fb      	ldr	r3, [r7, #12]
  40425c:	3b01      	subs	r3, #1
  40425e:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404260:	4b06      	ldr	r3, [pc, #24]	; (40427c <pmc_switch_mck_to_pllack+0x80>)
  404262:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404264:	f003 0308 	and.w	r3, r3, #8
  404268:	2b00      	cmp	r3, #0
  40426a:	d0f1      	beq.n	404250 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  40426c:	2300      	movs	r3, #0
}
  40426e:	4618      	mov	r0, r3
  404270:	3714      	adds	r7, #20
  404272:	46bd      	mov	sp, r7
  404274:	f85d 7b04 	ldr.w	r7, [sp], #4
  404278:	4770      	bx	lr
  40427a:	bf00      	nop
  40427c:	400e0400 	.word	0x400e0400

00404280 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  404280:	b480      	push	{r7}
  404282:	b083      	sub	sp, #12
  404284:	af00      	add	r7, sp, #0
  404286:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  404288:	687b      	ldr	r3, [r7, #4]
  40428a:	2b01      	cmp	r3, #1
  40428c:	d107      	bne.n	40429e <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  40428e:	4a08      	ldr	r2, [pc, #32]	; (4042b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  404290:	4b07      	ldr	r3, [pc, #28]	; (4042b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  404292:	689b      	ldr	r3, [r3, #8]
  404294:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  404298:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  40429c:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  40429e:	4b04      	ldr	r3, [pc, #16]	; (4042b0 <pmc_switch_sclk_to_32kxtal+0x30>)
  4042a0:	4a04      	ldr	r2, [pc, #16]	; (4042b4 <pmc_switch_sclk_to_32kxtal+0x34>)
  4042a2:	601a      	str	r2, [r3, #0]
}
  4042a4:	bf00      	nop
  4042a6:	370c      	adds	r7, #12
  4042a8:	46bd      	mov	sp, r7
  4042aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042ae:	4770      	bx	lr
  4042b0:	400e1410 	.word	0x400e1410
  4042b4:	a5000008 	.word	0xa5000008

004042b8 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4042b8:	b480      	push	{r7}
  4042ba:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4042bc:	4b09      	ldr	r3, [pc, #36]	; (4042e4 <pmc_osc_is_ready_32kxtal+0x2c>)
  4042be:	695b      	ldr	r3, [r3, #20]
  4042c0:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4042c4:	2b00      	cmp	r3, #0
  4042c6:	d007      	beq.n	4042d8 <pmc_osc_is_ready_32kxtal+0x20>
  4042c8:	4b07      	ldr	r3, [pc, #28]	; (4042e8 <pmc_osc_is_ready_32kxtal+0x30>)
  4042ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042cc:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4042d0:	2b00      	cmp	r3, #0
  4042d2:	d001      	beq.n	4042d8 <pmc_osc_is_ready_32kxtal+0x20>
  4042d4:	2301      	movs	r3, #1
  4042d6:	e000      	b.n	4042da <pmc_osc_is_ready_32kxtal+0x22>
  4042d8:	2300      	movs	r3, #0
}
  4042da:	4618      	mov	r0, r3
  4042dc:	46bd      	mov	sp, r7
  4042de:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042e2:	4770      	bx	lr
  4042e4:	400e1410 	.word	0x400e1410
  4042e8:	400e0400 	.word	0x400e0400

004042ec <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  4042ec:	b480      	push	{r7}
  4042ee:	b083      	sub	sp, #12
  4042f0:	af00      	add	r7, sp, #0
  4042f2:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4042f4:	4a18      	ldr	r2, [pc, #96]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042f6:	4b18      	ldr	r3, [pc, #96]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042f8:	6a1b      	ldr	r3, [r3, #32]
  4042fa:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4042fe:	f043 0308 	orr.w	r3, r3, #8
  404302:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  404304:	bf00      	nop
  404306:	4b14      	ldr	r3, [pc, #80]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  404308:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40430a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  40430e:	2b00      	cmp	r3, #0
  404310:	d0f9      	beq.n	404306 <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  404312:	4911      	ldr	r1, [pc, #68]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  404314:	4b10      	ldr	r3, [pc, #64]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  404316:	6a1b      	ldr	r3, [r3, #32]
  404318:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40431c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  404320:	687a      	ldr	r2, [r7, #4]
  404322:	4313      	orrs	r3, r2
  404324:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  404328:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  40432a:	bf00      	nop
  40432c:	4b0a      	ldr	r3, [pc, #40]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  40432e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404330:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  404334:	2b00      	cmp	r3, #0
  404336:	d0f9      	beq.n	40432c <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  404338:	4a07      	ldr	r2, [pc, #28]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  40433a:	4b07      	ldr	r3, [pc, #28]	; (404358 <pmc_switch_mainck_to_fastrc+0x6c>)
  40433c:	6a1b      	ldr	r3, [r3, #32]
  40433e:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  404342:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  404346:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40434a:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  40434c:	bf00      	nop
  40434e:	370c      	adds	r7, #12
  404350:	46bd      	mov	sp, r7
  404352:	f85d 7b04 	ldr.w	r7, [sp], #4
  404356:	4770      	bx	lr
  404358:	400e0400 	.word	0x400e0400

0040435c <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  40435c:	b480      	push	{r7}
  40435e:	b083      	sub	sp, #12
  404360:	af00      	add	r7, sp, #0
  404362:	6078      	str	r0, [r7, #4]
  404364:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  404366:	687b      	ldr	r3, [r7, #4]
  404368:	2b00      	cmp	r3, #0
  40436a:	d008      	beq.n	40437e <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40436c:	4916      	ldr	r1, [pc, #88]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  40436e:	4b16      	ldr	r3, [pc, #88]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404370:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  404372:	4a16      	ldr	r2, [pc, #88]	; (4043cc <pmc_switch_mainck_to_xtal+0x70>)
  404374:	401a      	ands	r2, r3
  404376:	4b16      	ldr	r3, [pc, #88]	; (4043d0 <pmc_switch_mainck_to_xtal+0x74>)
  404378:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40437a:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  40437c:	e01e      	b.n	4043bc <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40437e:	4912      	ldr	r1, [pc, #72]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404380:	4b11      	ldr	r3, [pc, #68]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  404382:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404384:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404388:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40438c:	683a      	ldr	r2, [r7, #0]
  40438e:	0212      	lsls	r2, r2, #8
  404390:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404392:	4313      	orrs	r3, r2
  404394:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  404398:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40439c:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40439e:	bf00      	nop
  4043a0:	4b09      	ldr	r3, [pc, #36]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4043a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4043a4:	f003 0301 	and.w	r3, r3, #1
  4043a8:	2b00      	cmp	r3, #0
  4043aa:	d0f9      	beq.n	4043a0 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4043ac:	4a06      	ldr	r2, [pc, #24]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4043ae:	4b06      	ldr	r3, [pc, #24]	; (4043c8 <pmc_switch_mainck_to_xtal+0x6c>)
  4043b0:	6a1b      	ldr	r3, [r3, #32]
  4043b2:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4043b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4043ba:	6213      	str	r3, [r2, #32]
}
  4043bc:	bf00      	nop
  4043be:	370c      	adds	r7, #12
  4043c0:	46bd      	mov	sp, r7
  4043c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043c6:	4770      	bx	lr
  4043c8:	400e0400 	.word	0x400e0400
  4043cc:	fec8fffc 	.word	0xfec8fffc
  4043d0:	01370002 	.word	0x01370002

004043d4 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4043d4:	b480      	push	{r7}
  4043d6:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4043d8:	4b04      	ldr	r3, [pc, #16]	; (4043ec <pmc_osc_is_ready_mainck+0x18>)
  4043da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4043dc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4043e0:	4618      	mov	r0, r3
  4043e2:	46bd      	mov	sp, r7
  4043e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043e8:	4770      	bx	lr
  4043ea:	bf00      	nop
  4043ec:	400e0400 	.word	0x400e0400

004043f0 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  4043f0:	b480      	push	{r7}
  4043f2:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
  4043f4:	4b03      	ldr	r3, [pc, #12]	; (404404 <pmc_disable_pllack+0x14>)
  4043f6:	2200      	movs	r2, #0
  4043f8:	629a      	str	r2, [r3, #40]	; 0x28
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
#endif
}
  4043fa:	bf00      	nop
  4043fc:	46bd      	mov	sp, r7
  4043fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  404402:	4770      	bx	lr
  404404:	400e0400 	.word	0x400e0400

00404408 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  404408:	b480      	push	{r7}
  40440a:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40440c:	4b04      	ldr	r3, [pc, #16]	; (404420 <pmc_is_locked_pllack+0x18>)
  40440e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404410:	f003 0302 	and.w	r3, r3, #2
}
  404414:	4618      	mov	r0, r3
  404416:	46bd      	mov	sp, r7
  404418:	f85d 7b04 	ldr.w	r7, [sp], #4
  40441c:	4770      	bx	lr
  40441e:	bf00      	nop
  404420:	400e0400 	.word	0x400e0400

00404424 <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  404424:	b480      	push	{r7}
  404426:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  404428:	4b03      	ldr	r3, [pc, #12]	; (404438 <pmc_disable_pllbck+0x14>)
  40442a:	2200      	movs	r2, #0
  40442c:	62da      	str	r2, [r3, #44]	; 0x2c
}
  40442e:	bf00      	nop
  404430:	46bd      	mov	sp, r7
  404432:	f85d 7b04 	ldr.w	r7, [sp], #4
  404436:	4770      	bx	lr
  404438:	400e0400 	.word	0x400e0400

0040443c <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  40443c:	b480      	push	{r7}
  40443e:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  404440:	4b04      	ldr	r3, [pc, #16]	; (404454 <pmc_is_locked_pllbck+0x18>)
  404442:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404444:	f003 0304 	and.w	r3, r3, #4
}
  404448:	4618      	mov	r0, r3
  40444a:	46bd      	mov	sp, r7
  40444c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404450:	4770      	bx	lr
  404452:	bf00      	nop
  404454:	400e0400 	.word	0x400e0400

00404458 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  404458:	b480      	push	{r7}
  40445a:	b083      	sub	sp, #12
  40445c:	af00      	add	r7, sp, #0
  40445e:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  404460:	687b      	ldr	r3, [r7, #4]
  404462:	2b32      	cmp	r3, #50	; 0x32
  404464:	d901      	bls.n	40446a <pmc_enable_periph_clk+0x12>
		return 1;
  404466:	2301      	movs	r3, #1
  404468:	e02f      	b.n	4044ca <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  40446a:	687b      	ldr	r3, [r7, #4]
  40446c:	2b1f      	cmp	r3, #31
  40446e:	d813      	bhi.n	404498 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  404470:	4b19      	ldr	r3, [pc, #100]	; (4044d8 <pmc_enable_periph_clk+0x80>)
  404472:	699a      	ldr	r2, [r3, #24]
  404474:	2101      	movs	r1, #1
  404476:	687b      	ldr	r3, [r7, #4]
  404478:	fa01 f303 	lsl.w	r3, r1, r3
  40447c:	401a      	ands	r2, r3
  40447e:	2101      	movs	r1, #1
  404480:	687b      	ldr	r3, [r7, #4]
  404482:	fa01 f303 	lsl.w	r3, r1, r3
  404486:	429a      	cmp	r2, r3
  404488:	d01e      	beq.n	4044c8 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  40448a:	4a13      	ldr	r2, [pc, #76]	; (4044d8 <pmc_enable_periph_clk+0x80>)
  40448c:	2101      	movs	r1, #1
  40448e:	687b      	ldr	r3, [r7, #4]
  404490:	fa01 f303 	lsl.w	r3, r1, r3
  404494:	6113      	str	r3, [r2, #16]
  404496:	e017      	b.n	4044c8 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  404498:	687b      	ldr	r3, [r7, #4]
  40449a:	3b20      	subs	r3, #32
  40449c:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40449e:	4b0e      	ldr	r3, [pc, #56]	; (4044d8 <pmc_enable_periph_clk+0x80>)
  4044a0:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4044a4:	2101      	movs	r1, #1
  4044a6:	687b      	ldr	r3, [r7, #4]
  4044a8:	fa01 f303 	lsl.w	r3, r1, r3
  4044ac:	401a      	ands	r2, r3
  4044ae:	2101      	movs	r1, #1
  4044b0:	687b      	ldr	r3, [r7, #4]
  4044b2:	fa01 f303 	lsl.w	r3, r1, r3
  4044b6:	429a      	cmp	r2, r3
  4044b8:	d006      	beq.n	4044c8 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  4044ba:	4a07      	ldr	r2, [pc, #28]	; (4044d8 <pmc_enable_periph_clk+0x80>)
  4044bc:	2101      	movs	r1, #1
  4044be:	687b      	ldr	r3, [r7, #4]
  4044c0:	fa01 f303 	lsl.w	r3, r1, r3
  4044c4:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4044c8:	2300      	movs	r3, #0
}
  4044ca:	4618      	mov	r0, r3
  4044cc:	370c      	adds	r7, #12
  4044ce:	46bd      	mov	sp, r7
  4044d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044d4:	4770      	bx	lr
  4044d6:	bf00      	nop
  4044d8:	400e0400 	.word	0x400e0400

004044dc <pmc_switch_pck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_pllack(uint32_t ul_id, uint32_t ul_pres)
{
  4044dc:	b480      	push	{r7}
  4044de:	b085      	sub	sp, #20
  4044e0:	af00      	add	r7, sp, #0
  4044e2:	6078      	str	r0, [r7, #4]
  4044e4:	6039      	str	r1, [r7, #0]
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_PLLA_CLK | ul_pres;
  4044e6:	4912      	ldr	r1, [pc, #72]	; (404530 <pmc_switch_pck_to_pllack+0x54>)
  4044e8:	683b      	ldr	r3, [r7, #0]
  4044ea:	f043 0202 	orr.w	r2, r3, #2
  4044ee:	687b      	ldr	r3, [r7, #4]
  4044f0:	3310      	adds	r3, #16
  4044f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
  4044f6:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4044fa:	60fb      	str	r3, [r7, #12]
  4044fc:	e007      	b.n	40450e <pmc_switch_pck_to_pllack+0x32>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  4044fe:	68fb      	ldr	r3, [r7, #12]
  404500:	2b00      	cmp	r3, #0
  404502:	d101      	bne.n	404508 <pmc_switch_pck_to_pllack+0x2c>
			return 1;
  404504:	2301      	movs	r3, #1
  404506:	e00d      	b.n	404524 <pmc_switch_pck_to_pllack+0x48>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  404508:	68fb      	ldr	r3, [r7, #12]
  40450a:	3b01      	subs	r3, #1
  40450c:	60fb      	str	r3, [r7, #12]
  40450e:	4b08      	ldr	r3, [pc, #32]	; (404530 <pmc_switch_pck_to_pllack+0x54>)
  404510:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  404512:	f44f 7180 	mov.w	r1, #256	; 0x100
  404516:	687b      	ldr	r3, [r7, #4]
  404518:	fa01 f303 	lsl.w	r3, r1, r3
  40451c:	4013      	ands	r3, r2
	for (ul_timeout = PMC_TIMEOUT;
  40451e:	2b00      	cmp	r3, #0
  404520:	d0ed      	beq.n	4044fe <pmc_switch_pck_to_pllack+0x22>
		}
	}

	return 0;
  404522:	2300      	movs	r3, #0
}
  404524:	4618      	mov	r0, r3
  404526:	3714      	adds	r7, #20
  404528:	46bd      	mov	sp, r7
  40452a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40452e:	4770      	bx	lr
  404530:	400e0400 	.word	0x400e0400

00404534 <pmc_switch_pck_to_mck>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
  404534:	b480      	push	{r7}
  404536:	b085      	sub	sp, #20
  404538:	af00      	add	r7, sp, #0
  40453a:	6078      	str	r0, [r7, #4]
  40453c:	6039      	str	r1, [r7, #0]
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
  40453e:	4912      	ldr	r1, [pc, #72]	; (404588 <pmc_switch_pck_to_mck+0x54>)
  404540:	683b      	ldr	r3, [r7, #0]
  404542:	f043 0204 	orr.w	r2, r3, #4
  404546:	687b      	ldr	r3, [r7, #4]
  404548:	3310      	adds	r3, #16
  40454a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
  40454e:	f44f 6300 	mov.w	r3, #2048	; 0x800
  404552:	60fb      	str	r3, [r7, #12]
  404554:	e007      	b.n	404566 <pmc_switch_pck_to_mck+0x32>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  404556:	68fb      	ldr	r3, [r7, #12]
  404558:	2b00      	cmp	r3, #0
  40455a:	d101      	bne.n	404560 <pmc_switch_pck_to_mck+0x2c>
			return 1;
  40455c:	2301      	movs	r3, #1
  40455e:	e00d      	b.n	40457c <pmc_switch_pck_to_mck+0x48>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  404560:	68fb      	ldr	r3, [r7, #12]
  404562:	3b01      	subs	r3, #1
  404564:	60fb      	str	r3, [r7, #12]
  404566:	4b08      	ldr	r3, [pc, #32]	; (404588 <pmc_switch_pck_to_mck+0x54>)
  404568:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  40456a:	f44f 7180 	mov.w	r1, #256	; 0x100
  40456e:	687b      	ldr	r3, [r7, #4]
  404570:	fa01 f303 	lsl.w	r3, r1, r3
  404574:	4013      	ands	r3, r2
	for (ul_timeout = PMC_TIMEOUT;
  404576:	2b00      	cmp	r3, #0
  404578:	d0ed      	beq.n	404556 <pmc_switch_pck_to_mck+0x22>
		}
	}

	return 0;
  40457a:	2300      	movs	r3, #0
}
  40457c:	4618      	mov	r0, r3
  40457e:	3714      	adds	r7, #20
  404580:	46bd      	mov	sp, r7
  404582:	f85d 7b04 	ldr.w	r7, [sp], #4
  404586:	4770      	bx	lr
  404588:	400e0400 	.word	0x400e0400

0040458c <pmc_enable_pck>:
 * \brief Enable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_enable_pck(uint32_t ul_id)
{
  40458c:	b480      	push	{r7}
  40458e:	b083      	sub	sp, #12
  404590:	af00      	add	r7, sp, #0
  404592:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCER = PMC_SCER_PCK0 << ul_id;
  404594:	4a06      	ldr	r2, [pc, #24]	; (4045b0 <pmc_enable_pck+0x24>)
  404596:	f44f 7180 	mov.w	r1, #256	; 0x100
  40459a:	687b      	ldr	r3, [r7, #4]
  40459c:	fa01 f303 	lsl.w	r3, r1, r3
  4045a0:	6013      	str	r3, [r2, #0]
}
  4045a2:	bf00      	nop
  4045a4:	370c      	adds	r7, #12
  4045a6:	46bd      	mov	sp, r7
  4045a8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4045ac:	4770      	bx	lr
  4045ae:	bf00      	nop
  4045b0:	400e0400 	.word	0x400e0400

004045b4 <pmc_disable_pck>:
 * \brief Disable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_disable_pck(uint32_t ul_id)
{
  4045b4:	b480      	push	{r7}
  4045b6:	b083      	sub	sp, #12
  4045b8:	af00      	add	r7, sp, #0
  4045ba:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCDR = PMC_SCER_PCK0 << ul_id;
  4045bc:	4a06      	ldr	r2, [pc, #24]	; (4045d8 <pmc_disable_pck+0x24>)
  4045be:	f44f 7180 	mov.w	r1, #256	; 0x100
  4045c2:	687b      	ldr	r3, [r7, #4]
  4045c4:	fa01 f303 	lsl.w	r3, r1, r3
  4045c8:	6053      	str	r3, [r2, #4]
}
  4045ca:	bf00      	nop
  4045cc:	370c      	adds	r7, #12
  4045ce:	46bd      	mov	sp, r7
  4045d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4045d4:	4770      	bx	lr
  4045d6:	bf00      	nop
  4045d8:	400e0400 	.word	0x400e0400

004045dc <pmc_set_flash_in_wait_mode>:
 *
 * \param ul_flash_state PMC_WAIT_MODE_FLASH_STANDBY flash in standby mode,
 * PMC_WAIT_MODE_FLASH_DEEP_POWERDOWN flash in deep power down mode.
 */
void pmc_set_flash_in_wait_mode(uint32_t ul_flash_state)
{
  4045dc:	b480      	push	{r7}
  4045de:	b083      	sub	sp, #12
  4045e0:	af00      	add	r7, sp, #0
  4045e2:	6078      	str	r0, [r7, #4]
	ul_flash_in_wait_mode = ul_flash_state;
  4045e4:	4a04      	ldr	r2, [pc, #16]	; (4045f8 <pmc_set_flash_in_wait_mode+0x1c>)
  4045e6:	687b      	ldr	r3, [r7, #4]
  4045e8:	6013      	str	r3, [r2, #0]
}
  4045ea:	bf00      	nop
  4045ec:	370c      	adds	r7, #12
  4045ee:	46bd      	mov	sp, r7
  4045f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4045f4:	4770      	bx	lr
  4045f6:	bf00      	nop
  4045f8:	2000016c 	.word	0x2000016c

004045fc <pmc_enable_waitmode>:
 * Generally, this function will be called by pmc_sleep() in order to
 * complete all sequence entering wait mode.
 * See \ref pmc_sleep() for entering different sleep modes.
 */
void pmc_enable_waitmode(void)
{
  4045fc:	b480      	push	{r7}
  4045fe:	b083      	sub	sp, #12
  404600:	af00      	add	r7, sp, #0
	uint32_t i;

	/* Flash in wait mode */
	i = PMC->PMC_FSMR;
  404602:	4b1b      	ldr	r3, [pc, #108]	; (404670 <pmc_enable_waitmode+0x74>)
  404604:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  404606:	607b      	str	r3, [r7, #4]
	i &= ~PMC_FSMR_FLPM_Msk;
  404608:	687b      	ldr	r3, [r7, #4]
  40460a:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
  40460e:	607b      	str	r3, [r7, #4]
#if !(SAMV71 || SAMV70 || SAME70 || SAMS70)
	i |= ul_flash_in_wait_mode;
  404610:	4b18      	ldr	r3, [pc, #96]	; (404674 <pmc_enable_waitmode+0x78>)
  404612:	681b      	ldr	r3, [r3, #0]
  404614:	687a      	ldr	r2, [r7, #4]
  404616:	4313      	orrs	r3, r2
  404618:	607b      	str	r3, [r7, #4]
#else
	i |= PMC_WAIT_MODE_FLASH_IDLE;
#endif
	PMC->PMC_FSMR = i;
  40461a:	4a15      	ldr	r2, [pc, #84]	; (404670 <pmc_enable_waitmode+0x74>)
  40461c:	687b      	ldr	r3, [r7, #4]
  40461e:	6713      	str	r3, [r2, #112]	; 0x70

	/* Set the WAITMODE bit = 1 */
	PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_WAITMODE;
  404620:	4a13      	ldr	r2, [pc, #76]	; (404670 <pmc_enable_waitmode+0x74>)
  404622:	4b13      	ldr	r3, [pc, #76]	; (404670 <pmc_enable_waitmode+0x74>)
  404624:	6a1b      	ldr	r3, [r3, #32]
  404626:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40462a:	f043 0304 	orr.w	r3, r3, #4
  40462e:	6213      	str	r3, [r2, #32]

	/* Waiting for Master Clock Ready MCKRDY = 1 */
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  404630:	bf00      	nop
  404632:	4b0f      	ldr	r3, [pc, #60]	; (404670 <pmc_enable_waitmode+0x74>)
  404634:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404636:	f003 0308 	and.w	r3, r3, #8
  40463a:	2b00      	cmp	r3, #0
  40463c:	d0f9      	beq.n	404632 <pmc_enable_waitmode+0x36>

	/* Waiting for MOSCRCEN bit cleared is strongly recommended
	 * to ensure that the core will not execute undesired instructions
	 */
	for (i = 0; i < 500; i++) {
  40463e:	2300      	movs	r3, #0
  404640:	607b      	str	r3, [r7, #4]
  404642:	e003      	b.n	40464c <pmc_enable_waitmode+0x50>
  __ASM volatile ("nop");
  404644:	bf00      	nop
  404646:	687b      	ldr	r3, [r7, #4]
  404648:	3301      	adds	r3, #1
  40464a:	607b      	str	r3, [r7, #4]
  40464c:	687b      	ldr	r3, [r7, #4]
  40464e:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  404652:	d3f7      	bcc.n	404644 <pmc_enable_waitmode+0x48>
		__NOP();
	}
	while (!(PMC->CKGR_MOR & CKGR_MOR_MOSCRCEN));
  404654:	bf00      	nop
  404656:	4b06      	ldr	r3, [pc, #24]	; (404670 <pmc_enable_waitmode+0x74>)
  404658:	6a1b      	ldr	r3, [r3, #32]
  40465a:	f003 0308 	and.w	r3, r3, #8
  40465e:	2b00      	cmp	r3, #0
  404660:	d0f9      	beq.n	404656 <pmc_enable_waitmode+0x5a>
	i = PMC->PMC_FSMR;
	i &= ~PMC_FSMR_FLPM_Msk;
	i |= PMC_WAIT_MODE_FLASH_IDLE;
	PMC->PMC_FSMR = i;
#endif
}
  404662:	bf00      	nop
  404664:	370c      	adds	r7, #12
  404666:	46bd      	mov	sp, r7
  404668:	f85d 7b04 	ldr.w	r7, [sp], #4
  40466c:	4770      	bx	lr
  40466e:	bf00      	nop
  404670:	400e0400 	.word	0x400e0400
  404674:	2000016c 	.word	0x2000016c

00404678 <pmc_sleep>:
static volatile bool b_is_sleep_clock_used = false;
/** Callback invoked once when clocks are restored */
static pmc_callback_wakeup_clocks_restored_t callback_clocks_restored = NULL;

void pmc_sleep(int sleep_mode)
{
  404678:	b590      	push	{r4, r7, lr}
  40467a:	b099      	sub	sp, #100	; 0x64
  40467c:	af00      	add	r7, sp, #0
  40467e:	6078      	str	r0, [r7, #4]
	switch (sleep_mode) {
  404680:	687b      	ldr	r3, [r7, #4]
  404682:	3b01      	subs	r3, #1
  404684:	2b04      	cmp	r3, #4
  404686:	f200 81af 	bhi.w	4049e8 <pmc_sleep+0x370>
  40468a:	a201      	add	r2, pc, #4	; (adr r2, 404690 <pmc_sleep+0x18>)
  40468c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  404690:	004046a5 	.word	0x004046a5
  404694:	004046a5 	.word	0x004046a5
  404698:	004046c5 	.word	0x004046c5
  40469c:	004046c5 	.word	0x004046c5
  4046a0:	004049c7 	.word	0x004049c7
	case SAM_PM_SMODE_SLEEP_WFI:
	case SAM_PM_SMODE_SLEEP_WFE:
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAM4CM || SAM4CP || SAMG || SAMV71 || SAMV70 || SAMS70 || SAME70)
		SCB->SCR &= (uint32_t)~SCR_SLEEPDEEP;
  4046a4:	4a77      	ldr	r2, [pc, #476]	; (404884 <pmc_sleep+0x20c>)
  4046a6:	4b77      	ldr	r3, [pc, #476]	; (404884 <pmc_sleep+0x20c>)
  4046a8:	691b      	ldr	r3, [r3, #16]
  4046aa:	f023 0304 	bic.w	r3, r3, #4
  4046ae:	6113      	str	r3, [r2, #16]
		cpu_irq_enable();
  4046b0:	4b75      	ldr	r3, [pc, #468]	; (404888 <pmc_sleep+0x210>)
  4046b2:	2201      	movs	r2, #1
  4046b4:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb");
  4046b6:	f3bf 8f5f 	dmb	sy
  4046ba:	b662      	cpsie	i
  __ASM volatile ("dsb");
  4046bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfi");
  4046c0:	bf30      	wfi
		__DSB();
		__WFI();
		break;
  4046c2:	e191      	b.n	4049e8 <pmc_sleep+0x370>
#if defined(EFC1)
		uint32_t fmr1;
#endif
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAM4CM || SAM4CP || SAMG || SAMV71 || SAMV70 || SAMS70 || SAME70)
		(sleep_mode == SAM_PM_SMODE_WAIT_FAST) ?
				pmc_set_flash_in_wait_mode(PMC_FSMR_FLPM_FLASH_STANDBY) :
  4046c4:	687b      	ldr	r3, [r7, #4]
  4046c6:	2b03      	cmp	r3, #3
  4046c8:	d103      	bne.n	4046d2 <pmc_sleep+0x5a>
  4046ca:	2000      	movs	r0, #0
  4046cc:	4b6f      	ldr	r3, [pc, #444]	; (40488c <pmc_sleep+0x214>)
  4046ce:	4798      	blx	r3
  4046d0:	e003      	b.n	4046da <pmc_sleep+0x62>
				pmc_set_flash_in_wait_mode(PMC_FSMR_FLPM_FLASH_DEEP_POWERDOWN);
  4046d2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  4046d6:	4b6d      	ldr	r3, [pc, #436]	; (40488c <pmc_sleep+0x214>)
  4046d8:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
  4046da:	b672      	cpsid	i
  __ASM volatile ("dmb");
  4046dc:	f3bf 8f5f 	dmb	sy
#endif
		cpu_irq_disable();
  4046e0:	4b69      	ldr	r3, [pc, #420]	; (404888 <pmc_sleep+0x210>)
  4046e2:	2200      	movs	r2, #0
  4046e4:	701a      	strb	r2, [r3, #0]
		b_is_sleep_clock_used = true;
  4046e6:	4b6a      	ldr	r3, [pc, #424]	; (404890 <pmc_sleep+0x218>)
  4046e8:	2201      	movs	r2, #1
  4046ea:	701a      	strb	r2, [r3, #0]
		/* Backup the sub-system 1 status and stop sub-system 1 */
		uint32_t cpclk_backup = PMC->PMC_SCSR &
				(PMC_SCSR_CPCK | PMC_SCSR_CPBMCK);
		PMC->PMC_SCDR = cpclk_backup | PMC_SCDR_CPKEY_PASSWD;
#endif
		pmc_save_clock_settings(&mor, &pllr0, &pllr1, &mckr, &fmr,
  4046ec:	687b      	ldr	r3, [r7, #4]
  4046ee:	2b04      	cmp	r3, #4
  4046f0:	bf0c      	ite	eq
  4046f2:	2301      	moveq	r3, #1
  4046f4:	2300      	movne	r3, #0
  4046f6:	b2da      	uxtb	r2, r3
  4046f8:	f107 031c 	add.w	r3, r7, #28
  4046fc:	643b      	str	r3, [r7, #64]	; 0x40
  4046fe:	f107 0318 	add.w	r3, r7, #24
  404702:	63fb      	str	r3, [r7, #60]	; 0x3c
  404704:	f107 0314 	add.w	r3, r7, #20
  404708:	63bb      	str	r3, [r7, #56]	; 0x38
  40470a:	f107 0310 	add.w	r3, r7, #16
  40470e:	637b      	str	r3, [r7, #52]	; 0x34
  404710:	f107 030c 	add.w	r3, r7, #12
  404714:	633b      	str	r3, [r7, #48]	; 0x30
  404716:	4613      	mov	r3, r2
  404718:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	uint32_t mor  = PMC->CKGR_MOR;
  40471c:	4b5d      	ldr	r3, [pc, #372]	; (404894 <pmc_sleep+0x21c>)
  40471e:	6a1b      	ldr	r3, [r3, #32]
  404720:	62bb      	str	r3, [r7, #40]	; 0x28
	uint32_t mckr = PMC->PMC_MCKR;
  404722:	4b5c      	ldr	r3, [pc, #368]	; (404894 <pmc_sleep+0x21c>)
  404724:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404726:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t fmr  = EFC0->EEFC_FMR;
  404728:	4b5b      	ldr	r3, [pc, #364]	; (404898 <pmc_sleep+0x220>)
  40472a:	681b      	ldr	r3, [r3, #0]
  40472c:	623b      	str	r3, [r7, #32]
	if (p_osc_setting) {
  40472e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  404730:	2b00      	cmp	r3, #0
  404732:	d002      	beq.n	40473a <pmc_sleep+0xc2>
		*p_osc_setting = mor;
  404734:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  404736:	6aba      	ldr	r2, [r7, #40]	; 0x28
  404738:	601a      	str	r2, [r3, #0]
	if (p_pll0_setting) {
  40473a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40473c:	2b00      	cmp	r3, #0
  40473e:	d003      	beq.n	404748 <pmc_sleep+0xd0>
		*p_pll0_setting = PMC->CKGR_PLLAR;
  404740:	4b54      	ldr	r3, [pc, #336]	; (404894 <pmc_sleep+0x21c>)
  404742:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  404744:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  404746:	601a      	str	r2, [r3, #0]
	if (p_pll1_setting) {
  404748:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40474a:	2b00      	cmp	r3, #0
  40474c:	d002      	beq.n	404754 <pmc_sleep+0xdc>
		*p_pll1_setting = 0;
  40474e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  404750:	2200      	movs	r2, #0
  404752:	601a      	str	r2, [r3, #0]
	if (p_mck_setting) {
  404754:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404756:	2b00      	cmp	r3, #0
  404758:	d002      	beq.n	404760 <pmc_sleep+0xe8>
		*p_mck_setting  = mckr;
  40475a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40475c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40475e:	601a      	str	r2, [r3, #0]
	if (p_fmr_setting) {
  404760:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  404762:	2b00      	cmp	r3, #0
  404764:	d002      	beq.n	40476c <pmc_sleep+0xf4>
		*p_fmr_setting  = fmr;
  404766:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  404768:	6a3a      	ldr	r2, [r7, #32]
  40476a:	601a      	str	r2, [r3, #0]
	PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | mor | CKGR_MOR_MOSCRCEN;
  40476c:	4a49      	ldr	r2, [pc, #292]	; (404894 <pmc_sleep+0x21c>)
  40476e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  404770:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  404774:	f043 0308 	orr.w	r3, r3, #8
  404778:	6213      	str	r3, [r2, #32]
	if ((mckr & PMC_MCKR_CSS_Msk) > PMC_MCKR_CSS_MAIN_CLK) {
  40477a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40477c:	f003 0303 	and.w	r3, r3, #3
  404780:	2b01      	cmp	r3, #1
  404782:	d90e      	bls.n	4047a2 <pmc_sleep+0x12a>
		mckr = (mckr & (~PMC_MCKR_CSS_Msk)) | PMC_MCKR_CSS_MAIN_CLK;
  404784:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  404786:	f023 0303 	bic.w	r3, r3, #3
  40478a:	f043 0301 	orr.w	r3, r3, #1
  40478e:	627b      	str	r3, [r7, #36]	; 0x24
		PMC->PMC_MCKR = mckr;
  404790:	4a40      	ldr	r2, [pc, #256]	; (404894 <pmc_sleep+0x21c>)
  404792:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  404794:	6313      	str	r3, [r2, #48]	; 0x30
		while(!(PMC->PMC_SR & PMC_SR_MCKRDY));
  404796:	4b3f      	ldr	r3, [pc, #252]	; (404894 <pmc_sleep+0x21c>)
  404798:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40479a:	f003 0308 	and.w	r3, r3, #8
  40479e:	2b00      	cmp	r3, #0
  4047a0:	d0f9      	beq.n	404796 <pmc_sleep+0x11e>
	if (mckr & PMC_MCKR_PRES_Msk) {
  4047a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4047a4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4047a8:	2b00      	cmp	r3, #0
  4047aa:	d00c      	beq.n	4047c6 <pmc_sleep+0x14e>
		mckr = (mckr & (~PMC_MCKR_PRES_Msk));
  4047ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4047ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  4047b2:	627b      	str	r3, [r7, #36]	; 0x24
		PMC->PMC_MCKR = mckr;
  4047b4:	4a37      	ldr	r2, [pc, #220]	; (404894 <pmc_sleep+0x21c>)
  4047b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4047b8:	6313      	str	r3, [r2, #48]	; 0x30
		while(!(PMC->PMC_SR & PMC_SR_MCKRDY));
  4047ba:	4b36      	ldr	r3, [pc, #216]	; (404894 <pmc_sleep+0x21c>)
  4047bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4047be:	f003 0308 	and.w	r3, r3, #8
  4047c2:	2b00      	cmp	r3, #0
  4047c4:	d0f9      	beq.n	4047ba <pmc_sleep+0x142>
	pmc_disable_pllack();
  4047c6:	4b35      	ldr	r3, [pc, #212]	; (40489c <pmc_sleep+0x224>)
  4047c8:	4798      	blx	r3
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4047ca:	4b32      	ldr	r3, [pc, #200]	; (404894 <pmc_sleep+0x21c>)
  4047cc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4047ce:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4047d2:	2b00      	cmp	r3, #0
  4047d4:	d0f9      	beq.n	4047ca <pmc_sleep+0x152>
	EFC0->EEFC_FMR = (fmr & (~EEFC_FMR_FWS_Msk)) | EEFC_FMR_FWS(1);
  4047d6:	4a30      	ldr	r2, [pc, #192]	; (404898 <pmc_sleep+0x220>)
  4047d8:	6a3b      	ldr	r3, [r7, #32]
  4047da:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  4047de:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4047e2:	6013      	str	r3, [r2, #0]
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | CKGR_MOR_MOSCRCF_24_MHz |
  4047e4:	492b      	ldr	r1, [pc, #172]	; (404894 <pmc_sleep+0x21c>)
  4047e6:	4b2b      	ldr	r3, [pc, #172]	; (404894 <pmc_sleep+0x21c>)
  4047e8:	6a1a      	ldr	r2, [r3, #32]
  4047ea:	4b2d      	ldr	r3, [pc, #180]	; (4048a0 <pmc_sleep+0x228>)
  4047ec:	4013      	ands	r3, r2
  4047ee:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4047f2:	f043 0320 	orr.w	r3, r3, #32
  4047f6:	620b      	str	r3, [r1, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS));
  4047f8:	4b26      	ldr	r3, [pc, #152]	; (404894 <pmc_sleep+0x21c>)
  4047fa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4047fc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  404800:	2b00      	cmp	r3, #0
  404802:	d0f9      	beq.n	4047f8 <pmc_sleep+0x180>
	if (disable_xtal) {
  404804:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  404808:	2b00      	cmp	r3, #0
  40480a:	d009      	beq.n	404820 <pmc_sleep+0x1a8>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40480c:	4a21      	ldr	r2, [pc, #132]	; (404894 <pmc_sleep+0x21c>)
  40480e:	4b21      	ldr	r3, [pc, #132]	; (404894 <pmc_sleep+0x21c>)
  404810:	6a1b      	ldr	r3, [r3, #32]
  404812:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404816:	f023 0301 	bic.w	r3, r3, #1
  40481a:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40481e:	6213      	str	r3, [r2, #32]
				&fmr1,
#endif
				(sleep_mode == SAM_PM_SMODE_WAIT));

		/* Enter wait mode */
		cpu_irq_enable();
  404820:	4b19      	ldr	r3, [pc, #100]	; (404888 <pmc_sleep+0x210>)
  404822:	2201      	movs	r2, #1
  404824:	701a      	strb	r2, [r3, #0]
  404826:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40482a:	b662      	cpsie	i

		pmc_enable_waitmode();
  40482c:	4b1d      	ldr	r3, [pc, #116]	; (4048a4 <pmc_sleep+0x22c>)
  40482e:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
  404830:	b672      	cpsid	i
  404832:	f3bf 8f5f 	dmb	sy

		cpu_irq_disable();
  404836:	4b14      	ldr	r3, [pc, #80]	; (404888 <pmc_sleep+0x210>)
  404838:	2200      	movs	r2, #0
  40483a:	701a      	strb	r2, [r3, #0]
		pmc_restore_clock_setting(mor, pllr0, pllr1, mckr, fmr
  40483c:	69fc      	ldr	r4, [r7, #28]
  40483e:	69b8      	ldr	r0, [r7, #24]
  404840:	6979      	ldr	r1, [r7, #20]
  404842:	693a      	ldr	r2, [r7, #16]
  404844:	68fb      	ldr	r3, [r7, #12]
  404846:	65fc      	str	r4, [r7, #92]	; 0x5c
  404848:	65b8      	str	r0, [r7, #88]	; 0x58
  40484a:	6579      	str	r1, [r7, #84]	; 0x54
  40484c:	653a      	str	r2, [r7, #80]	; 0x50
  40484e:	64fb      	str	r3, [r7, #76]	; 0x4c
	uint32_t pll_sr = 0;
  404850:	2300      	movs	r3, #0
  404852:	64bb      	str	r3, [r7, #72]	; 0x48
	if (CKGR_MOR_MOSCXTBY == (osc_setting & CKGR_MOR_MOSCXTBY)) {
  404854:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  404856:	f003 0302 	and.w	r3, r3, #2
  40485a:	2b00      	cmp	r3, #0
  40485c:	d028      	beq.n	4048b0 <pmc_sleep+0x238>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40485e:	490d      	ldr	r1, [pc, #52]	; (404894 <pmc_sleep+0x21c>)
  404860:	4b0c      	ldr	r3, [pc, #48]	; (404894 <pmc_sleep+0x21c>)
  404862:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  404864:	4a10      	ldr	r2, [pc, #64]	; (4048a8 <pmc_sleep+0x230>)
  404866:	401a      	ands	r2, r3
  404868:	4b10      	ldr	r3, [pc, #64]	; (4048ac <pmc_sleep+0x234>)
  40486a:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40486c:	620b      	str	r3, [r1, #32]
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN &
  40486e:	4a09      	ldr	r2, [pc, #36]	; (404894 <pmc_sleep+0x21c>)
  404870:	4b08      	ldr	r3, [pc, #32]	; (404894 <pmc_sleep+0x21c>)
  404872:	6a1b      	ldr	r3, [r3, #32]
				| CKGR_MOR_KEY_PASSWD;
  404874:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404878:	f023 0378 	bic.w	r3, r3, #120	; 0x78
  40487c:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN &
  404880:	6213      	str	r3, [r2, #32]
  404882:	e050      	b.n	404926 <pmc_sleep+0x2ae>
  404884:	e000ed00 	.word	0xe000ed00
  404888:	20000114 	.word	0x20000114
  40488c:	004045dd 	.word	0x004045dd
  404890:	20000424 	.word	0x20000424
  404894:	400e0400 	.word	0x400e0400
  404898:	400e0a00 	.word	0x400e0a00
  40489c:	004043f1 	.word	0x004043f1
  4048a0:	fec8ffdf 	.word	0xfec8ffdf
  4048a4:	004045fd 	.word	0x004045fd
  4048a8:	fec8fffc 	.word	0xfec8fffc
  4048ac:	01370002 	.word	0x01370002
	} else if (CKGR_MOR_MOSCXTEN == (osc_setting & CKGR_MOR_MOSCXTEN)) {
  4048b0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  4048b2:	f003 0301 	and.w	r3, r3, #1
  4048b6:	2b00      	cmp	r3, #0
  4048b8:	d035      	beq.n	404926 <pmc_sleep+0x2ae>
		if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN)) {
  4048ba:	4b4d      	ldr	r3, [pc, #308]	; (4049f0 <pmc_sleep+0x378>)
  4048bc:	6a1b      	ldr	r3, [r3, #32]
  4048be:	f003 0301 	and.w	r3, r3, #1
  4048c2:	2b00      	cmp	r3, #0
  4048c4:	d111      	bne.n	4048ea <pmc_sleep+0x272>
			PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4048c6:	4a4a      	ldr	r2, [pc, #296]	; (4049f0 <pmc_sleep+0x378>)
  4048c8:	4b49      	ldr	r3, [pc, #292]	; (4049f0 <pmc_sleep+0x378>)
  4048ca:	6a1b      	ldr	r3, [r3, #32]
					CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN;
  4048cc:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  4048d0:	f023 0303 	bic.w	r3, r3, #3
  4048d4:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4048d8:	f043 0301 	orr.w	r3, r3, #1
			PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4048dc:	6213      	str	r3, [r2, #32]
			while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4048de:	4b44      	ldr	r3, [pc, #272]	; (4049f0 <pmc_sleep+0x378>)
  4048e0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4048e2:	f003 0301 	and.w	r3, r3, #1
  4048e6:	2b00      	cmp	r3, #0
  4048e8:	d0f9      	beq.n	4048de <pmc_sleep+0x266>
		if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
  4048ea:	4b41      	ldr	r3, [pc, #260]	; (4049f0 <pmc_sleep+0x378>)
  4048ec:	6a1b      	ldr	r3, [r3, #32]
  4048ee:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4048f2:	2b00      	cmp	r3, #0
  4048f4:	d10d      	bne.n	404912 <pmc_sleep+0x29a>
			PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4048f6:	4a3e      	ldr	r2, [pc, #248]	; (4049f0 <pmc_sleep+0x378>)
  4048f8:	4b3d      	ldr	r3, [pc, #244]	; (4049f0 <pmc_sleep+0x378>)
  4048fa:	6a1b      	ldr	r3, [r3, #32]
  4048fc:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  404900:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  404904:	6213      	str	r3, [r2, #32]
			while (!(PMC->PMC_SR & PMC_SR_MOSCSELS));
  404906:	4b3a      	ldr	r3, [pc, #232]	; (4049f0 <pmc_sleep+0x378>)
  404908:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40490a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  40490e:	2b00      	cmp	r3, #0
  404910:	d0f9      	beq.n	404906 <pmc_sleep+0x28e>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN &
  404912:	4a37      	ldr	r2, [pc, #220]	; (4049f0 <pmc_sleep+0x378>)
  404914:	4b36      	ldr	r3, [pc, #216]	; (4049f0 <pmc_sleep+0x378>)
  404916:	6a1b      	ldr	r3, [r3, #32]
					| CKGR_MOR_KEY_PASSWD;
  404918:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40491c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
  404920:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN &
  404924:	6213      	str	r3, [r2, #32]
	if (pll0_setting & CKGR_PLLAR_MULA_Msk) {
  404926:	6dba      	ldr	r2, [r7, #88]	; 0x58
  404928:	4b32      	ldr	r3, [pc, #200]	; (4049f4 <pmc_sleep+0x37c>)
  40492a:	4013      	ands	r3, r2
  40492c:	2b00      	cmp	r3, #0
  40492e:	d006      	beq.n	40493e <pmc_sleep+0x2c6>
		PMC->CKGR_PLLAR = pll0_setting;
  404930:	4a2f      	ldr	r2, [pc, #188]	; (4049f0 <pmc_sleep+0x378>)
  404932:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  404934:	6293      	str	r3, [r2, #40]	; 0x28
		pll_sr |= PMC_SR_LOCKA;
  404936:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  404938:	f043 0302 	orr.w	r3, r3, #2
  40493c:	64bb      	str	r3, [r7, #72]	; 0x48
	switch(mck_setting & PMC_MCKR_CSS_Msk) {
  40493e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  404940:	f003 0303 	and.w	r3, r3, #3
  404944:	2b02      	cmp	r3, #2
  404946:	d105      	bne.n	404954 <pmc_sleep+0x2dc>
		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
  404948:	4b29      	ldr	r3, [pc, #164]	; (4049f0 <pmc_sleep+0x378>)
  40494a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40494c:	f003 0302 	and.w	r3, r3, #2
  404950:	2b00      	cmp	r3, #0
  404952:	d0f9      	beq.n	404948 <pmc_sleep+0x2d0>
	mckr = PMC->PMC_MCKR;
  404954:	4b26      	ldr	r3, [pc, #152]	; (4049f0 <pmc_sleep+0x378>)
  404956:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404958:	647b      	str	r3, [r7, #68]	; 0x44
	PMC->PMC_MCKR = (mckr & ~PMC_MCKR_PRES_Msk)
  40495a:	4925      	ldr	r1, [pc, #148]	; (4049f0 <pmc_sleep+0x378>)
  40495c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40495e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
		| (mck_setting & PMC_MCKR_PRES_Msk);
  404962:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  404964:	f003 0370 	and.w	r3, r3, #112	; 0x70
  404968:	4313      	orrs	r3, r2
	PMC->PMC_MCKR = (mckr & ~PMC_MCKR_PRES_Msk)
  40496a:	630b      	str	r3, [r1, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  40496c:	4b20      	ldr	r3, [pc, #128]	; (4049f0 <pmc_sleep+0x378>)
  40496e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404970:	f003 0308 	and.w	r3, r3, #8
  404974:	2b00      	cmp	r3, #0
  404976:	d0f9      	beq.n	40496c <pmc_sleep+0x2f4>
	EFC0->EEFC_FMR = fmr_setting;
  404978:	4a1f      	ldr	r2, [pc, #124]	; (4049f8 <pmc_sleep+0x380>)
  40497a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40497c:	6013      	str	r3, [r2, #0]
	PMC->PMC_MCKR = mck_setting;
  40497e:	4a1c      	ldr	r2, [pc, #112]	; (4049f0 <pmc_sleep+0x378>)
  404980:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  404982:	6313      	str	r3, [r2, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  404984:	4b1a      	ldr	r3, [pc, #104]	; (4049f0 <pmc_sleep+0x378>)
  404986:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404988:	f003 0308 	and.w	r3, r3, #8
  40498c:	2b00      	cmp	r3, #0
  40498e:	d0f9      	beq.n	404984 <pmc_sleep+0x30c>
	while (!(PMC->PMC_SR & pll_sr));
  404990:	4b17      	ldr	r3, [pc, #92]	; (4049f0 <pmc_sleep+0x378>)
  404992:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  404994:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  404996:	4013      	ands	r3, r2
  404998:	2b00      	cmp	r3, #0
  40499a:	d0f9      	beq.n	404990 <pmc_sleep+0x318>

#if (SAM4C || SAM4CM || SAM4CP)
		/* Restore the sub-system 1 */
		PMC->PMC_SCER = cpclk_backup | PMC_SCER_CPKEY_PASSWD;
#endif
		b_is_sleep_clock_used = false;
  40499c:	4b17      	ldr	r3, [pc, #92]	; (4049fc <pmc_sleep+0x384>)
  40499e:	2200      	movs	r2, #0
  4049a0:	701a      	strb	r2, [r3, #0]
		if (callback_clocks_restored) {
  4049a2:	4b17      	ldr	r3, [pc, #92]	; (404a00 <pmc_sleep+0x388>)
  4049a4:	681b      	ldr	r3, [r3, #0]
  4049a6:	2b00      	cmp	r3, #0
  4049a8:	d005      	beq.n	4049b6 <pmc_sleep+0x33e>
			callback_clocks_restored();
  4049aa:	4b15      	ldr	r3, [pc, #84]	; (404a00 <pmc_sleep+0x388>)
  4049ac:	681b      	ldr	r3, [r3, #0]
  4049ae:	4798      	blx	r3
			callback_clocks_restored = NULL;
  4049b0:	4b13      	ldr	r3, [pc, #76]	; (404a00 <pmc_sleep+0x388>)
  4049b2:	2200      	movs	r2, #0
  4049b4:	601a      	str	r2, [r3, #0]
		}
		cpu_irq_enable();
  4049b6:	4b13      	ldr	r3, [pc, #76]	; (404a04 <pmc_sleep+0x38c>)
  4049b8:	2201      	movs	r2, #1
  4049ba:	701a      	strb	r2, [r3, #0]
  4049bc:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4049c0:	b662      	cpsie	i

		break;
  4049c2:	bf00      	nop
  4049c4:	e010      	b.n	4049e8 <pmc_sleep+0x370>
	}
#if (!(SAMG51 || SAMG53 || SAMG54))
	case SAM_PM_SMODE_BACKUP:
		SCB->SCR |= SCR_SLEEPDEEP;
  4049c6:	4a10      	ldr	r2, [pc, #64]	; (404a08 <pmc_sleep+0x390>)
  4049c8:	4b0f      	ldr	r3, [pc, #60]	; (404a08 <pmc_sleep+0x390>)
  4049ca:	691b      	ldr	r3, [r3, #16]
  4049cc:	f043 0304 	orr.w	r3, r3, #4
  4049d0:	6113      	str	r3, [r2, #16]
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAMS70 || SAME70)
		SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_VROFF_STOP_VREG;
  4049d2:	4b0e      	ldr	r3, [pc, #56]	; (404a0c <pmc_sleep+0x394>)
  4049d4:	4a0e      	ldr	r2, [pc, #56]	; (404a10 <pmc_sleep+0x398>)
  4049d6:	601a      	str	r2, [r3, #0]
		cpu_irq_enable();
  4049d8:	4b0a      	ldr	r3, [pc, #40]	; (404a04 <pmc_sleep+0x38c>)
  4049da:	2201      	movs	r2, #1
  4049dc:	701a      	strb	r2, [r3, #0]
  4049de:	f3bf 8f5f 	dmb	sy
  4049e2:	b662      	cpsie	i
  __ASM volatile ("wfi");
  4049e4:	bf30      	wfi
		__WFI() ;
#else
		cpu_irq_enable();
		__WFE() ;
#endif
		break;
  4049e6:	bf00      	nop
#endif
	}
}
  4049e8:	bf00      	nop
  4049ea:	3764      	adds	r7, #100	; 0x64
  4049ec:	46bd      	mov	sp, r7
  4049ee:	bd90      	pop	{r4, r7, pc}
  4049f0:	400e0400 	.word	0x400e0400
  4049f4:	1fff0000 	.word	0x1fff0000
  4049f8:	400e0a00 	.word	0x400e0a00
  4049fc:	20000424 	.word	0x20000424
  404a00:	20000428 	.word	0x20000428
  404a04:	20000114 	.word	0x20000114
  404a08:	e000ed00 	.word	0xe000ed00
  404a0c:	400e1410 	.word	0x400e1410
  404a10:	a5000004 	.word	0xa5000004

00404a14 <rtt_get_status>:
 * \param p_rtt Pointer to an RTT instance.
 *
 * \return The Real-time Timer status.
 */
uint32_t rtt_get_status(Rtt *p_rtt)
{
  404a14:	b480      	push	{r7}
  404a16:	b083      	sub	sp, #12
  404a18:	af00      	add	r7, sp, #0
  404a1a:	6078      	str	r0, [r7, #4]
	return p_rtt->RTT_SR;
  404a1c:	687b      	ldr	r3, [r7, #4]
  404a1e:	68db      	ldr	r3, [r3, #12]
}
  404a20:	4618      	mov	r0, r3
  404a22:	370c      	adds	r7, #12
  404a24:	46bd      	mov	sp, r7
  404a26:	f85d 7b04 	ldr.w	r7, [sp], #4
  404a2a:	4770      	bx	lr

00404a2c <supc_set_regulator_trim_user>:
 * \param value the trim value.
 *
 * \note For the trim value in 96M PLL, please read the value in flash unique identifier area.
 */
void supc_set_regulator_trim_user(Supc *p_supc, uint32_t value)
{
  404a2c:	b480      	push	{r7}
  404a2e:	b085      	sub	sp, #20
  404a30:	af00      	add	r7, sp, #0
  404a32:	6078      	str	r0, [r7, #4]
  404a34:	6039      	str	r1, [r7, #0]
#if SAMG54
	uint32_t ul_mr = p_supc->SUPC_MR & (~SUPC_MR_VRVDD_Msk);
	p_supc->SUPC_MR = SUPC_MR_KEY_PASSWD | ul_mr | SUPC_MR_VDDSEL_USER_VRVDD
		 | SUPC_MR_VRVDD(value);
#else
	uint32_t ul_pwmr = p_supc->SUPC_PWMR & (~(0xFu << 9));
  404a36:	687b      	ldr	r3, [r7, #4]
  404a38:	69db      	ldr	r3, [r3, #28]
  404a3a:	f423 53f0 	bic.w	r3, r3, #7680	; 0x1e00
  404a3e:	60fb      	str	r3, [r7, #12]
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
		| ((value & 0xFu) << 9);
  404a40:	683b      	ldr	r3, [r7, #0]
  404a42:	025b      	lsls	r3, r3, #9
  404a44:	f403 52f0 	and.w	r2, r3, #7680	; 0x1e00
  404a48:	68fb      	ldr	r3, [r7, #12]
  404a4a:	4313      	orrs	r3, r2
  404a4c:	f043 43b4 	orr.w	r3, r3, #1509949440	; 0x5a000000
  404a50:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
  404a54:	687a      	ldr	r2, [r7, #4]
  404a56:	61d3      	str	r3, [r2, #28]
#endif
}
  404a58:	bf00      	nop
  404a5a:	3714      	adds	r7, #20
  404a5c:	46bd      	mov	sp, r7
  404a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404a62:	4770      	bx	lr

00404a64 <tc_init>:
 */
void tc_init(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_mode)
{
  404a64:	b480      	push	{r7}
  404a66:	b087      	sub	sp, #28
  404a68:	af00      	add	r7, sp, #0
  404a6a:	60f8      	str	r0, [r7, #12]
  404a6c:	60b9      	str	r1, [r7, #8]
  404a6e:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  404a70:	68fa      	ldr	r2, [r7, #12]
  404a72:	68bb      	ldr	r3, [r7, #8]
  404a74:	019b      	lsls	r3, r3, #6
  404a76:	4413      	add	r3, r2
  404a78:	617b      	str	r3, [r7, #20]

	/*  Disable TC clock. */
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  404a7a:	697b      	ldr	r3, [r7, #20]
  404a7c:	2202      	movs	r2, #2
  404a7e:	601a      	str	r2, [r3, #0]

	/*  Disable interrupts. */
	tc_channel->TC_IDR = 0xFFFFFFFF;
  404a80:	697b      	ldr	r3, [r7, #20]
  404a82:	f04f 32ff 	mov.w	r2, #4294967295
  404a86:	629a      	str	r2, [r3, #40]	; 0x28

	/*  Clear status register. */
	tc_channel->TC_SR;
  404a88:	697b      	ldr	r3, [r7, #20]
  404a8a:	6a1b      	ldr	r3, [r3, #32]

	/*  Set mode. */
	tc_channel->TC_CMR = ul_mode;
  404a8c:	697b      	ldr	r3, [r7, #20]
  404a8e:	687a      	ldr	r2, [r7, #4]
  404a90:	605a      	str	r2, [r3, #4]
}
  404a92:	bf00      	nop
  404a94:	371c      	adds	r7, #28
  404a96:	46bd      	mov	sp, r7
  404a98:	f85d 7b04 	ldr.w	r7, [sp], #4
  404a9c:	4770      	bx	lr

00404a9e <tc_start>:
 * \param[in] ul_channel Channel to configure
 */
void tc_start(
		Tc *p_tc,
		uint32_t ul_channel)
{
  404a9e:	b480      	push	{r7}
  404aa0:	b083      	sub	sp, #12
  404aa2:	af00      	add	r7, sp, #0
  404aa4:	6078      	str	r0, [r7, #4]
  404aa6:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
  404aa8:	687a      	ldr	r2, [r7, #4]
  404aaa:	683b      	ldr	r3, [r7, #0]
  404aac:	019b      	lsls	r3, r3, #6
  404aae:	4413      	add	r3, r2
  404ab0:	2205      	movs	r2, #5
  404ab2:	601a      	str	r2, [r3, #0]
}
  404ab4:	bf00      	nop
  404ab6:	370c      	adds	r7, #12
  404ab8:	46bd      	mov	sp, r7
  404aba:	f85d 7b04 	ldr.w	r7, [sp], #4
  404abe:	4770      	bx	lr

00404ac0 <tc_write_rc>:
 */
void tc_write_rc(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_value)
{
  404ac0:	b480      	push	{r7}
  404ac2:	b085      	sub	sp, #20
  404ac4:	af00      	add	r7, sp, #0
  404ac6:	60f8      	str	r0, [r7, #12]
  404ac8:	60b9      	str	r1, [r7, #8]
  404aca:	607a      	str	r2, [r7, #4]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_RC = ul_value;
  404acc:	68fa      	ldr	r2, [r7, #12]
  404ace:	68bb      	ldr	r3, [r7, #8]
  404ad0:	019b      	lsls	r3, r3, #6
  404ad2:	4413      	add	r3, r2
  404ad4:	331c      	adds	r3, #28
  404ad6:	687a      	ldr	r2, [r7, #4]
  404ad8:	601a      	str	r2, [r3, #0]
}
  404ada:	bf00      	nop
  404adc:	3714      	adds	r7, #20
  404ade:	46bd      	mov	sp, r7
  404ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
  404ae4:	4770      	bx	lr

00404ae6 <tc_enable_interrupt>:
 */
void tc_enable_interrupt(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_sources)
{
  404ae6:	b480      	push	{r7}
  404ae8:	b087      	sub	sp, #28
  404aea:	af00      	add	r7, sp, #0
  404aec:	60f8      	str	r0, [r7, #12]
  404aee:	60b9      	str	r1, [r7, #8]
  404af0:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  404af2:	68fa      	ldr	r2, [r7, #12]
  404af4:	68bb      	ldr	r3, [r7, #8]
  404af6:	019b      	lsls	r3, r3, #6
  404af8:	4413      	add	r3, r2
  404afa:	617b      	str	r3, [r7, #20]
	tc_channel->TC_IER = ul_sources;
  404afc:	697b      	ldr	r3, [r7, #20]
  404afe:	687a      	ldr	r2, [r7, #4]
  404b00:	625a      	str	r2, [r3, #36]	; 0x24
}
  404b02:	bf00      	nop
  404b04:	371c      	adds	r7, #28
  404b06:	46bd      	mov	sp, r7
  404b08:	f85d 7b04 	ldr.w	r7, [sp], #4
  404b0c:	4770      	bx	lr

00404b0e <tc_get_interrupt_mask>:
 * \return The TC interrupt mask value.
 */
uint32_t tc_get_interrupt_mask(
		Tc *p_tc,
		uint32_t ul_channel)
{
  404b0e:	b480      	push	{r7}
  404b10:	b085      	sub	sp, #20
  404b12:	af00      	add	r7, sp, #0
  404b14:	6078      	str	r0, [r7, #4]
  404b16:	6039      	str	r1, [r7, #0]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  404b18:	687a      	ldr	r2, [r7, #4]
  404b1a:	683b      	ldr	r3, [r7, #0]
  404b1c:	019b      	lsls	r3, r3, #6
  404b1e:	4413      	add	r3, r2
  404b20:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_IMR;
  404b22:	68fb      	ldr	r3, [r7, #12]
  404b24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  404b26:	4618      	mov	r0, r3
  404b28:	3714      	adds	r7, #20
  404b2a:	46bd      	mov	sp, r7
  404b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404b30:	4770      	bx	lr

00404b32 <tc_get_status>:
 * \return The current TC status.
 */
uint32_t tc_get_status(
		Tc *p_tc,
		uint32_t ul_channel)
{
  404b32:	b480      	push	{r7}
  404b34:	b085      	sub	sp, #20
  404b36:	af00      	add	r7, sp, #0
  404b38:	6078      	str	r0, [r7, #4]
  404b3a:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
			
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  404b3c:	687a      	ldr	r2, [r7, #4]
  404b3e:	683b      	ldr	r3, [r7, #0]
  404b40:	019b      	lsls	r3, r3, #6
  404b42:	4413      	add	r3, r2
  404b44:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_SR;
  404b46:	68fb      	ldr	r3, [r7, #12]
  404b48:	6a1b      	ldr	r3, [r3, #32]
}
  404b4a:	4618      	mov	r0, r3
  404b4c:	3714      	adds	r7, #20
  404b4e:	46bd      	mov	sp, r7
  404b50:	f85d 7b04 	ldr.w	r7, [sp], #4
  404b54:	4770      	bx	lr

00404b56 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  404b56:	b480      	push	{r7}
  404b58:	b083      	sub	sp, #12
  404b5a:	af00      	add	r7, sp, #0
  404b5c:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  404b5e:	687b      	ldr	r3, [r7, #4]
  404b60:	2208      	movs	r2, #8
  404b62:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  404b64:	687b      	ldr	r3, [r7, #4]
  404b66:	2220      	movs	r2, #32
  404b68:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  404b6a:	687b      	ldr	r3, [r7, #4]
  404b6c:	2204      	movs	r2, #4
  404b6e:	601a      	str	r2, [r3, #0]
}
  404b70:	bf00      	nop
  404b72:	370c      	adds	r7, #12
  404b74:	46bd      	mov	sp, r7
  404b76:	f85d 7b04 	ldr.w	r7, [sp], #4
  404b7a:	4770      	bx	lr

00404b7c <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  404b7c:	b580      	push	{r7, lr}
  404b7e:	b084      	sub	sp, #16
  404b80:	af00      	add	r7, sp, #0
  404b82:	6078      	str	r0, [r7, #4]
  404b84:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  404b86:	2300      	movs	r3, #0
  404b88:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  404b8a:	687b      	ldr	r3, [r7, #4]
  404b8c:	f04f 32ff 	mov.w	r2, #4294967295
  404b90:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  404b92:	687b      	ldr	r3, [r7, #4]
  404b94:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  404b96:	6878      	ldr	r0, [r7, #4]
  404b98:	4b0e      	ldr	r3, [pc, #56]	; (404bd4 <twi_master_init+0x58>)
  404b9a:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  404b9c:	6878      	ldr	r0, [r7, #4]
  404b9e:	4b0e      	ldr	r3, [pc, #56]	; (404bd8 <twi_master_init+0x5c>)
  404ba0:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  404ba2:	683b      	ldr	r3, [r7, #0]
  404ba4:	6859      	ldr	r1, [r3, #4]
  404ba6:	683b      	ldr	r3, [r7, #0]
  404ba8:	681b      	ldr	r3, [r3, #0]
  404baa:	461a      	mov	r2, r3
  404bac:	6878      	ldr	r0, [r7, #4]
  404bae:	4b0b      	ldr	r3, [pc, #44]	; (404bdc <twi_master_init+0x60>)
  404bb0:	4798      	blx	r3
  404bb2:	4603      	mov	r3, r0
  404bb4:	2b01      	cmp	r3, #1
  404bb6:	d101      	bne.n	404bbc <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  404bb8:	2301      	movs	r3, #1
  404bba:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  404bbc:	683b      	ldr	r3, [r7, #0]
  404bbe:	7a5b      	ldrb	r3, [r3, #9]
  404bc0:	2b01      	cmp	r3, #1
  404bc2:	d102      	bne.n	404bca <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  404bc4:	687b      	ldr	r3, [r7, #4]
  404bc6:	2240      	movs	r2, #64	; 0x40
  404bc8:	601a      	str	r2, [r3, #0]
	}

	return status;
  404bca:	68fb      	ldr	r3, [r7, #12]
}
  404bcc:	4618      	mov	r0, r3
  404bce:	3710      	adds	r7, #16
  404bd0:	46bd      	mov	sp, r7
  404bd2:	bd80      	pop	{r7, pc}
  404bd4:	00404f85 	.word	0x00404f85
  404bd8:	00404b57 	.word	0x00404b57
  404bdc:	00404be1 	.word	0x00404be1

00404be0 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  404be0:	b480      	push	{r7}
  404be2:	b089      	sub	sp, #36	; 0x24
  404be4:	af00      	add	r7, sp, #0
  404be6:	60f8      	str	r0, [r7, #12]
  404be8:	60b9      	str	r1, [r7, #8]
  404bea:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  404bec:	2300      	movs	r3, #0
  404bee:	61fb      	str	r3, [r7, #28]
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  404bf0:	68bb      	ldr	r3, [r7, #8]
  404bf2:	4a34      	ldr	r2, [pc, #208]	; (404cc4 <twi_set_speed+0xe4>)
  404bf4:	4293      	cmp	r3, r2
  404bf6:	d901      	bls.n	404bfc <twi_set_speed+0x1c>
		return FAIL;
  404bf8:	2301      	movs	r3, #1
  404bfa:	e05d      	b.n	404cb8 <twi_set_speed+0xd8>
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  404bfc:	68bb      	ldr	r3, [r7, #8]
  404bfe:	4a32      	ldr	r2, [pc, #200]	; (404cc8 <twi_set_speed+0xe8>)
  404c00:	4293      	cmp	r3, r2
  404c02:	d937      	bls.n	404c74 <twi_set_speed+0x94>
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  404c04:	687b      	ldr	r3, [r7, #4]
  404c06:	4a31      	ldr	r2, [pc, #196]	; (404ccc <twi_set_speed+0xec>)
  404c08:	fba2 2303 	umull	r2, r3, r2, r3
  404c0c:	0b9b      	lsrs	r3, r3, #14
  404c0e:	3b03      	subs	r3, #3
  404c10:	617b      	str	r3, [r7, #20]
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  404c12:	68ba      	ldr	r2, [r7, #8]
  404c14:	4b2e      	ldr	r3, [pc, #184]	; (404cd0 <twi_set_speed+0xf0>)
  404c16:	4413      	add	r3, r2
  404c18:	009b      	lsls	r3, r3, #2
  404c1a:	687a      	ldr	r2, [r7, #4]
  404c1c:	fbb2 f3f3 	udiv	r3, r2, r3
  404c20:	3b03      	subs	r3, #3
  404c22:	613b      	str	r3, [r7, #16]
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c24:	e005      	b.n	404c32 <twi_set_speed+0x52>
			/* Increase clock divider */
			ckdiv++;
  404c26:	69fb      	ldr	r3, [r7, #28]
  404c28:	3301      	adds	r3, #1
  404c2a:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			cldiv /= TWI_CLK_DIVIDER;
  404c2c:	697b      	ldr	r3, [r7, #20]
  404c2e:	085b      	lsrs	r3, r3, #1
  404c30:	617b      	str	r3, [r7, #20]
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c32:	697b      	ldr	r3, [r7, #20]
  404c34:	2bff      	cmp	r3, #255	; 0xff
  404c36:	d909      	bls.n	404c4c <twi_set_speed+0x6c>
  404c38:	69fb      	ldr	r3, [r7, #28]
  404c3a:	2b06      	cmp	r3, #6
  404c3c:	d9f3      	bls.n	404c26 <twi_set_speed+0x46>
		}
		/* chdiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c3e:	e005      	b.n	404c4c <twi_set_speed+0x6c>
			/* Increase clock divider */
			ckdiv++;
  404c40:	69fb      	ldr	r3, [r7, #28]
  404c42:	3301      	adds	r3, #1
  404c44:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			chdiv /= TWI_CLK_DIVIDER;
  404c46:	693b      	ldr	r3, [r7, #16]
  404c48:	085b      	lsrs	r3, r3, #1
  404c4a:	613b      	str	r3, [r7, #16]
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c4c:	693b      	ldr	r3, [r7, #16]
  404c4e:	2bff      	cmp	r3, #255	; 0xff
  404c50:	d902      	bls.n	404c58 <twi_set_speed+0x78>
  404c52:	69fb      	ldr	r3, [r7, #28]
  404c54:	2b06      	cmp	r3, #6
  404c56:	d9f3      	bls.n	404c40 <twi_set_speed+0x60>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  404c58:	697b      	ldr	r3, [r7, #20]
  404c5a:	b2da      	uxtb	r2, r3
  404c5c:	693b      	ldr	r3, [r7, #16]
  404c5e:	021b      	lsls	r3, r3, #8
  404c60:	b29b      	uxth	r3, r3
  404c62:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);		
  404c64:	69fb      	ldr	r3, [r7, #28]
  404c66:	041b      	lsls	r3, r3, #16
  404c68:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  404c6c:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  404c6e:	68fb      	ldr	r3, [r7, #12]
  404c70:	611a      	str	r2, [r3, #16]
  404c72:	e020      	b.n	404cb6 <twi_set_speed+0xd6>
	} else {
		c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  404c74:	68bb      	ldr	r3, [r7, #8]
  404c76:	005b      	lsls	r3, r3, #1
  404c78:	687a      	ldr	r2, [r7, #4]
  404c7a:	fbb2 f3f3 	udiv	r3, r2, r3
  404c7e:	3b03      	subs	r3, #3
  404c80:	61bb      	str	r3, [r7, #24]

		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c82:	e005      	b.n	404c90 <twi_set_speed+0xb0>
			/* Increase clock divider */
			ckdiv++;
  404c84:	69fb      	ldr	r3, [r7, #28]
  404c86:	3301      	adds	r3, #1
  404c88:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			c_lh_div /= TWI_CLK_DIVIDER;
  404c8a:	69bb      	ldr	r3, [r7, #24]
  404c8c:	085b      	lsrs	r3, r3, #1
  404c8e:	61bb      	str	r3, [r7, #24]
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  404c90:	69bb      	ldr	r3, [r7, #24]
  404c92:	2bff      	cmp	r3, #255	; 0xff
  404c94:	d902      	bls.n	404c9c <twi_set_speed+0xbc>
  404c96:	69fb      	ldr	r3, [r7, #28]
  404c98:	2b06      	cmp	r3, #6
  404c9a:	d9f3      	bls.n	404c84 <twi_set_speed+0xa4>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  404c9c:	69bb      	ldr	r3, [r7, #24]
  404c9e:	b2da      	uxtb	r2, r3
  404ca0:	69bb      	ldr	r3, [r7, #24]
  404ca2:	021b      	lsls	r3, r3, #8
  404ca4:	b29b      	uxth	r3, r3
  404ca6:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);
  404ca8:	69fb      	ldr	r3, [r7, #28]
  404caa:	041b      	lsls	r3, r3, #16
  404cac:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  404cb0:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  404cb2:	68fb      	ldr	r3, [r7, #12]
  404cb4:	611a      	str	r2, [r3, #16]
	}

	return PASS;
  404cb6:	2300      	movs	r3, #0
}
  404cb8:	4618      	mov	r0, r3
  404cba:	3724      	adds	r7, #36	; 0x24
  404cbc:	46bd      	mov	sp, r7
  404cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
  404cc2:	4770      	bx	lr
  404cc4:	00061a80 	.word	0x00061a80
  404cc8:	0005dc00 	.word	0x0005dc00
  404ccc:	057619f1 	.word	0x057619f1
  404cd0:	3ffd1200 	.word	0x3ffd1200

00404cd4 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  404cd4:	b480      	push	{r7}
  404cd6:	b085      	sub	sp, #20
  404cd8:	af00      	add	r7, sp, #0
  404cda:	6078      	str	r0, [r7, #4]
  404cdc:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  404cde:	683b      	ldr	r3, [r7, #0]
  404ce0:	2b00      	cmp	r3, #0
  404ce2:	d101      	bne.n	404ce8 <twi_mk_addr+0x14>
		return 0;
  404ce4:	2300      	movs	r3, #0
  404ce6:	e01d      	b.n	404d24 <twi_mk_addr+0x50>

	val = addr[0];
  404ce8:	687b      	ldr	r3, [r7, #4]
  404cea:	781b      	ldrb	r3, [r3, #0]
  404cec:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  404cee:	683b      	ldr	r3, [r7, #0]
  404cf0:	2b01      	cmp	r3, #1
  404cf2:	dd09      	ble.n	404d08 <twi_mk_addr+0x34>
		val <<= 8;
  404cf4:	68fb      	ldr	r3, [r7, #12]
  404cf6:	021b      	lsls	r3, r3, #8
  404cf8:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  404cfa:	687b      	ldr	r3, [r7, #4]
  404cfc:	3301      	adds	r3, #1
  404cfe:	781b      	ldrb	r3, [r3, #0]
  404d00:	461a      	mov	r2, r3
  404d02:	68fb      	ldr	r3, [r7, #12]
  404d04:	4313      	orrs	r3, r2
  404d06:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  404d08:	683b      	ldr	r3, [r7, #0]
  404d0a:	2b02      	cmp	r3, #2
  404d0c:	dd09      	ble.n	404d22 <twi_mk_addr+0x4e>
		val <<= 8;
  404d0e:	68fb      	ldr	r3, [r7, #12]
  404d10:	021b      	lsls	r3, r3, #8
  404d12:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  404d14:	687b      	ldr	r3, [r7, #4]
  404d16:	3302      	adds	r3, #2
  404d18:	781b      	ldrb	r3, [r3, #0]
  404d1a:	461a      	mov	r2, r3
  404d1c:	68fb      	ldr	r3, [r7, #12]
  404d1e:	4313      	orrs	r3, r2
  404d20:	60fb      	str	r3, [r7, #12]
	}
	return val;
  404d22:	68fb      	ldr	r3, [r7, #12]
}
  404d24:	4618      	mov	r0, r3
  404d26:	3714      	adds	r7, #20
  404d28:	46bd      	mov	sp, r7
  404d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  404d2e:	4770      	bx	lr

00404d30 <twi_master_read>:
 *        With -Os size optimization, a two-byte register read will sometimes
 *        only read the LSB but return value as if the MSB (observed on SAMG55).
 *        See bug report US-590.
 */
__attribute__((optimize("O0"))) uint32_t twi_master_read(Twi *p_twi, twi_packet_t *p_packet)
{
  404d30:	b580      	push	{r7, lr}
  404d32:	b088      	sub	sp, #32
  404d34:	af00      	add	r7, sp, #0
  404d36:	6078      	str	r0, [r7, #4]
  404d38:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  404d3a:	683b      	ldr	r3, [r7, #0]
  404d3c:	68db      	ldr	r3, [r3, #12]
  404d3e:	61fb      	str	r3, [r7, #28]
	uint8_t *buffer = p_packet->buffer;
  404d40:	683b      	ldr	r3, [r7, #0]
  404d42:	689b      	ldr	r3, [r3, #8]
  404d44:	61bb      	str	r3, [r7, #24]
	uint8_t stop_sent = 0;
  404d46:	2300      	movs	r3, #0
  404d48:	75fb      	strb	r3, [r7, #23]
	uint32_t timeout = TWI_TIMEOUT;;
  404d4a:	f247 5330 	movw	r3, #30000	; 0x7530
  404d4e:	613b      	str	r3, [r7, #16]
	
	/* Check argument */
	if (cnt == 0) {
  404d50:	69fb      	ldr	r3, [r7, #28]
  404d52:	2b00      	cmp	r3, #0
  404d54:	d101      	bne.n	404d5a <twi_master_read+0x2a>
		return TWI_INVALID_ARGUMENT;
  404d56:	2301      	movs	r3, #1
  404d58:	e069      	b.n	404e2e <twi_master_read+0xfe>
	}

	/* Set read mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  404d5a:	687b      	ldr	r3, [r7, #4]
  404d5c:	2200      	movs	r2, #0
  404d5e:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  404d60:	683b      	ldr	r3, [r7, #0]
  404d62:	7c1b      	ldrb	r3, [r3, #16]
  404d64:	041b      	lsls	r3, r3, #16
  404d66:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  404d6a:	683b      	ldr	r3, [r7, #0]
  404d6c:	685b      	ldr	r3, [r3, #4]
  404d6e:	021b      	lsls	r3, r3, #8
  404d70:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  404d74:	4313      	orrs	r3, r2
  404d76:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
  404d7a:	687b      	ldr	r3, [r7, #4]
  404d7c:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0; 
  404d7e:	687b      	ldr	r3, [r7, #4]
  404d80:	2200      	movs	r2, #0
  404d82:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  404d84:	683a      	ldr	r2, [r7, #0]
  404d86:	683b      	ldr	r3, [r7, #0]
  404d88:	685b      	ldr	r3, [r3, #4]
  404d8a:	4619      	mov	r1, r3
  404d8c:	4610      	mov	r0, r2
  404d8e:	4b2a      	ldr	r3, [pc, #168]	; (404e38 <twi_master_read+0x108>)
  404d90:	4798      	blx	r3
  404d92:	4602      	mov	r2, r0
  404d94:	687b      	ldr	r3, [r7, #4]
  404d96:	60da      	str	r2, [r3, #12]

	/* Send a START condition */
	if (cnt == 1) {
  404d98:	69fb      	ldr	r3, [r7, #28]
  404d9a:	2b01      	cmp	r3, #1
  404d9c:	d105      	bne.n	404daa <twi_master_read+0x7a>
		p_twi->TWI_CR = TWI_CR_START | TWI_CR_STOP;
  404d9e:	687b      	ldr	r3, [r7, #4]
  404da0:	2203      	movs	r2, #3
  404da2:	601a      	str	r2, [r3, #0]
		stop_sent = 1;
  404da4:	2301      	movs	r3, #1
  404da6:	75fb      	strb	r3, [r7, #23]
  404da8:	e034      	b.n	404e14 <twi_master_read+0xe4>
	} else {
		p_twi->TWI_CR = TWI_CR_START;
  404daa:	687b      	ldr	r3, [r7, #4]
  404dac:	2201      	movs	r2, #1
  404dae:	601a      	str	r2, [r3, #0]
		stop_sent = 0;
  404db0:	2300      	movs	r3, #0
  404db2:	75fb      	strb	r3, [r7, #23]
	}

	while (cnt > 0) {
  404db4:	e02e      	b.n	404e14 <twi_master_read+0xe4>
		status = p_twi->TWI_SR;
  404db6:	687b      	ldr	r3, [r7, #4]
  404db8:	6a1b      	ldr	r3, [r3, #32]
  404dba:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  404dbc:	68fb      	ldr	r3, [r7, #12]
  404dbe:	f403 7380 	and.w	r3, r3, #256	; 0x100
  404dc2:	2b00      	cmp	r3, #0
  404dc4:	d001      	beq.n	404dca <twi_master_read+0x9a>
			return TWI_RECEIVE_NACK;
  404dc6:	2305      	movs	r3, #5
  404dc8:	e031      	b.n	404e2e <twi_master_read+0xfe>
		}

		if (!timeout--) {
  404dca:	693b      	ldr	r3, [r7, #16]
  404dcc:	1e5a      	subs	r2, r3, #1
  404dce:	613a      	str	r2, [r7, #16]
  404dd0:	2b00      	cmp	r3, #0
  404dd2:	d101      	bne.n	404dd8 <twi_master_read+0xa8>
			return TWI_ERROR_TIMEOUT;
  404dd4:	2309      	movs	r3, #9
  404dd6:	e02a      	b.n	404e2e <twi_master_read+0xfe>
		}
				
		/* Last byte ? */
		if (cnt == 1  && !stop_sent) {
  404dd8:	69fb      	ldr	r3, [r7, #28]
  404dda:	2b01      	cmp	r3, #1
  404ddc:	d107      	bne.n	404dee <twi_master_read+0xbe>
  404dde:	7dfb      	ldrb	r3, [r7, #23]
  404de0:	2b00      	cmp	r3, #0
  404de2:	d104      	bne.n	404dee <twi_master_read+0xbe>
			p_twi->TWI_CR = TWI_CR_STOP;
  404de4:	687b      	ldr	r3, [r7, #4]
  404de6:	2202      	movs	r2, #2
  404de8:	601a      	str	r2, [r3, #0]
			stop_sent = 1;
  404dea:	2301      	movs	r3, #1
  404dec:	75fb      	strb	r3, [r7, #23]
		}

		if (!(status & TWI_SR_RXRDY)) {
  404dee:	68fb      	ldr	r3, [r7, #12]
  404df0:	f003 0302 	and.w	r3, r3, #2
  404df4:	2b00      	cmp	r3, #0
  404df6:	d100      	bne.n	404dfa <twi_master_read+0xca>
			continue;
  404df8:	e00c      	b.n	404e14 <twi_master_read+0xe4>
		}
		*buffer++ = p_twi->TWI_RHR;
  404dfa:	69bb      	ldr	r3, [r7, #24]
  404dfc:	1c5a      	adds	r2, r3, #1
  404dfe:	61ba      	str	r2, [r7, #24]
  404e00:	687a      	ldr	r2, [r7, #4]
  404e02:	6b12      	ldr	r2, [r2, #48]	; 0x30
  404e04:	b2d2      	uxtb	r2, r2
  404e06:	701a      	strb	r2, [r3, #0]

		cnt--;
  404e08:	69fb      	ldr	r3, [r7, #28]
  404e0a:	3b01      	subs	r3, #1
  404e0c:	61fb      	str	r3, [r7, #28]
		timeout = TWI_TIMEOUT;
  404e0e:	f247 5330 	movw	r3, #30000	; 0x7530
  404e12:	613b      	str	r3, [r7, #16]
	while (cnt > 0) {
  404e14:	69fb      	ldr	r3, [r7, #28]
  404e16:	2b00      	cmp	r3, #0
  404e18:	d1cd      	bne.n	404db6 <twi_master_read+0x86>
	}

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  404e1a:	bf00      	nop
  404e1c:	687b      	ldr	r3, [r7, #4]
  404e1e:	6a1b      	ldr	r3, [r3, #32]
  404e20:	f003 0301 	and.w	r3, r3, #1
  404e24:	2b00      	cmp	r3, #0
  404e26:	d0f9      	beq.n	404e1c <twi_master_read+0xec>
	}

	p_twi->TWI_SR;
  404e28:	687b      	ldr	r3, [r7, #4]
  404e2a:	6a1b      	ldr	r3, [r3, #32]

	return TWI_SUCCESS;
  404e2c:	2300      	movs	r3, #0
}
  404e2e:	4618      	mov	r0, r3
  404e30:	3720      	adds	r7, #32
  404e32:	46bd      	mov	sp, r7
  404e34:	bd80      	pop	{r7, pc}
  404e36:	bf00      	nop
  404e38:	00404cd5 	.word	0x00404cd5

00404e3c <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  404e3c:	b580      	push	{r7, lr}
  404e3e:	b086      	sub	sp, #24
  404e40:	af00      	add	r7, sp, #0
  404e42:	6078      	str	r0, [r7, #4]
  404e44:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  404e46:	683b      	ldr	r3, [r7, #0]
  404e48:	68db      	ldr	r3, [r3, #12]
  404e4a:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  404e4c:	683b      	ldr	r3, [r7, #0]
  404e4e:	689b      	ldr	r3, [r3, #8]
  404e50:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  404e52:	697b      	ldr	r3, [r7, #20]
  404e54:	2b00      	cmp	r3, #0
  404e56:	d101      	bne.n	404e5c <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  404e58:	2301      	movs	r3, #1
  404e5a:	e056      	b.n	404f0a <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  404e5c:	687b      	ldr	r3, [r7, #4]
  404e5e:	2200      	movs	r2, #0
  404e60:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  404e62:	683b      	ldr	r3, [r7, #0]
  404e64:	7c1b      	ldrb	r3, [r3, #16]
  404e66:	041b      	lsls	r3, r3, #16
  404e68:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  404e6c:	683b      	ldr	r3, [r7, #0]
  404e6e:	685b      	ldr	r3, [r3, #4]
  404e70:	021b      	lsls	r3, r3, #8
  404e72:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  404e76:	431a      	orrs	r2, r3
  404e78:	687b      	ldr	r3, [r7, #4]
  404e7a:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  404e7c:	687b      	ldr	r3, [r7, #4]
  404e7e:	2200      	movs	r2, #0
  404e80:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  404e82:	683a      	ldr	r2, [r7, #0]
  404e84:	683b      	ldr	r3, [r7, #0]
  404e86:	685b      	ldr	r3, [r3, #4]
  404e88:	4619      	mov	r1, r3
  404e8a:	4610      	mov	r0, r2
  404e8c:	4b21      	ldr	r3, [pc, #132]	; (404f14 <twi_master_write+0xd8>)
  404e8e:	4798      	blx	r3
  404e90:	4602      	mov	r2, r0
  404e92:	687b      	ldr	r3, [r7, #4]
  404e94:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  404e96:	e019      	b.n	404ecc <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  404e98:	687b      	ldr	r3, [r7, #4]
  404e9a:	6a1b      	ldr	r3, [r3, #32]
  404e9c:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  404e9e:	68fb      	ldr	r3, [r7, #12]
  404ea0:	f403 7380 	and.w	r3, r3, #256	; 0x100
  404ea4:	2b00      	cmp	r3, #0
  404ea6:	d001      	beq.n	404eac <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  404ea8:	2305      	movs	r3, #5
  404eaa:	e02e      	b.n	404f0a <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  404eac:	68fb      	ldr	r3, [r7, #12]
  404eae:	f003 0304 	and.w	r3, r3, #4
  404eb2:	2b00      	cmp	r3, #0
  404eb4:	d100      	bne.n	404eb8 <twi_master_write+0x7c>
			continue;
  404eb6:	e009      	b.n	404ecc <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  404eb8:	693b      	ldr	r3, [r7, #16]
  404eba:	1c5a      	adds	r2, r3, #1
  404ebc:	613a      	str	r2, [r7, #16]
  404ebe:	781b      	ldrb	r3, [r3, #0]
  404ec0:	461a      	mov	r2, r3
  404ec2:	687b      	ldr	r3, [r7, #4]
  404ec4:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  404ec6:	697b      	ldr	r3, [r7, #20]
  404ec8:	3b01      	subs	r3, #1
  404eca:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  404ecc:	697b      	ldr	r3, [r7, #20]
  404ece:	2b00      	cmp	r3, #0
  404ed0:	d1e2      	bne.n	404e98 <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  404ed2:	687b      	ldr	r3, [r7, #4]
  404ed4:	6a1b      	ldr	r3, [r3, #32]
  404ed6:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  404ed8:	68fb      	ldr	r3, [r7, #12]
  404eda:	f403 7380 	and.w	r3, r3, #256	; 0x100
  404ede:	2b00      	cmp	r3, #0
  404ee0:	d001      	beq.n	404ee6 <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  404ee2:	2305      	movs	r3, #5
  404ee4:	e011      	b.n	404f0a <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  404ee6:	68fb      	ldr	r3, [r7, #12]
  404ee8:	f003 0304 	and.w	r3, r3, #4
  404eec:	2b00      	cmp	r3, #0
  404eee:	d100      	bne.n	404ef2 <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  404ef0:	e7ef      	b.n	404ed2 <twi_master_write+0x96>
			break;
  404ef2:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  404ef4:	687b      	ldr	r3, [r7, #4]
  404ef6:	2202      	movs	r2, #2
  404ef8:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  404efa:	bf00      	nop
  404efc:	687b      	ldr	r3, [r7, #4]
  404efe:	6a1b      	ldr	r3, [r3, #32]
  404f00:	f003 0301 	and.w	r3, r3, #1
  404f04:	2b00      	cmp	r3, #0
  404f06:	d0f9      	beq.n	404efc <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  404f08:	2300      	movs	r3, #0
}
  404f0a:	4618      	mov	r0, r3
  404f0c:	3718      	adds	r7, #24
  404f0e:	46bd      	mov	sp, r7
  404f10:	bd80      	pop	{r7, pc}
  404f12:	bf00      	nop
  404f14:	00404cd5 	.word	0x00404cd5

00404f18 <twi_enable_interrupt>:
 *
 * \param p_twi Pointer to a TWI instance.
 * \param ul_sources Interrupts to be enabled.
 */
void twi_enable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
  404f18:	b480      	push	{r7}
  404f1a:	b083      	sub	sp, #12
  404f1c:	af00      	add	r7, sp, #0
  404f1e:	6078      	str	r0, [r7, #4]
  404f20:	6039      	str	r1, [r7, #0]
	/* Enable the specified interrupts */
	p_twi->TWI_IER = ul_sources;
  404f22:	687b      	ldr	r3, [r7, #4]
  404f24:	683a      	ldr	r2, [r7, #0]
  404f26:	625a      	str	r2, [r3, #36]	; 0x24
}
  404f28:	bf00      	nop
  404f2a:	370c      	adds	r7, #12
  404f2c:	46bd      	mov	sp, r7
  404f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404f32:	4770      	bx	lr

00404f34 <twi_disable_interrupt>:
 *
 * \param p_twi Pointer to a TWI instance.
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
  404f34:	b480      	push	{r7}
  404f36:	b083      	sub	sp, #12
  404f38:	af00      	add	r7, sp, #0
  404f3a:	6078      	str	r0, [r7, #4]
  404f3c:	6039      	str	r1, [r7, #0]
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  404f3e:	687b      	ldr	r3, [r7, #4]
  404f40:	683a      	ldr	r2, [r7, #0]
  404f42:	629a      	str	r2, [r3, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  404f44:	687b      	ldr	r3, [r7, #4]
  404f46:	6a1b      	ldr	r3, [r3, #32]
}
  404f48:	bf00      	nop
  404f4a:	370c      	adds	r7, #12
  404f4c:	46bd      	mov	sp, r7
  404f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404f52:	4770      	bx	lr

00404f54 <twi_get_interrupt_status>:
 * \param p_twi Pointer to a TWI instance.
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
  404f54:	b480      	push	{r7}
  404f56:	b083      	sub	sp, #12
  404f58:	af00      	add	r7, sp, #0
  404f5a:	6078      	str	r0, [r7, #4]
	return p_twi->TWI_SR;
  404f5c:	687b      	ldr	r3, [r7, #4]
  404f5e:	6a1b      	ldr	r3, [r3, #32]
}
  404f60:	4618      	mov	r0, r3
  404f62:	370c      	adds	r7, #12
  404f64:	46bd      	mov	sp, r7
  404f66:	f85d 7b04 	ldr.w	r7, [sp], #4
  404f6a:	4770      	bx	lr

00404f6c <twi_get_interrupt_mask>:
 * \param p_twi Pointer to a TWI instance.
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
  404f6c:	b480      	push	{r7}
  404f6e:	b083      	sub	sp, #12
  404f70:	af00      	add	r7, sp, #0
  404f72:	6078      	str	r0, [r7, #4]
	return p_twi->TWI_IMR;
  404f74:	687b      	ldr	r3, [r7, #4]
  404f76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  404f78:	4618      	mov	r0, r3
  404f7a:	370c      	adds	r7, #12
  404f7c:	46bd      	mov	sp, r7
  404f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404f82:	4770      	bx	lr

00404f84 <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  404f84:	b480      	push	{r7}
  404f86:	b083      	sub	sp, #12
  404f88:	af00      	add	r7, sp, #0
  404f8a:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  404f8c:	687b      	ldr	r3, [r7, #4]
  404f8e:	2280      	movs	r2, #128	; 0x80
  404f90:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  404f92:	687b      	ldr	r3, [r7, #4]
  404f94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  404f96:	bf00      	nop
  404f98:	370c      	adds	r7, #12
  404f9a:	46bd      	mov	sp, r7
  404f9c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404fa0:	4770      	bx	lr
	...

00404fa4 <twi_get_pdc_base>:
 * \param p_twi Pointer to a TWI instance.
 *
 * \return TWI PDC registers base for PDC driver to access.
 */
Pdc *twi_get_pdc_base(Twi *p_twi)
{
  404fa4:	b480      	push	{r7}
  404fa6:	b085      	sub	sp, #20
  404fa8:	af00      	add	r7, sp, #0
  404faa:	6078      	str	r0, [r7, #4]
	Pdc *p_pdc_base = NULL;
  404fac:	2300      	movs	r3, #0
  404fae:	60fb      	str	r3, [r7, #12]
	if (p_twi == TWI0) {
		p_pdc_base = PDC_TWI0;
	} else
#endif
#ifdef PDC_TWI1
	 if (p_twi == TWI1) {
  404fb0:	687b      	ldr	r3, [r7, #4]
  404fb2:	4a0d      	ldr	r2, [pc, #52]	; (404fe8 <twi_get_pdc_base+0x44>)
  404fb4:	4293      	cmp	r3, r2
  404fb6:	d102      	bne.n	404fbe <twi_get_pdc_base+0x1a>
		p_pdc_base = PDC_TWI1;
  404fb8:	4b0c      	ldr	r3, [pc, #48]	; (404fec <twi_get_pdc_base+0x48>)
  404fba:	60fb      	str	r3, [r7, #12]
  404fbc:	e00c      	b.n	404fd8 <twi_get_pdc_base+0x34>
	} else
#endif
#ifdef PDC_TWI2
	if (p_twi == TWI2) {
  404fbe:	687b      	ldr	r3, [r7, #4]
  404fc0:	4a0b      	ldr	r2, [pc, #44]	; (404ff0 <twi_get_pdc_base+0x4c>)
  404fc2:	4293      	cmp	r3, r2
  404fc4:	d102      	bne.n	404fcc <twi_get_pdc_base+0x28>
		p_pdc_base = PDC_TWI2;
  404fc6:	4b0b      	ldr	r3, [pc, #44]	; (404ff4 <twi_get_pdc_base+0x50>)
  404fc8:	60fb      	str	r3, [r7, #12]
  404fca:	e005      	b.n	404fd8 <twi_get_pdc_base+0x34>
	} else
#endif
#ifdef PDC_TWI3
	if (p_twi == TWI3) {
  404fcc:	687b      	ldr	r3, [r7, #4]
  404fce:	4a0a      	ldr	r2, [pc, #40]	; (404ff8 <twi_get_pdc_base+0x54>)
  404fd0:	4293      	cmp	r3, r2
  404fd2:	d101      	bne.n	404fd8 <twi_get_pdc_base+0x34>
		p_pdc_base = PDC_TWI3;
  404fd4:	4b09      	ldr	r3, [pc, #36]	; (404ffc <twi_get_pdc_base+0x58>)
  404fd6:	60fb      	str	r3, [r7, #12]
#endif
	{
		Assert(false);
	}

	return p_pdc_base;
  404fd8:	68fb      	ldr	r3, [r7, #12]
}
  404fda:	4618      	mov	r0, r3
  404fdc:	3714      	adds	r7, #20
  404fde:	46bd      	mov	sp, r7
  404fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
  404fe4:	4770      	bx	lr
  404fe6:	bf00      	nop
  404fe8:	40020600 	.word	0x40020600
  404fec:	40020700 	.word	0x40020700
  404ff0:	40024600 	.word	0x40024600
  404ff4:	40024700 	.word	0x40024700
  404ff8:	40018600 	.word	0x40018600
  404ffc:	40018700 	.word	0x40018700

00405000 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  405000:	b480      	push	{r7}
  405002:	b089      	sub	sp, #36	; 0x24
  405004:	af00      	add	r7, sp, #0
  405006:	60f8      	str	r0, [r7, #12]
  405008:	60b9      	str	r1, [r7, #8]
  40500a:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  40500c:	68bb      	ldr	r3, [r7, #8]
  40500e:	011a      	lsls	r2, r3, #4
  405010:	687b      	ldr	r3, [r7, #4]
  405012:	429a      	cmp	r2, r3
  405014:	d802      	bhi.n	40501c <usart_set_async_baudrate+0x1c>
		over = HIGH_FRQ_SAMPLE_DIV;
  405016:	2310      	movs	r3, #16
  405018:	61fb      	str	r3, [r7, #28]
  40501a:	e001      	b.n	405020 <usart_set_async_baudrate+0x20>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
  40501c:	2308      	movs	r3, #8
  40501e:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  405020:	687b      	ldr	r3, [r7, #4]
  405022:	00da      	lsls	r2, r3, #3
  405024:	69fb      	ldr	r3, [r7, #28]
  405026:	68b9      	ldr	r1, [r7, #8]
  405028:	fb01 f303 	mul.w	r3, r1, r3
  40502c:	085b      	lsrs	r3, r3, #1
  40502e:	441a      	add	r2, r3
  405030:	69fb      	ldr	r3, [r7, #28]
  405032:	68b9      	ldr	r1, [r7, #8]
  405034:	fb01 f303 	mul.w	r3, r1, r3
  405038:	fbb2 f3f3 	udiv	r3, r2, r3
  40503c:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
  40503e:	69bb      	ldr	r3, [r7, #24]
  405040:	08db      	lsrs	r3, r3, #3
  405042:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
  405044:	69bb      	ldr	r3, [r7, #24]
  405046:	f003 0307 	and.w	r3, r3, #7
  40504a:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  40504c:	697b      	ldr	r3, [r7, #20]
  40504e:	2b00      	cmp	r3, #0
  405050:	d003      	beq.n	40505a <usart_set_async_baudrate+0x5a>
  405052:	697b      	ldr	r3, [r7, #20]
  405054:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  405058:	d301      	bcc.n	40505e <usart_set_async_baudrate+0x5e>
		return 1;
  40505a:	2301      	movs	r3, #1
  40505c:	e00f      	b.n	40507e <usart_set_async_baudrate+0x7e>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
  40505e:	69fb      	ldr	r3, [r7, #28]
  405060:	2b08      	cmp	r3, #8
  405062:	d105      	bne.n	405070 <usart_set_async_baudrate+0x70>
		p_usart->US_MR |= US_MR_OVER;
  405064:	68fb      	ldr	r3, [r7, #12]
  405066:	685b      	ldr	r3, [r3, #4]
  405068:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
  40506c:	68fb      	ldr	r3, [r7, #12]
  40506e:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  405070:	693b      	ldr	r3, [r7, #16]
  405072:	041a      	lsls	r2, r3, #16
  405074:	697b      	ldr	r3, [r7, #20]
  405076:	431a      	orrs	r2, r3
  405078:	68fb      	ldr	r3, [r7, #12]
  40507a:	621a      	str	r2, [r3, #32]

	return 0;
  40507c:	2300      	movs	r3, #0
}
  40507e:	4618      	mov	r0, r3
  405080:	3724      	adds	r7, #36	; 0x24
  405082:	46bd      	mov	sp, r7
  405084:	f85d 7b04 	ldr.w	r7, [sp], #4
  405088:	4770      	bx	lr
	...

0040508c <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
  40508c:	b580      	push	{r7, lr}
  40508e:	b082      	sub	sp, #8
  405090:	af00      	add	r7, sp, #0
  405092:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);
  405094:	6878      	ldr	r0, [r7, #4]
  405096:	4b0d      	ldr	r3, [pc, #52]	; (4050cc <usart_reset+0x40>)
  405098:	4798      	blx	r3

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  40509a:	687b      	ldr	r3, [r7, #4]
  40509c:	2200      	movs	r2, #0
  40509e:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
  4050a0:	687b      	ldr	r3, [r7, #4]
  4050a2:	2200      	movs	r2, #0
  4050a4:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  4050a6:	687b      	ldr	r3, [r7, #4]
  4050a8:	2200      	movs	r2, #0
  4050aa:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX. */
	usart_reset_tx(p_usart);
  4050ac:	6878      	ldr	r0, [r7, #4]
  4050ae:	4b08      	ldr	r3, [pc, #32]	; (4050d0 <usart_reset+0x44>)
  4050b0:	4798      	blx	r3
	usart_reset_rx(p_usart);
  4050b2:	6878      	ldr	r0, [r7, #4]
  4050b4:	4b07      	ldr	r3, [pc, #28]	; (4050d4 <usart_reset+0x48>)
  4050b6:	4798      	blx	r3
	/* Reset status bits. */
	usart_reset_status(p_usart);
  4050b8:	6878      	ldr	r0, [r7, #4]
  4050ba:	4b07      	ldr	r3, [pc, #28]	; (4050d8 <usart_reset+0x4c>)
  4050bc:	4798      	blx	r3
	/* Turn off RTS and DTR if exist. */
	usart_drive_RTS_pin_high(p_usart);
  4050be:	6878      	ldr	r0, [r7, #4]
  4050c0:	4b06      	ldr	r3, [pc, #24]	; (4050dc <usart_reset+0x50>)
  4050c2:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U || SAM4L || SAM4E)
	usart_drive_DTR_pin_high(p_usart);
#endif
}
  4050c4:	bf00      	nop
  4050c6:	3708      	adds	r7, #8
  4050c8:	46bd      	mov	sp, r7
  4050ca:	bd80      	pop	{r7, pc}
  4050cc:	004052a1 	.word	0x004052a1
  4050d0:	0040517f 	.word	0x0040517f
  4050d4:	004051b3 	.word	0x004051b3
  4050d8:	00405201 	.word	0x00405201
  4050dc:	0040521d 	.word	0x0040521d

004050e0 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  4050e0:	b580      	push	{r7, lr}
  4050e2:	b084      	sub	sp, #16
  4050e4:	af00      	add	r7, sp, #0
  4050e6:	60f8      	str	r0, [r7, #12]
  4050e8:	60b9      	str	r1, [r7, #8]
  4050ea:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  4050ec:	68f8      	ldr	r0, [r7, #12]
  4050ee:	4b1a      	ldr	r3, [pc, #104]	; (405158 <usart_init_rs232+0x78>)
  4050f0:	4798      	blx	r3

	ul_reg_val = 0;
  4050f2:	4b1a      	ldr	r3, [pc, #104]	; (40515c <usart_init_rs232+0x7c>)
  4050f4:	2200      	movs	r2, #0
  4050f6:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  4050f8:	68bb      	ldr	r3, [r7, #8]
  4050fa:	2b00      	cmp	r3, #0
  4050fc:	d009      	beq.n	405112 <usart_init_rs232+0x32>
  4050fe:	68bb      	ldr	r3, [r7, #8]
  405100:	681b      	ldr	r3, [r3, #0]
  405102:	687a      	ldr	r2, [r7, #4]
  405104:	4619      	mov	r1, r3
  405106:	68f8      	ldr	r0, [r7, #12]
  405108:	4b15      	ldr	r3, [pc, #84]	; (405160 <usart_init_rs232+0x80>)
  40510a:	4798      	blx	r3
  40510c:	4603      	mov	r3, r0
  40510e:	2b00      	cmp	r3, #0
  405110:	d001      	beq.n	405116 <usart_init_rs232+0x36>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  405112:	2301      	movs	r3, #1
  405114:	e01b      	b.n	40514e <usart_init_rs232+0x6e>
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  405116:	68bb      	ldr	r3, [r7, #8]
  405118:	685a      	ldr	r2, [r3, #4]
  40511a:	68bb      	ldr	r3, [r7, #8]
  40511c:	689b      	ldr	r3, [r3, #8]
  40511e:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  405120:	68bb      	ldr	r3, [r7, #8]
  405122:	691b      	ldr	r3, [r3, #16]
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  405124:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  405126:	68bb      	ldr	r3, [r7, #8]
  405128:	68db      	ldr	r3, [r3, #12]
  40512a:	431a      	orrs	r2, r3
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  40512c:	4b0b      	ldr	r3, [pc, #44]	; (40515c <usart_init_rs232+0x7c>)
  40512e:	681b      	ldr	r3, [r3, #0]
  405130:	4313      	orrs	r3, r2
  405132:	4a0a      	ldr	r2, [pc, #40]	; (40515c <usart_init_rs232+0x7c>)
  405134:	6013      	str	r3, [r2, #0]

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
  405136:	4b09      	ldr	r3, [pc, #36]	; (40515c <usart_init_rs232+0x7c>)
  405138:	681b      	ldr	r3, [r3, #0]
  40513a:	4a08      	ldr	r2, [pc, #32]	; (40515c <usart_init_rs232+0x7c>)
  40513c:	6013      	str	r3, [r2, #0]

	p_usart->US_MR |= ul_reg_val;
  40513e:	68fb      	ldr	r3, [r7, #12]
  405140:	685a      	ldr	r2, [r3, #4]
  405142:	4b06      	ldr	r3, [pc, #24]	; (40515c <usart_init_rs232+0x7c>)
  405144:	681b      	ldr	r3, [r3, #0]
  405146:	431a      	orrs	r2, r3
  405148:	68fb      	ldr	r3, [r7, #12]
  40514a:	605a      	str	r2, [r3, #4]

	return 0;
  40514c:	2300      	movs	r3, #0
}
  40514e:	4618      	mov	r0, r3
  405150:	3710      	adds	r7, #16
  405152:	46bd      	mov	sp, r7
  405154:	bd80      	pop	{r7, pc}
  405156:	bf00      	nop
  405158:	0040508d 	.word	0x0040508d
  40515c:	2000042c 	.word	0x2000042c
  405160:	00405001 	.word	0x00405001

00405164 <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
  405164:	b480      	push	{r7}
  405166:	b083      	sub	sp, #12
  405168:	af00      	add	r7, sp, #0
  40516a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
  40516c:	687b      	ldr	r3, [r7, #4]
  40516e:	2240      	movs	r2, #64	; 0x40
  405170:	601a      	str	r2, [r3, #0]
}
  405172:	bf00      	nop
  405174:	370c      	adds	r7, #12
  405176:	46bd      	mov	sp, r7
  405178:	f85d 7b04 	ldr.w	r7, [sp], #4
  40517c:	4770      	bx	lr

0040517e <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
  40517e:	b480      	push	{r7}
  405180:	b083      	sub	sp, #12
  405182:	af00      	add	r7, sp, #0
  405184:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  405186:	687b      	ldr	r3, [r7, #4]
  405188:	2288      	movs	r2, #136	; 0x88
  40518a:	601a      	str	r2, [r3, #0]
}
  40518c:	bf00      	nop
  40518e:	370c      	adds	r7, #12
  405190:	46bd      	mov	sp, r7
  405192:	f85d 7b04 	ldr.w	r7, [sp], #4
  405196:	4770      	bx	lr

00405198 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
  405198:	b480      	push	{r7}
  40519a:	b083      	sub	sp, #12
  40519c:	af00      	add	r7, sp, #0
  40519e:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
  4051a0:	687b      	ldr	r3, [r7, #4]
  4051a2:	2210      	movs	r2, #16
  4051a4:	601a      	str	r2, [r3, #0]
}
  4051a6:	bf00      	nop
  4051a8:	370c      	adds	r7, #12
  4051aa:	46bd      	mov	sp, r7
  4051ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4051b0:	4770      	bx	lr

004051b2 <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
  4051b2:	b480      	push	{r7}
  4051b4:	b083      	sub	sp, #12
  4051b6:	af00      	add	r7, sp, #0
  4051b8:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  4051ba:	687b      	ldr	r3, [r7, #4]
  4051bc:	2224      	movs	r2, #36	; 0x24
  4051be:	601a      	str	r2, [r3, #0]
}
  4051c0:	bf00      	nop
  4051c2:	370c      	adds	r7, #12
  4051c4:	46bd      	mov	sp, r7
  4051c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4051ca:	4770      	bx	lr

004051cc <usart_disable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  4051cc:	b480      	push	{r7}
  4051ce:	b083      	sub	sp, #12
  4051d0:	af00      	add	r7, sp, #0
  4051d2:	6078      	str	r0, [r7, #4]
  4051d4:	6039      	str	r1, [r7, #0]
	p_usart->US_IDR = ul_sources;
  4051d6:	687b      	ldr	r3, [r7, #4]
  4051d8:	683a      	ldr	r2, [r7, #0]
  4051da:	60da      	str	r2, [r3, #12]
}
  4051dc:	bf00      	nop
  4051de:	370c      	adds	r7, #12
  4051e0:	46bd      	mov	sp, r7
  4051e2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4051e6:	4770      	bx	lr

004051e8 <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
  4051e8:	b480      	push	{r7}
  4051ea:	b083      	sub	sp, #12
  4051ec:	af00      	add	r7, sp, #0
  4051ee:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
  4051f0:	687b      	ldr	r3, [r7, #4]
  4051f2:	695b      	ldr	r3, [r3, #20]
}
  4051f4:	4618      	mov	r0, r3
  4051f6:	370c      	adds	r7, #12
  4051f8:	46bd      	mov	sp, r7
  4051fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4051fe:	4770      	bx	lr

00405200 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
  405200:	b480      	push	{r7}
  405202:	b083      	sub	sp, #12
  405204:	af00      	add	r7, sp, #0
  405206:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
  405208:	687b      	ldr	r3, [r7, #4]
  40520a:	f44f 7280 	mov.w	r2, #256	; 0x100
  40520e:	601a      	str	r2, [r3, #0]
}
  405210:	bf00      	nop
  405212:	370c      	adds	r7, #12
  405214:	46bd      	mov	sp, r7
  405216:	f85d 7b04 	ldr.w	r7, [sp], #4
  40521a:	4770      	bx	lr

0040521c <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
  40521c:	b480      	push	{r7}
  40521e:	b083      	sub	sp, #12
  405220:	af00      	add	r7, sp, #0
  405222:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  405224:	687b      	ldr	r3, [r7, #4]
  405226:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40522a:	601a      	str	r2, [r3, #0]
}
  40522c:	bf00      	nop
  40522e:	370c      	adds	r7, #12
  405230:	46bd      	mov	sp, r7
  405232:	f85d 7b04 	ldr.w	r7, [sp], #4
  405236:	4770      	bx	lr

00405238 <usart_write>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
  405238:	b480      	push	{r7}
  40523a:	b083      	sub	sp, #12
  40523c:	af00      	add	r7, sp, #0
  40523e:	6078      	str	r0, [r7, #4]
  405240:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  405242:	687b      	ldr	r3, [r7, #4]
  405244:	695b      	ldr	r3, [r3, #20]
  405246:	f003 0302 	and.w	r3, r3, #2
  40524a:	2b00      	cmp	r3, #0
  40524c:	d101      	bne.n	405252 <usart_write+0x1a>
		return 1;
  40524e:	2301      	movs	r3, #1
  405250:	e005      	b.n	40525e <usart_write+0x26>
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  405252:	683b      	ldr	r3, [r7, #0]
  405254:	f3c3 0208 	ubfx	r2, r3, #0, #9
  405258:	687b      	ldr	r3, [r7, #4]
  40525a:	61da      	str	r2, [r3, #28]
	return 0;
  40525c:	2300      	movs	r3, #0
}
  40525e:	4618      	mov	r0, r3
  405260:	370c      	adds	r7, #12
  405262:	46bd      	mov	sp, r7
  405264:	f85d 7b04 	ldr.w	r7, [sp], #4
  405268:	4770      	bx	lr

0040526a <usart_read>:
 *
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
  40526a:	b480      	push	{r7}
  40526c:	b083      	sub	sp, #12
  40526e:	af00      	add	r7, sp, #0
  405270:	6078      	str	r0, [r7, #4]
  405272:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  405274:	687b      	ldr	r3, [r7, #4]
  405276:	695b      	ldr	r3, [r3, #20]
  405278:	f003 0301 	and.w	r3, r3, #1
  40527c:	2b00      	cmp	r3, #0
  40527e:	d101      	bne.n	405284 <usart_read+0x1a>
		return 1;
  405280:	2301      	movs	r3, #1
  405282:	e006      	b.n	405292 <usart_read+0x28>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  405284:	687b      	ldr	r3, [r7, #4]
  405286:	699b      	ldr	r3, [r3, #24]
  405288:	f3c3 0208 	ubfx	r2, r3, #0, #9
  40528c:	683b      	ldr	r3, [r7, #0]
  40528e:	601a      	str	r2, [r3, #0]

	return 0;
  405290:	2300      	movs	r3, #0
}
  405292:	4618      	mov	r0, r3
  405294:	370c      	adds	r7, #12
  405296:	46bd      	mov	sp, r7
  405298:	f85d 7b04 	ldr.w	r7, [sp], #4
  40529c:	4770      	bx	lr
	...

004052a0 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
  4052a0:	b480      	push	{r7}
  4052a2:	b083      	sub	sp, #12
  4052a4:	af00      	add	r7, sp, #0
  4052a6:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  4052a8:	687b      	ldr	r3, [r7, #4]
  4052aa:	4a04      	ldr	r2, [pc, #16]	; (4052bc <usart_disable_writeprotect+0x1c>)
  4052ac:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  4052b0:	bf00      	nop
  4052b2:	370c      	adds	r7, #12
  4052b4:	46bd      	mov	sp, r7
  4052b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4052ba:	4770      	bx	lr
  4052bc:	55534100 	.word	0x55534100

004052c0 <cpu_irq_save>:
{
  4052c0:	b480      	push	{r7}
  4052c2:	b083      	sub	sp, #12
  4052c4:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4052c6:	f3ef 8310 	mrs	r3, PRIMASK
  4052ca:	607b      	str	r3, [r7, #4]
  return(result);
  4052cc:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  4052ce:	2b00      	cmp	r3, #0
  4052d0:	bf0c      	ite	eq
  4052d2:	2301      	moveq	r3, #1
  4052d4:	2300      	movne	r3, #0
  4052d6:	b2db      	uxtb	r3, r3
  4052d8:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4052da:	b672      	cpsid	i
  __ASM volatile ("dmb");
  4052dc:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  4052e0:	4b04      	ldr	r3, [pc, #16]	; (4052f4 <cpu_irq_save+0x34>)
  4052e2:	2200      	movs	r2, #0
  4052e4:	701a      	strb	r2, [r3, #0]
	return flags;
  4052e6:	683b      	ldr	r3, [r7, #0]
}
  4052e8:	4618      	mov	r0, r3
  4052ea:	370c      	adds	r7, #12
  4052ec:	46bd      	mov	sp, r7
  4052ee:	f85d 7b04 	ldr.w	r7, [sp], #4
  4052f2:	4770      	bx	lr
  4052f4:	20000114 	.word	0x20000114

004052f8 <cpu_irq_is_enabled_flags>:
{
  4052f8:	b480      	push	{r7}
  4052fa:	b083      	sub	sp, #12
  4052fc:	af00      	add	r7, sp, #0
  4052fe:	6078      	str	r0, [r7, #4]
	return (flags);
  405300:	687b      	ldr	r3, [r7, #4]
  405302:	2b00      	cmp	r3, #0
  405304:	bf14      	ite	ne
  405306:	2301      	movne	r3, #1
  405308:	2300      	moveq	r3, #0
  40530a:	b2db      	uxtb	r3, r3
}
  40530c:	4618      	mov	r0, r3
  40530e:	370c      	adds	r7, #12
  405310:	46bd      	mov	sp, r7
  405312:	f85d 7b04 	ldr.w	r7, [sp], #4
  405316:	4770      	bx	lr

00405318 <cpu_irq_restore>:
{
  405318:	b580      	push	{r7, lr}
  40531a:	b082      	sub	sp, #8
  40531c:	af00      	add	r7, sp, #0
  40531e:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  405320:	6878      	ldr	r0, [r7, #4]
  405322:	4b07      	ldr	r3, [pc, #28]	; (405340 <cpu_irq_restore+0x28>)
  405324:	4798      	blx	r3
  405326:	4603      	mov	r3, r0
  405328:	2b00      	cmp	r3, #0
  40532a:	d005      	beq.n	405338 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  40532c:	4b05      	ldr	r3, [pc, #20]	; (405344 <cpu_irq_restore+0x2c>)
  40532e:	2201      	movs	r2, #1
  405330:	701a      	strb	r2, [r3, #0]
  405332:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  405336:	b662      	cpsie	i
}
  405338:	bf00      	nop
  40533a:	3708      	adds	r7, #8
  40533c:	46bd      	mov	sp, r7
  40533e:	bd80      	pop	{r7, pc}
  405340:	004052f9 	.word	0x004052f9
  405344:	20000114 	.word	0x20000114

00405348 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  405348:	b580      	push	{r7, lr}
  40534a:	b084      	sub	sp, #16
  40534c:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
  40534e:	4b25      	ldr	r3, [pc, #148]	; (4053e4 <Reset_Handler+0x9c>)
  405350:	60fb      	str	r3, [r7, #12]
        pDest = &_srelocate;
  405352:	4b25      	ldr	r3, [pc, #148]	; (4053e8 <Reset_Handler+0xa0>)
  405354:	60bb      	str	r3, [r7, #8]

        if (pSrc != pDest) {
  405356:	68fa      	ldr	r2, [r7, #12]
  405358:	68bb      	ldr	r3, [r7, #8]
  40535a:	429a      	cmp	r2, r3
  40535c:	d00c      	beq.n	405378 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
  40535e:	e007      	b.n	405370 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
  405360:	68bb      	ldr	r3, [r7, #8]
  405362:	1d1a      	adds	r2, r3, #4
  405364:	60ba      	str	r2, [r7, #8]
  405366:	68fa      	ldr	r2, [r7, #12]
  405368:	1d11      	adds	r1, r2, #4
  40536a:	60f9      	str	r1, [r7, #12]
  40536c:	6812      	ldr	r2, [r2, #0]
  40536e:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
  405370:	68bb      	ldr	r3, [r7, #8]
  405372:	4a1e      	ldr	r2, [pc, #120]	; (4053ec <Reset_Handler+0xa4>)
  405374:	4293      	cmp	r3, r2
  405376:	d3f3      	bcc.n	405360 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  405378:	4b1d      	ldr	r3, [pc, #116]	; (4053f0 <Reset_Handler+0xa8>)
  40537a:	60bb      	str	r3, [r7, #8]
  40537c:	e004      	b.n	405388 <Reset_Handler+0x40>
                *pDest++ = 0;
  40537e:	68bb      	ldr	r3, [r7, #8]
  405380:	1d1a      	adds	r2, r3, #4
  405382:	60ba      	str	r2, [r7, #8]
  405384:	2200      	movs	r2, #0
  405386:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
  405388:	68bb      	ldr	r3, [r7, #8]
  40538a:	4a1a      	ldr	r2, [pc, #104]	; (4053f4 <Reset_Handler+0xac>)
  40538c:	4293      	cmp	r3, r2
  40538e:	d3f6      	bcc.n	40537e <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
  405390:	4b19      	ldr	r3, [pc, #100]	; (4053f8 <Reset_Handler+0xb0>)
  405392:	60fb      	str	r3, [r7, #12]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  405394:	4a19      	ldr	r2, [pc, #100]	; (4053fc <Reset_Handler+0xb4>)
  405396:	68fb      	ldr	r3, [r7, #12]
  405398:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40539c:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  40539e:	4b18      	ldr	r3, [pc, #96]	; (405400 <Reset_Handler+0xb8>)
  4053a0:	4798      	blx	r3
  4053a2:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  4053a4:	4a17      	ldr	r2, [pc, #92]	; (405404 <Reset_Handler+0xbc>)
  4053a6:	4b17      	ldr	r3, [pc, #92]	; (405404 <Reset_Handler+0xbc>)
  4053a8:	681b      	ldr	r3, [r3, #0]
  4053aa:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4053ae:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb");
  4053b0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  4053b4:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  4053b8:	6878      	ldr	r0, [r7, #4]
  4053ba:	4b13      	ldr	r3, [pc, #76]	; (405408 <Reset_Handler+0xc0>)
  4053bc:	4798      	blx	r3

#if __FPU_USED
	fpu_enable();
#endif

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  4053be:	68fb      	ldr	r3, [r7, #12]
  4053c0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  4053c4:	d309      	bcc.n	4053da <Reset_Handler+0x92>
  4053c6:	68fb      	ldr	r3, [r7, #12]
  4053c8:	4a10      	ldr	r2, [pc, #64]	; (40540c <Reset_Handler+0xc4>)
  4053ca:	4293      	cmp	r3, r2
  4053cc:	d805      	bhi.n	4053da <Reset_Handler+0x92>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4053ce:	4a0b      	ldr	r2, [pc, #44]	; (4053fc <Reset_Handler+0xb4>)
  4053d0:	4b0a      	ldr	r3, [pc, #40]	; (4053fc <Reset_Handler+0xb4>)
  4053d2:	689b      	ldr	r3, [r3, #8]
  4053d4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  4053d8:	6093      	str	r3, [r2, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4053da:	4b0d      	ldr	r3, [pc, #52]	; (405410 <Reset_Handler+0xc8>)
  4053dc:	4798      	blx	r3

        /* Branch to main function */
        main();
  4053de:	4b0d      	ldr	r3, [pc, #52]	; (405414 <Reset_Handler+0xcc>)
  4053e0:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  4053e2:	e7fe      	b.n	4053e2 <Reset_Handler+0x9a>
  4053e4:	0040e180 	.word	0x0040e180
  4053e8:	20000000 	.word	0x20000000
  4053ec:	20000348 	.word	0x20000348
  4053f0:	20000348 	.word	0x20000348
  4053f4:	20002978 	.word	0x20002978
  4053f8:	00400000 	.word	0x00400000
  4053fc:	e000ed00 	.word	0xe000ed00
  405400:	004052c1 	.word	0x004052c1
  405404:	e000ed88 	.word	0xe000ed88
  405408:	00405319 	.word	0x00405319
  40540c:	20027fff 	.word	0x20027fff
  405410:	004095bd 	.word	0x004095bd
  405414:	004001b5 	.word	0x004001b5

00405418 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  405418:	b480      	push	{r7}
  40541a:	af00      	add	r7, sp, #0
        while (1) {
  40541c:	e7fe      	b.n	40541c <Dummy_Handler+0x4>
	...

00405420 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  405420:	b480      	push	{r7}
  405422:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  405424:	4b41      	ldr	r3, [pc, #260]	; (40552c <SystemCoreClockUpdate+0x10c>)
  405426:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405428:	f003 0303 	and.w	r3, r3, #3
  40542c:	2b01      	cmp	r3, #1
  40542e:	d014      	beq.n	40545a <SystemCoreClockUpdate+0x3a>
  405430:	2b01      	cmp	r3, #1
  405432:	d302      	bcc.n	40543a <SystemCoreClockUpdate+0x1a>
  405434:	2b02      	cmp	r3, #2
  405436:	d038      	beq.n	4054aa <SystemCoreClockUpdate+0x8a>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
					CKGR_PLLAR_MULA_Pos) + 1U);
		}
		break;
	default:
		break;
  405438:	e059      	b.n	4054ee <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  40543a:	4b3d      	ldr	r3, [pc, #244]	; (405530 <SystemCoreClockUpdate+0x110>)
  40543c:	695b      	ldr	r3, [r3, #20]
  40543e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  405442:	2b00      	cmp	r3, #0
  405444:	d004      	beq.n	405450 <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405446:	4b3b      	ldr	r3, [pc, #236]	; (405534 <SystemCoreClockUpdate+0x114>)
  405448:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40544c:	601a      	str	r2, [r3, #0]
		break;
  40544e:	e04e      	b.n	4054ee <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  405450:	4b38      	ldr	r3, [pc, #224]	; (405534 <SystemCoreClockUpdate+0x114>)
  405452:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  405456:	601a      	str	r2, [r3, #0]
		break;
  405458:	e049      	b.n	4054ee <SystemCoreClockUpdate+0xce>
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  40545a:	4b34      	ldr	r3, [pc, #208]	; (40552c <SystemCoreClockUpdate+0x10c>)
  40545c:	6a1b      	ldr	r3, [r3, #32]
  40545e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  405462:	2b00      	cmp	r3, #0
  405464:	d003      	beq.n	40546e <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  405466:	4b33      	ldr	r3, [pc, #204]	; (405534 <SystemCoreClockUpdate+0x114>)
  405468:	4a33      	ldr	r2, [pc, #204]	; (405538 <SystemCoreClockUpdate+0x118>)
  40546a:	601a      	str	r2, [r3, #0]
		break;
  40546c:	e03f      	b.n	4054ee <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40546e:	4b31      	ldr	r3, [pc, #196]	; (405534 <SystemCoreClockUpdate+0x114>)
  405470:	4a32      	ldr	r2, [pc, #200]	; (40553c <SystemCoreClockUpdate+0x11c>)
  405472:	601a      	str	r2, [r3, #0]
			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  405474:	4b2d      	ldr	r3, [pc, #180]	; (40552c <SystemCoreClockUpdate+0x10c>)
  405476:	6a1b      	ldr	r3, [r3, #32]
  405478:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40547c:	2b10      	cmp	r3, #16
  40547e:	d004      	beq.n	40548a <SystemCoreClockUpdate+0x6a>
  405480:	2b20      	cmp	r3, #32
  405482:	d008      	beq.n	405496 <SystemCoreClockUpdate+0x76>
  405484:	2b00      	cmp	r3, #0
  405486:	d00e      	beq.n	4054a6 <SystemCoreClockUpdate+0x86>
				break;
  405488:	e00e      	b.n	4054a8 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  40548a:	4b2a      	ldr	r3, [pc, #168]	; (405534 <SystemCoreClockUpdate+0x114>)
  40548c:	681b      	ldr	r3, [r3, #0]
  40548e:	005b      	lsls	r3, r3, #1
  405490:	4a28      	ldr	r2, [pc, #160]	; (405534 <SystemCoreClockUpdate+0x114>)
  405492:	6013      	str	r3, [r2, #0]
				break;
  405494:	e008      	b.n	4054a8 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  405496:	4b27      	ldr	r3, [pc, #156]	; (405534 <SystemCoreClockUpdate+0x114>)
  405498:	681a      	ldr	r2, [r3, #0]
  40549a:	4613      	mov	r3, r2
  40549c:	005b      	lsls	r3, r3, #1
  40549e:	4413      	add	r3, r2
  4054a0:	4a24      	ldr	r2, [pc, #144]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054a2:	6013      	str	r3, [r2, #0]
				break;
  4054a4:	e000      	b.n	4054a8 <SystemCoreClockUpdate+0x88>
				break;
  4054a6:	bf00      	nop
		break;
  4054a8:	e021      	b.n	4054ee <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  4054aa:	4b21      	ldr	r3, [pc, #132]	; (405530 <SystemCoreClockUpdate+0x110>)
  4054ac:	695b      	ldr	r3, [r3, #20]
  4054ae:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4054b2:	2b00      	cmp	r3, #0
  4054b4:	d004      	beq.n	4054c0 <SystemCoreClockUpdate+0xa0>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4054b6:	4b1f      	ldr	r3, [pc, #124]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054b8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  4054bc:	601a      	str	r2, [r3, #0]
  4054be:	e003      	b.n	4054c8 <SystemCoreClockUpdate+0xa8>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  4054c0:	4b1c      	ldr	r3, [pc, #112]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054c2:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  4054c6:	601a      	str	r2, [r3, #0]
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  4054c8:	4b18      	ldr	r3, [pc, #96]	; (40552c <SystemCoreClockUpdate+0x10c>)
  4054ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4054cc:	f003 0303 	and.w	r3, r3, #3
  4054d0:	2b02      	cmp	r3, #2
  4054d2:	d10b      	bne.n	4054ec <SystemCoreClockUpdate+0xcc>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4054d4:	4b15      	ldr	r3, [pc, #84]	; (40552c <SystemCoreClockUpdate+0x10c>)
  4054d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  4054d8:	0c1b      	lsrs	r3, r3, #16
  4054da:	f3c3 030c 	ubfx	r3, r3, #0, #13
					CKGR_PLLAR_MULA_Pos) + 1U);
  4054de:	3301      	adds	r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  4054e0:	4a14      	ldr	r2, [pc, #80]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054e2:	6812      	ldr	r2, [r2, #0]
  4054e4:	fb02 f303 	mul.w	r3, r2, r3
  4054e8:	4a12      	ldr	r2, [pc, #72]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054ea:	6013      	str	r3, [r2, #0]
		break;
  4054ec:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  4054ee:	4b0f      	ldr	r3, [pc, #60]	; (40552c <SystemCoreClockUpdate+0x10c>)
  4054f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4054f2:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4054f6:	2b70      	cmp	r3, #112	; 0x70
  4054f8:	d108      	bne.n	40550c <SystemCoreClockUpdate+0xec>
		SystemCoreClock /= 3U;
  4054fa:	4b0e      	ldr	r3, [pc, #56]	; (405534 <SystemCoreClockUpdate+0x114>)
  4054fc:	681b      	ldr	r3, [r3, #0]
  4054fe:	4a10      	ldr	r2, [pc, #64]	; (405540 <SystemCoreClockUpdate+0x120>)
  405500:	fba2 2303 	umull	r2, r3, r2, r3
  405504:	085b      	lsrs	r3, r3, #1
  405506:	4a0b      	ldr	r2, [pc, #44]	; (405534 <SystemCoreClockUpdate+0x114>)
  405508:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
	}
}
  40550a:	e00a      	b.n	405522 <SystemCoreClockUpdate+0x102>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40550c:	4b07      	ldr	r3, [pc, #28]	; (40552c <SystemCoreClockUpdate+0x10c>)
  40550e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405510:	091b      	lsrs	r3, r3, #4
  405512:	f003 0307 	and.w	r3, r3, #7
  405516:	4a07      	ldr	r2, [pc, #28]	; (405534 <SystemCoreClockUpdate+0x114>)
  405518:	6812      	ldr	r2, [r2, #0]
  40551a:	fa22 f303 	lsr.w	r3, r2, r3
  40551e:	4a05      	ldr	r2, [pc, #20]	; (405534 <SystemCoreClockUpdate+0x114>)
  405520:	6013      	str	r3, [r2, #0]
}
  405522:	bf00      	nop
  405524:	46bd      	mov	sp, r7
  405526:	f85d 7b04 	ldr.w	r7, [sp], #4
  40552a:	4770      	bx	lr
  40552c:	400e0400 	.word	0x400e0400
  405530:	400e1410 	.word	0x400e1410
  405534:	20000170 	.word	0x20000170
  405538:	00b71b00 	.word	0x00b71b00
  40553c:	007a1200 	.word	0x007a1200
  405540:	aaaaaaab 	.word	0xaaaaaaab

00405544 <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  405544:	b480      	push	{r7}
  405546:	b083      	sub	sp, #12
  405548:	af00      	add	r7, sp, #0
  40554a:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  40554c:	687b      	ldr	r3, [r7, #4]
  40554e:	4a19      	ldr	r2, [pc, #100]	; (4055b4 <system_init_flash+0x70>)
  405550:	4293      	cmp	r3, r2
  405552:	d804      	bhi.n	40555e <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  405554:	4b18      	ldr	r3, [pc, #96]	; (4055b8 <system_init_flash+0x74>)
  405556:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40555a:	601a      	str	r2, [r3, #0]
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
	}
}
  40555c:	e023      	b.n	4055a6 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  40555e:	687b      	ldr	r3, [r7, #4]
  405560:	4a16      	ldr	r2, [pc, #88]	; (4055bc <system_init_flash+0x78>)
  405562:	4293      	cmp	r3, r2
  405564:	d803      	bhi.n	40556e <system_init_flash+0x2a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  405566:	4b14      	ldr	r3, [pc, #80]	; (4055b8 <system_init_flash+0x74>)
  405568:	4a15      	ldr	r2, [pc, #84]	; (4055c0 <system_init_flash+0x7c>)
  40556a:	601a      	str	r2, [r3, #0]
}
  40556c:	e01b      	b.n	4055a6 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  40556e:	687b      	ldr	r3, [r7, #4]
  405570:	4a14      	ldr	r2, [pc, #80]	; (4055c4 <system_init_flash+0x80>)
  405572:	4293      	cmp	r3, r2
  405574:	d803      	bhi.n	40557e <system_init_flash+0x3a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  405576:	4b10      	ldr	r3, [pc, #64]	; (4055b8 <system_init_flash+0x74>)
  405578:	4a13      	ldr	r2, [pc, #76]	; (4055c8 <system_init_flash+0x84>)
  40557a:	601a      	str	r2, [r3, #0]
}
  40557c:	e013      	b.n	4055a6 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  40557e:	687b      	ldr	r3, [r7, #4]
  405580:	4a12      	ldr	r2, [pc, #72]	; (4055cc <system_init_flash+0x88>)
  405582:	4293      	cmp	r3, r2
  405584:	d803      	bhi.n	40558e <system_init_flash+0x4a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  405586:	4b0c      	ldr	r3, [pc, #48]	; (4055b8 <system_init_flash+0x74>)
  405588:	4a11      	ldr	r2, [pc, #68]	; (4055d0 <system_init_flash+0x8c>)
  40558a:	601a      	str	r2, [r3, #0]
}
  40558c:	e00b      	b.n	4055a6 <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  40558e:	687b      	ldr	r3, [r7, #4]
  405590:	4a10      	ldr	r2, [pc, #64]	; (4055d4 <system_init_flash+0x90>)
  405592:	4293      	cmp	r3, r2
  405594:	d804      	bhi.n	4055a0 <system_init_flash+0x5c>
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  405596:	4b08      	ldr	r3, [pc, #32]	; (4055b8 <system_init_flash+0x74>)
  405598:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  40559c:	601a      	str	r2, [r3, #0]
}
  40559e:	e002      	b.n	4055a6 <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4055a0:	4b05      	ldr	r3, [pc, #20]	; (4055b8 <system_init_flash+0x74>)
  4055a2:	4a0d      	ldr	r2, [pc, #52]	; (4055d8 <system_init_flash+0x94>)
  4055a4:	601a      	str	r2, [r3, #0]
}
  4055a6:	bf00      	nop
  4055a8:	370c      	adds	r7, #12
  4055aa:	46bd      	mov	sp, r7
  4055ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4055b0:	4770      	bx	lr
  4055b2:	bf00      	nop
  4055b4:	01312cff 	.word	0x01312cff
  4055b8:	400e0a00 	.word	0x400e0a00
  4055bc:	026259ff 	.word	0x026259ff
  4055c0:	04000100 	.word	0x04000100
  4055c4:	039386ff 	.word	0x039386ff
  4055c8:	04000200 	.word	0x04000200
  4055cc:	04c4b3ff 	.word	0x04c4b3ff
  4055d0:	04000300 	.word	0x04000300
  4055d4:	05f5e0ff 	.word	0x05f5e0ff
  4055d8:	04000500 	.word	0x04000500

004055dc <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
  4055dc:	b480      	push	{r7}
  4055de:	b085      	sub	sp, #20
  4055e0:	af00      	add	r7, sp, #0
  4055e2:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  4055e4:	4b10      	ldr	r3, [pc, #64]	; (405628 <_sbrk+0x4c>)
  4055e6:	60fb      	str	r3, [r7, #12]

	if (heap == NULL) {
  4055e8:	4b10      	ldr	r3, [pc, #64]	; (40562c <_sbrk+0x50>)
  4055ea:	681b      	ldr	r3, [r3, #0]
  4055ec:	2b00      	cmp	r3, #0
  4055ee:	d102      	bne.n	4055f6 <_sbrk+0x1a>
		heap = (unsigned char *)&_end;
  4055f0:	4b0e      	ldr	r3, [pc, #56]	; (40562c <_sbrk+0x50>)
  4055f2:	4a0f      	ldr	r2, [pc, #60]	; (405630 <_sbrk+0x54>)
  4055f4:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  4055f6:	4b0d      	ldr	r3, [pc, #52]	; (40562c <_sbrk+0x50>)
  4055f8:	681b      	ldr	r3, [r3, #0]
  4055fa:	60bb      	str	r3, [r7, #8]

	if (((int)prev_heap + incr) > ramend) {
  4055fc:	68ba      	ldr	r2, [r7, #8]
  4055fe:	687b      	ldr	r3, [r7, #4]
  405600:	441a      	add	r2, r3
  405602:	68fb      	ldr	r3, [r7, #12]
  405604:	429a      	cmp	r2, r3
  405606:	dd02      	ble.n	40560e <_sbrk+0x32>
		return (caddr_t) -1;	
  405608:	f04f 33ff 	mov.w	r3, #4294967295
  40560c:	e006      	b.n	40561c <_sbrk+0x40>
	}

	heap += incr;
  40560e:	4b07      	ldr	r3, [pc, #28]	; (40562c <_sbrk+0x50>)
  405610:	681a      	ldr	r2, [r3, #0]
  405612:	687b      	ldr	r3, [r7, #4]
  405614:	4413      	add	r3, r2
  405616:	4a05      	ldr	r2, [pc, #20]	; (40562c <_sbrk+0x50>)
  405618:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
  40561a:	68bb      	ldr	r3, [r7, #8]
}
  40561c:	4618      	mov	r0, r3
  40561e:	3714      	adds	r7, #20
  405620:	46bd      	mov	sp, r7
  405622:	f85d 7b04 	ldr.w	r7, [sp], #4
  405626:	4770      	bx	lr
  405628:	20027ffc 	.word	0x20027ffc
  40562c:	20000430 	.word	0x20000430
  405630:	20005978 	.word	0x20005978

00405634 <_close>:
{
	return -1;
}

extern int _close(__attribute__((unused)) int file)
{
  405634:	b480      	push	{r7}
  405636:	b083      	sub	sp, #12
  405638:	af00      	add	r7, sp, #0
  40563a:	6078      	str	r0, [r7, #4]
	return -1;
  40563c:	f04f 33ff 	mov.w	r3, #4294967295
}
  405640:	4618      	mov	r0, r3
  405642:	370c      	adds	r7, #12
  405644:	46bd      	mov	sp, r7
  405646:	f85d 7b04 	ldr.w	r7, [sp], #4
  40564a:	4770      	bx	lr

0040564c <_fstat>:

extern int _fstat(__attribute__((unused)) int file, struct stat *st)
{
  40564c:	b480      	push	{r7}
  40564e:	b083      	sub	sp, #12
  405650:	af00      	add	r7, sp, #0
  405652:	6078      	str	r0, [r7, #4]
  405654:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
  405656:	683b      	ldr	r3, [r7, #0]
  405658:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  40565c:	605a      	str	r2, [r3, #4]

	return 0;
  40565e:	2300      	movs	r3, #0
}
  405660:	4618      	mov	r0, r3
  405662:	370c      	adds	r7, #12
  405664:	46bd      	mov	sp, r7
  405666:	f85d 7b04 	ldr.w	r7, [sp], #4
  40566a:	4770      	bx	lr

0040566c <_isatty>:

extern int _isatty(__attribute__((unused)) int file)
{
  40566c:	b480      	push	{r7}
  40566e:	b083      	sub	sp, #12
  405670:	af00      	add	r7, sp, #0
  405672:	6078      	str	r0, [r7, #4]
	return 1;
  405674:	2301      	movs	r3, #1
}
  405676:	4618      	mov	r0, r3
  405678:	370c      	adds	r7, #12
  40567a:	46bd      	mov	sp, r7
  40567c:	f85d 7b04 	ldr.w	r7, [sp], #4
  405680:	4770      	bx	lr

00405682 <_lseek>:

extern int _lseek(__attribute__((unused)) int file, __attribute__((unused)) int ptr, __attribute__((unused)) int dir)
{
  405682:	b480      	push	{r7}
  405684:	b085      	sub	sp, #20
  405686:	af00      	add	r7, sp, #0
  405688:	60f8      	str	r0, [r7, #12]
  40568a:	60b9      	str	r1, [r7, #8]
  40568c:	607a      	str	r2, [r7, #4]
	return 0;
  40568e:	2300      	movs	r3, #0
}
  405690:	4618      	mov	r0, r3
  405692:	3714      	adds	r7, #20
  405694:	46bd      	mov	sp, r7
  405696:	f85d 7b04 	ldr.w	r7, [sp], #4
  40569a:	4770      	bx	lr

0040569c <ch201_gprmt_init>:

#include "soniclib.h"
#include "ch201_gprmt.h"
#include "ch_common.h"

uint8_t ch201_gprmt_init(ch_dev_t *dev_ptr, ch_group_t *grp_ptr, uint8_t i2c_addr, uint8_t io_index, uint8_t i2c_bus_index) {
  40569c:	b580      	push	{r7, lr}
  40569e:	b084      	sub	sp, #16
  4056a0:	af00      	add	r7, sp, #0
  4056a2:	60f8      	str	r0, [r7, #12]
  4056a4:	60b9      	str	r1, [r7, #8]
  4056a6:	4611      	mov	r1, r2
  4056a8:	461a      	mov	r2, r3
  4056aa:	460b      	mov	r3, r1
  4056ac:	71fb      	strb	r3, [r7, #7]
  4056ae:	4613      	mov	r3, r2
  4056b0:	71bb      	strb	r3, [r7, #6]
	
	dev_ptr->part_number = CH201_PART_NUMBER;
  4056b2:	68fb      	ldr	r3, [r7, #12]
  4056b4:	22c9      	movs	r2, #201	; 0xc9
  4056b6:	839a      	strh	r2, [r3, #28]
	dev_ptr->app_i2c_address = i2c_addr;
  4056b8:	68fb      	ldr	r3, [r7, #12]
  4056ba:	79fa      	ldrb	r2, [r7, #7]
  4056bc:	765a      	strb	r2, [r3, #25]
	dev_ptr->io_index = io_index;
  4056be:	68fb      	ldr	r3, [r7, #12]
  4056c0:	79ba      	ldrb	r2, [r7, #6]
  4056c2:	f883 2020 	strb.w	r2, [r3, #32]
	dev_ptr->i2c_bus_index = i2c_bus_index;
  4056c6:	68fb      	ldr	r3, [r7, #12]
  4056c8:	7e3a      	ldrb	r2, [r7, #24]
  4056ca:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

	dev_ptr->freqCounterCycles = CH201_COMMON_FREQCOUNTERCYCLES;
  4056ce:	68fb      	ldr	r3, [r7, #12]
  4056d0:	2280      	movs	r2, #128	; 0x80
  4056d2:	80da      	strh	r2, [r3, #6]
	dev_ptr->freqLockValue     = CH201_COMMON_READY_FREQ_LOCKED;
  4056d4:	68fb      	ldr	r3, [r7, #12]
  4056d6:	2202      	movs	r2, #2
  4056d8:	715a      	strb	r2, [r3, #5]

	/* Init firmware-specific function pointers */
	dev_ptr->firmware 					= ch201_gprmt_fw;
  4056da:	68fb      	ldr	r3, [r7, #12]
  4056dc:	4a45      	ldr	r2, [pc, #276]	; (4057f4 <ch201_gprmt_init+0x158>)
  4056de:	631a      	str	r2, [r3, #48]	; 0x30
	dev_ptr->fw_version_string			= ch201_gprmt_version;
  4056e0:	4b45      	ldr	r3, [pc, #276]	; (4057f8 <ch201_gprmt_init+0x15c>)
  4056e2:	681a      	ldr	r2, [r3, #0]
  4056e4:	68fb      	ldr	r3, [r7, #12]
  4056e6:	62da      	str	r2, [r3, #44]	; 0x2c
	dev_ptr->ram_init 					= get_ram_ch201_gprmt_init_ptr();
  4056e8:	4b44      	ldr	r3, [pc, #272]	; (4057fc <ch201_gprmt_init+0x160>)
  4056ea:	4798      	blx	r3
  4056ec:	4602      	mov	r2, r0
  4056ee:	68fb      	ldr	r3, [r7, #12]
  4056f0:	635a      	str	r2, [r3, #52]	; 0x34
	dev_ptr->get_fw_ram_init_size 		= get_ch201_gprmt_fw_ram_init_size;
  4056f2:	68fb      	ldr	r3, [r7, #12]
  4056f4:	4a42      	ldr	r2, [pc, #264]	; (405800 <ch201_gprmt_init+0x164>)
  4056f6:	651a      	str	r2, [r3, #80]	; 0x50
	dev_ptr->get_fw_ram_init_addr 		= get_ch201_gprmt_fw_ram_init_addr;
  4056f8:	68fb      	ldr	r3, [r7, #12]
  4056fa:	4a42      	ldr	r2, [pc, #264]	; (405804 <ch201_gprmt_init+0x168>)
  4056fc:	655a      	str	r2, [r3, #84]	; 0x54

	dev_ptr->prepare_pulse_timer 		= ch_common_prepare_pulse_timer;
  4056fe:	68fb      	ldr	r3, [r7, #12]
  405700:	4a41      	ldr	r2, [pc, #260]	; (405808 <ch201_gprmt_init+0x16c>)
  405702:	639a      	str	r2, [r3, #56]	; 0x38
	dev_ptr->store_pt_result 			= ch_common_store_pt_result;
  405704:	68fb      	ldr	r3, [r7, #12]
  405706:	4a41      	ldr	r2, [pc, #260]	; (40580c <ch201_gprmt_init+0x170>)
  405708:	63da      	str	r2, [r3, #60]	; 0x3c
	dev_ptr->store_op_freq 				= ch_common_store_op_freq;
  40570a:	68fb      	ldr	r3, [r7, #12]
  40570c:	4a40      	ldr	r2, [pc, #256]	; (405810 <ch201_gprmt_init+0x174>)
  40570e:	641a      	str	r2, [r3, #64]	; 0x40
	dev_ptr->store_bandwidth 			= ch_common_store_bandwidth;
  405710:	68fb      	ldr	r3, [r7, #12]
  405712:	4a40      	ldr	r2, [pc, #256]	; (405814 <ch201_gprmt_init+0x178>)
  405714:	645a      	str	r2, [r3, #68]	; 0x44
	dev_ptr->store_scalefactor 			= ch_common_store_scale_factor;
  405716:	68fb      	ldr	r3, [r7, #12]
  405718:	4a3f      	ldr	r2, [pc, #252]	; (405818 <ch201_gprmt_init+0x17c>)
  40571a:	649a      	str	r2, [r3, #72]	; 0x48
	dev_ptr->get_locked_state 			= ch_common_get_locked_state;
  40571c:	68fb      	ldr	r3, [r7, #12]
  40571e:	4a3f      	ldr	r2, [pc, #252]	; (40581c <ch201_gprmt_init+0x180>)
  405720:	64da      	str	r2, [r3, #76]	; 0x4c

	/* Init API function pointers */
	dev_ptr->api_funcs.set_frequency		= ch_common_set_frequency;
  405722:	68fb      	ldr	r3, [r7, #12]
  405724:	4a3e      	ldr	r2, [pc, #248]	; (405820 <ch201_gprmt_init+0x184>)
  405726:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	dev_ptr->api_funcs.fw_load          	= ch_common_fw_load;
  40572a:	68fb      	ldr	r3, [r7, #12]
  40572c:	4a3d      	ldr	r2, [pc, #244]	; (405824 <ch201_gprmt_init+0x188>)
  40572e:	659a      	str	r2, [r3, #88]	; 0x58
	dev_ptr->api_funcs.set_mode         	= ch_common_set_mode;
  405730:	68fb      	ldr	r3, [r7, #12]
  405732:	4a3d      	ldr	r2, [pc, #244]	; (405828 <ch201_gprmt_init+0x18c>)
  405734:	65da      	str	r2, [r3, #92]	; 0x5c
	dev_ptr->api_funcs.set_sample_interval  = ch_common_set_sample_interval;
  405736:	68fb      	ldr	r3, [r7, #12]
  405738:	4a3c      	ldr	r2, [pc, #240]	; (40582c <ch201_gprmt_init+0x190>)
  40573a:	661a      	str	r2, [r3, #96]	; 0x60
	dev_ptr->api_funcs.set_num_samples  	= ch_common_set_num_samples;
  40573c:	68fb      	ldr	r3, [r7, #12]
  40573e:	4a3c      	ldr	r2, [pc, #240]	; (405830 <ch201_gprmt_init+0x194>)
  405740:	665a      	str	r2, [r3, #100]	; 0x64
	dev_ptr->api_funcs.set_max_range    	= ch_common_set_max_range;
  405742:	68fb      	ldr	r3, [r7, #12]
  405744:	4a3b      	ldr	r2, [pc, #236]	; (405834 <ch201_gprmt_init+0x198>)
  405746:	669a      	str	r2, [r3, #104]	; 0x68
	dev_ptr->api_funcs.set_static_range 	= NULL;								// not supported
  405748:	68fb      	ldr	r3, [r7, #12]
  40574a:	2200      	movs	r2, #0
  40574c:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
	dev_ptr->api_funcs.set_rx_holdoff   	= ch_common_set_rx_holdoff;
  405750:	68fb      	ldr	r3, [r7, #12]
  405752:	4a39      	ldr	r2, [pc, #228]	; (405838 <ch201_gprmt_init+0x19c>)
  405754:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	dev_ptr->api_funcs.get_rx_holdoff   	= ch_common_get_rx_holdoff;
  405758:	68fb      	ldr	r3, [r7, #12]
  40575a:	4a38      	ldr	r2, [pc, #224]	; (40583c <ch201_gprmt_init+0x1a0>)
  40575c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	dev_ptr->api_funcs.get_range        	= ch_common_get_range;
  405760:	68fb      	ldr	r3, [r7, #12]
  405762:	4a37      	ldr	r2, [pc, #220]	; (405840 <ch201_gprmt_init+0x1a4>)
  405764:	671a      	str	r2, [r3, #112]	; 0x70
	dev_ptr->api_funcs.get_amplitude    	= ch_common_get_amplitude;
  405766:	68fb      	ldr	r3, [r7, #12]
  405768:	4a36      	ldr	r2, [pc, #216]	; (405844 <ch201_gprmt_init+0x1a8>)
  40576a:	679a      	str	r2, [r3, #120]	; 0x78
	dev_ptr->api_funcs.get_iq_data      	= ch_common_get_iq_data;
  40576c:	68fb      	ldr	r3, [r7, #12]
  40576e:	4a36      	ldr	r2, [pc, #216]	; (405848 <ch201_gprmt_init+0x1ac>)
  405770:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	dev_ptr->api_funcs.get_amplitude_data  	= ch_common_get_amplitude_data;
  405774:	68fb      	ldr	r3, [r7, #12]
  405776:	4a35      	ldr	r2, [pc, #212]	; (40584c <ch201_gprmt_init+0x1b0>)
  405778:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	dev_ptr->api_funcs.samples_to_mm    	= ch_common_samples_to_mm;
  40577c:	68fb      	ldr	r3, [r7, #12]
  40577e:	4a34      	ldr	r2, [pc, #208]	; (405850 <ch201_gprmt_init+0x1b4>)
  405780:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	dev_ptr->api_funcs.mm_to_samples    	= ch_common_mm_to_samples;
  405784:	68fb      	ldr	r3, [r7, #12]
  405786:	4a33      	ldr	r2, [pc, #204]	; (405854 <ch201_gprmt_init+0x1b8>)
  405788:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	dev_ptr->api_funcs.set_thresholds   	= ch_common_set_thresholds;
  40578c:	68fb      	ldr	r3, [r7, #12]
  40578e:	4a32      	ldr	r2, [pc, #200]	; (405858 <ch201_gprmt_init+0x1bc>)
  405790:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	dev_ptr->api_funcs.get_thresholds   	= ch_common_get_thresholds;
  405794:	68fb      	ldr	r3, [r7, #12]
  405796:	4a31      	ldr	r2, [pc, #196]	; (40585c <ch201_gprmt_init+0x1c0>)
  405798:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	dev_ptr->api_funcs.set_sample_window 	= ch_common_set_sample_window;
  40579c:	68fb      	ldr	r3, [r7, #12]
  40579e:	4a30      	ldr	r2, [pc, #192]	; (405860 <ch201_gprmt_init+0x1c4>)
  4057a0:	66da      	str	r2, [r3, #108]	; 0x6c
	dev_ptr->api_funcs.get_amplitude_avg 	= ch_common_get_amplitude_avg;
  4057a2:	68fb      	ldr	r3, [r7, #12]
  4057a4:	4a2f      	ldr	r2, [pc, #188]	; (405864 <ch201_gprmt_init+0x1c8>)
  4057a6:	67da      	str	r2, [r3, #124]	; 0x7c
	dev_ptr->api_funcs.set_rx_low_gain		= ch_common_set_rx_low_gain;
  4057a8:	68fb      	ldr	r3, [r7, #12]
  4057aa:	4a2f      	ldr	r2, [pc, #188]	; (405868 <ch201_gprmt_init+0x1cc>)
  4057ac:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	dev_ptr->api_funcs.get_rx_low_gain		= ch_common_get_rx_low_gain;
  4057b0:	68fb      	ldr	r3, [r7, #12]
  4057b2:	4a2e      	ldr	r2, [pc, #184]	; (40586c <ch201_gprmt_init+0x1d0>)
  4057b4:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	dev_ptr->api_funcs.set_tx_length		= NULL;								// not supported
  4057b8:	68fb      	ldr	r3, [r7, #12]
  4057ba:	2200      	movs	r2, #0
  4057bc:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
	dev_ptr->api_funcs.get_tx_length		= ch_common_get_tx_length;
  4057c0:	68fb      	ldr	r3, [r7, #12]
  4057c2:	4a2b      	ldr	r2, [pc, #172]	; (405870 <ch201_gprmt_init+0x1d4>)
  4057c4:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

	/* Init max sample count */
	dev_ptr->max_samples = CH201_GPRMT_MAX_SAMPLES;
  4057c8:	68fb      	ldr	r3, [r7, #12]
  4057ca:	f44f 72e1 	mov.w	r2, #450	; 0x1c2
  4057ce:	845a      	strh	r2, [r3, #34]	; 0x22

	/* This firmware does not use oversampling */
	dev_ptr->oversample = 0;
  4057d0:	68fb      	ldr	r3, [r7, #12]
  4057d2:	2200      	movs	r2, #0
  4057d4:	779a      	strb	r2, [r3, #30]

	/* Init device and group descriptor linkage */
	dev_ptr->group						= grp_ptr;			// set parent group pointer
  4057d6:	68fb      	ldr	r3, [r7, #12]
  4057d8:	68ba      	ldr	r2, [r7, #8]
  4057da:	601a      	str	r2, [r3, #0]
	grp_ptr->device[io_index] 	   		= dev_ptr;			// add to parent group
  4057dc:	79ba      	ldrb	r2, [r7, #6]
  4057de:	68bb      	ldr	r3, [r7, #8]
  4057e0:	3206      	adds	r2, #6
  4057e2:	68f9      	ldr	r1, [r7, #12]
  4057e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	return 0;
  4057e8:	2300      	movs	r3, #0
}
  4057ea:	4618      	mov	r0, r3
  4057ec:	3710      	adds	r7, #16
  4057ee:	46bd      	mov	sp, r7
  4057f0:	bd80      	pop	{r7, pc}
  4057f2:	bf00      	nop
  4057f4:	0040d388 	.word	0x0040d388
  4057f8:	20000174 	.word	0x20000174
  4057fc:	00405899 	.word	0x00405899
  405800:	00405887 	.word	0x00405887
  405804:	00405875 	.word	0x00405875
  405808:	004067e9 	.word	0x004067e9
  40580c:	0040681d 	.word	0x0040681d
  405810:	004068b1 	.word	0x004068b1
  405814:	00406925 	.word	0x00406925
  405818:	00406a05 	.word	0x00406a05
  40581c:	00406789 	.word	0x00406789
  405820:	00406859 	.word	0x00406859
  405824:	00406195 	.word	0x00406195
  405828:	00406039 	.word	0x00406039
  40582c:	00406251 	.word	0x00406251
  405830:	0040637d 	.word	0x0040637d
  405834:	00406421 	.word	0x00406421
  405838:	004070f5 	.word	0x004070f5
  40583c:	00407155 	.word	0x00407155
  405840:	0040662d 	.word	0x0040662d
  405844:	00406745 	.word	0x00406745
  405848:	00406f79 	.word	0x00406f79
  40584c:	00406fb5 	.word	0x00406fb5
  405850:	004065dd 	.word	0x004065dd
  405854:	004064f1 	.word	0x004064f1
  405858:	00406a55 	.word	0x00406a55
  40585c:	00406b69 	.word	0x00406b69
  405860:	00406e55 	.word	0x00406e55
  405864:	00406ea9 	.word	0x00406ea9
  405868:	004071ad 	.word	0x004071ad
  40586c:	00407211 	.word	0x00407211
  405870:	00407255 	.word	0x00407255

00405874 <get_ch201_gprmt_fw_ram_init_addr>:
const char * ch201_gprmt_gitsha1 = "247eb617b50e896de61a12488571555935b91867";

#define RAM_INIT_ADDRESS 2392
#define RAM_INIT_WRITE_SIZE   28

uint16_t get_ch201_gprmt_fw_ram_init_addr(void) { return (uint16_t)RAM_INIT_ADDRESS;}
  405874:	b480      	push	{r7}
  405876:	af00      	add	r7, sp, #0
  405878:	f640 1358 	movw	r3, #2392	; 0x958
  40587c:	4618      	mov	r0, r3
  40587e:	46bd      	mov	sp, r7
  405880:	f85d 7b04 	ldr.w	r7, [sp], #4
  405884:	4770      	bx	lr

00405886 <get_ch201_gprmt_fw_ram_init_size>:
uint16_t get_ch201_gprmt_fw_ram_init_size(void) { return (uint16_t)RAM_INIT_WRITE_SIZE;}
  405886:	b480      	push	{r7}
  405888:	af00      	add	r7, sp, #0
  40588a:	231c      	movs	r3, #28
  40588c:	4618      	mov	r0, r3
  40588e:	46bd      	mov	sp, r7
  405890:	f85d 7b04 	ldr.w	r7, [sp], #4
  405894:	4770      	bx	lr
	...

00405898 <get_ram_ch201_gprmt_init_ptr>:

const unsigned char ram_ch201_gprmt_init[RAM_INIT_WRITE_SIZE] = {
0x88, 0x13, 0xD0, 0x07, 0x20, 0x03, 0x90, 0x01, 0xFA, 0x00, 0xAF, 0x00, 0x06, 0x00, 0x00, 0x00, 
0x00, 0xFA, 0x00, 0x00, 0x64, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x00, };

const unsigned char * get_ram_ch201_gprmt_init_ptr(void) { return &ram_ch201_gprmt_init[0];}
  405898:	b480      	push	{r7}
  40589a:	af00      	add	r7, sp, #0
  40589c:	4b02      	ldr	r3, [pc, #8]	; (4058a8 <get_ram_ch201_gprmt_init_ptr+0x10>)
  40589e:	4618      	mov	r0, r3
  4058a0:	46bd      	mov	sp, r7
  4058a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4058a6:	4770      	bx	lr
  4058a8:	0040d36c 	.word	0x0040d36c

004058ac <chbsp_debug_toggle>:



/* Functions supporting debugging */

__attribute__((weak)) void chbsp_debug_toggle(uint8_t __attribute__((unused)) dbg_pin_num) {}
  4058ac:	b480      	push	{r7}
  4058ae:	b083      	sub	sp, #12
  4058b0:	af00      	add	r7, sp, #0
  4058b2:	4603      	mov	r3, r0
  4058b4:	71fb      	strb	r3, [r7, #7]
  4058b6:	bf00      	nop
  4058b8:	370c      	adds	r7, #12
  4058ba:	46bd      	mov	sp, r7
  4058bc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4058c0:	4770      	bx	lr

004058c2 <chbsp_external_i2c_irq_handler>:

__attribute__((weak)) void chbsp_io_set(ch_dev_t *dev_ptr) {
	(void)(dev_ptr);
}

__attribute__((weak)) void chbsp_external_i2c_irq_handler(chdrv_i2c_transaction_t *trans){
  4058c2:	b480      	push	{r7}
  4058c4:	b083      	sub	sp, #12
  4058c6:	af00      	add	r7, sp, #0
  4058c8:	6078      	str	r0, [r7, #4]
	(void)(trans);
}
  4058ca:	bf00      	nop
  4058cc:	370c      	adds	r7, #12
  4058ce:	46bd      	mov	sp, r7
  4058d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4058d4:	4770      	bx	lr
	...

004058d8 <ch_init>:
 *
 * \return 0 (RET_OK) if successful, non-zero otherwise
 *
 */

uint8_t	ch_init(ch_dev_t *dev_ptr, ch_group_t *grp_ptr, uint8_t dev_num, ch_fw_init_func_t fw_init_func) {
  4058d8:	b590      	push	{r4, r7, lr}
  4058da:	b089      	sub	sp, #36	; 0x24
  4058dc:	af02      	add	r7, sp, #8
  4058de:	60f8      	str	r0, [r7, #12]
  4058e0:	60b9      	str	r1, [r7, #8]
  4058e2:	603b      	str	r3, [r7, #0]
  4058e4:	4613      	mov	r3, r2
  4058e6:	71fb      	strb	r3, [r7, #7]
	
	uint8_t	ret_val = RET_ERR;
  4058e8:	2301      	movs	r3, #1
  4058ea:	75fb      	strb	r3, [r7, #23]

	ch_i2c_info_t	i2c_info;

	if (fw_init_func != NULL) {
  4058ec:	683b      	ldr	r3, [r7, #0]
  4058ee:	2b00      	cmp	r3, #0
  4058f0:	d019      	beq.n	405926 <ch_init+0x4e>
		/* Get I2C parameters from BSP */
		ret_val = chbsp_i2c_get_info(grp_ptr, dev_num, &i2c_info);
  4058f2:	f107 0210 	add.w	r2, r7, #16
  4058f6:	79fb      	ldrb	r3, [r7, #7]
  4058f8:	4619      	mov	r1, r3
  4058fa:	68b8      	ldr	r0, [r7, #8]
  4058fc:	4b0c      	ldr	r3, [pc, #48]	; (405930 <ch_init+0x58>)
  4058fe:	4798      	blx	r3
  405900:	4603      	mov	r3, r0
  405902:	75fb      	strb	r3, [r7, #23]
	
		if (ret_val == RET_OK) {
  405904:	7dfb      	ldrb	r3, [r7, #23]
  405906:	2b00      	cmp	r3, #0
  405908:	d10d      	bne.n	405926 <ch_init+0x4e>
			/* Save special handling flags for Chirp driver */
			grp_ptr->i2c_drv_flags = i2c_info.drv_flags;
  40590a:	8a7a      	ldrh	r2, [r7, #18]
  40590c:	68bb      	ldr	r3, [r7, #8]
  40590e:	809a      	strh	r2, [r3, #4]

			/* Call asic f/w init function passed in as parameter */
			ret_val = (*fw_init_func)(dev_ptr, grp_ptr, i2c_info.address, dev_num, i2c_info.bus_num);
  405910:	7c3a      	ldrb	r2, [r7, #16]
  405912:	7c7b      	ldrb	r3, [r7, #17]
  405914:	79f9      	ldrb	r1, [r7, #7]
  405916:	9300      	str	r3, [sp, #0]
  405918:	683c      	ldr	r4, [r7, #0]
  40591a:	460b      	mov	r3, r1
  40591c:	68b9      	ldr	r1, [r7, #8]
  40591e:	68f8      	ldr	r0, [r7, #12]
  405920:	47a0      	blx	r4
  405922:	4603      	mov	r3, r0
  405924:	75fb      	strb	r3, [r7, #23]
		}
	}

	return ret_val;
  405926:	7dfb      	ldrb	r3, [r7, #23]
}
  405928:	4618      	mov	r0, r3
  40592a:	371c      	adds	r7, #28
  40592c:	46bd      	mov	sp, r7
  40592e:	bd90      	pop	{r4, r7, pc}
  405930:	00402785 	.word	0x00402785

00405934 <ch_get_config>:


uint8_t	ch_get_config(ch_dev_t *dev_ptr, ch_config_t *config_ptr) {
  405934:	b480      	push	{r7}
  405936:	b085      	sub	sp, #20
  405938:	af00      	add	r7, sp, #0
  40593a:	6078      	str	r0, [r7, #4]
  40593c:	6039      	str	r1, [r7, #0]
	uint8_t ret_val = 0;
  40593e:	2300      	movs	r3, #0
  405940:	73fb      	strb	r3, [r7, #15]

	config_ptr->mode         	= dev_ptr->mode;
  405942:	687b      	ldr	r3, [r7, #4]
  405944:	791a      	ldrb	r2, [r3, #4]
  405946:	683b      	ldr	r3, [r7, #0]
  405948:	701a      	strb	r2, [r3, #0]
	config_ptr->max_range    	= dev_ptr->max_range;
  40594a:	687b      	ldr	r3, [r7, #4]
  40594c:	891a      	ldrh	r2, [r3, #8]
  40594e:	683b      	ldr	r3, [r7, #0]
  405950:	805a      	strh	r2, [r3, #2]
	config_ptr->static_range 	= dev_ptr->static_range;
  405952:	687b      	ldr	r3, [r7, #4]
  405954:	895a      	ldrh	r2, [r3, #10]
  405956:	683b      	ldr	r3, [r7, #0]
  405958:	809a      	strh	r2, [r3, #4]
	config_ptr->sample_interval	= dev_ptr->sample_interval;
  40595a:	687b      	ldr	r3, [r7, #4]
  40595c:	899a      	ldrh	r2, [r3, #12]
  40595e:	683b      	ldr	r3, [r7, #0]
  405960:	80da      	strh	r2, [r3, #6]
	config_ptr->thresh_ptr   	= NULL;				// thresholds not returned here - use ch_get_thresholds()
  405962:	683b      	ldr	r3, [r7, #0]
  405964:	2200      	movs	r2, #0
  405966:	609a      	str	r2, [r3, #8]

	return ret_val;
  405968:	7bfb      	ldrb	r3, [r7, #15]
}
  40596a:	4618      	mov	r0, r3
  40596c:	3714      	adds	r7, #20
  40596e:	46bd      	mov	sp, r7
  405970:	f85d 7b04 	ldr.w	r7, [sp], #4
  405974:	4770      	bx	lr
	...

00405978 <ch_set_config>:


uint8_t	ch_set_config(ch_dev_t *dev_ptr, ch_config_t *config_ptr) {
  405978:	b580      	push	{r7, lr}
  40597a:	b084      	sub	sp, #16
  40597c:	af00      	add	r7, sp, #0
  40597e:	6078      	str	r0, [r7, #4]
  405980:	6039      	str	r1, [r7, #0]
	uint8_t ret_val = 0;
  405982:	2300      	movs	r3, #0
  405984:	73fb      	strb	r3, [r7, #15]


	ret_val = ch_set_max_range(dev_ptr, config_ptr->max_range);			// set max range
  405986:	683b      	ldr	r3, [r7, #0]
  405988:	885b      	ldrh	r3, [r3, #2]
  40598a:	4619      	mov	r1, r3
  40598c:	6878      	ldr	r0, [r7, #4]
  40598e:	4b3a      	ldr	r3, [pc, #232]	; (405a78 <ch_set_config+0x100>)
  405990:	4798      	blx	r3
  405992:	4603      	mov	r3, r0
  405994:	73fb      	strb	r3, [r7, #15]

	if (!ret_val) {
  405996:	7bfb      	ldrb	r3, [r7, #15]
  405998:	2b00      	cmp	r3, #0
  40599a:	d113      	bne.n	4059c4 <ch_set_config+0x4c>

		if (dev_ptr->api_funcs.set_static_range != NULL) {			// if STR supported
  40599c:	687b      	ldr	r3, [r7, #4]
  40599e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
  4059a2:	2b00      	cmp	r3, #0
  4059a4:	d00e      	beq.n	4059c4 <ch_set_config+0x4c>
			ret_val = ch_set_static_range(dev_ptr, config_ptr->static_range);	// set static target rejection range
  4059a6:	683b      	ldr	r3, [r7, #0]
  4059a8:	889b      	ldrh	r3, [r3, #4]
  4059aa:	4619      	mov	r1, r3
  4059ac:	6878      	ldr	r0, [r7, #4]
  4059ae:	4b33      	ldr	r3, [pc, #204]	; (405a7c <ch_set_config+0x104>)
  4059b0:	4798      	blx	r3
  4059b2:	4603      	mov	r3, r0
  4059b4:	73fb      	strb	r3, [r7, #15]

			if (!ret_val) {
  4059b6:	7bfb      	ldrb	r3, [r7, #15]
  4059b8:	2b00      	cmp	r3, #0
  4059ba:	d103      	bne.n	4059c4 <ch_set_config+0x4c>
				dev_ptr->static_range = config_ptr->static_range;
  4059bc:	683b      	ldr	r3, [r7, #0]
  4059be:	889a      	ldrh	r2, [r3, #4]
  4059c0:	687b      	ldr	r3, [r7, #4]
  4059c2:	815a      	strh	r2, [r3, #10]
			}
		}
	}

	if (!ret_val) {
  4059c4:	7bfb      	ldrb	r3, [r7, #15]
  4059c6:	2b00      	cmp	r3, #0
  4059c8:	d10b      	bne.n	4059e2 <ch_set_config+0x6a>
		if (config_ptr->sample_interval != 0) {
  4059ca:	683b      	ldr	r3, [r7, #0]
  4059cc:	88db      	ldrh	r3, [r3, #6]
  4059ce:	2b00      	cmp	r3, #0
  4059d0:	d007      	beq.n	4059e2 <ch_set_config+0x6a>
			ret_val = ch_set_sample_interval(dev_ptr, config_ptr->sample_interval);		// set sample interval (free-run mode only)
  4059d2:	683b      	ldr	r3, [r7, #0]
  4059d4:	88db      	ldrh	r3, [r3, #6]
  4059d6:	4619      	mov	r1, r3
  4059d8:	6878      	ldr	r0, [r7, #4]
  4059da:	4b29      	ldr	r3, [pc, #164]	; (405a80 <ch_set_config+0x108>)
  4059dc:	4798      	blx	r3
  4059de:	4603      	mov	r3, r0
  4059e0:	73fb      	strb	r3, [r7, #15]
		}
	}

	if (!ret_val) {
  4059e2:	7bfb      	ldrb	r3, [r7, #15]
  4059e4:	2b00      	cmp	r3, #0
  4059e6:	d110      	bne.n	405a0a <ch_set_config+0x92>
		dev_ptr->sample_interval = config_ptr->sample_interval;				// store sample interval
  4059e8:	683b      	ldr	r3, [r7, #0]
  4059ea:	88da      	ldrh	r2, [r3, #6]
  4059ec:	687b      	ldr	r3, [r7, #4]
  4059ee:	819a      	strh	r2, [r3, #12]

		if (dev_ptr->api_funcs.set_thresholds != NULL) {					// if multi-thresholds supported
  4059f0:	687b      	ldr	r3, [r7, #4]
  4059f2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  4059f6:	2b00      	cmp	r3, #0
  4059f8:	d007      	beq.n	405a0a <ch_set_config+0x92>
			ret_val = ch_set_thresholds(dev_ptr, config_ptr->thresh_ptr);	// set multiple thresholds
  4059fa:	683b      	ldr	r3, [r7, #0]
  4059fc:	689b      	ldr	r3, [r3, #8]
  4059fe:	4619      	mov	r1, r3
  405a00:	6878      	ldr	r0, [r7, #4]
  405a02:	4b20      	ldr	r3, [pc, #128]	; (405a84 <ch_set_config+0x10c>)
  405a04:	4798      	blx	r3
  405a06:	4603      	mov	r3, r0
  405a08:	73fb      	strb	r3, [r7, #15]
		}
	}

	if (!ret_val) {
  405a0a:	7bfb      	ldrb	r3, [r7, #15]
  405a0c:	2b00      	cmp	r3, #0
  405a0e:	d10c      	bne.n	405a2a <ch_set_config+0xb2>
		if (dev_ptr->api_funcs.set_target_interrupt != NULL) {					// if target interrupt mode supported
  405a10:	687b      	ldr	r3, [r7, #4]
  405a12:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
  405a16:	2b00      	cmp	r3, #0
  405a18:	d007      	beq.n	405a2a <ch_set_config+0xb2>
			ret_val = ch_set_target_interrupt(dev_ptr, config_ptr->enable_target_int);	// enable/disable target detect interrupt 
  405a1a:	683b      	ldr	r3, [r7, #0]
  405a1c:	7b5b      	ldrb	r3, [r3, #13]
  405a1e:	4619      	mov	r1, r3
  405a20:	6878      	ldr	r0, [r7, #4]
  405a22:	4b19      	ldr	r3, [pc, #100]	; (405a88 <ch_set_config+0x110>)
  405a24:	4798      	blx	r3
  405a26:	4603      	mov	r3, r0
  405a28:	73fb      	strb	r3, [r7, #15]
		}
	}

	if (!ret_val) {
  405a2a:	7bfb      	ldrb	r3, [r7, #15]
  405a2c:	2b00      	cmp	r3, #0
  405a2e:	d10c      	bne.n	405a4a <ch_set_config+0xd2>
		if (dev_ptr->api_funcs.set_time_plan != NULL) {						// if SonicSync time plans supported
  405a30:	687b      	ldr	r3, [r7, #4]
  405a32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
  405a36:	2b00      	cmp	r3, #0
  405a38:	d007      	beq.n	405a4a <ch_set_config+0xd2>
			ret_val = ch_set_time_plan(dev_ptr,config_ptr->time_plan);		// set time plan (sonicsync only)
  405a3a:	683b      	ldr	r3, [r7, #0]
  405a3c:	7b1b      	ldrb	r3, [r3, #12]
  405a3e:	4619      	mov	r1, r3
  405a40:	6878      	ldr	r0, [r7, #4]
  405a42:	4b12      	ldr	r3, [pc, #72]	; (405a8c <ch_set_config+0x114>)
  405a44:	4798      	blx	r3
  405a46:	4603      	mov	r3, r0
  405a48:	73fb      	strb	r3, [r7, #15]
		}
	}

	if (!ret_val) {
  405a4a:	7bfb      	ldrb	r3, [r7, #15]
  405a4c:	2b00      	cmp	r3, #0
  405a4e:	d107      	bne.n	405a60 <ch_set_config+0xe8>
		ret_val = ch_set_mode(dev_ptr, config_ptr->mode);						// set operating mode last
  405a50:	683b      	ldr	r3, [r7, #0]
  405a52:	781b      	ldrb	r3, [r3, #0]
  405a54:	4619      	mov	r1, r3
  405a56:	6878      	ldr	r0, [r7, #4]
  405a58:	4b0d      	ldr	r3, [pc, #52]	; (405a90 <ch_set_config+0x118>)
  405a5a:	4798      	blx	r3
  405a5c:	4603      	mov	r3, r0
  405a5e:	73fb      	strb	r3, [r7, #15]
	}

	if (!ret_val) {
  405a60:	7bfb      	ldrb	r3, [r7, #15]
  405a62:	2b00      	cmp	r3, #0
  405a64:	d103      	bne.n	405a6e <ch_set_config+0xf6>
		dev_ptr->mode = config_ptr->mode;
  405a66:	683b      	ldr	r3, [r7, #0]
  405a68:	781a      	ldrb	r2, [r3, #0]
  405a6a:	687b      	ldr	r3, [r7, #4]
  405a6c:	711a      	strb	r2, [r3, #4]
	}
	
	return ret_val;
  405a6e:	7bfb      	ldrb	r3, [r7, #15]
}
  405a70:	4618      	mov	r0, r3
  405a72:	3710      	adds	r7, #16
  405a74:	46bd      	mov	sp, r7
  405a76:	bd80      	pop	{r7, pc}
  405a78:	00405c95 	.word	0x00405c95
  405a7c:	00405cc9 	.word	0x00405cc9
  405a80:	00405bf9 	.word	0x00405bf9
  405a84:	00405e95 	.word	0x00405e95
  405a88:	00405f9d 	.word	0x00405f9d
  405a8c:	00405f09 	.word	0x00405f09
  405a90:	00405bb7 	.word	0x00405bb7

00405a94 <ch_group_start>:




uint8_t	ch_group_start(ch_group_t *grp_ptr) {
  405a94:	b580      	push	{r7, lr}
  405a96:	b084      	sub	sp, #16
  405a98:	af00      	add	r7, sp, #0
  405a9a:	6078      	str	r0, [r7, #4]
	uint8_t ret_val;

	ret_val = chdrv_group_start(grp_ptr);
  405a9c:	6878      	ldr	r0, [r7, #4]
  405a9e:	4b04      	ldr	r3, [pc, #16]	; (405ab0 <ch_group_start+0x1c>)
  405aa0:	4798      	blx	r3
  405aa2:	4603      	mov	r3, r0
  405aa4:	73fb      	strb	r3, [r7, #15]

	return ret_val;
  405aa6:	7bfb      	ldrb	r3, [r7, #15]
}
  405aa8:	4618      	mov	r0, r3
  405aaa:	3710      	adds	r7, #16
  405aac:	46bd      	mov	sp, r7
  405aae:	bd80      	pop	{r7, pc}
  405ab0:	00408271 	.word	0x00408271

00405ab4 <ch_group_trigger>:

void ch_trigger(ch_dev_t *dev_ptr) {
	chdrv_hw_trigger(dev_ptr);
}

void ch_group_trigger(ch_group_t *grp_ptr) {
  405ab4:	b580      	push	{r7, lr}
  405ab6:	b082      	sub	sp, #8
  405ab8:	af00      	add	r7, sp, #0
  405aba:	6078      	str	r0, [r7, #4]
	chdrv_group_hw_trigger(grp_ptr);
  405abc:	6878      	ldr	r0, [r7, #4]
  405abe:	4b03      	ldr	r3, [pc, #12]	; (405acc <ch_group_trigger+0x18>)
  405ac0:	4798      	blx	r3
}
  405ac2:	bf00      	nop
  405ac4:	3708      	adds	r7, #8
  405ac6:	46bd      	mov	sp, r7
  405ac8:	bd80      	pop	{r7, pc}
  405aca:	bf00      	nop
  405acc:	004079a9 	.word	0x004079a9

00405ad0 <ch_sensor_is_connected>:
	} else {
		chdrv_group_soft_reset(grp_ptr);
	}
}

uint8_t ch_sensor_is_connected(ch_dev_t *dev_ptr) {
  405ad0:	b480      	push	{r7}
  405ad2:	b083      	sub	sp, #12
  405ad4:	af00      	add	r7, sp, #0
  405ad6:	6078      	str	r0, [r7, #4]

	return dev_ptr->sensor_connected;
  405ad8:	687b      	ldr	r3, [r7, #4]
  405ada:	7fdb      	ldrb	r3, [r3, #31]
}
  405adc:	4618      	mov	r0, r3
  405ade:	370c      	adds	r7, #12
  405ae0:	46bd      	mov	sp, r7
  405ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
  405ae6:	4770      	bx	lr

00405ae8 <ch_get_part_number>:


uint16_t ch_get_part_number(ch_dev_t *dev_ptr) {
  405ae8:	b480      	push	{r7}
  405aea:	b083      	sub	sp, #12
  405aec:	af00      	add	r7, sp, #0
  405aee:	6078      	str	r0, [r7, #4]

	return dev_ptr->part_number;
  405af0:	687b      	ldr	r3, [r7, #4]
  405af2:	8b9b      	ldrh	r3, [r3, #28]
}
  405af4:	4618      	mov	r0, r3
  405af6:	370c      	adds	r7, #12
  405af8:	46bd      	mov	sp, r7
  405afa:	f85d 7b04 	ldr.w	r7, [sp], #4
  405afe:	4770      	bx	lr

00405b00 <ch_get_dev_num>:


uint8_t  ch_get_dev_num(ch_dev_t *dev_ptr) {
  405b00:	b480      	push	{r7}
  405b02:	b083      	sub	sp, #12
  405b04:	af00      	add	r7, sp, #0
  405b06:	6078      	str	r0, [r7, #4]

	return dev_ptr->io_index;
  405b08:	687b      	ldr	r3, [r7, #4]
  405b0a:	f893 3020 	ldrb.w	r3, [r3, #32]
}
  405b0e:	4618      	mov	r0, r3
  405b10:	370c      	adds	r7, #12
  405b12:	46bd      	mov	sp, r7
  405b14:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b18:	4770      	bx	lr

00405b1a <ch_get_dev_ptr>:


ch_dev_t *ch_get_dev_ptr(ch_group_t *grp_ptr, uint8_t dev_num) {
  405b1a:	b480      	push	{r7}
  405b1c:	b083      	sub	sp, #12
  405b1e:	af00      	add	r7, sp, #0
  405b20:	6078      	str	r0, [r7, #4]
  405b22:	460b      	mov	r3, r1
  405b24:	70fb      	strb	r3, [r7, #3]

	return grp_ptr->device[dev_num];
  405b26:	78fa      	ldrb	r2, [r7, #3]
  405b28:	687b      	ldr	r3, [r7, #4]
  405b2a:	3206      	adds	r2, #6
  405b2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
  405b30:	4618      	mov	r0, r3
  405b32:	370c      	adds	r7, #12
  405b34:	46bd      	mov	sp, r7
  405b36:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b3a:	4770      	bx	lr

00405b3c <ch_get_i2c_address>:

uint8_t  ch_get_i2c_address(ch_dev_t *dev_ptr) {
  405b3c:	b480      	push	{r7}
  405b3e:	b083      	sub	sp, #12
  405b40:	af00      	add	r7, sp, #0
  405b42:	6078      	str	r0, [r7, #4]

	return dev_ptr->i2c_address;
  405b44:	687b      	ldr	r3, [r7, #4]
  405b46:	7e1b      	ldrb	r3, [r3, #24]
}
  405b48:	4618      	mov	r0, r3
  405b4a:	370c      	adds	r7, #12
  405b4c:	46bd      	mov	sp, r7
  405b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b52:	4770      	bx	lr

00405b54 <ch_get_i2c_bus>:


uint8_t  ch_get_i2c_bus(ch_dev_t *dev_ptr) {
  405b54:	b480      	push	{r7}
  405b56:	b083      	sub	sp, #12
  405b58:	af00      	add	r7, sp, #0
  405b5a:	6078      	str	r0, [r7, #4]

	return dev_ptr->i2c_bus_index;
  405b5c:	687b      	ldr	r3, [r7, #4]
  405b5e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
}
  405b62:	4618      	mov	r0, r3
  405b64:	370c      	adds	r7, #12
  405b66:	46bd      	mov	sp, r7
  405b68:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b6c:	4770      	bx	lr

00405b6e <ch_get_num_ports>:


uint8_t ch_get_num_ports(ch_group_t *grp_ptr) {
  405b6e:	b480      	push	{r7}
  405b70:	b083      	sub	sp, #12
  405b72:	af00      	add	r7, sp, #0
  405b74:	6078      	str	r0, [r7, #4]

	return grp_ptr->num_ports;
  405b76:	687b      	ldr	r3, [r7, #4]
  405b78:	781b      	ldrb	r3, [r3, #0]
}
  405b7a:	4618      	mov	r0, r3
  405b7c:	370c      	adds	r7, #12
  405b7e:	46bd      	mov	sp, r7
  405b80:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b84:	4770      	bx	lr

00405b86 <ch_get_fw_version_string>:

const char *ch_get_fw_version_string(ch_dev_t *dev_ptr) {
  405b86:	b480      	push	{r7}
  405b88:	b083      	sub	sp, #12
  405b8a:	af00      	add	r7, sp, #0
  405b8c:	6078      	str	r0, [r7, #4]

	return dev_ptr->fw_version_string;
  405b8e:	687b      	ldr	r3, [r7, #4]
  405b90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  405b92:	4618      	mov	r0, r3
  405b94:	370c      	adds	r7, #12
  405b96:	46bd      	mov	sp, r7
  405b98:	f85d 7b04 	ldr.w	r7, [sp], #4
  405b9c:	4770      	bx	lr

00405b9e <ch_get_mode>:

ch_mode_t ch_get_mode(ch_dev_t *dev_ptr) {
  405b9e:	b480      	push	{r7}
  405ba0:	b083      	sub	sp, #12
  405ba2:	af00      	add	r7, sp, #0
  405ba4:	6078      	str	r0, [r7, #4]

	return dev_ptr->mode;
  405ba6:	687b      	ldr	r3, [r7, #4]
  405ba8:	791b      	ldrb	r3, [r3, #4]
}
  405baa:	4618      	mov	r0, r3
  405bac:	370c      	adds	r7, #12
  405bae:	46bd      	mov	sp, r7
  405bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
  405bb4:	4770      	bx	lr

00405bb6 <ch_set_mode>:


uint8_t ch_set_mode(ch_dev_t *dev_ptr, ch_mode_t mode) {
  405bb6:	b580      	push	{r7, lr}
  405bb8:	b084      	sub	sp, #16
  405bba:	af00      	add	r7, sp, #0
  405bbc:	6078      	str	r0, [r7, #4]
  405bbe:	460b      	mov	r3, r1
  405bc0:	70fb      	strb	r3, [r7, #3]
	int	ret_val = RET_ERR;
  405bc2:	2301      	movs	r3, #1
  405bc4:	60fb      	str	r3, [r7, #12]
	ch_set_mode_func_t func_ptr = dev_ptr->api_funcs.set_mode;
  405bc6:	687b      	ldr	r3, [r7, #4]
  405bc8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  405bca:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405bcc:	68bb      	ldr	r3, [r7, #8]
  405bce:	2b00      	cmp	r3, #0
  405bd0:	d006      	beq.n	405be0 <ch_set_mode+0x2a>
		ret_val = (*func_ptr)(dev_ptr, mode);
  405bd2:	78fa      	ldrb	r2, [r7, #3]
  405bd4:	68bb      	ldr	r3, [r7, #8]
  405bd6:	4611      	mov	r1, r2
  405bd8:	6878      	ldr	r0, [r7, #4]
  405bda:	4798      	blx	r3
  405bdc:	4603      	mov	r3, r0
  405bde:	60fb      	str	r3, [r7, #12]
	}

	if (ret_val == 0) {
  405be0:	68fb      	ldr	r3, [r7, #12]
  405be2:	2b00      	cmp	r3, #0
  405be4:	d102      	bne.n	405bec <ch_set_mode+0x36>
		dev_ptr->mode = mode;
  405be6:	687b      	ldr	r3, [r7, #4]
  405be8:	78fa      	ldrb	r2, [r7, #3]
  405bea:	711a      	strb	r2, [r3, #4]
	}

	return ret_val;
  405bec:	68fb      	ldr	r3, [r7, #12]
  405bee:	b2db      	uxtb	r3, r3
}
  405bf0:	4618      	mov	r0, r3
  405bf2:	3710      	adds	r7, #16
  405bf4:	46bd      	mov	sp, r7
  405bf6:	bd80      	pop	{r7, pc}

00405bf8 <ch_set_sample_interval>:
	}

	return sample_interval;
}

uint8_t ch_set_sample_interval(ch_dev_t *dev_ptr, uint16_t sample_interval) {
  405bf8:	b580      	push	{r7, lr}
  405bfa:	b084      	sub	sp, #16
  405bfc:	af00      	add	r7, sp, #0
  405bfe:	6078      	str	r0, [r7, #4]
  405c00:	460b      	mov	r3, r1
  405c02:	807b      	strh	r3, [r7, #2]
	int	ret_val = RET_ERR;
  405c04:	2301      	movs	r3, #1
  405c06:	60fb      	str	r3, [r7, #12]
	ch_set_sample_interval_func_t func_ptr = dev_ptr->api_funcs.set_sample_interval;
  405c08:	687b      	ldr	r3, [r7, #4]
  405c0a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  405c0c:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405c0e:	68bb      	ldr	r3, [r7, #8]
  405c10:	2b00      	cmp	r3, #0
  405c12:	d006      	beq.n	405c22 <ch_set_sample_interval+0x2a>
		ret_val = (*func_ptr)(dev_ptr, sample_interval);
  405c14:	887a      	ldrh	r2, [r7, #2]
  405c16:	68bb      	ldr	r3, [r7, #8]
  405c18:	4611      	mov	r1, r2
  405c1a:	6878      	ldr	r0, [r7, #4]
  405c1c:	4798      	blx	r3
  405c1e:	4603      	mov	r3, r0
  405c20:	60fb      	str	r3, [r7, #12]
	}

	return ret_val;
  405c22:	68fb      	ldr	r3, [r7, #12]
  405c24:	b2db      	uxtb	r3, r3
}
  405c26:	4618      	mov	r0, r3
  405c28:	3710      	adds	r7, #16
  405c2a:	46bd      	mov	sp, r7
  405c2c:	bd80      	pop	{r7, pc}

00405c2e <ch_get_num_samples>:

uint16_t ch_get_num_samples(ch_dev_t *dev_ptr) {
  405c2e:	b480      	push	{r7}
  405c30:	b083      	sub	sp, #12
  405c32:	af00      	add	r7, sp, #0
  405c34:	6078      	str	r0, [r7, #4]

	return dev_ptr->num_rx_samples;
  405c36:	687b      	ldr	r3, [r7, #4]
  405c38:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
}
  405c3a:	4618      	mov	r0, r3
  405c3c:	370c      	adds	r7, #12
  405c3e:	46bd      	mov	sp, r7
  405c40:	f85d 7b04 	ldr.w	r7, [sp], #4
  405c44:	4770      	bx	lr
	...

00405c48 <ch_set_num_samples>:

uint8_t ch_set_num_samples(ch_dev_t *dev_ptr, uint16_t num_samples) {
  405c48:	b580      	push	{r7, lr}
  405c4a:	b084      	sub	sp, #16
  405c4c:	af00      	add	r7, sp, #0
  405c4e:	6078      	str	r0, [r7, #4]
  405c50:	460b      	mov	r3, r1
  405c52:	807b      	strh	r3, [r7, #2]
	uint8_t	ret_val = RET_ERR;
  405c54:	2301      	movs	r3, #1
  405c56:	73fb      	strb	r3, [r7, #15]
	ch_set_num_samples_func_t func_ptr = dev_ptr->api_funcs.set_num_samples;
  405c58:	687b      	ldr	r3, [r7, #4]
  405c5a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  405c5c:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405c5e:	68bb      	ldr	r3, [r7, #8]
  405c60:	2b00      	cmp	r3, #0
  405c62:	d006      	beq.n	405c72 <ch_set_num_samples+0x2a>
		ret_val = (*func_ptr)(dev_ptr, num_samples);
  405c64:	887a      	ldrh	r2, [r7, #2]
  405c66:	68bb      	ldr	r3, [r7, #8]
  405c68:	4611      	mov	r1, r2
  405c6a:	6878      	ldr	r0, [r7, #4]
  405c6c:	4798      	blx	r3
  405c6e:	4603      	mov	r3, r0
  405c70:	73fb      	strb	r3, [r7, #15]
	}

	dev_ptr->max_range = ch_samples_to_mm(dev_ptr, num_samples);	// store corresponding range in mm
  405c72:	887b      	ldrh	r3, [r7, #2]
  405c74:	4619      	mov	r1, r3
  405c76:	6878      	ldr	r0, [r7, #4]
  405c78:	4b05      	ldr	r3, [pc, #20]	; (405c90 <ch_set_num_samples+0x48>)
  405c7a:	4798      	blx	r3
  405c7c:	4603      	mov	r3, r0
  405c7e:	461a      	mov	r2, r3
  405c80:	687b      	ldr	r3, [r7, #4]
  405c82:	811a      	strh	r2, [r3, #8]

	return ret_val;
  405c84:	7bfb      	ldrb	r3, [r7, #15]
}
  405c86:	4618      	mov	r0, r3
  405c88:	3710      	adds	r7, #16
  405c8a:	46bd      	mov	sp, r7
  405c8c:	bd80      	pop	{r7, pc}
  405c8e:	bf00      	nop
  405c90:	00405e0d 	.word	0x00405e0d

00405c94 <ch_set_max_range>:

	return dev_ptr->max_range;
}


uint8_t ch_set_max_range(ch_dev_t *dev_ptr, uint16_t max_range) {
  405c94:	b580      	push	{r7, lr}
  405c96:	b084      	sub	sp, #16
  405c98:	af00      	add	r7, sp, #0
  405c9a:	6078      	str	r0, [r7, #4]
  405c9c:	460b      	mov	r3, r1
  405c9e:	807b      	strh	r3, [r7, #2]
	uint8_t	ret_val = RET_ERR;
  405ca0:	2301      	movs	r3, #1
  405ca2:	73fb      	strb	r3, [r7, #15]
	ch_set_max_range_func_t func_ptr = dev_ptr->api_funcs.set_max_range;
  405ca4:	687b      	ldr	r3, [r7, #4]
  405ca6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  405ca8:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405caa:	68bb      	ldr	r3, [r7, #8]
  405cac:	2b00      	cmp	r3, #0
  405cae:	d006      	beq.n	405cbe <ch_set_max_range+0x2a>
		ret_val = (*func_ptr)(dev_ptr, max_range);
  405cb0:	887a      	ldrh	r2, [r7, #2]
  405cb2:	68bb      	ldr	r3, [r7, #8]
  405cb4:	4611      	mov	r1, r2
  405cb6:	6878      	ldr	r0, [r7, #4]
  405cb8:	4798      	blx	r3
  405cba:	4603      	mov	r3, r0
  405cbc:	73fb      	strb	r3, [r7, #15]
	}

	return ret_val;
  405cbe:	7bfb      	ldrb	r3, [r7, #15]
}
  405cc0:	4618      	mov	r0, r3
  405cc2:	3710      	adds	r7, #16
  405cc4:	46bd      	mov	sp, r7
  405cc6:	bd80      	pop	{r7, pc}

00405cc8 <ch_set_static_range>:
uint16_t ch_get_static_range(ch_dev_t *dev_ptr) {

	return dev_ptr->static_range;
}

uint8_t ch_set_static_range(ch_dev_t *dev_ptr, uint16_t num_samples) {
  405cc8:	b580      	push	{r7, lr}
  405cca:	b084      	sub	sp, #16
  405ccc:	af00      	add	r7, sp, #0
  405cce:	6078      	str	r0, [r7, #4]
  405cd0:	460b      	mov	r3, r1
  405cd2:	807b      	strh	r3, [r7, #2]
	uint8_t	ret_val = RET_OK;
  405cd4:	2300      	movs	r3, #0
  405cd6:	73fb      	strb	r3, [r7, #15]
	ch_set_static_range_func_t func_ptr = dev_ptr->api_funcs.set_static_range;
  405cd8:	687b      	ldr	r3, [r7, #4]
  405cda:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
  405cde:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405ce0:	68bb      	ldr	r3, [r7, #8]
  405ce2:	2b00      	cmp	r3, #0
  405ce4:	d006      	beq.n	405cf4 <ch_set_static_range+0x2c>
		ret_val = (*func_ptr)(dev_ptr, num_samples);
  405ce6:	887a      	ldrh	r2, [r7, #2]
  405ce8:	68bb      	ldr	r3, [r7, #8]
  405cea:	4611      	mov	r1, r2
  405cec:	6878      	ldr	r0, [r7, #4]
  405cee:	4798      	blx	r3
  405cf0:	4603      	mov	r3, r0
  405cf2:	73fb      	strb	r3, [r7, #15]
	}

	return ret_val;
  405cf4:	7bfb      	ldrb	r3, [r7, #15]
}
  405cf6:	4618      	mov	r0, r3
  405cf8:	3710      	adds	r7, #16
  405cfa:	46bd      	mov	sp, r7
  405cfc:	bd80      	pop	{r7, pc}

00405cfe <ch_get_range>:

uint32_t ch_get_range(ch_dev_t *dev_ptr, ch_range_t range_type) {
  405cfe:	b580      	push	{r7, lr}
  405d00:	b084      	sub	sp, #16
  405d02:	af00      	add	r7, sp, #0
  405d04:	6078      	str	r0, [r7, #4]
  405d06:	460b      	mov	r3, r1
  405d08:	70fb      	strb	r3, [r7, #3]
	uint32_t	range = 0;
  405d0a:	2300      	movs	r3, #0
  405d0c:	60fb      	str	r3, [r7, #12]
	ch_get_range_func_t func_ptr = dev_ptr->api_funcs.get_range;
  405d0e:	687b      	ldr	r3, [r7, #4]
  405d10:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  405d12:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405d14:	68bb      	ldr	r3, [r7, #8]
  405d16:	2b00      	cmp	r3, #0
  405d18:	d005      	beq.n	405d26 <ch_get_range+0x28>
		range = (*func_ptr)(dev_ptr, range_type);
  405d1a:	78fa      	ldrb	r2, [r7, #3]
  405d1c:	68bb      	ldr	r3, [r7, #8]
  405d1e:	4611      	mov	r1, r2
  405d20:	6878      	ldr	r0, [r7, #4]
  405d22:	4798      	blx	r3
  405d24:	60f8      	str	r0, [r7, #12]
	}

	return range;
  405d26:	68fb      	ldr	r3, [r7, #12]
}
  405d28:	4618      	mov	r0, r3
  405d2a:	3710      	adds	r7, #16
  405d2c:	46bd      	mov	sp, r7
  405d2e:	bd80      	pop	{r7, pc}

00405d30 <ch_get_amplitude>:
	}

	return tof_us;
}

uint16_t ch_get_amplitude(ch_dev_t *dev_ptr) {
  405d30:	b580      	push	{r7, lr}
  405d32:	b084      	sub	sp, #16
  405d34:	af00      	add	r7, sp, #0
  405d36:	6078      	str	r0, [r7, #4]
	int	amplitude = 0;
  405d38:	2300      	movs	r3, #0
  405d3a:	60fb      	str	r3, [r7, #12]
	ch_get_amplitude_func_t func_ptr = dev_ptr->api_funcs.get_amplitude;
  405d3c:	687b      	ldr	r3, [r7, #4]
  405d3e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  405d40:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405d42:	68bb      	ldr	r3, [r7, #8]
  405d44:	2b00      	cmp	r3, #0
  405d46:	d004      	beq.n	405d52 <ch_get_amplitude+0x22>
		amplitude = (*func_ptr)(dev_ptr);
  405d48:	68bb      	ldr	r3, [r7, #8]
  405d4a:	6878      	ldr	r0, [r7, #4]
  405d4c:	4798      	blx	r3
  405d4e:	4603      	mov	r3, r0
  405d50:	60fb      	str	r3, [r7, #12]
	}

	return amplitude;
  405d52:	68fb      	ldr	r3, [r7, #12]
  405d54:	b29b      	uxth	r3, r3
}
  405d56:	4618      	mov	r0, r3
  405d58:	3710      	adds	r7, #16
  405d5a:	46bd      	mov	sp, r7
  405d5c:	bd80      	pop	{r7, pc}

00405d5e <ch_get_frequency>:
	}

	return ret_val;	
}

uint32_t ch_get_frequency(ch_dev_t *dev_ptr) {
  405d5e:	b480      	push	{r7}
  405d60:	b083      	sub	sp, #12
  405d62:	af00      	add	r7, sp, #0
  405d64:	6078      	str	r0, [r7, #4]

	return dev_ptr->op_frequency;
  405d66:	687b      	ldr	r3, [r7, #4]
  405d68:	691b      	ldr	r3, [r3, #16]
}
  405d6a:	4618      	mov	r0, r3
  405d6c:	370c      	adds	r7, #12
  405d6e:	46bd      	mov	sp, r7
  405d70:	f85d 7b04 	ldr.w	r7, [sp], #4
  405d74:	4770      	bx	lr

00405d76 <ch_get_rtc_cal_pulselength>:

uint16_t ch_get_rtc_cal_pulselength(ch_dev_t *dev_ptr) {
  405d76:	b480      	push	{r7}
  405d78:	b083      	sub	sp, #12
  405d7a:	af00      	add	r7, sp, #0
  405d7c:	6078      	str	r0, [r7, #4]

	return dev_ptr->group->rtc_cal_pulse_ms;
  405d7e:	687b      	ldr	r3, [r7, #4]
  405d80:	681b      	ldr	r3, [r3, #0]
  405d82:	88db      	ldrh	r3, [r3, #6]
}
  405d84:	4618      	mov	r0, r3
  405d86:	370c      	adds	r7, #12
  405d88:	46bd      	mov	sp, r7
  405d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  405d8e:	4770      	bx	lr

00405d90 <ch_get_rtc_cal_result>:


uint16_t ch_get_rtc_cal_result(ch_dev_t *dev_ptr) {
  405d90:	b480      	push	{r7}
  405d92:	b083      	sub	sp, #12
  405d94:	af00      	add	r7, sp, #0
  405d96:	6078      	str	r0, [r7, #4]

	return dev_ptr->rtc_cal_result;
  405d98:	687b      	ldr	r3, [r7, #4]
  405d9a:	89db      	ldrh	r3, [r3, #14]
}
  405d9c:	4618      	mov	r0, r3
  405d9e:	370c      	adds	r7, #12
  405da0:	46bd      	mov	sp, r7
  405da2:	f85d 7b04 	ldr.w	r7, [sp], #4
  405da6:	4770      	bx	lr

00405da8 <ch_get_scale_factor>:


uint16_t ch_get_scale_factor(ch_dev_t *dev_ptr) {
  405da8:	b480      	push	{r7}
  405daa:	b083      	sub	sp, #12
  405dac:	af00      	add	r7, sp, #0
  405dae:	6078      	str	r0, [r7, #4]

	return dev_ptr->scale_factor;
  405db0:	687b      	ldr	r3, [r7, #4]
  405db2:	8adb      	ldrh	r3, [r3, #22]
}
  405db4:	4618      	mov	r0, r3
  405db6:	370c      	adds	r7, #12
  405db8:	46bd      	mov	sp, r7
  405dba:	f85d 7b04 	ldr.w	r7, [sp], #4
  405dbe:	4770      	bx	lr

00405dc0 <ch_get_iq_data>:


uint8_t ch_get_iq_data(ch_dev_t *dev_ptr, ch_iq_sample_t *buf_ptr, uint16_t start_sample, uint16_t num_samples, ch_io_mode_t mode) {
  405dc0:	b590      	push	{r4, r7, lr}
  405dc2:	b089      	sub	sp, #36	; 0x24
  405dc4:	af02      	add	r7, sp, #8
  405dc6:	60f8      	str	r0, [r7, #12]
  405dc8:	60b9      	str	r1, [r7, #8]
  405dca:	4611      	mov	r1, r2
  405dcc:	461a      	mov	r2, r3
  405dce:	460b      	mov	r3, r1
  405dd0:	80fb      	strh	r3, [r7, #6]
  405dd2:	4613      	mov	r3, r2
  405dd4:	80bb      	strh	r3, [r7, #4]
	int	ret_val = RET_ERR;
  405dd6:	2301      	movs	r3, #1
  405dd8:	617b      	str	r3, [r7, #20]
	ch_get_iq_data_func_t func_ptr = dev_ptr->api_funcs.get_iq_data;
  405dda:	68fb      	ldr	r3, [r7, #12]
  405ddc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  405de0:	613b      	str	r3, [r7, #16]

	if (func_ptr != NULL) {
  405de2:	693b      	ldr	r3, [r7, #16]
  405de4:	2b00      	cmp	r3, #0
  405de6:	d00b      	beq.n	405e00 <ch_get_iq_data+0x40>
		ret_val = (*func_ptr)(dev_ptr, buf_ptr, start_sample, num_samples, mode);
  405de8:	88b9      	ldrh	r1, [r7, #4]
  405dea:	88fa      	ldrh	r2, [r7, #6]
  405dec:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  405df0:	9300      	str	r3, [sp, #0]
  405df2:	693c      	ldr	r4, [r7, #16]
  405df4:	460b      	mov	r3, r1
  405df6:	68b9      	ldr	r1, [r7, #8]
  405df8:	68f8      	ldr	r0, [r7, #12]
  405dfa:	47a0      	blx	r4
  405dfc:	4603      	mov	r3, r0
  405dfe:	617b      	str	r3, [r7, #20]
	}

	return ret_val;
  405e00:	697b      	ldr	r3, [r7, #20]
  405e02:	b2db      	uxtb	r3, r3
}
  405e04:	4618      	mov	r0, r3
  405e06:	371c      	adds	r7, #28
  405e08:	46bd      	mov	sp, r7
  405e0a:	bd90      	pop	{r4, r7, pc}

00405e0c <ch_samples_to_mm>:


uint16_t ch_samples_to_mm(ch_dev_t *dev_ptr, uint16_t num_samples) {
  405e0c:	b580      	push	{r7, lr}
  405e0e:	b084      	sub	sp, #16
  405e10:	af00      	add	r7, sp, #0
  405e12:	6078      	str	r0, [r7, #4]
  405e14:	460b      	mov	r3, r1
  405e16:	807b      	strh	r3, [r7, #2]
	int	num_mm = 0;
  405e18:	2300      	movs	r3, #0
  405e1a:	60fb      	str	r3, [r7, #12]
	ch_samples_to_mm_func_t func_ptr = dev_ptr->api_funcs.samples_to_mm;
  405e1c:	687b      	ldr	r3, [r7, #4]
  405e1e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  405e22:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405e24:	68bb      	ldr	r3, [r7, #8]
  405e26:	2b00      	cmp	r3, #0
  405e28:	d006      	beq.n	405e38 <ch_samples_to_mm+0x2c>
		num_mm = (*func_ptr)(dev_ptr, num_samples);
  405e2a:	887a      	ldrh	r2, [r7, #2]
  405e2c:	68bb      	ldr	r3, [r7, #8]
  405e2e:	4611      	mov	r1, r2
  405e30:	6878      	ldr	r0, [r7, #4]
  405e32:	4798      	blx	r3
  405e34:	4603      	mov	r3, r0
  405e36:	60fb      	str	r3, [r7, #12]
	}

	return num_mm;
  405e38:	68fb      	ldr	r3, [r7, #12]
  405e3a:	b29b      	uxth	r3, r3
}
  405e3c:	4618      	mov	r0, r3
  405e3e:	3710      	adds	r7, #16
  405e40:	46bd      	mov	sp, r7
  405e42:	bd80      	pop	{r7, pc}

00405e44 <ch_iq_to_amplitude>:
	}

	return amplitude;	
}

uint16_t ch_iq_to_amplitude(ch_iq_sample_t *iq_sample) {
  405e44:	b580      	push	{r7, lr}
  405e46:	b086      	sub	sp, #24
  405e48:	af00      	add	r7, sp, #0
  405e4a:	6078      	str	r0, [r7, #4]
	uint32_t amplitude;
	uint32_t i_sq = ((uint32_t) iq_sample->i * (uint32_t) iq_sample->i);
  405e4c:	687b      	ldr	r3, [r7, #4]
  405e4e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
  405e52:	461a      	mov	r2, r3
  405e54:	687b      	ldr	r3, [r7, #4]
  405e56:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
  405e5a:	fb03 f302 	mul.w	r3, r3, r2
  405e5e:	617b      	str	r3, [r7, #20]
	uint32_t q_sq = ((uint32_t) iq_sample->q * (uint32_t) iq_sample->q);
  405e60:	687b      	ldr	r3, [r7, #4]
  405e62:	f9b3 3000 	ldrsh.w	r3, [r3]
  405e66:	461a      	mov	r2, r3
  405e68:	687b      	ldr	r3, [r7, #4]
  405e6a:	f9b3 3000 	ldrsh.w	r3, [r3]
  405e6e:	fb03 f302 	mul.w	r3, r3, r2
  405e72:	613b      	str	r3, [r7, #16]

	amplitude = sqrt_int32(i_sq + q_sq);
  405e74:	697a      	ldr	r2, [r7, #20]
  405e76:	693b      	ldr	r3, [r7, #16]
  405e78:	4413      	add	r3, r2
  405e7a:	4618      	mov	r0, r3
  405e7c:	4b04      	ldr	r3, [pc, #16]	; (405e90 <ch_iq_to_amplitude+0x4c>)
  405e7e:	4798      	blx	r3
  405e80:	4603      	mov	r3, r0
  405e82:	60fb      	str	r3, [r7, #12]

	return (uint16_t) amplitude;
  405e84:	68fb      	ldr	r3, [r7, #12]
  405e86:	b29b      	uxth	r3, r3
}
  405e88:	4618      	mov	r0, r3
  405e8a:	3718      	adds	r7, #24
  405e8c:	46bd      	mov	sp, r7
  405e8e:	bd80      	pop	{r7, pc}
  405e90:	004086e5 	.word	0x004086e5

00405e94 <ch_set_thresholds>:


uint8_t ch_set_thresholds(ch_dev_t *dev_ptr, ch_thresholds_t *thresh_ptr) {
  405e94:	b580      	push	{r7, lr}
  405e96:	b084      	sub	sp, #16
  405e98:	af00      	add	r7, sp, #0
  405e9a:	6078      	str	r0, [r7, #4]
  405e9c:	6039      	str	r1, [r7, #0]
	int	ret_val = RET_ERR;
  405e9e:	2301      	movs	r3, #1
  405ea0:	60fb      	str	r3, [r7, #12]
	ch_set_thresholds_func_t func_ptr = dev_ptr->api_funcs.set_thresholds;
  405ea2:	687b      	ldr	r3, [r7, #4]
  405ea4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  405ea8:	60bb      	str	r3, [r7, #8]

	if ((func_ptr != NULL) && (thresh_ptr != NULL)) {
  405eaa:	68bb      	ldr	r3, [r7, #8]
  405eac:	2b00      	cmp	r3, #0
  405eae:	d008      	beq.n	405ec2 <ch_set_thresholds+0x2e>
  405eb0:	683b      	ldr	r3, [r7, #0]
  405eb2:	2b00      	cmp	r3, #0
  405eb4:	d005      	beq.n	405ec2 <ch_set_thresholds+0x2e>
		ret_val = (*func_ptr)(dev_ptr, thresh_ptr);
  405eb6:	68bb      	ldr	r3, [r7, #8]
  405eb8:	6839      	ldr	r1, [r7, #0]
  405eba:	6878      	ldr	r0, [r7, #4]
  405ebc:	4798      	blx	r3
  405ebe:	4603      	mov	r3, r0
  405ec0:	60fb      	str	r3, [r7, #12]
		}

	return ret_val;
  405ec2:	68fb      	ldr	r3, [r7, #12]
  405ec4:	b2db      	uxtb	r3, r3
}
  405ec6:	4618      	mov	r0, r3
  405ec8:	3710      	adds	r7, #16
  405eca:	46bd      	mov	sp, r7
  405ecc:	bd80      	pop	{r7, pc}

00405ece <ch_get_thresholds>:

uint8_t ch_get_thresholds(ch_dev_t *dev_ptr, ch_thresholds_t *thresh_ptr) {
  405ece:	b580      	push	{r7, lr}
  405ed0:	b084      	sub	sp, #16
  405ed2:	af00      	add	r7, sp, #0
  405ed4:	6078      	str	r0, [r7, #4]
  405ed6:	6039      	str	r1, [r7, #0]
	int	ret_val = RET_ERR;
  405ed8:	2301      	movs	r3, #1
  405eda:	60fb      	str	r3, [r7, #12]
	ch_get_thresholds_func_t func_ptr = dev_ptr->api_funcs.get_thresholds;
  405edc:	687b      	ldr	r3, [r7, #4]
  405ede:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  405ee2:	60bb      	str	r3, [r7, #8]

	if ((func_ptr != NULL) && (thresh_ptr != NULL)) {
  405ee4:	68bb      	ldr	r3, [r7, #8]
  405ee6:	2b00      	cmp	r3, #0
  405ee8:	d008      	beq.n	405efc <ch_get_thresholds+0x2e>
  405eea:	683b      	ldr	r3, [r7, #0]
  405eec:	2b00      	cmp	r3, #0
  405eee:	d005      	beq.n	405efc <ch_get_thresholds+0x2e>
		ret_val = (*func_ptr)(dev_ptr, thresh_ptr);
  405ef0:	68bb      	ldr	r3, [r7, #8]
  405ef2:	6839      	ldr	r1, [r7, #0]
  405ef4:	6878      	ldr	r0, [r7, #4]
  405ef6:	4798      	blx	r3
  405ef8:	4603      	mov	r3, r0
  405efa:	60fb      	str	r3, [r7, #12]
	}

	return ret_val;
  405efc:	68fb      	ldr	r3, [r7, #12]
  405efe:	b2db      	uxtb	r3, r3
}
  405f00:	4618      	mov	r0, r3
  405f02:	3710      	adds	r7, #16
  405f04:	46bd      	mov	sp, r7
  405f06:	bd80      	pop	{r7, pc}

00405f08 <ch_set_time_plan>:

uint8_t ch_set_time_plan(ch_dev_t *dev_ptr, ch_time_plan_t time_plan) {
  405f08:	b580      	push	{r7, lr}
  405f0a:	b084      	sub	sp, #16
  405f0c:	af00      	add	r7, sp, #0
  405f0e:	6078      	str	r0, [r7, #4]
  405f10:	460b      	mov	r3, r1
  405f12:	70fb      	strb	r3, [r7, #3]
	uint8_t ret_val = RET_ERR;
  405f14:	2301      	movs	r3, #1
  405f16:	73fb      	strb	r3, [r7, #15]
	ch_set_time_plan_func_t func_ptr = dev_ptr->api_funcs.set_time_plan;
  405f18:	687b      	ldr	r3, [r7, #4]
  405f1a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
  405f1e:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405f20:	68bb      	ldr	r3, [r7, #8]
  405f22:	2b00      	cmp	r3, #0
  405f24:	d006      	beq.n	405f34 <ch_set_time_plan+0x2c>
		ret_val = (*func_ptr)(dev_ptr, time_plan);
  405f26:	78fa      	ldrb	r2, [r7, #3]
  405f28:	68bb      	ldr	r3, [r7, #8]
  405f2a:	4611      	mov	r1, r2
  405f2c:	6878      	ldr	r0, [r7, #4]
  405f2e:	4798      	blx	r3
  405f30:	4603      	mov	r3, r0
  405f32:	73fb      	strb	r3, [r7, #15]
	}

	return ret_val;
  405f34:	7bfb      	ldrb	r3, [r7, #15]
}
  405f36:	4618      	mov	r0, r3
  405f38:	3710      	adds	r7, #16
  405f3a:	46bd      	mov	sp, r7
  405f3c:	bd80      	pop	{r7, pc}

00405f3e <ch_io_int_callback_set>:
/*!
 * \brief Set callback function for Chirp sensor I/O interrupt
 *
 * \note
 */
void ch_io_int_callback_set(ch_group_t *grp_ptr, ch_io_int_callback_t callback_func_ptr) {
  405f3e:	b480      	push	{r7}
  405f40:	b083      	sub	sp, #12
  405f42:	af00      	add	r7, sp, #0
  405f44:	6078      	str	r0, [r7, #4]
  405f46:	6039      	str	r1, [r7, #0]

	grp_ptr->io_int_callback = callback_func_ptr;
  405f48:	687b      	ldr	r3, [r7, #4]
  405f4a:	683a      	ldr	r2, [r7, #0]
  405f4c:	611a      	str	r2, [r3, #16]
}
  405f4e:	bf00      	nop
  405f50:	370c      	adds	r7, #12
  405f52:	46bd      	mov	sp, r7
  405f54:	f85d 7b04 	ldr.w	r7, [sp], #4
  405f58:	4770      	bx	lr

00405f5a <ch_io_complete_callback_set>:
/*!
 * \brief Set callback function for Chirp sensor I/O operation complete
 *
 * \note
 */
void ch_io_complete_callback_set(ch_group_t *grp_ptr, ch_io_complete_callback_t callback_func_ptr) {
  405f5a:	b480      	push	{r7}
  405f5c:	b083      	sub	sp, #12
  405f5e:	af00      	add	r7, sp, #0
  405f60:	6078      	str	r0, [r7, #4]
  405f62:	6039      	str	r1, [r7, #0]

	grp_ptr->io_complete_callback = callback_func_ptr;
  405f64:	687b      	ldr	r3, [r7, #4]
  405f66:	683a      	ldr	r2, [r7, #0]
  405f68:	615a      	str	r2, [r3, #20]
}
  405f6a:	bf00      	nop
  405f6c:	370c      	adds	r7, #12
  405f6e:	46bd      	mov	sp, r7
  405f70:	f85d 7b04 	ldr.w	r7, [sp], #4
  405f74:	4770      	bx	lr
	...

00405f78 <ch_io_notify>:
 *
 * Call this function once from your I2C interrupt handler each time it completes an I/O operation.
 * It will call the function previously specified during \a ch_io_complete_callback_set() when all group
 * transactions are complete.
 */
void ch_io_notify(ch_group_t *grp_ptr, uint8_t i2c_bus_index) {
  405f78:	b580      	push	{r7, lr}
  405f7a:	b082      	sub	sp, #8
  405f7c:	af00      	add	r7, sp, #0
  405f7e:	6078      	str	r0, [r7, #4]
  405f80:	460b      	mov	r3, r1
  405f82:	70fb      	strb	r3, [r7, #3]
	
	chdrv_group_i2c_irq_handler(grp_ptr, i2c_bus_index);
  405f84:	78fb      	ldrb	r3, [r7, #3]
  405f86:	4619      	mov	r1, r3
  405f88:	6878      	ldr	r0, [r7, #4]
  405f8a:	4b03      	ldr	r3, [pc, #12]	; (405f98 <ch_io_notify+0x20>)
  405f8c:	4798      	blx	r3
}
  405f8e:	bf00      	nop
  405f90:	3708      	adds	r7, #8
  405f92:	46bd      	mov	sp, r7
  405f94:	bd80      	pop	{r7, pc}
  405f96:	bf00      	nop
  405f98:	004075f5 	.word	0x004075f5

00405f9c <ch_set_target_interrupt>:

uint8_t ch_set_target_interrupt(ch_dev_t *dev_ptr, uint8_t enable) {
  405f9c:	b580      	push	{r7, lr}
  405f9e:	b084      	sub	sp, #16
  405fa0:	af00      	add	r7, sp, #0
  405fa2:	6078      	str	r0, [r7, #4]
  405fa4:	460b      	mov	r3, r1
  405fa6:	70fb      	strb	r3, [r7, #3]
	int	ret_val = RET_ERR;
  405fa8:	2301      	movs	r3, #1
  405faa:	60fb      	str	r3, [r7, #12]
	ch_set_target_interrupt_func_t func_ptr = dev_ptr->api_funcs.set_target_interrupt;
  405fac:	687b      	ldr	r3, [r7, #4]
  405fae:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
  405fb2:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405fb4:	68bb      	ldr	r3, [r7, #8]
  405fb6:	2b00      	cmp	r3, #0
  405fb8:	d006      	beq.n	405fc8 <ch_set_target_interrupt+0x2c>
		ret_val = (*func_ptr)(dev_ptr, enable);
  405fba:	78fa      	ldrb	r2, [r7, #3]
  405fbc:	68bb      	ldr	r3, [r7, #8]
  405fbe:	4611      	mov	r1, r2
  405fc0:	6878      	ldr	r0, [r7, #4]
  405fc2:	4798      	blx	r3
  405fc4:	4603      	mov	r3, r0
  405fc6:	60fb      	str	r3, [r7, #12]
	}

	return ret_val;
  405fc8:	68fb      	ldr	r3, [r7, #12]
  405fca:	b2db      	uxtb	r3, r3
}
  405fcc:	4618      	mov	r0, r3
  405fce:	3710      	adds	r7, #16
  405fd0:	46bd      	mov	sp, r7
  405fd2:	bd80      	pop	{r7, pc}

00405fd4 <ch_get_rx_low_gain>:
	}

	return ret_val;
}

uint16_t ch_get_rx_low_gain(ch_dev_t *dev_ptr) {
  405fd4:	b580      	push	{r7, lr}
  405fd6:	b084      	sub	sp, #16
  405fd8:	af00      	add	r7, sp, #0
  405fda:	6078      	str	r0, [r7, #4]
	uint16_t num_samples = 0;
  405fdc:	2300      	movs	r3, #0
  405fde:	81fb      	strh	r3, [r7, #14]

	ch_get_rx_low_gain_func_t func_ptr = dev_ptr->api_funcs.get_rx_low_gain;
  405fe0:	687b      	ldr	r3, [r7, #4]
  405fe2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
  405fe6:	60bb      	str	r3, [r7, #8]

	if (func_ptr != NULL) {
  405fe8:	68bb      	ldr	r3, [r7, #8]
  405fea:	2b00      	cmp	r3, #0
  405fec:	d004      	beq.n	405ff8 <ch_get_rx_low_gain+0x24>
		num_samples = (*func_ptr)(dev_ptr);
  405fee:	68bb      	ldr	r3, [r7, #8]
  405ff0:	6878      	ldr	r0, [r7, #4]
  405ff2:	4798      	blx	r3
  405ff4:	4603      	mov	r3, r0
  405ff6:	81fb      	strh	r3, [r7, #14]
	}

	return num_samples;		
  405ff8:	89fb      	ldrh	r3, [r7, #14]
}
  405ffa:	4618      	mov	r0, r3
  405ffc:	3710      	adds	r7, #16
  405ffe:	46bd      	mov	sp, r7
  406000:	bd80      	pop	{r7, pc}
	...

00406004 <ch_set_rx_pretrigger>:
	}

	return rx_pulse_length;		
}

void ch_set_rx_pretrigger(ch_group_t *grp_ptr, uint8_t enable) {
  406004:	b580      	push	{r7, lr}
  406006:	b082      	sub	sp, #8
  406008:	af00      	add	r7, sp, #0
  40600a:	6078      	str	r0, [r7, #4]
  40600c:	460b      	mov	r3, r1
  40600e:	70fb      	strb	r3, [r7, #3]

	if (enable) {
  406010:	78fb      	ldrb	r3, [r7, #3]
  406012:	2b00      	cmp	r3, #0
  406014:	d005      	beq.n	406022 <ch_set_rx_pretrigger+0x1e>
		chdrv_pretrigger_delay_set(grp_ptr, CHDRV_PRETRIGGER_DELAY_US);
  406016:	f44f 7116 	mov.w	r1, #600	; 0x258
  40601a:	6878      	ldr	r0, [r7, #4]
  40601c:	4b05      	ldr	r3, [pc, #20]	; (406034 <ch_set_rx_pretrigger+0x30>)
  40601e:	4798      	blx	r3
	} else {
		chdrv_pretrigger_delay_set(grp_ptr, 0);
	}
}
  406020:	e003      	b.n	40602a <ch_set_rx_pretrigger+0x26>
		chdrv_pretrigger_delay_set(grp_ptr, 0);
  406022:	2100      	movs	r1, #0
  406024:	6878      	ldr	r0, [r7, #4]
  406026:	4b03      	ldr	r3, [pc, #12]	; (406034 <ch_set_rx_pretrigger+0x30>)
  406028:	4798      	blx	r3
}
  40602a:	bf00      	nop
  40602c:	3708      	adds	r7, #8
  40602e:	46bd      	mov	sp, r7
  406030:	bd80      	pop	{r7, pc}
  406032:	bf00      	nop
  406034:	004085a1 	.word	0x004085a1

00406038 <ch_common_set_mode>:
static uint8_t get_sample_data(ch_dev_t *dev_ptr, ch_iq_sample_t *buf_ptr, uint16_t start_sample, uint16_t num_samples,
							   ch_io_mode_t mode, uint8_t sample_size_in_byte);

/* Functions */

uint8_t ch_common_set_mode(ch_dev_t *dev_ptr, ch_mode_t mode) {
  406038:	b580      	push	{r7, lr}
  40603a:	b084      	sub	sp, #16
  40603c:	af00      	add	r7, sp, #0
  40603e:	6078      	str	r0, [r7, #4]
  406040:	460b      	mov	r3, r1
  406042:	70fb      	strb	r3, [r7, #3]
	uint8_t ret_val = 0;
  406044:	2300      	movs	r3, #0
  406046:	73fb      	strb	r3, [r7, #15]
	uint8_t	opmode_reg;
	uint8_t	period_reg;
	uint8_t	tick_interval_reg;
	uint16_t max_tick_interval;

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406048:	687b      	ldr	r3, [r7, #4]
  40604a:	8b9b      	ldrh	r3, [r3, #28]
  40604c:	2b65      	cmp	r3, #101	; 0x65
  40604e:	d109      	bne.n	406064 <ch_common_set_mode+0x2c>
		opmode_reg = CH101_COMMON_REG_OPMODE;
  406050:	2301      	movs	r3, #1
  406052:	73bb      	strb	r3, [r7, #14]
		period_reg = CH101_COMMON_REG_PERIOD;
  406054:	2305      	movs	r3, #5
  406056:	737b      	strb	r3, [r7, #13]
		tick_interval_reg = CH101_COMMON_REG_TICK_INTERVAL;
  406058:	2302      	movs	r3, #2
  40605a:	733b      	strb	r3, [r7, #12]
		max_tick_interval = CH101_MAX_TICK_INTERVAL;
  40605c:	f44f 7380 	mov.w	r3, #256	; 0x100
  406060:	817b      	strh	r3, [r7, #10]
  406062:	e008      	b.n	406076 <ch_common_set_mode+0x3e>
	} else {
		opmode_reg = CH201_COMMON_REG_OPMODE;
  406064:	2301      	movs	r3, #1
  406066:	73bb      	strb	r3, [r7, #14]
		period_reg = CH201_COMMON_REG_PERIOD;
  406068:	2305      	movs	r3, #5
  40606a:	737b      	strb	r3, [r7, #13]
		tick_interval_reg = CH201_COMMON_REG_TICK_INTERVAL;
  40606c:	2302      	movs	r3, #2
  40606e:	733b      	strb	r3, [r7, #12]
		max_tick_interval = CH201_MAX_TICK_INTERVAL;
  406070:	f44f 7380 	mov.w	r3, #256	; 0x100
  406074:	817b      	strh	r3, [r7, #10]
	}

	if (dev_ptr->sensor_connected) {
  406076:	687b      	ldr	r3, [r7, #4]
  406078:	7fdb      	ldrb	r3, [r3, #31]
  40607a:	2b00      	cmp	r3, #0
  40607c:	d07f      	beq.n	40617e <ch_common_set_mode+0x146>
		switch (mode) {
  40607e:	78fb      	ldrb	r3, [r7, #3]
  406080:	2b20      	cmp	r3, #32
  406082:	d879      	bhi.n	406178 <ch_common_set_mode+0x140>
  406084:	a201      	add	r2, pc, #4	; (adr r2, 40608c <ch_common_set_mode+0x54>)
  406086:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40608a:	bf00      	nop
  40608c:	00406111 	.word	0x00406111
  406090:	00406179 	.word	0x00406179
  406094:	0040613d 	.word	0x0040613d
  406098:	00406179 	.word	0x00406179
  40609c:	00406179 	.word	0x00406179
  4060a0:	00406179 	.word	0x00406179
  4060a4:	00406179 	.word	0x00406179
  4060a8:	00406179 	.word	0x00406179
  4060ac:	00406179 	.word	0x00406179
  4060b0:	00406179 	.word	0x00406179
  4060b4:	00406179 	.word	0x00406179
  4060b8:	00406179 	.word	0x00406179
  4060bc:	00406179 	.word	0x00406179
  4060c0:	00406179 	.word	0x00406179
  4060c4:	00406179 	.word	0x00406179
  4060c8:	00406179 	.word	0x00406179
  4060cc:	00406159 	.word	0x00406159
  4060d0:	00406179 	.word	0x00406179
  4060d4:	00406179 	.word	0x00406179
  4060d8:	00406179 	.word	0x00406179
  4060dc:	00406179 	.word	0x00406179
  4060e0:	00406179 	.word	0x00406179
  4060e4:	00406179 	.word	0x00406179
  4060e8:	00406179 	.word	0x00406179
  4060ec:	00406179 	.word	0x00406179
  4060f0:	00406179 	.word	0x00406179
  4060f4:	00406179 	.word	0x00406179
  4060f8:	00406179 	.word	0x00406179
  4060fc:	00406179 	.word	0x00406179
  406100:	00406179 	.word	0x00406179
  406104:	00406179 	.word	0x00406179
  406108:	00406179 	.word	0x00406179
  40610c:	00406169 	.word	0x00406169
			case CH_MODE_IDLE:
				chdrv_write_byte(dev_ptr, period_reg, 0);
  406110:	7b7b      	ldrb	r3, [r7, #13]
  406112:	b29b      	uxth	r3, r3
  406114:	2200      	movs	r2, #0
  406116:	4619      	mov	r1, r3
  406118:	6878      	ldr	r0, [r7, #4]
  40611a:	4b1b      	ldr	r3, [pc, #108]	; (406188 <ch_common_set_mode+0x150>)
  40611c:	4798      	blx	r3
				chdrv_write_word(dev_ptr, tick_interval_reg, max_tick_interval);
  40611e:	7b3b      	ldrb	r3, [r7, #12]
  406120:	b29b      	uxth	r3, r3
  406122:	897a      	ldrh	r2, [r7, #10]
  406124:	4619      	mov	r1, r3
  406126:	6878      	ldr	r0, [r7, #4]
  406128:	4b18      	ldr	r3, [pc, #96]	; (40618c <ch_common_set_mode+0x154>)
  40612a:	4798      	blx	r3
				chdrv_write_byte(dev_ptr, opmode_reg, CH_MODE_IDLE);
  40612c:	7bbb      	ldrb	r3, [r7, #14]
  40612e:	b29b      	uxth	r3, r3
  406130:	2200      	movs	r2, #0
  406132:	4619      	mov	r1, r3
  406134:	6878      	ldr	r0, [r7, #4]
  406136:	4b14      	ldr	r3, [pc, #80]	; (406188 <ch_common_set_mode+0x150>)
  406138:	4798      	blx	r3
				break;
  40613a:	e020      	b.n	40617e <ch_common_set_mode+0x146>

			case CH_MODE_FREERUN:
				ch_set_sample_interval(dev_ptr, dev_ptr->sample_interval);
  40613c:	687b      	ldr	r3, [r7, #4]
  40613e:	899b      	ldrh	r3, [r3, #12]
  406140:	4619      	mov	r1, r3
  406142:	6878      	ldr	r0, [r7, #4]
  406144:	4b12      	ldr	r3, [pc, #72]	; (406190 <ch_common_set_mode+0x158>)
  406146:	4798      	blx	r3
				chdrv_write_byte(dev_ptr, opmode_reg, CH_MODE_FREERUN);
  406148:	7bbb      	ldrb	r3, [r7, #14]
  40614a:	b29b      	uxth	r3, r3
  40614c:	2202      	movs	r2, #2
  40614e:	4619      	mov	r1, r3
  406150:	6878      	ldr	r0, [r7, #4]
  406152:	4b0d      	ldr	r3, [pc, #52]	; (406188 <ch_common_set_mode+0x150>)
  406154:	4798      	blx	r3
				break;
  406156:	e012      	b.n	40617e <ch_common_set_mode+0x146>

			case CH_MODE_TRIGGERED_TX_RX:
				chdrv_write_byte(dev_ptr, opmode_reg, CH_MODE_TRIGGERED_TX_RX);
  406158:	7bbb      	ldrb	r3, [r7, #14]
  40615a:	b29b      	uxth	r3, r3
  40615c:	2210      	movs	r2, #16
  40615e:	4619      	mov	r1, r3
  406160:	6878      	ldr	r0, [r7, #4]
  406162:	4b09      	ldr	r3, [pc, #36]	; (406188 <ch_common_set_mode+0x150>)
  406164:	4798      	blx	r3
				break;
  406166:	e00a      	b.n	40617e <ch_common_set_mode+0x146>

			case CH_MODE_TRIGGERED_RX_ONLY:
				chdrv_write_byte(dev_ptr, opmode_reg, CH_MODE_TRIGGERED_RX_ONLY);
  406168:	7bbb      	ldrb	r3, [r7, #14]
  40616a:	b29b      	uxth	r3, r3
  40616c:	2220      	movs	r2, #32
  40616e:	4619      	mov	r1, r3
  406170:	6878      	ldr	r0, [r7, #4]
  406172:	4b05      	ldr	r3, [pc, #20]	; (406188 <ch_common_set_mode+0x150>)
  406174:	4798      	blx	r3
				break;
  406176:	e002      	b.n	40617e <ch_common_set_mode+0x146>

			default:
				ret_val = RET_ERR;				// return non-zero to indicate error
  406178:	2301      	movs	r3, #1
  40617a:	73fb      	strb	r3, [r7, #15]
				break;
  40617c:	bf00      	nop
		}
	}

	return ret_val;
  40617e:	7bfb      	ldrb	r3, [r7, #15]
}
  406180:	4618      	mov	r0, r3
  406182:	3710      	adds	r7, #16
  406184:	46bd      	mov	sp, r7
  406186:	bd80      	pop	{r7, pc}
  406188:	00407335 	.word	0x00407335
  40618c:	0040736d 	.word	0x0040736d
  406190:	00405bf9 	.word	0x00405bf9

00406194 <ch_common_fw_load>:

uint8_t ch_common_fw_load(ch_dev_t *dev_ptr) {
  406194:	b590      	push	{r4, r7, lr}
  406196:	b089      	sub	sp, #36	; 0x24
  406198:	af00      	add	r7, sp, #0
  40619a:	6078      	str	r0, [r7, #4]
	uint8_t	 ch_err = 0;
  40619c:	2300      	movs	r3, #0
  40619e:	77fb      	strb	r3, [r7, #31]
	uint16_t prog_mem_addr;
	uint16_t fw_size;
	uint16_t num_xfers;
	uint16_t xfer_num = 0;
  4061a0:	2300      	movs	r3, #0
  4061a2:	833b      	strh	r3, [r7, #24]
	uint16_t bytes_left = 0;
  4061a4:	2300      	movs	r3, #0
  4061a6:	82fb      	strh	r3, [r7, #22]
	uint16_t max_xfer_size;
	uint8_t *src_addr = (uint8_t *) dev_ptr->firmware;
  4061a8:	687b      	ldr	r3, [r7, #4]
  4061aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4061ac:	613b      	str	r3, [r7, #16]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  4061ae:	687b      	ldr	r3, [r7, #4]
  4061b0:	8b9b      	ldrh	r3, [r3, #28]
  4061b2:	2b65      	cmp	r3, #101	; 0x65
  4061b4:	d109      	bne.n	4061ca <ch_common_fw_load+0x36>
		prog_mem_addr = CH101_PROG_MEM_ADDR;
  4061b6:	f44f 4378 	mov.w	r3, #63488	; 0xf800
  4061ba:	83bb      	strh	r3, [r7, #28]
		fw_size = CH101_FW_SIZE;
  4061bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4061c0:	837b      	strh	r3, [r7, #26]
#if (defined(MAX_PROG_XFER_SIZE) && (MAX_PROG_XFER_SIZE < CH101_FW_SIZE))
		max_xfer_size = MAX_PROG_XFER_SIZE;		// optional user-supplied size limit
#else
		max_xfer_size = CH101_FW_SIZE;
  4061c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4061c6:	82bb      	strh	r3, [r7, #20]
  4061c8:	e008      	b.n	4061dc <ch_common_fw_load+0x48>
#endif
	} else {
		prog_mem_addr = CH201_PROG_MEM_ADDR;
  4061ca:	f44f 4378 	mov.w	r3, #63488	; 0xf800
  4061ce:	83bb      	strh	r3, [r7, #28]
		fw_size = CH201_FW_SIZE;
  4061d0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4061d4:	837b      	strh	r3, [r7, #26]
#if (defined(MAX_PROG_XFER_SIZE) && (MAX_PROG_XFER_SIZE < CH201_FW_SIZE))
		max_xfer_size = MAX_PROG_XFER_SIZE;		// optional user-supplied size limit
#else
		max_xfer_size = CH201_FW_SIZE;
  4061d6:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4061da:	82bb      	strh	r3, [r7, #20]
#endif
	}

	bytes_left = fw_size;
  4061dc:	8b7b      	ldrh	r3, [r7, #26]
  4061de:	82fb      	strh	r3, [r7, #22]
	num_xfers = (fw_size + (max_xfer_size - 1)) / max_xfer_size;
  4061e0:	8b7a      	ldrh	r2, [r7, #26]
  4061e2:	8abb      	ldrh	r3, [r7, #20]
  4061e4:	3b01      	subs	r3, #1
  4061e6:	441a      	add	r2, r3
  4061e8:	8abb      	ldrh	r3, [r7, #20]
  4061ea:	fb92 f3f3 	sdiv	r3, r2, r3
  4061ee:	81bb      	strh	r3, [r7, #12]

	while (!ch_err && (xfer_num < num_xfers)) {
  4061f0:	e01f      	b.n	406232 <ch_common_fw_load+0x9e>
		uint16_t xfer_nbytes;			// number of bytes in this transfer

		if (bytes_left >= max_xfer_size) {
  4061f2:	8afa      	ldrh	r2, [r7, #22]
  4061f4:	8abb      	ldrh	r3, [r7, #20]
  4061f6:	429a      	cmp	r2, r3
  4061f8:	d302      	bcc.n	406200 <ch_common_fw_load+0x6c>
			xfer_nbytes = max_xfer_size;
  4061fa:	8abb      	ldrh	r3, [r7, #20]
  4061fc:	81fb      	strh	r3, [r7, #14]
  4061fe:	e001      	b.n	406204 <ch_common_fw_load+0x70>
		} else {
			xfer_nbytes = bytes_left;
  406200:	8afb      	ldrh	r3, [r7, #22]
  406202:	81fb      	strh	r3, [r7, #14]
		}

		ch_err = chdrv_prog_mem_write(dev_ptr, prog_mem_addr, src_addr, xfer_nbytes);
  406204:	89fb      	ldrh	r3, [r7, #14]
  406206:	8bb9      	ldrh	r1, [r7, #28]
  406208:	693a      	ldr	r2, [r7, #16]
  40620a:	6878      	ldr	r0, [r7, #4]
  40620c:	4c0f      	ldr	r4, [pc, #60]	; (40624c <ch_common_fw_load+0xb8>)
  40620e:	47a0      	blx	r4
  406210:	4603      	mov	r3, r0
  406212:	77fb      	strb	r3, [r7, #31]

		src_addr += xfer_nbytes;		// adjust source and destination addrs
  406214:	89fb      	ldrh	r3, [r7, #14]
  406216:	693a      	ldr	r2, [r7, #16]
  406218:	4413      	add	r3, r2
  40621a:	613b      	str	r3, [r7, #16]
		prog_mem_addr += xfer_nbytes;
  40621c:	8bba      	ldrh	r2, [r7, #28]
  40621e:	89fb      	ldrh	r3, [r7, #14]
  406220:	4413      	add	r3, r2
  406222:	83bb      	strh	r3, [r7, #28]

		bytes_left -= xfer_nbytes;		// adjust remaining byte count
  406224:	8afa      	ldrh	r2, [r7, #22]
  406226:	89fb      	ldrh	r3, [r7, #14]
  406228:	1ad3      	subs	r3, r2, r3
  40622a:	82fb      	strh	r3, [r7, #22]
		xfer_num++;
  40622c:	8b3b      	ldrh	r3, [r7, #24]
  40622e:	3301      	adds	r3, #1
  406230:	833b      	strh	r3, [r7, #24]
	while (!ch_err && (xfer_num < num_xfers)) {
  406232:	7ffb      	ldrb	r3, [r7, #31]
  406234:	2b00      	cmp	r3, #0
  406236:	d103      	bne.n	406240 <ch_common_fw_load+0xac>
  406238:	8b3a      	ldrh	r2, [r7, #24]
  40623a:	89bb      	ldrh	r3, [r7, #12]
  40623c:	429a      	cmp	r2, r3
  40623e:	d3d8      	bcc.n	4061f2 <ch_common_fw_load+0x5e>
	}

	return ch_err;
  406240:	7ffb      	ldrb	r3, [r7, #31]
}
  406242:	4618      	mov	r0, r3
  406244:	3724      	adds	r7, #36	; 0x24
  406246:	46bd      	mov	sp, r7
  406248:	bd90      	pop	{r4, r7, pc}
  40624a:	bf00      	nop
  40624c:	00407b05 	.word	0x00407b05

00406250 <ch_common_set_sample_interval>:


#define	MAX_PERIOD_VALUE	16		// XXX limit adjustment to interval vs. period

uint8_t ch_common_set_sample_interval(ch_dev_t *dev_ptr, uint16_t interval_ms) {
  406250:	b590      	push	{r4, r7, lr}
  406252:	b09f      	sub	sp, #124	; 0x7c
  406254:	af02      	add	r7, sp, #8
  406256:	6078      	str	r0, [r7, #4]
  406258:	460b      	mov	r3, r1
  40625a:	807b      	strh	r3, [r7, #2]
	uint8_t	period_reg;
	uint8_t	tick_interval_reg;
	uint16_t max_tick_interval;
	uint8_t ret_val = 0;
  40625c:	2300      	movs	r3, #0
  40625e:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406262:	687b      	ldr	r3, [r7, #4]
  406264:	8b9b      	ldrh	r3, [r3, #28]
  406266:	2b65      	cmp	r3, #101	; 0x65
  406268:	d10a      	bne.n	406280 <ch_common_set_sample_interval+0x30>
		period_reg 		  = CH101_COMMON_REG_PERIOD;
  40626a:	2305      	movs	r3, #5
  40626c:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
		tick_interval_reg = CH101_COMMON_REG_TICK_INTERVAL;
  406270:	2302      	movs	r3, #2
  406272:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
		max_tick_interval = CH101_MAX_TICK_INTERVAL;
  406276:	f44f 7380 	mov.w	r3, #256	; 0x100
  40627a:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
  40627e:	e009      	b.n	406294 <ch_common_set_sample_interval+0x44>
	} else {
		period_reg 		  = CH201_COMMON_REG_PERIOD;
  406280:	2305      	movs	r3, #5
  406282:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
		tick_interval_reg = CH201_COMMON_REG_TICK_INTERVAL;
  406286:	2302      	movs	r3, #2
  406288:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
		max_tick_interval = CH201_MAX_TICK_INTERVAL;
  40628c:	f44f 7380 	mov.w	r3, #256	; 0x100
  406290:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
	}

	if (dev_ptr->sensor_connected) {
  406294:	687b      	ldr	r3, [r7, #4]
  406296:	7fdb      	ldrb	r3, [r3, #31]
  406298:	2b00      	cmp	r3, #0
  40629a:	d05e      	beq.n	40635a <ch_common_set_sample_interval+0x10a>
		uint32_t sample_interval = dev_ptr->rtc_cal_result * interval_ms / dev_ptr->group->rtc_cal_pulse_ms;
  40629c:	687b      	ldr	r3, [r7, #4]
  40629e:	89db      	ldrh	r3, [r3, #14]
  4062a0:	461a      	mov	r2, r3
  4062a2:	887b      	ldrh	r3, [r7, #2]
  4062a4:	fb03 f302 	mul.w	r3, r3, r2
  4062a8:	687a      	ldr	r2, [r7, #4]
  4062aa:	6812      	ldr	r2, [r2, #0]
  4062ac:	88d2      	ldrh	r2, [r2, #6]
  4062ae:	fb93 f3f2 	sdiv	r3, r3, r2
  4062b2:	65fb      	str	r3, [r7, #92]	; 0x5c
		uint32_t period;

		if (interval_ms != 0) {
  4062b4:	887b      	ldrh	r3, [r7, #2]
  4062b6:	2b00      	cmp	r3, #0
  4062b8:	d00a      	beq.n	4062d0 <ch_common_set_sample_interval+0x80>
			period = (sample_interval / 2048) + 1;				// XXX need define
  4062ba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  4062bc:	0adb      	lsrs	r3, r3, #11
  4062be:	3301      	adds	r3, #1
  4062c0:	667b      	str	r3, [r7, #100]	; 0x64
			if (period > UINT8_MAX) {					/* check if result fits in register */
  4062c2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4062c4:	2bff      	cmp	r3, #255	; 0xff
  4062c6:	d906      	bls.n	4062d6 <ch_common_set_sample_interval+0x86>
				ret_val = 1;
  4062c8:	2301      	movs	r3, #1
  4062ca:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
  4062ce:	e002      	b.n	4062d6 <ch_common_set_sample_interval+0x86>
			}
		} else {
			ret_val = 1;						// interval cannot be zero
  4062d0:	2301      	movs	r3, #1
  4062d2:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
		}

		if (ret_val == 0) {
  4062d6:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
  4062da:	2b00      	cmp	r3, #0
  4062dc:	d13d      	bne.n	40635a <ch_common_set_sample_interval+0x10a>
			uint32_t tick_interval;

			if (period != 0) {
  4062de:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4062e0:	2b00      	cmp	r3, #0
  4062e2:	d014      	beq.n	40630e <ch_common_set_sample_interval+0xbe>
				tick_interval = sample_interval / period;
  4062e4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  4062e6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4062e8:	fbb2 f3f3 	udiv	r3, r2, r3
  4062ec:	663b      	str	r3, [r7, #96]	; 0x60
				
				while ((tick_interval > max_tick_interval) && (period < MAX_PERIOD_VALUE)) {  // enforce max interval
  4062ee:	e005      	b.n	4062fc <ch_common_set_sample_interval+0xac>
					tick_interval >>= 1;
  4062f0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  4062f2:	085b      	lsrs	r3, r3, #1
  4062f4:	663b      	str	r3, [r7, #96]	; 0x60
					period <<= 1;
  4062f6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4062f8:	005b      	lsls	r3, r3, #1
  4062fa:	667b      	str	r3, [r7, #100]	; 0x64
				while ((tick_interval > max_tick_interval) && (period < MAX_PERIOD_VALUE)) {  // enforce max interval
  4062fc:	f8b7 206c 	ldrh.w	r2, [r7, #108]	; 0x6c
  406300:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  406302:	429a      	cmp	r2, r3
  406304:	d206      	bcs.n	406314 <ch_common_set_sample_interval+0xc4>
  406306:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406308:	2b0f      	cmp	r3, #15
  40630a:	d9f1      	bls.n	4062f0 <ch_common_set_sample_interval+0xa0>
  40630c:	e002      	b.n	406314 <ch_common_set_sample_interval+0xc4>
				}
			} else {
				tick_interval = max_tick_interval;
  40630e:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
  406312:	663b      	str	r3, [r7, #96]	; 0x60
			}

#ifdef CHDRV_DEBUG
			char cbuf[80];
			snprintf(cbuf, sizeof(cbuf), "Set period=%lu, tick_interval=%lu\n", period, tick_interval);
  406314:	f107 000c 	add.w	r0, r7, #12
  406318:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  40631a:	9300      	str	r3, [sp, #0]
  40631c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40631e:	4a12      	ldr	r2, [pc, #72]	; (406368 <ch_common_set_sample_interval+0x118>)
  406320:	2150      	movs	r1, #80	; 0x50
  406322:	4c12      	ldr	r4, [pc, #72]	; (40636c <ch_common_set_sample_interval+0x11c>)
  406324:	47a0      	blx	r4
			chbsp_print_str(cbuf);
  406326:	f107 030c 	add.w	r3, r7, #12
  40632a:	4618      	mov	r0, r3
  40632c:	4b10      	ldr	r3, [pc, #64]	; (406370 <ch_common_set_sample_interval+0x120>)
  40632e:	4798      	blx	r3
#endif
			chdrv_write_byte(dev_ptr, period_reg, (uint8_t) period);
  406330:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  406334:	b29b      	uxth	r3, r3
  406336:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  406338:	b2d2      	uxtb	r2, r2
  40633a:	4619      	mov	r1, r3
  40633c:	6878      	ldr	r0, [r7, #4]
  40633e:	4b0d      	ldr	r3, [pc, #52]	; (406374 <ch_common_set_sample_interval+0x124>)
  406340:	4798      	blx	r3
			chdrv_write_word(dev_ptr, tick_interval_reg, (uint16_t) tick_interval);
  406342:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
  406346:	b29b      	uxth	r3, r3
  406348:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  40634a:	b292      	uxth	r2, r2
  40634c:	4619      	mov	r1, r3
  40634e:	6878      	ldr	r0, [r7, #4]
  406350:	4b09      	ldr	r3, [pc, #36]	; (406378 <ch_common_set_sample_interval+0x128>)
  406352:	4798      	blx	r3

			dev_ptr->sample_interval = interval_ms;
  406354:	687b      	ldr	r3, [r7, #4]
  406356:	887a      	ldrh	r2, [r7, #2]
  406358:	819a      	strh	r2, [r3, #12]
		}
	}

	return ret_val;
  40635a:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
}
  40635e:	4618      	mov	r0, r3
  406360:	3774      	adds	r7, #116	; 0x74
  406362:	46bd      	mov	sp, r7
  406364:	bd90      	pop	{r4, r7, pc}
  406366:	bf00      	nop
  406368:	0040db88 	.word	0x0040db88
  40636c:	0040a085 	.word	0x0040a085
  406370:	00402fa9 	.word	0x00402fa9
  406374:	00407335 	.word	0x00407335
  406378:	0040736d 	.word	0x0040736d

0040637c <ch_common_set_num_samples>:

// Note: uses actual num_samples, even for CH201
uint8_t ch_common_set_num_samples(ch_dev_t *dev_ptr, uint16_t num_samples ) {
  40637c:	b580      	push	{r7, lr}
  40637e:	b084      	sub	sp, #16
  406380:	af00      	add	r7, sp, #0
  406382:	6078      	str	r0, [r7, #4]
  406384:	460b      	mov	r3, r1
  406386:	807b      	strh	r3, [r7, #2]
	uint8_t max_range_reg;
	uint8_t ret_val = 1;		// default is error (not connected or num_samples too big)
  406388:	2301      	movs	r3, #1
  40638a:	73bb      	strb	r3, [r7, #14]
	uint16_t num_rx_low_gain_samples = ch_get_rx_low_gain(dev_ptr);		// zero if unsupported
  40638c:	6878      	ldr	r0, [r7, #4]
  40638e:	4b22      	ldr	r3, [pc, #136]	; (406418 <ch_common_set_num_samples+0x9c>)
  406390:	4798      	blx	r3
  406392:	4603      	mov	r3, r0
  406394:	81bb      	strh	r3, [r7, #12]


	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406396:	687b      	ldr	r3, [r7, #4]
  406398:	8b9b      	ldrh	r3, [r3, #28]
  40639a:	2b65      	cmp	r3, #101	; 0x65
  40639c:	d102      	bne.n	4063a4 <ch_common_set_num_samples+0x28>
		max_range_reg = CH101_COMMON_REG_MAX_RANGE;
  40639e:	2307      	movs	r3, #7
  4063a0:	73fb      	strb	r3, [r7, #15]
  4063a2:	e007      	b.n	4063b4 <ch_common_set_num_samples+0x38>
	} else {
		max_range_reg = CH201_COMMON_REG_MAX_RANGE;
  4063a4:	2307      	movs	r3, #7
  4063a6:	73fb      	strb	r3, [r7, #15]
		num_samples /= 2;					// each internal count for CH201 represents 2 physical samples
  4063a8:	887b      	ldrh	r3, [r7, #2]
  4063aa:	085b      	lsrs	r3, r3, #1
  4063ac:	807b      	strh	r3, [r7, #2]
		num_rx_low_gain_samples /= 2;
  4063ae:	89bb      	ldrh	r3, [r7, #12]
  4063b0:	085b      	lsrs	r3, r3, #1
  4063b2:	81bb      	strh	r3, [r7, #12]
	}

	if (num_samples < (num_rx_low_gain_samples + 1)) {
  4063b4:	887a      	ldrh	r2, [r7, #2]
  4063b6:	89bb      	ldrh	r3, [r7, #12]
  4063b8:	3301      	adds	r3, #1
  4063ba:	429a      	cmp	r2, r3
  4063bc:	da02      	bge.n	4063c4 <ch_common_set_num_samples+0x48>
		num_samples = (num_rx_low_gain_samples + 1);
  4063be:	89bb      	ldrh	r3, [r7, #12]
  4063c0:	3301      	adds	r3, #1
  4063c2:	807b      	strh	r3, [r7, #2]
	}

	if (dev_ptr->sensor_connected && (num_samples <= UINT8_MAX)) {
  4063c4:	687b      	ldr	r3, [r7, #4]
  4063c6:	7fdb      	ldrb	r3, [r3, #31]
  4063c8:	2b00      	cmp	r3, #0
  4063ca:	d00c      	beq.n	4063e6 <ch_common_set_num_samples+0x6a>
  4063cc:	887b      	ldrh	r3, [r7, #2]
  4063ce:	2bff      	cmp	r3, #255	; 0xff
  4063d0:	d809      	bhi.n	4063e6 <ch_common_set_num_samples+0x6a>
		ret_val = chdrv_write_byte(dev_ptr, max_range_reg, num_samples);
  4063d2:	7bfb      	ldrb	r3, [r7, #15]
  4063d4:	b29b      	uxth	r3, r3
  4063d6:	887a      	ldrh	r2, [r7, #2]
  4063d8:	b2d2      	uxtb	r2, r2
  4063da:	4619      	mov	r1, r3
  4063dc:	6878      	ldr	r0, [r7, #4]
  4063de:	4b0f      	ldr	r3, [pc, #60]	; (40641c <ch_common_set_num_samples+0xa0>)
  4063e0:	4798      	blx	r3
  4063e2:	4603      	mov	r3, r0
  4063e4:	73bb      	strb	r3, [r7, #14]
	}

	if (!ret_val) {
  4063e6:	7bbb      	ldrb	r3, [r7, #14]
  4063e8:	2b00      	cmp	r3, #0
  4063ea:	d10d      	bne.n	406408 <ch_common_set_num_samples+0x8c>
		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  4063ec:	687b      	ldr	r3, [r7, #4]
  4063ee:	8b9b      	ldrh	r3, [r3, #28]
  4063f0:	2b65      	cmp	r3, #101	; 0x65
  4063f2:	d103      	bne.n	4063fc <ch_common_set_num_samples+0x80>
			dev_ptr->num_rx_samples = num_samples;
  4063f4:	687b      	ldr	r3, [r7, #4]
  4063f6:	887a      	ldrh	r2, [r7, #2]
  4063f8:	849a      	strh	r2, [r3, #36]	; 0x24
  4063fa:	e008      	b.n	40640e <ch_common_set_num_samples+0x92>
		} else {
			dev_ptr->num_rx_samples = (num_samples * 2);	// store actual physical sample count
  4063fc:	887b      	ldrh	r3, [r7, #2]
  4063fe:	005b      	lsls	r3, r3, #1
  406400:	b29a      	uxth	r2, r3
  406402:	687b      	ldr	r3, [r7, #4]
  406404:	849a      	strh	r2, [r3, #36]	; 0x24
  406406:	e002      	b.n	40640e <ch_common_set_num_samples+0x92>
		}
	} else {
		dev_ptr->num_rx_samples = 0;
  406408:	687b      	ldr	r3, [r7, #4]
  40640a:	2200      	movs	r2, #0
  40640c:	849a      	strh	r2, [r3, #36]	; 0x24
	}
	
	return ret_val;
  40640e:	7bbb      	ldrb	r3, [r7, #14]
}
  406410:	4618      	mov	r0, r3
  406412:	3710      	adds	r7, #16
  406414:	46bd      	mov	sp, r7
  406416:	bd80      	pop	{r7, pc}
  406418:	00405fd5 	.word	0x00405fd5
  40641c:	00407335 	.word	0x00407335

00406420 <ch_common_set_max_range>:


uint8_t ch_common_set_max_range(ch_dev_t *dev_ptr, uint16_t max_range_mm) {
  406420:	b590      	push	{r4, r7, lr}
  406422:	b099      	sub	sp, #100	; 0x64
  406424:	af00      	add	r7, sp, #0
  406426:	6078      	str	r0, [r7, #4]
  406428:	460b      	mov	r3, r1
  40642a:	807b      	strh	r3, [r7, #2]
	uint8_t ret_val;
	uint32_t num_samples;

	ret_val = (!dev_ptr->sensor_connected);
  40642c:	687b      	ldr	r3, [r7, #4]
  40642e:	7fdb      	ldrb	r3, [r3, #31]
  406430:	2b00      	cmp	r3, #0
  406432:	bf0c      	ite	eq
  406434:	2301      	moveq	r3, #1
  406436:	2300      	movne	r3, #0
  406438:	b2db      	uxtb	r3, r3
  40643a:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f

	if (!ret_val) {
  40643e:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
  406442:	2b00      	cmp	r3, #0
  406444:	d12b      	bne.n	40649e <ch_common_set_max_range+0x7e>
		num_samples = dev_ptr->api_funcs.mm_to_samples(dev_ptr, max_range_mm);
  406446:	687b      	ldr	r3, [r7, #4]
  406448:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
  40644c:	887a      	ldrh	r2, [r7, #2]
  40644e:	4611      	mov	r1, r2
  406450:	6878      	ldr	r0, [r7, #4]
  406452:	4798      	blx	r3
  406454:	4603      	mov	r3, r0
  406456:	65bb      	str	r3, [r7, #88]	; 0x58

		if (num_samples > dev_ptr->max_samples) {
  406458:	687b      	ldr	r3, [r7, #4]
  40645a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  40645c:	461a      	mov	r2, r3
  40645e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  406460:	429a      	cmp	r2, r3
  406462:	d20d      	bcs.n	406480 <ch_common_set_max_range+0x60>
			num_samples = dev_ptr->max_samples;
  406464:	687b      	ldr	r3, [r7, #4]
  406466:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  406468:	65bb      	str	r3, [r7, #88]	; 0x58
			dev_ptr->max_range = ch_samples_to_mm(dev_ptr, num_samples);	// store reduced max range
  40646a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40646c:	b29b      	uxth	r3, r3
  40646e:	4619      	mov	r1, r3
  406470:	6878      	ldr	r0, [r7, #4]
  406472:	4b18      	ldr	r3, [pc, #96]	; (4064d4 <ch_common_set_max_range+0xb4>)
  406474:	4798      	blx	r3
  406476:	4603      	mov	r3, r0
  406478:	461a      	mov	r2, r3
  40647a:	687b      	ldr	r3, [r7, #4]
  40647c:	811a      	strh	r2, [r3, #8]
  40647e:	e002      	b.n	406486 <ch_common_set_max_range+0x66>
		} else {
			dev_ptr->max_range = max_range_mm;							// store user-specified max range
  406480:	687b      	ldr	r3, [r7, #4]
  406482:	887a      	ldrh	r2, [r7, #2]
  406484:	811a      	strh	r2, [r3, #8]
		}


#ifdef CHDRV_DEBUG
		char cbuf[80];
		snprintf(cbuf, sizeof(cbuf), "num_samples=%lu\n", num_samples);
  406486:	f107 0008 	add.w	r0, r7, #8
  40648a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  40648c:	4a12      	ldr	r2, [pc, #72]	; (4064d8 <ch_common_set_max_range+0xb8>)
  40648e:	2150      	movs	r1, #80	; 0x50
  406490:	4c12      	ldr	r4, [pc, #72]	; (4064dc <ch_common_set_max_range+0xbc>)
  406492:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  406494:	f107 0308 	add.w	r3, r7, #8
  406498:	4618      	mov	r0, r3
  40649a:	4b11      	ldr	r3, [pc, #68]	; (4064e0 <ch_common_set_max_range+0xc0>)
  40649c:	4798      	blx	r3
#endif
	}


	if (!ret_val) {
  40649e:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
  4064a2:	2b00      	cmp	r3, #0
  4064a4:	d108      	bne.n	4064b8 <ch_common_set_max_range+0x98>
		ret_val = ch_set_num_samples(dev_ptr, num_samples);
  4064a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  4064a8:	b29b      	uxth	r3, r3
  4064aa:	4619      	mov	r1, r3
  4064ac:	6878      	ldr	r0, [r7, #4]
  4064ae:	4b0d      	ldr	r3, [pc, #52]	; (4064e4 <ch_common_set_max_range+0xc4>)
  4064b0:	4798      	blx	r3
  4064b2:	4603      	mov	r3, r0
  4064b4:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
	}

#ifdef CHDRV_DEBUG
	printf("Set samples: ret_val: %u  dev_ptr->num_rx_samples: %u\n", ret_val, dev_ptr->num_rx_samples);
  4064b8:	f897 105f 	ldrb.w	r1, [r7, #95]	; 0x5f
  4064bc:	687b      	ldr	r3, [r7, #4]
  4064be:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  4064c0:	461a      	mov	r2, r3
  4064c2:	4809      	ldr	r0, [pc, #36]	; (4064e8 <ch_common_set_max_range+0xc8>)
  4064c4:	4b09      	ldr	r3, [pc, #36]	; (4064ec <ch_common_set_max_range+0xcc>)
  4064c6:	4798      	blx	r3
#endif
	return ret_val;
  4064c8:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
}
  4064cc:	4618      	mov	r0, r3
  4064ce:	3764      	adds	r7, #100	; 0x64
  4064d0:	46bd      	mov	sp, r7
  4064d2:	bd90      	pop	{r4, r7, pc}
  4064d4:	00405e0d 	.word	0x00405e0d
  4064d8:	0040dbac 	.word	0x0040dbac
  4064dc:	0040a085 	.word	0x0040a085
  4064e0:	00402fa9 	.word	0x00402fa9
  4064e4:	00405c49 	.word	0x00405c49
  4064e8:	0040dbc0 	.word	0x0040dbc0
  4064ec:	00409ee9 	.word	0x00409ee9

004064f0 <ch_common_mm_to_samples>:


uint16_t ch_common_mm_to_samples(ch_dev_t *dev_ptr, uint16_t num_mm) {
  4064f0:	b580      	push	{r7, lr}
  4064f2:	b086      	sub	sp, #24
  4064f4:	af00      	add	r7, sp, #0
  4064f6:	6078      	str	r0, [r7, #4]
  4064f8:	460b      	mov	r3, r1
  4064fa:	807b      	strh	r3, [r7, #2]
	uint8_t err;
	uint16_t scale_factor;
	uint32_t num_samples = 0;
  4064fc:	2300      	movs	r3, #0
  4064fe:	613b      	str	r3, [r7, #16]
	uint32_t divisor1;
	uint32_t divisor2 = (dev_ptr->group->rtc_cal_pulse_ms * CH_SPEEDOFSOUND_MPS);
  406500:	687b      	ldr	r3, [r7, #4]
  406502:	681b      	ldr	r3, [r3, #0]
  406504:	88db      	ldrh	r3, [r3, #6]
  406506:	461a      	mov	r2, r3
  406508:	f240 1357 	movw	r3, #343	; 0x157
  40650c:	fb03 f302 	mul.w	r3, r3, r2
  406510:	60bb      	str	r3, [r7, #8]

	err = (!dev_ptr) || (!dev_ptr->sensor_connected);
  406512:	687b      	ldr	r3, [r7, #4]
  406514:	2b00      	cmp	r3, #0
  406516:	d003      	beq.n	406520 <ch_common_mm_to_samples+0x30>
  406518:	687b      	ldr	r3, [r7, #4]
  40651a:	7fdb      	ldrb	r3, [r3, #31]
  40651c:	2b00      	cmp	r3, #0
  40651e:	d101      	bne.n	406524 <ch_common_mm_to_samples+0x34>
  406520:	2301      	movs	r3, #1
  406522:	e000      	b.n	406526 <ch_common_mm_to_samples+0x36>
  406524:	2300      	movs	r3, #0
  406526:	75fb      	strb	r3, [r7, #23]

	if (!err) {
  406528:	7dfb      	ldrb	r3, [r7, #23]
  40652a:	2b00      	cmp	r3, #0
  40652c:	d114      	bne.n	406558 <ch_common_mm_to_samples+0x68>
		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  40652e:	687b      	ldr	r3, [r7, #4]
  406530:	8b9b      	ldrh	r3, [r3, #28]
  406532:	2b65      	cmp	r3, #101	; 0x65
  406534:	d103      	bne.n	40653e <ch_common_mm_to_samples+0x4e>
			divisor1 = 0x2000;			// (4*16*128)  XXX need define(s)
  406536:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  40653a:	60fb      	str	r3, [r7, #12]
  40653c:	e002      	b.n	406544 <ch_common_mm_to_samples+0x54>
		} else {
			divisor1 = 0x4000;			// (4*16*128*2)  XXX need define(s)
  40653e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  406542:	60fb      	str	r3, [r7, #12]
		}

		if (dev_ptr->scale_factor == 0) {
  406544:	687b      	ldr	r3, [r7, #4]
  406546:	8adb      	ldrh	r3, [r3, #22]
  406548:	2b00      	cmp	r3, #0
  40654a:	d102      	bne.n	406552 <ch_common_mm_to_samples+0x62>
			ch_common_store_scale_factor(dev_ptr);
  40654c:	6878      	ldr	r0, [r7, #4]
  40654e:	4b22      	ldr	r3, [pc, #136]	; (4065d8 <ch_common_mm_to_samples+0xe8>)
  406550:	4798      	blx	r3
		}

		scale_factor = dev_ptr->scale_factor;
  406552:	687b      	ldr	r3, [r7, #4]
  406554:	8adb      	ldrh	r3, [r3, #22]
  406556:	82bb      	strh	r3, [r7, #20]
	}

	if (!err) {
  406558:	7dfb      	ldrb	r3, [r7, #23]
  40655a:	2b00      	cmp	r3, #0
  40655c:	d126      	bne.n	4065ac <ch_common_mm_to_samples+0xbc>
		// Two steps of division to avoid needing a type larger than 32 bits
		// Ceiling division to ensure result is at least enough samples to meet specified range
		// Oversample value is signed power of two for this firmware relative to standard f/8 sampling.

		num_samples = ((dev_ptr->rtc_cal_result * scale_factor) + (divisor1 - 1)) / divisor1;
  40655e:	687b      	ldr	r3, [r7, #4]
  406560:	89db      	ldrh	r3, [r3, #14]
  406562:	461a      	mov	r2, r3
  406564:	8abb      	ldrh	r3, [r7, #20]
  406566:	fb03 f302 	mul.w	r3, r3, r2
  40656a:	461a      	mov	r2, r3
  40656c:	68fb      	ldr	r3, [r7, #12]
  40656e:	4413      	add	r3, r2
  406570:	1e5a      	subs	r2, r3, #1
  406572:	68fb      	ldr	r3, [r7, #12]
  406574:	fbb2 f3f3 	udiv	r3, r2, r3
  406578:	613b      	str	r3, [r7, #16]

		num_samples = (((num_samples * num_mm) << dev_ptr->oversample) + (divisor2 - 1)) / divisor2;
  40657a:	887b      	ldrh	r3, [r7, #2]
  40657c:	693a      	ldr	r2, [r7, #16]
  40657e:	fb02 f303 	mul.w	r3, r2, r3
  406582:	687a      	ldr	r2, [r7, #4]
  406584:	f992 201e 	ldrsb.w	r2, [r2, #30]
  406588:	fa03 f202 	lsl.w	r2, r3, r2
  40658c:	68bb      	ldr	r3, [r7, #8]
  40658e:	4413      	add	r3, r2
  406590:	1e5a      	subs	r2, r3, #1
  406592:	68bb      	ldr	r3, [r7, #8]
  406594:	fbb2 f3f3 	udiv	r3, r2, r3
  406598:	613b      	str	r3, [r7, #16]

		err = (num_samples > UINT16_MAX);
  40659a:	693b      	ldr	r3, [r7, #16]
  40659c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4065a0:	4293      	cmp	r3, r2
  4065a2:	bf8c      	ite	hi
  4065a4:	2301      	movhi	r3, #1
  4065a6:	2300      	movls	r3, #0
  4065a8:	b2db      	uxtb	r3, r3
  4065aa:	75fb      	strb	r3, [r7, #23]
	}

	if (!err) {
  4065ac:	7dfb      	ldrb	r3, [r7, #23]
  4065ae:	2b00      	cmp	r3, #0
  4065b0:	d106      	bne.n	4065c0 <ch_common_mm_to_samples+0xd0>
		if (dev_ptr->part_number == CH201_PART_NUMBER) {
  4065b2:	687b      	ldr	r3, [r7, #4]
  4065b4:	8b9b      	ldrh	r3, [r3, #28]
  4065b6:	2bc9      	cmp	r3, #201	; 0xc9
  4065b8:	d102      	bne.n	4065c0 <ch_common_mm_to_samples+0xd0>
			num_samples *= 2;			// each internal count for CH201 represents 2 physical samples
  4065ba:	693b      	ldr	r3, [r7, #16]
  4065bc:	005b      	lsls	r3, r3, #1
  4065be:	613b      	str	r3, [r7, #16]
		}
	}

	if (err) {
  4065c0:	7dfb      	ldrb	r3, [r7, #23]
  4065c2:	2b00      	cmp	r3, #0
  4065c4:	d001      	beq.n	4065ca <ch_common_mm_to_samples+0xda>
		num_samples = 0;		// return zero if error
  4065c6:	2300      	movs	r3, #0
  4065c8:	613b      	str	r3, [r7, #16]
	}

	return (uint16_t) num_samples;
  4065ca:	693b      	ldr	r3, [r7, #16]
  4065cc:	b29b      	uxth	r3, r3
}
  4065ce:	4618      	mov	r0, r3
  4065d0:	3718      	adds	r7, #24
  4065d2:	46bd      	mov	sp, r7
  4065d4:	bd80      	pop	{r7, pc}
  4065d6:	bf00      	nop
  4065d8:	00406a05 	.word	0x00406a05

004065dc <ch_common_samples_to_mm>:


uint16_t ch_common_samples_to_mm(ch_dev_t *dev_ptr, uint16_t num_samples) {
  4065dc:	b480      	push	{r7}
  4065de:	b085      	sub	sp, #20
  4065e0:	af00      	add	r7, sp, #0
  4065e2:	6078      	str	r0, [r7, #4]
  4065e4:	460b      	mov	r3, r1
  4065e6:	807b      	strh	r3, [r7, #2]
	uint32_t	num_mm = 0;
  4065e8:	2300      	movs	r3, #0
  4065ea:	60fb      	str	r3, [r7, #12]
	uint32_t	op_freq = dev_ptr->op_frequency;
  4065ec:	687b      	ldr	r3, [r7, #4]
  4065ee:	691b      	ldr	r3, [r3, #16]
  4065f0:	60bb      	str	r3, [r7, #8]

	if (op_freq != 0) {
  4065f2:	68bb      	ldr	r3, [r7, #8]
  4065f4:	2b00      	cmp	r3, #0
  4065f6:	d008      	beq.n	40660a <ch_common_samples_to_mm+0x2e>
		num_mm = ((uint32_t) num_samples * CH_SPEEDOFSOUND_MPS * 8 * 1000) / (op_freq * 2);
  4065f8:	887b      	ldrh	r3, [r7, #2]
  4065fa:	4a0b      	ldr	r2, [pc, #44]	; (406628 <ch_common_samples_to_mm+0x4c>)
  4065fc:	fb02 f203 	mul.w	r2, r2, r3
  406600:	68bb      	ldr	r3, [r7, #8]
  406602:	005b      	lsls	r3, r3, #1
  406604:	fbb2 f3f3 	udiv	r3, r2, r3
  406608:	60fb      	str	r3, [r7, #12]
	}

	/* Adjust for oversampling, if used */
	num_mm >>= dev_ptr->oversample;
  40660a:	687b      	ldr	r3, [r7, #4]
  40660c:	f993 301e 	ldrsb.w	r3, [r3, #30]
  406610:	461a      	mov	r2, r3
  406612:	68fb      	ldr	r3, [r7, #12]
  406614:	40d3      	lsrs	r3, r2
  406616:	60fb      	str	r3, [r7, #12]

	return (uint16_t) num_mm;
  406618:	68fb      	ldr	r3, [r7, #12]
  40661a:	b29b      	uxth	r3, r3
}
  40661c:	4618      	mov	r0, r3
  40661e:	3714      	adds	r7, #20
  406620:	46bd      	mov	sp, r7
  406622:	f85d 7b04 	ldr.w	r7, [sp], #4
  406626:	4770      	bx	lr
  406628:	0029dec0 	.word	0x0029dec0

0040662c <ch_common_get_range>:
		}
	}
	return ret_val;
}

uint32_t ch_common_get_range(ch_dev_t *dev_ptr, ch_range_t range_type) {
  40662c:	b580      	push	{r7, lr}
  40662e:	b08a      	sub	sp, #40	; 0x28
  406630:	af00      	add	r7, sp, #0
  406632:	6078      	str	r0, [r7, #4]
  406634:	460b      	mov	r3, r1
  406636:	70fb      	strb	r3, [r7, #3]
	uint8_t		tof_reg;
	uint32_t	range = CH_NO_TARGET;
  406638:	f04f 33ff 	mov.w	r3, #4294967295
  40663c:	623b      	str	r3, [r7, #32]
	uint16_t 	time_of_flight;
	uint16_t 	scale_factor;
	int 		err;

	if (dev_ptr->sensor_connected) {
  40663e:	687b      	ldr	r3, [r7, #4]
  406640:	7fdb      	ldrb	r3, [r3, #31]
  406642:	2b00      	cmp	r3, #0
  406644:	d073      	beq.n	40672e <ch_common_get_range+0x102>

		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406646:	687b      	ldr	r3, [r7, #4]
  406648:	8b9b      	ldrh	r3, [r3, #28]
  40664a:	2b65      	cmp	r3, #101	; 0x65
  40664c:	d103      	bne.n	406656 <ch_common_get_range+0x2a>
			tof_reg = CH101_COMMON_REG_TOF;
  40664e:	2318      	movs	r3, #24
  406650:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  406654:	e002      	b.n	40665c <ch_common_get_range+0x30>
		} else {
			tof_reg = CH201_COMMON_REG_TOF;
  406656:	2324      	movs	r3, #36	; 0x24
  406658:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		}

		err = chdrv_read_word(dev_ptr, tof_reg, &time_of_flight);
  40665c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  406660:	b29b      	uxth	r3, r3
  406662:	f107 020a 	add.w	r2, r7, #10
  406666:	4619      	mov	r1, r3
  406668:	6878      	ldr	r0, [r7, #4]
  40666a:	4b33      	ldr	r3, [pc, #204]	; (406738 <ch_common_get_range+0x10c>)
  40666c:	4798      	blx	r3
  40666e:	61f8      	str	r0, [r7, #28]

		if (!err && (time_of_flight != UINT16_MAX)) { // If object detected
  406670:	69fb      	ldr	r3, [r7, #28]
  406672:	2b00      	cmp	r3, #0
  406674:	d15b      	bne.n	40672e <ch_common_get_range+0x102>
  406676:	897b      	ldrh	r3, [r7, #10]
  406678:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40667c:	4293      	cmp	r3, r2
  40667e:	d056      	beq.n	40672e <ch_common_get_range+0x102>

			if (dev_ptr->scale_factor == 0) {
  406680:	687b      	ldr	r3, [r7, #4]
  406682:	8adb      	ldrh	r3, [r3, #22]
  406684:	2b00      	cmp	r3, #0
  406686:	d102      	bne.n	40668e <ch_common_get_range+0x62>
				ch_common_store_scale_factor(dev_ptr);
  406688:	6878      	ldr	r0, [r7, #4]
  40668a:	4b2c      	ldr	r3, [pc, #176]	; (40673c <ch_common_get_range+0x110>)
  40668c:	4798      	blx	r3
			}
			scale_factor = dev_ptr->scale_factor;
  40668e:	687b      	ldr	r3, [r7, #4]
  406690:	8adb      	ldrh	r3, [r3, #22]
  406692:	837b      	strh	r3, [r7, #26]
			
			if (scale_factor != 0) {
  406694:	8b7b      	ldrh	r3, [r7, #26]
  406696:	2b00      	cmp	r3, #0
  406698:	d049      	beq.n	40672e <ch_common_get_range+0x102>
				uint32_t num = (CH_SPEEDOFSOUND_MPS * dev_ptr->group->rtc_cal_pulse_ms * (uint32_t) time_of_flight);
  40669a:	687b      	ldr	r3, [r7, #4]
  40669c:	681b      	ldr	r3, [r3, #0]
  40669e:	88db      	ldrh	r3, [r3, #6]
  4066a0:	897a      	ldrh	r2, [r7, #10]
  4066a2:	fb02 f303 	mul.w	r3, r2, r3
  4066a6:	f240 1257 	movw	r2, #343	; 0x157
  4066aa:	fb02 f303 	mul.w	r3, r2, r3
  4066ae:	617b      	str	r3, [r7, #20]
				uint32_t den = ((uint32_t) dev_ptr->rtc_cal_result * (uint32_t) scale_factor) >> 11;		// XXX need define
  4066b0:	687b      	ldr	r3, [r7, #4]
  4066b2:	89db      	ldrh	r3, [r3, #14]
  4066b4:	461a      	mov	r2, r3
  4066b6:	8b7b      	ldrh	r3, [r7, #26]
  4066b8:	fb03 f302 	mul.w	r3, r3, r2
  4066bc:	0adb      	lsrs	r3, r3, #11
  4066be:	613b      	str	r3, [r7, #16]
				//printf("Time of flight: %u \n", time_of_flight);
				range = (num / den);
  4066c0:	697a      	ldr	r2, [r7, #20]
  4066c2:	693b      	ldr	r3, [r7, #16]
  4066c4:	fbb2 f3f3 	udiv	r3, r2, r3
  4066c8:	623b      	str	r3, [r7, #32]

				if (dev_ptr->part_number == CH201_PART_NUMBER) {
  4066ca:	687b      	ldr	r3, [r7, #4]
  4066cc:	8b9b      	ldrh	r3, [r3, #28]
  4066ce:	2bc9      	cmp	r3, #201	; 0xc9
  4066d0:	d102      	bne.n	4066d8 <ch_common_get_range+0xac>
					range *= 2;
  4066d2:	6a3b      	ldr	r3, [r7, #32]
  4066d4:	005b      	lsls	r3, r3, #1
  4066d6:	623b      	str	r3, [r7, #32]
				}

				if (range_type == CH_RANGE_ECHO_ONE_WAY) {
  4066d8:	78fb      	ldrb	r3, [r7, #3]
  4066da:	2b00      	cmp	r3, #0
  4066dc:	d102      	bne.n	4066e4 <ch_common_get_range+0xb8>
					range /= 2;
  4066de:	6a3b      	ldr	r3, [r7, #32]
  4066e0:	085b      	lsrs	r3, r3, #1
  4066e2:	623b      	str	r3, [r7, #32]
				}

				/* Adjust for oversampling, if used */
				range >>= dev_ptr->oversample;
  4066e4:	687b      	ldr	r3, [r7, #4]
  4066e6:	f993 301e 	ldrsb.w	r3, [r3, #30]
  4066ea:	461a      	mov	r2, r3
  4066ec:	6a3b      	ldr	r3, [r7, #32]
  4066ee:	40d3      	lsrs	r3, r2
  4066f0:	623b      	str	r3, [r7, #32]

				/* If rx-only node, adjust for pre-trigger time included in ToF */
				if (dev_ptr->mode == CH_MODE_TRIGGERED_RX_ONLY) {
  4066f2:	687b      	ldr	r3, [r7, #4]
  4066f4:	791b      	ldrb	r3, [r3, #4]
  4066f6:	2b20      	cmp	r3, #32
  4066f8:	d119      	bne.n	40672e <ch_common_get_range+0x102>
					uint32_t pretrig_adj = (CH_SPEEDOFSOUND_MPS * dev_ptr->group->pretrig_delay_us * 32) / 1000;
  4066fa:	687b      	ldr	r3, [r7, #4]
  4066fc:	681b      	ldr	r3, [r3, #0]
  4066fe:	891b      	ldrh	r3, [r3, #8]
  406700:	461a      	mov	r2, r3
  406702:	f642 23e0 	movw	r3, #10976	; 0x2ae0
  406706:	fb03 f302 	mul.w	r3, r3, r2
  40670a:	4a0d      	ldr	r2, [pc, #52]	; (406740 <ch_common_get_range+0x114>)
  40670c:	fb82 1203 	smull	r1, r2, r2, r3
  406710:	1192      	asrs	r2, r2, #6
  406712:	17db      	asrs	r3, r3, #31
  406714:	1ad3      	subs	r3, r2, r3
  406716:	60fb      	str	r3, [r7, #12]

					if (range > pretrig_adj) {
  406718:	6a3a      	ldr	r2, [r7, #32]
  40671a:	68fb      	ldr	r3, [r7, #12]
  40671c:	429a      	cmp	r2, r3
  40671e:	d904      	bls.n	40672a <ch_common_get_range+0xfe>
						range -= pretrig_adj;			// subtract adjustment from calculated range
  406720:	6a3a      	ldr	r2, [r7, #32]
  406722:	68fb      	ldr	r3, [r7, #12]
  406724:	1ad3      	subs	r3, r2, r3
  406726:	623b      	str	r3, [r7, #32]
  406728:	e001      	b.n	40672e <ch_common_get_range+0x102>
					} else {
						range = CH_MIN_RANGE_VAL;		// underflow - range is very close to zero, use minimum value
  40672a:	2301      	movs	r3, #1
  40672c:	623b      	str	r3, [r7, #32]
					}
				}
			}
		}
	}
	return range;
  40672e:	6a3b      	ldr	r3, [r7, #32]
}
  406730:	4618      	mov	r0, r3
  406732:	3728      	adds	r7, #40	; 0x28
  406734:	46bd      	mov	sp, r7
  406736:	bd80      	pop	{r7, pc}
  406738:	00407409 	.word	0x00407409
  40673c:	00406a05 	.word	0x00406a05
  406740:	10624dd3 	.word	0x10624dd3

00406744 <ch_common_get_amplitude>:


uint16_t ch_common_get_amplitude(ch_dev_t *dev_ptr) {
  406744:	b580      	push	{r7, lr}
  406746:	b084      	sub	sp, #16
  406748:	af00      	add	r7, sp, #0
  40674a:	6078      	str	r0, [r7, #4]
	uint8_t  amplitude_reg;
	uint16_t amplitude = 0;
  40674c:	2300      	movs	r3, #0
  40674e:	81bb      	strh	r3, [r7, #12]

	if (dev_ptr->sensor_connected) {
  406750:	687b      	ldr	r3, [r7, #4]
  406752:	7fdb      	ldrb	r3, [r3, #31]
  406754:	2b00      	cmp	r3, #0
  406756:	d010      	beq.n	40677a <ch_common_get_amplitude+0x36>
		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406758:	687b      	ldr	r3, [r7, #4]
  40675a:	8b9b      	ldrh	r3, [r3, #28]
  40675c:	2b65      	cmp	r3, #101	; 0x65
  40675e:	d102      	bne.n	406766 <ch_common_get_amplitude+0x22>
			amplitude_reg = CH101_COMMON_REG_AMPLITUDE;
  406760:	231a      	movs	r3, #26
  406762:	73fb      	strb	r3, [r7, #15]
  406764:	e001      	b.n	40676a <ch_common_get_amplitude+0x26>
		} else {
			amplitude_reg = CH201_COMMON_REG_AMPLITUDE;
  406766:	2326      	movs	r3, #38	; 0x26
  406768:	73fb      	strb	r3, [r7, #15]
		}

		chdrv_read_word(dev_ptr, amplitude_reg, &amplitude);
  40676a:	7bfb      	ldrb	r3, [r7, #15]
  40676c:	b29b      	uxth	r3, r3
  40676e:	f107 020c 	add.w	r2, r7, #12
  406772:	4619      	mov	r1, r3
  406774:	6878      	ldr	r0, [r7, #4]
  406776:	4b03      	ldr	r3, [pc, #12]	; (406784 <ch_common_get_amplitude+0x40>)
  406778:	4798      	blx	r3
	}

	return amplitude;
  40677a:	89bb      	ldrh	r3, [r7, #12]
}
  40677c:	4618      	mov	r0, r3
  40677e:	3710      	adds	r7, #16
  406780:	46bd      	mov	sp, r7
  406782:	bd80      	pop	{r7, pc}
  406784:	00407409 	.word	0x00407409

00406788 <ch_common_get_locked_state>:


uint8_t ch_common_get_locked_state(ch_dev_t *dev_ptr) {
  406788:	b580      	push	{r7, lr}
  40678a:	b084      	sub	sp, #16
  40678c:	af00      	add	r7, sp, #0
  40678e:	6078      	str	r0, [r7, #4]
	uint8_t ready_reg;
	uint8_t lock_mask = dev_ptr->freqLockValue;
  406790:	687b      	ldr	r3, [r7, #4]
  406792:	795b      	ldrb	r3, [r3, #5]
  406794:	737b      	strb	r3, [r7, #13]
	uint8_t ret_val = 0;
  406796:	2300      	movs	r3, #0
  406798:	73bb      	strb	r3, [r7, #14]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  40679a:	687b      	ldr	r3, [r7, #4]
  40679c:	8b9b      	ldrh	r3, [r3, #28]
  40679e:	2b65      	cmp	r3, #101	; 0x65
  4067a0:	d102      	bne.n	4067a8 <ch_common_get_locked_state+0x20>
		ready_reg = CH101_COMMON_REG_READY;
  4067a2:	2314      	movs	r3, #20
  4067a4:	73fb      	strb	r3, [r7, #15]
  4067a6:	e001      	b.n	4067ac <ch_common_get_locked_state+0x24>
	} else {
		ready_reg = CH201_COMMON_REG_READY;
  4067a8:	2314      	movs	r3, #20
  4067aa:	73fb      	strb	r3, [r7, #15]
	}

	if (dev_ptr->sensor_connected) {
  4067ac:	687b      	ldr	r3, [r7, #4]
  4067ae:	7fdb      	ldrb	r3, [r3, #31]
  4067b0:	2b00      	cmp	r3, #0
  4067b2:	d011      	beq.n	4067d8 <ch_common_get_locked_state+0x50>
		uint8_t ready_value = 0;
  4067b4:	2300      	movs	r3, #0
  4067b6:	733b      	strb	r3, [r7, #12]
		chdrv_read_byte(dev_ptr, ready_reg, &ready_value);
  4067b8:	7bfb      	ldrb	r3, [r7, #15]
  4067ba:	b29b      	uxth	r3, r3
  4067bc:	f107 020c 	add.w	r2, r7, #12
  4067c0:	4619      	mov	r1, r3
  4067c2:	6878      	ldr	r0, [r7, #4]
  4067c4:	4b07      	ldr	r3, [pc, #28]	; (4067e4 <ch_common_get_locked_state+0x5c>)
  4067c6:	4798      	blx	r3
		if (ready_value & lock_mask) {
  4067c8:	7b3a      	ldrb	r2, [r7, #12]
  4067ca:	7b7b      	ldrb	r3, [r7, #13]
  4067cc:	4013      	ands	r3, r2
  4067ce:	b2db      	uxtb	r3, r3
  4067d0:	2b00      	cmp	r3, #0
  4067d2:	d001      	beq.n	4067d8 <ch_common_get_locked_state+0x50>
			ret_val = 1;
  4067d4:	2301      	movs	r3, #1
  4067d6:	73bb      	strb	r3, [r7, #14]
		}
	}
	return ret_val;
  4067d8:	7bbb      	ldrb	r3, [r7, #14]
}
  4067da:	4618      	mov	r0, r3
  4067dc:	3710      	adds	r7, #16
  4067de:	46bd      	mov	sp, r7
  4067e0:	bd80      	pop	{r7, pc}
  4067e2:	bf00      	nop
  4067e4:	004073b1 	.word	0x004073b1

004067e8 <ch_common_prepare_pulse_timer>:

void ch_common_prepare_pulse_timer(ch_dev_t *dev_ptr) {
  4067e8:	b580      	push	{r7, lr}
  4067ea:	b084      	sub	sp, #16
  4067ec:	af00      	add	r7, sp, #0
  4067ee:	6078      	str	r0, [r7, #4]
	uint8_t cal_trig_reg;

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  4067f0:	687b      	ldr	r3, [r7, #4]
  4067f2:	8b9b      	ldrh	r3, [r3, #28]
  4067f4:	2b65      	cmp	r3, #101	; 0x65
  4067f6:	d102      	bne.n	4067fe <ch_common_prepare_pulse_timer+0x16>
		cal_trig_reg = CH101_COMMON_REG_CAL_TRIG;
  4067f8:	2306      	movs	r3, #6
  4067fa:	73fb      	strb	r3, [r7, #15]
  4067fc:	e001      	b.n	406802 <ch_common_prepare_pulse_timer+0x1a>
	} else {
		cal_trig_reg = CH201_COMMON_REG_CAL_TRIG;
  4067fe:	2306      	movs	r3, #6
  406800:	73fb      	strb	r3, [r7, #15]
	}

	chdrv_write_byte(dev_ptr, cal_trig_reg, 0);
  406802:	7bfb      	ldrb	r3, [r7, #15]
  406804:	b29b      	uxth	r3, r3
  406806:	2200      	movs	r2, #0
  406808:	4619      	mov	r1, r3
  40680a:	6878      	ldr	r0, [r7, #4]
  40680c:	4b02      	ldr	r3, [pc, #8]	; (406818 <ch_common_prepare_pulse_timer+0x30>)
  40680e:	4798      	blx	r3
}
  406810:	bf00      	nop
  406812:	3710      	adds	r7, #16
  406814:	46bd      	mov	sp, r7
  406816:	bd80      	pop	{r7, pc}
  406818:	00407335 	.word	0x00407335

0040681c <ch_common_store_pt_result>:

void ch_common_store_pt_result(ch_dev_t *dev_ptr) {
  40681c:	b580      	push	{r7, lr}
  40681e:	b084      	sub	sp, #16
  406820:	af00      	add	r7, sp, #0
  406822:	6078      	str	r0, [r7, #4]
	uint8_t pt_result_reg;
	uint16_t rtc_cal_result;

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406824:	687b      	ldr	r3, [r7, #4]
  406826:	8b9b      	ldrh	r3, [r3, #28]
  406828:	2b65      	cmp	r3, #101	; 0x65
  40682a:	d102      	bne.n	406832 <ch_common_store_pt_result+0x16>
		pt_result_reg = CH101_COMMON_REG_CAL_RESULT;
  40682c:	230a      	movs	r3, #10
  40682e:	73fb      	strb	r3, [r7, #15]
  406830:	e001      	b.n	406836 <ch_common_store_pt_result+0x1a>
	} else {
		pt_result_reg = CH201_COMMON_REG_CAL_RESULT;
  406832:	230a      	movs	r3, #10
  406834:	73fb      	strb	r3, [r7, #15]
	}

	chdrv_read_word(dev_ptr, pt_result_reg, &rtc_cal_result);
  406836:	7bfb      	ldrb	r3, [r7, #15]
  406838:	b29b      	uxth	r3, r3
  40683a:	f107 020c 	add.w	r2, r7, #12
  40683e:	4619      	mov	r1, r3
  406840:	6878      	ldr	r0, [r7, #4]
  406842:	4b04      	ldr	r3, [pc, #16]	; (406854 <ch_common_store_pt_result+0x38>)
  406844:	4798      	blx	r3
	dev_ptr->rtc_cal_result = rtc_cal_result;
  406846:	89ba      	ldrh	r2, [r7, #12]
  406848:	687b      	ldr	r3, [r7, #4]
  40684a:	81da      	strh	r2, [r3, #14]
}
  40684c:	bf00      	nop
  40684e:	3710      	adds	r7, #16
  406850:	46bd      	mov	sp, r7
  406852:	bd80      	pop	{r7, pc}
  406854:	00407409 	.word	0x00407409

00406858 <ch_common_set_frequency>:

uint8_t ch_common_set_frequency(ch_dev_t *dev_ptr, uint32_t target_freq_Hz){
  406858:	b580      	push	{r7, lr}
  40685a:	b084      	sub	sp, #16
  40685c:	af00      	add	r7, sp, #0
  40685e:	6078      	str	r0, [r7, #4]
  406860:	6039      	str	r1, [r7, #0]
	uint8_t	 tof_sf_reg;
	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406862:	687b      	ldr	r3, [r7, #4]
  406864:	8b9b      	ldrh	r3, [r3, #28]
  406866:	2b65      	cmp	r3, #101	; 0x65
  406868:	d102      	bne.n	406870 <ch_common_set_frequency+0x18>
		tof_sf_reg = CH101_COMMON_REG_TOF_SF;
  40686a:	2316      	movs	r3, #22
  40686c:	73fb      	strb	r3, [r7, #15]
  40686e:	e001      	b.n	406874 <ch_common_set_frequency+0x1c>
		} else {
		tof_sf_reg = CH201_COMMON_REG_TOF_SF;
  406870:	2322      	movs	r3, #34	; 0x22
  406872:	73fb      	strb	r3, [r7, #15]
	}
	uint8_t err = chdrv_write_word(dev_ptr, tof_sf_reg, target_freq_Hz);
  406874:	7bfb      	ldrb	r3, [r7, #15]
  406876:	b29b      	uxth	r3, r3
  406878:	683a      	ldr	r2, [r7, #0]
  40687a:	b292      	uxth	r2, r2
  40687c:	4619      	mov	r1, r3
  40687e:	6878      	ldr	r0, [r7, #4]
  406880:	4b08      	ldr	r3, [pc, #32]	; (4068a4 <ch_common_set_frequency+0x4c>)
  406882:	4798      	blx	r3
  406884:	4603      	mov	r3, r0
  406886:	73bb      	strb	r3, [r7, #14]
	if (!err) {
  406888:	7bbb      	ldrb	r3, [r7, #14]
  40688a:	2b00      	cmp	r3, #0
  40688c:	d104      	bne.n	406898 <ch_common_set_frequency+0x40>
		printf("Write SF Successful: %u\n", err);
  40688e:	7bbb      	ldrb	r3, [r7, #14]
  406890:	4619      	mov	r1, r3
  406892:	4805      	ldr	r0, [pc, #20]	; (4068a8 <ch_common_set_frequency+0x50>)
  406894:	4b05      	ldr	r3, [pc, #20]	; (4068ac <ch_common_set_frequency+0x54>)
  406896:	4798      	blx	r3
	} else {
		//printf("Write not Successful: %u\n", err);
	}
	return err;
  406898:	7bbb      	ldrb	r3, [r7, #14]
}
  40689a:	4618      	mov	r0, r3
  40689c:	3710      	adds	r7, #16
  40689e:	46bd      	mov	sp, r7
  4068a0:	bd80      	pop	{r7, pc}
  4068a2:	bf00      	nop
  4068a4:	0040736d 	.word	0x0040736d
  4068a8:	0040dbf8 	.word	0x0040dbf8
  4068ac:	00409ee9 	.word	0x00409ee9

004068b0 <ch_common_store_op_freq>:

void ch_common_store_op_freq(ch_dev_t *dev_ptr){
  4068b0:	b580      	push	{r7, lr}
  4068b2:	b088      	sub	sp, #32
  4068b4:	af00      	add	r7, sp, #0
  4068b6:	6078      	str	r0, [r7, #4]
	uint32_t freq_counter_cycles;
	uint32_t num;
	uint32_t den;
	uint32_t op_freq;

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  4068b8:	687b      	ldr	r3, [r7, #4]
  4068ba:	8b9b      	ldrh	r3, [r3, #28]
  4068bc:	2b65      	cmp	r3, #101	; 0x65
  4068be:	d102      	bne.n	4068c6 <ch_common_store_op_freq+0x16>
		tof_sf_reg = CH101_COMMON_REG_TOF_SF;
  4068c0:	2316      	movs	r3, #22
  4068c2:	77fb      	strb	r3, [r7, #31]
  4068c4:	e001      	b.n	4068ca <ch_common_store_op_freq+0x1a>
	} else {
		tof_sf_reg = CH201_COMMON_REG_TOF_SF;
  4068c6:	2322      	movs	r3, #34	; 0x22
  4068c8:	77fb      	strb	r3, [r7, #31]
	}

	freq_counter_cycles = dev_ptr->freqCounterCycles;
  4068ca:	687b      	ldr	r3, [r7, #4]
  4068cc:	88db      	ldrh	r3, [r3, #6]
  4068ce:	61bb      	str	r3, [r7, #24]

	chdrv_read_word(dev_ptr, tof_sf_reg, &raw_freq);
  4068d0:	7ffb      	ldrb	r3, [r7, #31]
  4068d2:	b29b      	uxth	r3, r3
  4068d4:	f107 020a 	add.w	r2, r7, #10
  4068d8:	4619      	mov	r1, r3
  4068da:	6878      	ldr	r0, [r7, #4]
  4068dc:	4b10      	ldr	r3, [pc, #64]	; (406920 <ch_common_store_op_freq+0x70>)
  4068de:	4798      	blx	r3

	num = (uint32_t)(((dev_ptr->rtc_cal_result)*1000U) / (16U * freq_counter_cycles)) * (uint32_t)(raw_freq);
  4068e0:	687b      	ldr	r3, [r7, #4]
  4068e2:	89db      	ldrh	r3, [r3, #14]
  4068e4:	461a      	mov	r2, r3
  4068e6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  4068ea:	fb03 f202 	mul.w	r2, r3, r2
  4068ee:	69bb      	ldr	r3, [r7, #24]
  4068f0:	011b      	lsls	r3, r3, #4
  4068f2:	fbb2 f3f3 	udiv	r3, r2, r3
  4068f6:	897a      	ldrh	r2, [r7, #10]
  4068f8:	fb02 f303 	mul.w	r3, r2, r3
  4068fc:	617b      	str	r3, [r7, #20]
	den = (uint32_t)(dev_ptr->group->rtc_cal_pulse_ms);
  4068fe:	687b      	ldr	r3, [r7, #4]
  406900:	681b      	ldr	r3, [r3, #0]
  406902:	88db      	ldrh	r3, [r3, #6]
  406904:	613b      	str	r3, [r7, #16]
	op_freq = (num/den);
  406906:	697a      	ldr	r2, [r7, #20]
  406908:	693b      	ldr	r3, [r7, #16]
  40690a:	fbb2 f3f3 	udiv	r3, r2, r3
  40690e:	60fb      	str	r3, [r7, #12]

	dev_ptr->op_frequency = op_freq;
  406910:	687b      	ldr	r3, [r7, #4]
  406912:	68fa      	ldr	r2, [r7, #12]
  406914:	611a      	str	r2, [r3, #16]
}
  406916:	bf00      	nop
  406918:	3720      	adds	r7, #32
  40691a:	46bd      	mov	sp, r7
  40691c:	bd80      	pop	{r7, pc}
  40691e:	bf00      	nop
  406920:	00407409 	.word	0x00407409

00406924 <ch_common_store_bandwidth>:

void ch_common_store_bandwidth(ch_dev_t *dev_ptr) {
  406924:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  406928:	b08b      	sub	sp, #44	; 0x2c
  40692a:	af02      	add	r7, sp, #8
  40692c:	6078      	str	r0, [r7, #4]
	uint32_t bandwidth = 0;
  40692e:	2300      	movs	r3, #0
  406930:	61fb      	str	r3, [r7, #28]
	ch_iq_sample_t iq_buf[2];		// XXX assumes two consecutive samples

	(void) ch_get_iq_data(dev_ptr, iq_buf, CH_COMMON_BANDWIDTH_INDEX_1, 2, CH_IO_MODE_BLOCK);
  406932:	f107 010c 	add.w	r1, r7, #12
  406936:	2300      	movs	r3, #0
  406938:	9300      	str	r3, [sp, #0]
  40693a:	2302      	movs	r3, #2
  40693c:	2206      	movs	r2, #6
  40693e:	6878      	ldr	r0, [r7, #4]
  406940:	4c2b      	ldr	r4, [pc, #172]	; (4069f0 <ch_common_store_bandwidth+0xcc>)
  406942:	47a0      	blx	r4

	uint32_t mag1sq = (uint32_t)(((int32_t)iq_buf[0].i * (int32_t)iq_buf[0].i) + ((int32_t)iq_buf[0].q * (int32_t)iq_buf[0].q));
  406944:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  406948:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
  40694c:	fb02 f203 	mul.w	r2, r2, r3
  406950:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
  406954:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
  406958:	fb01 f303 	mul.w	r3, r1, r3
  40695c:	4413      	add	r3, r2
  40695e:	61bb      	str	r3, [r7, #24]
	uint32_t mag2sq = (uint32_t)(((int32_t)iq_buf[1].i * (int32_t)iq_buf[1].i) + ((int32_t)iq_buf[1].q * (int32_t)iq_buf[1].q));
  406960:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
  406964:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
  406968:	fb02 f203 	mul.w	r2, r2, r3
  40696c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
  406970:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
  406974:	fb01 f303 	mul.w	r3, r1, r3
  406978:	4413      	add	r3, r2
  40697a:	617b      	str	r3, [r7, #20]

	//can perform below calculations using floating point for higher accuracy.
	bandwidth = FIXEDMUL(FP_log( FP_sqrt( FIXEDDIV(mag1sq,mag2sq))), 
  40697c:	69bb      	ldr	r3, [r7, #24]
  40697e:	f04f 0400 	mov.w	r4, #0
  406982:	0c1e      	lsrs	r6, r3, #16
  406984:	041d      	lsls	r5, r3, #16
  406986:	697b      	ldr	r3, [r7, #20]
  406988:	f04f 0400 	mov.w	r4, #0
  40698c:	4a19      	ldr	r2, [pc, #100]	; (4069f4 <ch_common_store_bandwidth+0xd0>)
  40698e:	603a      	str	r2, [r7, #0]
  406990:	461a      	mov	r2, r3
  406992:	4623      	mov	r3, r4
  406994:	4628      	mov	r0, r5
  406996:	4631      	mov	r1, r6
  406998:	683c      	ldr	r4, [r7, #0]
  40699a:	47a0      	blx	r4
  40699c:	4603      	mov	r3, r0
  40699e:	460c      	mov	r4, r1
  4069a0:	4618      	mov	r0, r3
  4069a2:	4b15      	ldr	r3, [pc, #84]	; (4069f8 <ch_common_store_bandwidth+0xd4>)
  4069a4:	4798      	blx	r3
  4069a6:	4603      	mov	r3, r0
  4069a8:	4618      	mov	r0, r3
  4069aa:	4b14      	ldr	r3, [pc, #80]	; (4069fc <ch_common_store_bandwidth+0xd8>)
  4069ac:	4798      	blx	r3
  4069ae:	4603      	mov	r3, r0
  4069b0:	0a1d      	lsrs	r5, r3, #8
  4069b2:	687b      	ldr	r3, [r7, #4]
  4069b4:	691b      	ldr	r3, [r3, #16]
  4069b6:	f04f 0400 	mov.w	r4, #0
  4069ba:	4699      	mov	r9, r3
  4069bc:	f04f 0800 	mov.w	r8, #0
  4069c0:	4c0c      	ldr	r4, [pc, #48]	; (4069f4 <ch_common_store_bandwidth+0xd0>)
  4069c2:	4a0f      	ldr	r2, [pc, #60]	; (406a00 <ch_common_store_bandwidth+0xdc>)
  4069c4:	f04f 0300 	mov.w	r3, #0
  4069c8:	4640      	mov	r0, r8
  4069ca:	4649      	mov	r1, r9
  4069cc:	47a0      	blx	r4
  4069ce:	4603      	mov	r3, r0
  4069d0:	460c      	mov	r4, r1
  4069d2:	0a1b      	lsrs	r3, r3, #8
  4069d4:	fb03 f305 	mul.w	r3, r3, r5
  4069d8:	61fb      	str	r3, [r7, #28]
			             (FIXEDDIV(INT2FIXED((uint64_t)dev_ptr->op_frequency),
								   (FIXED_PI * ((CH_COMMON_BANDWIDTH_INDEX_2 - CH_COMMON_BANDWIDTH_INDEX_1) * 8 )))));

	dev_ptr->bandwidth = (uint16_t) FIXED2INT(bandwidth);
  4069da:	69fb      	ldr	r3, [r7, #28]
  4069dc:	0c1b      	lsrs	r3, r3, #16
  4069de:	b29a      	uxth	r2, r3
  4069e0:	687b      	ldr	r3, [r7, #4]
  4069e2:	829a      	strh	r2, [r3, #20]
}
  4069e4:	bf00      	nop
  4069e6:	3724      	adds	r7, #36	; 0x24
  4069e8:	46bd      	mov	sp, r7
  4069ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4069ee:	bf00      	nop
  4069f0:	00405dc1 	.word	0x00405dc1
  4069f4:	0040cbad 	.word	0x0040cbad
  4069f8:	004085bf 	.word	0x004085bf
  4069fc:	004086b5 	.word	0x004086b5
  406a00:	001921f8 	.word	0x001921f8

00406a04 <ch_common_store_scale_factor>:

void ch_common_store_scale_factor(ch_dev_t *dev_ptr) {
  406a04:	b580      	push	{r7, lr}
  406a06:	b084      	sub	sp, #16
  406a08:	af00      	add	r7, sp, #0
  406a0a:	6078      	str	r0, [r7, #4]
	uint8_t	err;
	uint8_t	tof_sf_reg;
	uint16_t scale_factor;

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406a0c:	687b      	ldr	r3, [r7, #4]
  406a0e:	8b9b      	ldrh	r3, [r3, #28]
  406a10:	2b65      	cmp	r3, #101	; 0x65
  406a12:	d102      	bne.n	406a1a <ch_common_store_scale_factor+0x16>
		tof_sf_reg = CH101_COMMON_REG_TOF_SF;
  406a14:	2316      	movs	r3, #22
  406a16:	73fb      	strb	r3, [r7, #15]
  406a18:	e001      	b.n	406a1e <ch_common_store_scale_factor+0x1a>
	} else {
		tof_sf_reg = CH201_COMMON_REG_TOF_SF;
  406a1a:	2322      	movs	r3, #34	; 0x22
  406a1c:	73fb      	strb	r3, [r7, #15]
	}

	err = chdrv_read_word(dev_ptr, tof_sf_reg, &scale_factor);
  406a1e:	7bfb      	ldrb	r3, [r7, #15]
  406a20:	b29b      	uxth	r3, r3
  406a22:	f107 020c 	add.w	r2, r7, #12
  406a26:	4619      	mov	r1, r3
  406a28:	6878      	ldr	r0, [r7, #4]
  406a2a:	4b09      	ldr	r3, [pc, #36]	; (406a50 <ch_common_store_scale_factor+0x4c>)
  406a2c:	4798      	blx	r3
  406a2e:	4603      	mov	r3, r0
  406a30:	73bb      	strb	r3, [r7, #14]
	if (!err) {
  406a32:	7bbb      	ldrb	r3, [r7, #14]
  406a34:	2b00      	cmp	r3, #0
  406a36:	d103      	bne.n	406a40 <ch_common_store_scale_factor+0x3c>
		dev_ptr->scale_factor = scale_factor;
  406a38:	89ba      	ldrh	r2, [r7, #12]
  406a3a:	687b      	ldr	r3, [r7, #4]
  406a3c:	82da      	strh	r2, [r3, #22]
	} else {
		dev_ptr->scale_factor = 0;
	}
}
  406a3e:	e002      	b.n	406a46 <ch_common_store_scale_factor+0x42>
		dev_ptr->scale_factor = 0;
  406a40:	687b      	ldr	r3, [r7, #4]
  406a42:	2200      	movs	r2, #0
  406a44:	82da      	strh	r2, [r3, #22]
}
  406a46:	bf00      	nop
  406a48:	3710      	adds	r7, #16
  406a4a:	46bd      	mov	sp, r7
  406a4c:	bd80      	pop	{r7, pc}
  406a4e:	bf00      	nop
  406a50:	00407409 	.word	0x00407409

00406a54 <ch_common_set_thresholds>:


uint8_t ch_common_set_thresholds(ch_dev_t *dev_ptr, ch_thresholds_t *thresholds_ptr) {
  406a54:	b580      	push	{r7, lr}
  406a56:	b088      	sub	sp, #32
  406a58:	af00      	add	r7, sp, #0
  406a5a:	6078      	str	r0, [r7, #4]
  406a5c:	6039      	str	r1, [r7, #0]

	uint8_t	thresh_len_reg = 0;		// offset of register for this threshold's length
  406a5e:	2300      	movs	r3, #0
  406a60:	77fb      	strb	r3, [r7, #31]
	uint8_t thresh_level_reg;	// threshold level reg (first in array)
	uint8_t max_num_thresholds;
	int ret_val = 1;		// default return = error
  406a62:	2301      	movs	r3, #1
  406a64:	61bb      	str	r3, [r7, #24]
	uint8_t	thresh_num;
	uint8_t thresh_len;
	uint16_t thresh_level;
	uint16_t start_sample = 0;
  406a66:	2300      	movs	r3, #0
  406a68:	82bb      	strh	r3, [r7, #20]

	if (dev_ptr->sensor_connected) {
  406a6a:	687b      	ldr	r3, [r7, #4]
  406a6c:	7fdb      	ldrb	r3, [r3, #31]
  406a6e:	2b00      	cmp	r3, #0
  406a70:	d070      	beq.n	406b54 <ch_common_set_thresholds+0x100>
		
		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406a72:	687b      	ldr	r3, [r7, #4]
  406a74:	8b9b      	ldrh	r3, [r3, #28]
  406a76:	2b65      	cmp	r3, #101	; 0x65
  406a78:	d102      	bne.n	406a80 <ch_common_set_thresholds+0x2c>
			return ret_val;		// NOT SUPPORTED in CH101
  406a7a:	69bb      	ldr	r3, [r7, #24]
  406a7c:	b2db      	uxtb	r3, r3
  406a7e:	e06b      	b.n	406b58 <ch_common_set_thresholds+0x104>

		} else {
			thresh_level_reg = CH201_COMMON_REG_THRESHOLDS;
  406a80:	2316      	movs	r3, #22
  406a82:	74fb      	strb	r3, [r7, #19]
			max_num_thresholds = CH201_COMMON_NUM_THRESHOLDS;
  406a84:	2306      	movs	r3, #6
  406a86:	74bb      	strb	r3, [r7, #18]
		}

		for (thresh_num = 0; thresh_num < max_num_thresholds; thresh_num++) {
  406a88:	2300      	movs	r3, #0
  406a8a:	75fb      	strb	r3, [r7, #23]
  406a8c:	e05c      	b.n	406b48 <ch_common_set_thresholds+0xf4>

			if (thresh_num < (max_num_thresholds - 1)) {
  406a8e:	7dfa      	ldrb	r2, [r7, #23]
  406a90:	7cbb      	ldrb	r3, [r7, #18]
  406a92:	3b01      	subs	r3, #1
  406a94:	429a      	cmp	r2, r3
  406a96:	da0e      	bge.n	406ab6 <ch_common_set_thresholds+0x62>
				uint16_t next_start_sample = thresholds_ptr->threshold[thresh_num + 1].start_sample;
  406a98:	7dfb      	ldrb	r3, [r7, #23]
  406a9a:	1c5a      	adds	r2, r3, #1
  406a9c:	683b      	ldr	r3, [r7, #0]
  406a9e:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  406aa2:	823b      	strh	r3, [r7, #16]

				thresh_len = (next_start_sample - start_sample);
  406aa4:	8a3b      	ldrh	r3, [r7, #16]
  406aa6:	b2da      	uxtb	r2, r3
  406aa8:	8abb      	ldrh	r3, [r7, #20]
  406aaa:	b2db      	uxtb	r3, r3
  406aac:	1ad3      	subs	r3, r2, r3
  406aae:	75bb      	strb	r3, [r7, #22]
				start_sample  = next_start_sample;
  406ab0:	8a3b      	ldrh	r3, [r7, #16]
  406ab2:	82bb      	strh	r3, [r7, #20]
  406ab4:	e001      	b.n	406aba <ch_common_set_thresholds+0x66>
			} else {
				thresh_len = 0;
  406ab6:	2300      	movs	r3, #0
  406ab8:	75bb      	strb	r3, [r7, #22]
			}

			if (dev_ptr->part_number == CH201_PART_NUMBER) {
  406aba:	687b      	ldr	r3, [r7, #4]
  406abc:	8b9b      	ldrh	r3, [r3, #28]
  406abe:	2bc9      	cmp	r3, #201	; 0xc9
  406ac0:	d122      	bne.n	406b08 <ch_common_set_thresholds+0xb4>
				if (thresh_num == 0) {
  406ac2:	7dfb      	ldrb	r3, [r7, #23]
  406ac4:	2b00      	cmp	r3, #0
  406ac6:	d102      	bne.n	406ace <ch_common_set_thresholds+0x7a>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_0;
  406ac8:	2308      	movs	r3, #8
  406aca:	77fb      	strb	r3, [r7, #31]
  406acc:	e01c      	b.n	406b08 <ch_common_set_thresholds+0xb4>
				} else if (thresh_num == 1) {
  406ace:	7dfb      	ldrb	r3, [r7, #23]
  406ad0:	2b01      	cmp	r3, #1
  406ad2:	d102      	bne.n	406ada <ch_common_set_thresholds+0x86>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_1;
  406ad4:	2309      	movs	r3, #9
  406ad6:	77fb      	strb	r3, [r7, #31]
  406ad8:	e016      	b.n	406b08 <ch_common_set_thresholds+0xb4>
				} else if (thresh_num == 2) {
  406ada:	7dfb      	ldrb	r3, [r7, #23]
  406adc:	2b02      	cmp	r3, #2
  406ade:	d102      	bne.n	406ae6 <ch_common_set_thresholds+0x92>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_2;
  406ae0:	230c      	movs	r3, #12
  406ae2:	77fb      	strb	r3, [r7, #31]
  406ae4:	e010      	b.n	406b08 <ch_common_set_thresholds+0xb4>
				} else if (thresh_num == 3) {
  406ae6:	7dfb      	ldrb	r3, [r7, #23]
  406ae8:	2b03      	cmp	r3, #3
  406aea:	d102      	bne.n	406af2 <ch_common_set_thresholds+0x9e>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_3;
  406aec:	230d      	movs	r3, #13
  406aee:	77fb      	strb	r3, [r7, #31]
  406af0:	e00a      	b.n	406b08 <ch_common_set_thresholds+0xb4>
				} else if (thresh_num == 4) {
  406af2:	7dfb      	ldrb	r3, [r7, #23]
  406af4:	2b04      	cmp	r3, #4
  406af6:	d102      	bne.n	406afe <ch_common_set_thresholds+0xaa>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_4;
  406af8:	2315      	movs	r3, #21
  406afa:	77fb      	strb	r3, [r7, #31]
  406afc:	e004      	b.n	406b08 <ch_common_set_thresholds+0xb4>
				} else if (thresh_num == 5) {
  406afe:	7dfb      	ldrb	r3, [r7, #23]
  406b00:	2b05      	cmp	r3, #5
  406b02:	d101      	bne.n	406b08 <ch_common_set_thresholds+0xb4>
					thresh_len_reg = 0;			// last threshold does not have length field - assumed to extend to end of data
  406b04:	2300      	movs	r3, #0
  406b06:	77fb      	strb	r3, [r7, #31]
				}
			}

			if (thresh_len_reg != 0) {
  406b08:	7ffb      	ldrb	r3, [r7, #31]
  406b0a:	2b00      	cmp	r3, #0
  406b0c:	d006      	beq.n	406b1c <ch_common_set_thresholds+0xc8>
				chdrv_write_byte(dev_ptr, thresh_len_reg, thresh_len); 	// set the length field (if any) for this threshold
  406b0e:	7ffb      	ldrb	r3, [r7, #31]
  406b10:	b29b      	uxth	r3, r3
  406b12:	7dba      	ldrb	r2, [r7, #22]
  406b14:	4619      	mov	r1, r3
  406b16:	6878      	ldr	r0, [r7, #4]
  406b18:	4b11      	ldr	r3, [pc, #68]	; (406b60 <ch_common_set_thresholds+0x10c>)
  406b1a:	4798      	blx	r3
			}
			// write level to this threshold's entry in register array
			thresh_level = thresholds_ptr->threshold[thresh_num].level;
  406b1c:	7dfb      	ldrb	r3, [r7, #23]
  406b1e:	683a      	ldr	r2, [r7, #0]
  406b20:	009b      	lsls	r3, r3, #2
  406b22:	4413      	add	r3, r2
  406b24:	885b      	ldrh	r3, [r3, #2]
  406b26:	81fb      	strh	r3, [r7, #14]
			chdrv_write_word(dev_ptr, (thresh_level_reg + (thresh_num * sizeof(uint16_t))), thresh_level);
  406b28:	7cfb      	ldrb	r3, [r7, #19]
  406b2a:	b29a      	uxth	r2, r3
  406b2c:	7dfb      	ldrb	r3, [r7, #23]
  406b2e:	b29b      	uxth	r3, r3
  406b30:	005b      	lsls	r3, r3, #1
  406b32:	b29b      	uxth	r3, r3
  406b34:	4413      	add	r3, r2
  406b36:	b29b      	uxth	r3, r3
  406b38:	89fa      	ldrh	r2, [r7, #14]
  406b3a:	4619      	mov	r1, r3
  406b3c:	6878      	ldr	r0, [r7, #4]
  406b3e:	4b09      	ldr	r3, [pc, #36]	; (406b64 <ch_common_set_thresholds+0x110>)
  406b40:	4798      	blx	r3
		for (thresh_num = 0; thresh_num < max_num_thresholds; thresh_num++) {
  406b42:	7dfb      	ldrb	r3, [r7, #23]
  406b44:	3301      	adds	r3, #1
  406b46:	75fb      	strb	r3, [r7, #23]
  406b48:	7dfa      	ldrb	r2, [r7, #23]
  406b4a:	7cbb      	ldrb	r3, [r7, #18]
  406b4c:	429a      	cmp	r2, r3
  406b4e:	d39e      	bcc.n	406a8e <ch_common_set_thresholds+0x3a>
		}

		ret_val = 0;	// return OK
  406b50:	2300      	movs	r3, #0
  406b52:	61bb      	str	r3, [r7, #24]
	}
	return ret_val;
  406b54:	69bb      	ldr	r3, [r7, #24]
  406b56:	b2db      	uxtb	r3, r3
}
  406b58:	4618      	mov	r0, r3
  406b5a:	3720      	adds	r7, #32
  406b5c:	46bd      	mov	sp, r7
  406b5e:	bd80      	pop	{r7, pc}
  406b60:	00407335 	.word	0x00407335
  406b64:	0040736d 	.word	0x0040736d

00406b68 <ch_common_get_thresholds>:


uint8_t ch_common_get_thresholds(ch_dev_t *dev_ptr, ch_thresholds_t *thresholds_ptr) {
  406b68:	b580      	push	{r7, lr}
  406b6a:	b086      	sub	sp, #24
  406b6c:	af00      	add	r7, sp, #0
  406b6e:	6078      	str	r0, [r7, #4]
  406b70:	6039      	str	r1, [r7, #0]
	uint8_t	thresh_len_reg = 0;		// offset of register for this threshold's length
  406b72:	2300      	movs	r3, #0
  406b74:	75fb      	strb	r3, [r7, #23]
	uint8_t thresh_level_reg;	// threshold level reg (first in array)
	uint8_t max_num_thresholds;
	uint8_t ret_val = 1;		// default = error return
  406b76:	2301      	movs	r3, #1
  406b78:	75bb      	strb	r3, [r7, #22]
	uint8_t thresh_num;
	uint8_t	thresh_len = 0;		// number of samples described by each threshold
  406b7a:	2300      	movs	r3, #0
  406b7c:	73fb      	strb	r3, [r7, #15]
	uint16_t	start_sample = 0;	// calculated start sample for each threshold
  406b7e:	2300      	movs	r3, #0
  406b80:	827b      	strh	r3, [r7, #18]

	if (dev_ptr->sensor_connected && (thresholds_ptr != NULL)) {
  406b82:	687b      	ldr	r3, [r7, #4]
  406b84:	7fdb      	ldrb	r3, [r3, #31]
  406b86:	2b00      	cmp	r3, #0
  406b88:	d068      	beq.n	406c5c <ch_common_get_thresholds+0xf4>
  406b8a:	683b      	ldr	r3, [r7, #0]
  406b8c:	2b00      	cmp	r3, #0
  406b8e:	d065      	beq.n	406c5c <ch_common_get_thresholds+0xf4>
		
		if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406b90:	687b      	ldr	r3, [r7, #4]
  406b92:	8b9b      	ldrh	r3, [r3, #28]
  406b94:	2b65      	cmp	r3, #101	; 0x65
  406b96:	d101      	bne.n	406b9c <ch_common_get_thresholds+0x34>
			return ret_val;		// NOT SUPPORTED in CH101
  406b98:	7dbb      	ldrb	r3, [r7, #22]
  406b9a:	e060      	b.n	406c5e <ch_common_get_thresholds+0xf6>
			
		} else {
			thresh_level_reg = CH201_COMMON_REG_THRESHOLDS;
  406b9c:	2316      	movs	r3, #22
  406b9e:	747b      	strb	r3, [r7, #17]
			max_num_thresholds = CH201_COMMON_NUM_THRESHOLDS;
  406ba0:	2306      	movs	r3, #6
  406ba2:	743b      	strb	r3, [r7, #16]
		}

		for (thresh_num = 0; thresh_num < max_num_thresholds; thresh_num++) {
  406ba4:	2300      	movs	r3, #0
  406ba6:	757b      	strb	r3, [r7, #21]
  406ba8:	e052      	b.n	406c50 <ch_common_get_thresholds+0xe8>

			if (dev_ptr->part_number == CH201_PART_NUMBER) {
  406baa:	687b      	ldr	r3, [r7, #4]
  406bac:	8b9b      	ldrh	r3, [r3, #28]
  406bae:	2bc9      	cmp	r3, #201	; 0xc9
  406bb0:	d122      	bne.n	406bf8 <ch_common_get_thresholds+0x90>
				if (thresh_num == 0) {
  406bb2:	7d7b      	ldrb	r3, [r7, #21]
  406bb4:	2b00      	cmp	r3, #0
  406bb6:	d102      	bne.n	406bbe <ch_common_get_thresholds+0x56>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_0;
  406bb8:	2308      	movs	r3, #8
  406bba:	75fb      	strb	r3, [r7, #23]
  406bbc:	e01c      	b.n	406bf8 <ch_common_get_thresholds+0x90>
				} else if (thresh_num == 1) {
  406bbe:	7d7b      	ldrb	r3, [r7, #21]
  406bc0:	2b01      	cmp	r3, #1
  406bc2:	d102      	bne.n	406bca <ch_common_get_thresholds+0x62>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_1;
  406bc4:	2309      	movs	r3, #9
  406bc6:	75fb      	strb	r3, [r7, #23]
  406bc8:	e016      	b.n	406bf8 <ch_common_get_thresholds+0x90>
				} else if (thresh_num == 2) {
  406bca:	7d7b      	ldrb	r3, [r7, #21]
  406bcc:	2b02      	cmp	r3, #2
  406bce:	d102      	bne.n	406bd6 <ch_common_get_thresholds+0x6e>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_2;
  406bd0:	230c      	movs	r3, #12
  406bd2:	75fb      	strb	r3, [r7, #23]
  406bd4:	e010      	b.n	406bf8 <ch_common_get_thresholds+0x90>
				} else if (thresh_num == 3) {
  406bd6:	7d7b      	ldrb	r3, [r7, #21]
  406bd8:	2b03      	cmp	r3, #3
  406bda:	d102      	bne.n	406be2 <ch_common_get_thresholds+0x7a>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_3;
  406bdc:	230d      	movs	r3, #13
  406bde:	75fb      	strb	r3, [r7, #23]
  406be0:	e00a      	b.n	406bf8 <ch_common_get_thresholds+0x90>
				} else if (thresh_num == 4) {
  406be2:	7d7b      	ldrb	r3, [r7, #21]
  406be4:	2b04      	cmp	r3, #4
  406be6:	d102      	bne.n	406bee <ch_common_get_thresholds+0x86>
					thresh_len_reg = CH201_COMMON_REG_THRESH_LEN_4;
  406be8:	2315      	movs	r3, #21
  406bea:	75fb      	strb	r3, [r7, #23]
  406bec:	e004      	b.n	406bf8 <ch_common_get_thresholds+0x90>
				} else if (thresh_num == 5) {
  406bee:	7d7b      	ldrb	r3, [r7, #21]
  406bf0:	2b05      	cmp	r3, #5
  406bf2:	d101      	bne.n	406bf8 <ch_common_get_thresholds+0x90>
					thresh_len_reg = 0;			// last threshold does not have length field - assumed to extend to end of data
  406bf4:	2300      	movs	r3, #0
  406bf6:	75fb      	strb	r3, [r7, #23]
				}
			}

			if (thresh_len_reg != 0) {
  406bf8:	7dfb      	ldrb	r3, [r7, #23]
  406bfa:	2b00      	cmp	r3, #0
  406bfc:	d008      	beq.n	406c10 <ch_common_get_thresholds+0xa8>
				// read the length field register for this threshold
				chdrv_read_byte(dev_ptr, thresh_len_reg, &thresh_len);
  406bfe:	7dfb      	ldrb	r3, [r7, #23]
  406c00:	b29b      	uxth	r3, r3
  406c02:	f107 020f 	add.w	r2, r7, #15
  406c06:	4619      	mov	r1, r3
  406c08:	6878      	ldr	r0, [r7, #4]
  406c0a:	4b17      	ldr	r3, [pc, #92]	; (406c68 <ch_common_get_thresholds+0x100>)
  406c0c:	4798      	blx	r3
  406c0e:	e001      	b.n	406c14 <ch_common_get_thresholds+0xac>
			} else {
				thresh_len = 0;
  406c10:	2300      	movs	r3, #0
  406c12:	73fb      	strb	r3, [r7, #15]
			}

			thresholds_ptr->threshold[thresh_num].start_sample = start_sample;
  406c14:	7d7a      	ldrb	r2, [r7, #21]
  406c16:	683b      	ldr	r3, [r7, #0]
  406c18:	8a79      	ldrh	r1, [r7, #18]
  406c1a:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			start_sample += thresh_len;				// increment start sample for next threshold
  406c1e:	7bfb      	ldrb	r3, [r7, #15]
  406c20:	b29a      	uxth	r2, r3
  406c22:	8a7b      	ldrh	r3, [r7, #18]
  406c24:	4413      	add	r3, r2
  406c26:	827b      	strh	r3, [r7, #18]

			// get level from this threshold's entry in register array
			chdrv_read_word(dev_ptr, (thresh_level_reg + (thresh_num * sizeof(uint16_t))), 
  406c28:	7c7b      	ldrb	r3, [r7, #17]
  406c2a:	b29a      	uxth	r2, r3
  406c2c:	7d7b      	ldrb	r3, [r7, #21]
  406c2e:	b29b      	uxth	r3, r3
  406c30:	005b      	lsls	r3, r3, #1
  406c32:	b29b      	uxth	r3, r3
  406c34:	4413      	add	r3, r2
  406c36:	b299      	uxth	r1, r3
						    &(thresholds_ptr->threshold[thresh_num].level));
  406c38:	7d7b      	ldrb	r3, [r7, #21]
			chdrv_read_word(dev_ptr, (thresh_level_reg + (thresh_num * sizeof(uint16_t))), 
  406c3a:	009b      	lsls	r3, r3, #2
  406c3c:	683a      	ldr	r2, [r7, #0]
  406c3e:	4413      	add	r3, r2
  406c40:	3302      	adds	r3, #2
  406c42:	461a      	mov	r2, r3
  406c44:	6878      	ldr	r0, [r7, #4]
  406c46:	4b09      	ldr	r3, [pc, #36]	; (406c6c <ch_common_get_thresholds+0x104>)
  406c48:	4798      	blx	r3
		for (thresh_num = 0; thresh_num < max_num_thresholds; thresh_num++) {
  406c4a:	7d7b      	ldrb	r3, [r7, #21]
  406c4c:	3301      	adds	r3, #1
  406c4e:	757b      	strb	r3, [r7, #21]
  406c50:	7d7a      	ldrb	r2, [r7, #21]
  406c52:	7c3b      	ldrb	r3, [r7, #16]
  406c54:	429a      	cmp	r2, r3
  406c56:	d3a8      	bcc.n	406baa <ch_common_get_thresholds+0x42>

		}
		ret_val = 0;	// return OK
  406c58:	2300      	movs	r3, #0
  406c5a:	75bb      	strb	r3, [r7, #22]
	}
	return ret_val;
  406c5c:	7dbb      	ldrb	r3, [r7, #22]
}
  406c5e:	4618      	mov	r0, r3
  406c60:	3718      	adds	r7, #24
  406c62:	46bd      	mov	sp, r7
  406c64:	bd80      	pop	{r7, pc}
  406c66:	bf00      	nop
  406c68:	004073b1 	.word	0x004073b1
  406c6c:	00407409 	.word	0x00407409

00406c70 <get_sample_data>:


static uint8_t get_sample_data(ch_dev_t *dev_ptr, ch_iq_sample_t *buf_ptr, uint16_t start_sample, uint16_t num_samples,
							   ch_io_mode_t mode, uint8_t sample_size_in_bytes) {
  406c70:	b590      	push	{r4, r7, lr}
  406c72:	b093      	sub	sp, #76	; 0x4c
  406c74:	af04      	add	r7, sp, #16
  406c76:	60f8      	str	r0, [r7, #12]
  406c78:	60b9      	str	r1, [r7, #8]
  406c7a:	4611      	mov	r1, r2
  406c7c:	461a      	mov	r2, r3
  406c7e:	460b      	mov	r3, r1
  406c80:	80fb      	strh	r3, [r7, #6]
  406c82:	4613      	mov	r3, r2
  406c84:	80bb      	strh	r3, [r7, #4]

	uint16_t   iq_data_addr;
	ch_group_t *grp_ptr = dev_ptr->group;
  406c86:	68fb      	ldr	r3, [r7, #12]
  406c88:	681b      	ldr	r3, [r3, #0]
  406c8a:	623b      	str	r3, [r7, #32]
	int        error = 1;
  406c8c:	2301      	movs	r3, #1
  406c8e:	633b      	str	r3, [r7, #48]	; 0x30
	uint8_t	   use_prog_read = 0;		// default = do not use low-level programming interface
  406c90:	2300      	movs	r3, #0
  406c92:	77fb      	strb	r3, [r7, #31]
	if (grp_ptr->num_connected[dev_ptr->i2c_bus_index] == 1) {		// if only one device on this bus
		use_prog_read = 1;											//   use low-level interface
	}
#endif

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406c94:	68fb      	ldr	r3, [r7, #12]
  406c96:	8b9b      	ldrh	r3, [r3, #28]
  406c98:	2b65      	cmp	r3, #101	; 0x65
  406c9a:	d102      	bne.n	406ca2 <get_sample_data+0x32>
		iq_data_addr = CH101_COMMON_REG_DATA;
  406c9c:	231c      	movs	r3, #28
  406c9e:	86fb      	strh	r3, [r7, #54]	; 0x36
  406ca0:	e001      	b.n	406ca6 <get_sample_data+0x36>
	} else {
		iq_data_addr = CH201_COMMON_REG_DATA;
  406ca2:	2328      	movs	r3, #40	; 0x28
  406ca4:	86fb      	strh	r3, [r7, #54]	; 0x36
	}

	iq_data_addr += (start_sample * sample_size_in_bytes);
  406ca6:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
  406caa:	b29b      	uxth	r3, r3
  406cac:	88fa      	ldrh	r2, [r7, #6]
  406cae:	fb12 f303 	smulbb	r3, r2, r3
  406cb2:	b29a      	uxth	r2, r3
  406cb4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406cb6:	4413      	add	r3, r2
  406cb8:	86fb      	strh	r3, [r7, #54]	; 0x36

	if ((num_samples != 0) && ((start_sample + num_samples) <= dev_ptr->max_samples)) {
  406cba:	88bb      	ldrh	r3, [r7, #4]
  406cbc:	2b00      	cmp	r3, #0
  406cbe:	f000 80b3 	beq.w	406e28 <get_sample_data+0x1b8>
  406cc2:	88fa      	ldrh	r2, [r7, #6]
  406cc4:	88bb      	ldrh	r3, [r7, #4]
  406cc6:	4413      	add	r3, r2
  406cc8:	68fa      	ldr	r2, [r7, #12]
  406cca:	8c52      	ldrh	r2, [r2, #34]	; 0x22
  406ccc:	4293      	cmp	r3, r2
  406cce:	f300 80ab 	bgt.w	406e28 <get_sample_data+0x1b8>
		uint16_t num_bytes = (num_samples * sample_size_in_bytes);
  406cd2:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
  406cd6:	b29b      	uxth	r3, r3
  406cd8:	88ba      	ldrh	r2, [r7, #4]
  406cda:	fb12 f303 	smulbb	r3, r2, r3
  406cde:	83bb      	strh	r3, [r7, #28]

		if (mode == CH_IO_MODE_BLOCK) {
  406ce0:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
  406ce4:	2b00      	cmp	r3, #0
  406ce6:	d16e      	bne.n	406dc6 <get_sample_data+0x156>
			/* blocking transfer */

			if (use_prog_read) {
  406ce8:	7ffb      	ldrb	r3, [r7, #31]
  406cea:	2b00      	cmp	r3, #0
  406cec:	d063      	beq.n	406db6 <get_sample_data+0x146>
				/* use low-level programming interface for speed */

				int num_transfers = (num_bytes + (CH_PROG_XFER_SIZE - 1)) / CH_PROG_XFER_SIZE;
  406cee:	8bbb      	ldrh	r3, [r7, #28]
  406cf0:	33ff      	adds	r3, #255	; 0xff
  406cf2:	2b00      	cmp	r3, #0
  406cf4:	da00      	bge.n	406cf8 <get_sample_data+0x88>
  406cf6:	33ff      	adds	r3, #255	; 0xff
  406cf8:	121b      	asrs	r3, r3, #8
  406cfa:	61bb      	str	r3, [r7, #24]
    			int bytes_left = num_bytes;       // remaining bytes to read
  406cfc:	8bbb      	ldrh	r3, [r7, #28]
  406cfe:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* Convert register offsets to full memory addresses */
				if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406d00:	68fb      	ldr	r3, [r7, #12]
  406d02:	8b9b      	ldrh	r3, [r3, #28]
  406d04:	2b65      	cmp	r3, #101	; 0x65
  406d06:	d104      	bne.n	406d12 <get_sample_data+0xa2>
					iq_data_addr += CH101_DATA_MEM_ADDR + CH101_COMMON_I2CREGS_OFFSET;
  406d08:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406d0a:	f503 7300 	add.w	r3, r3, #512	; 0x200
  406d0e:	86fb      	strh	r3, [r7, #54]	; 0x36
  406d10:	e003      	b.n	406d1a <get_sample_data+0xaa>
				} else {
					iq_data_addr += CH201_DATA_MEM_ADDR + CH201_COMMON_I2CREGS_OFFSET;
  406d12:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406d14:	f503 7300 	add.w	r3, r3, #512	; 0x200
  406d18:	86fb      	strh	r3, [r7, #54]	; 0x36
				}

				chbsp_program_enable(dev_ptr);					// assert PROG pin
  406d1a:	68f8      	ldr	r0, [r7, #12]
  406d1c:	4b45      	ldr	r3, [pc, #276]	; (406e34 <get_sample_data+0x1c4>)
  406d1e:	4798      	blx	r3

    			for (int xfer = 0; xfer < num_transfers; xfer++) {
  406d20:	2300      	movs	r3, #0
  406d22:	62bb      	str	r3, [r7, #40]	; 0x28
  406d24:	e03f      	b.n	406da6 <get_sample_data+0x136>
        			int bytes_to_read;
        			uint8_t message[] = { (0x80 | CH_PROG_REG_CTL), 0x09 };      // read burst command
  406d26:	4b44      	ldr	r3, [pc, #272]	; (406e38 <get_sample_data+0x1c8>)
  406d28:	881b      	ldrh	r3, [r3, #0]
  406d2a:	82bb      	strh	r3, [r7, #20]

        			if (bytes_left > CH_PROG_XFER_SIZE) {
  406d2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  406d2e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  406d32:	dd03      	ble.n	406d3c <get_sample_data+0xcc>
                		bytes_to_read = CH_PROG_XFER_SIZE;
  406d34:	f44f 7380 	mov.w	r3, #256	; 0x100
  406d38:	627b      	str	r3, [r7, #36]	; 0x24
  406d3a:	e001      	b.n	406d40 <get_sample_data+0xd0>
        			} else {
                		bytes_to_read = bytes_left;
  406d3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  406d3e:	627b      	str	r3, [r7, #36]	; 0x24
        			}
        			chdrv_prog_write(dev_ptr, CH_PROG_REG_ADDR, (iq_data_addr + (xfer * CH_PROG_XFER_SIZE)));
  406d40:	6abb      	ldr	r3, [r7, #40]	; 0x28
  406d42:	b29b      	uxth	r3, r3
  406d44:	021b      	lsls	r3, r3, #8
  406d46:	b29a      	uxth	r2, r3
  406d48:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406d4a:	4413      	add	r3, r2
  406d4c:	b29b      	uxth	r3, r3
  406d4e:	461a      	mov	r2, r3
  406d50:	2105      	movs	r1, #5
  406d52:	68f8      	ldr	r0, [r7, #12]
  406d54:	4b39      	ldr	r3, [pc, #228]	; (406e3c <get_sample_data+0x1cc>)
  406d56:	4798      	blx	r3
        			chdrv_prog_write(dev_ptr, CH_PROG_REG_CNT, (bytes_to_read - 1));
  406d58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406d5a:	b29b      	uxth	r3, r3
  406d5c:	3b01      	subs	r3, #1
  406d5e:	b29b      	uxth	r3, r3
  406d60:	461a      	mov	r2, r3
  406d62:	2107      	movs	r1, #7
  406d64:	68f8      	ldr	r0, [r7, #12]
  406d66:	4b35      	ldr	r3, [pc, #212]	; (406e3c <get_sample_data+0x1cc>)
  406d68:	4798      	blx	r3
        			error = chdrv_prog_i2c_write(dev_ptr, message, sizeof(message));
  406d6a:	f107 0314 	add.w	r3, r7, #20
  406d6e:	2202      	movs	r2, #2
  406d70:	4619      	mov	r1, r3
  406d72:	68f8      	ldr	r0, [r7, #12]
  406d74:	4b32      	ldr	r3, [pc, #200]	; (406e40 <get_sample_data+0x1d0>)
  406d76:	4798      	blx	r3
  406d78:	6338      	str	r0, [r7, #48]	; 0x30
        			error |= chdrv_prog_i2c_read(dev_ptr, ((uint8_t *)buf_ptr + (xfer * CH_PROG_XFER_SIZE)), bytes_to_read);
  406d7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  406d7c:	021b      	lsls	r3, r3, #8
  406d7e:	461a      	mov	r2, r3
  406d80:	68bb      	ldr	r3, [r7, #8]
  406d82:	4413      	add	r3, r2
  406d84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406d86:	b292      	uxth	r2, r2
  406d88:	4619      	mov	r1, r3
  406d8a:	68f8      	ldr	r0, [r7, #12]
  406d8c:	4b2d      	ldr	r3, [pc, #180]	; (406e44 <get_sample_data+0x1d4>)
  406d8e:	4798      	blx	r3
  406d90:	4602      	mov	r2, r0
  406d92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406d94:	4313      	orrs	r3, r2
  406d96:	633b      	str	r3, [r7, #48]	; 0x30

        			bytes_left -= bytes_to_read;
  406d98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  406d9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  406d9c:	1ad3      	subs	r3, r2, r3
  406d9e:	62fb      	str	r3, [r7, #44]	; 0x2c
    			for (int xfer = 0; xfer < num_transfers; xfer++) {
  406da0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  406da2:	3301      	adds	r3, #1
  406da4:	62bb      	str	r3, [r7, #40]	; 0x28
  406da6:	6aba      	ldr	r2, [r7, #40]	; 0x28
  406da8:	69bb      	ldr	r3, [r7, #24]
  406daa:	429a      	cmp	r2, r3
  406dac:	dbbb      	blt.n	406d26 <get_sample_data+0xb6>
    			}
    			chbsp_program_disable(dev_ptr);					// de-assert PROG pin
  406dae:	68f8      	ldr	r0, [r7, #12]
  406db0:	4b25      	ldr	r3, [pc, #148]	; (406e48 <get_sample_data+0x1d8>)
  406db2:	4798      	blx	r3
  406db4:	e038      	b.n	406e28 <get_sample_data+0x1b8>

			} else {	/* if (use_prog_read) */
				/* use standard I2C interface */

				error = chdrv_burst_read(dev_ptr, iq_data_addr, (uint8_t *) buf_ptr, num_bytes);
  406db6:	8bbb      	ldrh	r3, [r7, #28]
  406db8:	8ef9      	ldrh	r1, [r7, #54]	; 0x36
  406dba:	68ba      	ldr	r2, [r7, #8]
  406dbc:	68f8      	ldr	r0, [r7, #12]
  406dbe:	4c23      	ldr	r4, [pc, #140]	; (406e4c <get_sample_data+0x1dc>)
  406dc0:	47a0      	blx	r4
  406dc2:	6338      	str	r0, [r7, #48]	; 0x30
  406dc4:	e030      	b.n	406e28 <get_sample_data+0x1b8>
			}

		} else {
			/* non-blocking transfer - queue a read transaction (must be started using ch_io_start_nb() ) */

			if (use_prog_read && (grp_ptr->i2c_drv_flags & I2C_DRV_FLAG_USE_PROG_NB)) {
  406dc6:	7ffb      	ldrb	r3, [r7, #31]
  406dc8:	2b00      	cmp	r3, #0
  406dca:	d020      	beq.n	406e0e <get_sample_data+0x19e>
  406dcc:	6a3b      	ldr	r3, [r7, #32]
  406dce:	889b      	ldrh	r3, [r3, #4]
  406dd0:	f003 0302 	and.w	r3, r3, #2
  406dd4:	2b00      	cmp	r3, #0
  406dd6:	d01a      	beq.n	406e0e <get_sample_data+0x19e>
				/* Use low-level programming interface to read data */

				/* Convert register offsets to full memory addresses */
				if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406dd8:	68fb      	ldr	r3, [r7, #12]
  406dda:	8b9b      	ldrh	r3, [r3, #28]
  406ddc:	2b65      	cmp	r3, #101	; 0x65
  406dde:	d104      	bne.n	406dea <get_sample_data+0x17a>
					iq_data_addr += (CH101_DATA_MEM_ADDR + CH101_COMMON_I2CREGS_OFFSET);
  406de0:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406de2:	f503 7300 	add.w	r3, r3, #512	; 0x200
  406de6:	86fb      	strh	r3, [r7, #54]	; 0x36
  406de8:	e003      	b.n	406df2 <get_sample_data+0x182>
				} else {
					iq_data_addr += (CH201_DATA_MEM_ADDR + CH201_COMMON_I2CREGS_OFFSET);
  406dea:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406dec:	f503 7300 	add.w	r3, r3, #512	; 0x200
  406df0:	86fb      	strh	r3, [r7, #54]	; 0x36
				}

				error = chdrv_group_i2c_queue(grp_ptr, dev_ptr, 1, CHDRV_NB_TRANS_TYPE_PROG, iq_data_addr, num_bytes, 
  406df2:	68bb      	ldr	r3, [r7, #8]
  406df4:	9302      	str	r3, [sp, #8]
  406df6:	8bbb      	ldrh	r3, [r7, #28]
  406df8:	9301      	str	r3, [sp, #4]
  406dfa:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406dfc:	9300      	str	r3, [sp, #0]
  406dfe:	2301      	movs	r3, #1
  406e00:	2201      	movs	r2, #1
  406e02:	68f9      	ldr	r1, [r7, #12]
  406e04:	6a38      	ldr	r0, [r7, #32]
  406e06:	4c12      	ldr	r4, [pc, #72]	; (406e50 <get_sample_data+0x1e0>)
  406e08:	47a0      	blx	r4
  406e0a:	6338      	str	r0, [r7, #48]	; 0x30
  406e0c:	e00c      	b.n	406e28 <get_sample_data+0x1b8>
					                      	(uint8_t *) buf_ptr);
			} else {
				/* Use regular I2C register interface to read data */
				error = chdrv_group_i2c_queue(grp_ptr, dev_ptr, 1, CHDRV_NB_TRANS_TYPE_STD, iq_data_addr, num_bytes, 
  406e0e:	68bb      	ldr	r3, [r7, #8]
  406e10:	9302      	str	r3, [sp, #8]
  406e12:	8bbb      	ldrh	r3, [r7, #28]
  406e14:	9301      	str	r3, [sp, #4]
  406e16:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  406e18:	9300      	str	r3, [sp, #0]
  406e1a:	2300      	movs	r3, #0
  406e1c:	2201      	movs	r2, #1
  406e1e:	68f9      	ldr	r1, [r7, #12]
  406e20:	6a38      	ldr	r0, [r7, #32]
  406e22:	4c0b      	ldr	r4, [pc, #44]	; (406e50 <get_sample_data+0x1e0>)
  406e24:	47a0      	blx	r4
  406e26:	6338      	str	r0, [r7, #48]	; 0x30
											  (uint8_t*) buf_ptr);
			}
		}
	}

	return error;
  406e28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  406e2a:	b2db      	uxtb	r3, r3
}
  406e2c:	4618      	mov	r0, r3
  406e2e:	373c      	adds	r7, #60	; 0x3c
  406e30:	46bd      	mov	sp, r7
  406e32:	bd90      	pop	{r4, r7, pc}
  406e34:	004020d5 	.word	0x004020d5
  406e38:	0040dc14 	.word	0x0040dc14
  406e3c:	00407aad 	.word	0x00407aad
  406e40:	0040728d 	.word	0x0040728d
  406e44:	004072c5 	.word	0x004072c5
  406e48:	0040210d 	.word	0x0040210d
  406e4c:	004073d9 	.word	0x004073d9
  406e50:	0040755d 	.word	0x0040755d

00406e54 <ch_common_set_sample_window>:

uint8_t	 ch_common_set_sample_window(ch_dev_t *dev_ptr, uint16_t start_sample, uint16_t num_samples) {
  406e54:	b480      	push	{r7}
  406e56:	b085      	sub	sp, #20
  406e58:	af00      	add	r7, sp, #0
  406e5a:	6078      	str	r0, [r7, #4]
  406e5c:	460b      	mov	r3, r1
  406e5e:	807b      	strh	r3, [r7, #2]
  406e60:	4613      	mov	r3, r2
  406e62:	803b      	strh	r3, [r7, #0]
	uint8_t err = 1;
  406e64:	2301      	movs	r3, #1
  406e66:	73fb      	strb	r3, [r7, #15]
	uint16_t max_num_samples;


	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  406e68:	687b      	ldr	r3, [r7, #4]
  406e6a:	8b9b      	ldrh	r3, [r3, #28]
  406e6c:	2b65      	cmp	r3, #101	; 0x65
  406e6e:	d102      	bne.n	406e76 <ch_common_set_sample_window+0x22>
		max_num_samples = CH101_MAX_NUM_SAMPLES;
  406e70:	23e1      	movs	r3, #225	; 0xe1
  406e72:	81bb      	strh	r3, [r7, #12]
  406e74:	e002      	b.n	406e7c <ch_common_set_sample_window+0x28>
	} else {
		max_num_samples = CH201_MAX_NUM_SAMPLES;
  406e76:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
  406e7a:	81bb      	strh	r3, [r7, #12]
	}

	if ((start_sample + num_samples) <= max_num_samples) {
  406e7c:	887a      	ldrh	r2, [r7, #2]
  406e7e:	883b      	ldrh	r3, [r7, #0]
  406e80:	441a      	add	r2, r3
  406e82:	89bb      	ldrh	r3, [r7, #12]
  406e84:	429a      	cmp	r2, r3
  406e86:	dc07      	bgt.n	406e98 <ch_common_set_sample_window+0x44>
		dev_ptr->win_start_sample = start_sample;
  406e88:	687b      	ldr	r3, [r7, #4]
  406e8a:	887a      	ldrh	r2, [r7, #2]
  406e8c:	84da      	strh	r2, [r3, #38]	; 0x26
		dev_ptr->num_win_samples = num_samples;
  406e8e:	687b      	ldr	r3, [r7, #4]
  406e90:	883a      	ldrh	r2, [r7, #0]
  406e92:	851a      	strh	r2, [r3, #40]	; 0x28

		err = 0;
  406e94:	2300      	movs	r3, #0
  406e96:	73fb      	strb	r3, [r7, #15]
	}

	return err;
  406e98:	7bfb      	ldrb	r3, [r7, #15]
}
  406e9a:	4618      	mov	r0, r3
  406e9c:	3714      	adds	r7, #20
  406e9e:	46bd      	mov	sp, r7
  406ea0:	f85d 7b04 	ldr.w	r7, [sp], #4
  406ea4:	4770      	bx	lr
	...

00406ea8 <ch_common_get_amplitude_avg>:


uint16_t ch_common_get_amplitude_avg(ch_dev_t *dev_ptr) {
  406ea8:	b590      	push	{r4, r7, lr}
  406eaa:	b0c9      	sub	sp, #292	; 0x124
  406eac:	af02      	add	r7, sp, #8
  406eae:	1d3b      	adds	r3, r7, #4
  406eb0:	6018      	str	r0, [r3, #0]
	ch_iq_sample_t window_buf[CH_IQ_SAMPLES_PER_READ];
	uint16_t start_sample = dev_ptr->win_start_sample;
  406eb2:	1d3b      	adds	r3, r7, #4
  406eb4:	681b      	ldr	r3, [r3, #0]
  406eb6:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  406eb8:	f8a7 310c 	strh.w	r3, [r7, #268]	; 0x10c
	uint16_t num_samples = dev_ptr->num_win_samples;
  406ebc:	1d3b      	adds	r3, r7, #4
  406ebe:	681b      	ldr	r3, [r3, #0]
  406ec0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
  406ec2:	f8a7 310a 	strh.w	r3, [r7, #266]	; 0x10a
	uint32_t total_amp = 0;
  406ec6:	2300      	movs	r3, #0
  406ec8:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
	uint32_t avg_amp = 0;
  406ecc:	2300      	movs	r3, #0
  406ece:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
	uint8_t err = 0;
  406ed2:	2300      	movs	r3, #0
  406ed4:	f887 3109 	strb.w	r3, [r7, #265]	; 0x109

	if ((start_sample != 0) && (num_samples != 0)) {
  406ed8:	f8b7 310c 	ldrh.w	r3, [r7, #268]	; 0x10c
  406edc:	2b00      	cmp	r3, #0
  406ede:	d03e      	beq.n	406f5e <ch_common_get_amplitude_avg+0xb6>
  406ee0:	f8b7 310a 	ldrh.w	r3, [r7, #266]	; 0x10a
  406ee4:	2b00      	cmp	r3, #0
  406ee6:	d03a      	beq.n	406f5e <ch_common_get_amplitude_avg+0xb6>

		err = ch_get_iq_data(dev_ptr, window_buf, start_sample, num_samples, CH_IO_MODE_BLOCK);
  406ee8:	f8b7 410a 	ldrh.w	r4, [r7, #266]	; 0x10a
  406eec:	f8b7 210c 	ldrh.w	r2, [r7, #268]	; 0x10c
  406ef0:	f107 0108 	add.w	r1, r7, #8
  406ef4:	1d38      	adds	r0, r7, #4
  406ef6:	2300      	movs	r3, #0
  406ef8:	9300      	str	r3, [sp, #0]
  406efa:	4623      	mov	r3, r4
  406efc:	6800      	ldr	r0, [r0, #0]
  406efe:	4c1c      	ldr	r4, [pc, #112]	; (406f70 <ch_common_get_amplitude_avg+0xc8>)
  406f00:	47a0      	blx	r4
  406f02:	4603      	mov	r3, r0
  406f04:	f887 3109 	strb.w	r3, [r7, #265]	; 0x109

		if (!err) {
  406f08:	f897 3109 	ldrb.w	r3, [r7, #265]	; 0x109
  406f0c:	2b00      	cmp	r3, #0
  406f0e:	d126      	bne.n	406f5e <ch_common_get_amplitude_avg+0xb6>
			for (uint16_t idx = 0; idx < num_samples; idx++) {
  406f10:	2300      	movs	r3, #0
  406f12:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
  406f16:	e014      	b.n	406f42 <ch_common_get_amplitude_avg+0x9a>
				total_amp += ch_iq_to_amplitude(&(window_buf[idx]));		// add amplitude for this sample
  406f18:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
  406f1c:	f107 0208 	add.w	r2, r7, #8
  406f20:	009b      	lsls	r3, r3, #2
  406f22:	4413      	add	r3, r2
  406f24:	4618      	mov	r0, r3
  406f26:	4b13      	ldr	r3, [pc, #76]	; (406f74 <ch_common_get_amplitude_avg+0xcc>)
  406f28:	4798      	blx	r3
  406f2a:	4603      	mov	r3, r0
  406f2c:	461a      	mov	r2, r3
  406f2e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
  406f32:	4413      	add	r3, r2
  406f34:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
			for (uint16_t idx = 0; idx < num_samples; idx++) {
  406f38:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
  406f3c:	3301      	adds	r3, #1
  406f3e:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
  406f42:	f8b7 210e 	ldrh.w	r2, [r7, #270]	; 0x10e
  406f46:	f8b7 310a 	ldrh.w	r3, [r7, #266]	; 0x10a
  406f4a:	429a      	cmp	r2, r3
  406f4c:	d3e4      	bcc.n	406f18 <ch_common_get_amplitude_avg+0x70>
			}

		avg_amp = (total_amp / num_samples);
  406f4e:	f8b7 310a 	ldrh.w	r3, [r7, #266]	; 0x10a
  406f52:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
  406f56:	fbb2 f3f3 	udiv	r3, r2, r3
  406f5a:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
		}
	}

	return (uint16_t) avg_amp;
  406f5e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
  406f62:	b29b      	uxth	r3, r3
}
  406f64:	4618      	mov	r0, r3
  406f66:	f507 778e 	add.w	r7, r7, #284	; 0x11c
  406f6a:	46bd      	mov	sp, r7
  406f6c:	bd90      	pop	{r4, r7, pc}
  406f6e:	bf00      	nop
  406f70:	00405dc1 	.word	0x00405dc1
  406f74:	00405e45 	.word	0x00405e45

00406f78 <ch_common_get_iq_data>:

uint8_t  ch_common_get_iq_data(ch_dev_t *dev_ptr, ch_iq_sample_t *buf_ptr, uint16_t start_sample, uint16_t num_samples,
							   ch_io_mode_t mode) {
  406f78:	b590      	push	{r4, r7, lr}
  406f7a:	b087      	sub	sp, #28
  406f7c:	af02      	add	r7, sp, #8
  406f7e:	60f8      	str	r0, [r7, #12]
  406f80:	60b9      	str	r1, [r7, #8]
  406f82:	4611      	mov	r1, r2
  406f84:	461a      	mov	r2, r3
  406f86:	460b      	mov	r3, r1
  406f88:	80fb      	strh	r3, [r7, #6]
  406f8a:	4613      	mov	r3, r2
  406f8c:	80bb      	strh	r3, [r7, #4]

	return get_sample_data(dev_ptr, buf_ptr, start_sample, num_samples, mode, sizeof(ch_iq_sample_t));
  406f8e:	88b9      	ldrh	r1, [r7, #4]
  406f90:	88fa      	ldrh	r2, [r7, #6]
  406f92:	2304      	movs	r3, #4
  406f94:	9301      	str	r3, [sp, #4]
  406f96:	f897 3020 	ldrb.w	r3, [r7, #32]
  406f9a:	9300      	str	r3, [sp, #0]
  406f9c:	460b      	mov	r3, r1
  406f9e:	68b9      	ldr	r1, [r7, #8]
  406fa0:	68f8      	ldr	r0, [r7, #12]
  406fa2:	4c03      	ldr	r4, [pc, #12]	; (406fb0 <ch_common_get_iq_data+0x38>)
  406fa4:	47a0      	blx	r4
  406fa6:	4603      	mov	r3, r0
}
  406fa8:	4618      	mov	r0, r3
  406faa:	3714      	adds	r7, #20
  406fac:	46bd      	mov	sp, r7
  406fae:	bd90      	pop	{r4, r7, pc}
  406fb0:	00406c71 	.word	0x00406c71

00406fb4 <ch_common_get_amplitude_data>:


uint8_t ch_common_get_amplitude_data(ch_dev_t *dev_ptr, uint16_t *buf_ptr, uint16_t start_sample, uint16_t num_samples,
									 ch_io_mode_t mode) {
  406fb4:	b590      	push	{r4, r7, lr}
  406fb6:	b0cb      	sub	sp, #300	; 0x12c
  406fb8:	af02      	add	r7, sp, #8
  406fba:	f107 040c 	add.w	r4, r7, #12
  406fbe:	6020      	str	r0, [r4, #0]
  406fc0:	f107 0008 	add.w	r0, r7, #8
  406fc4:	6001      	str	r1, [r0, #0]
  406fc6:	4619      	mov	r1, r3
  406fc8:	1dbb      	adds	r3, r7, #6
  406fca:	801a      	strh	r2, [r3, #0]
  406fcc:	1d3b      	adds	r3, r7, #4
  406fce:	460a      	mov	r2, r1
  406fd0:	801a      	strh	r2, [r3, #0]

	ch_iq_sample_t	iq_buf[CH_IQ_SAMPLES_PER_READ];
	uint16_t		samples_in_chunk = 0;
  406fd2:	2300      	movs	r3, #0
  406fd4:	f8a7 311e 	strh.w	r3, [r7, #286]	; 0x11e
	uint8_t			error = 0;
  406fd8:	2300      	movs	r3, #0
  406fda:	f887 311d 	strb.w	r3, [r7, #285]	; 0x11d
	uint16_t		sample_num   = start_sample;
  406fde:	1dbb      	adds	r3, r7, #6
  406fe0:	881b      	ldrh	r3, [r3, #0]
  406fe2:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
	uint16_t		samples_left = num_samples;
  406fe6:	1d3b      	adds	r3, r7, #4
  406fe8:	881b      	ldrh	r3, [r3, #0]
  406fea:	f8a7 3118 	strh.w	r3, [r7, #280]	; 0x118
	uint8_t 		chunks_left  = (num_samples + CH_IQ_SAMPLES_PER_READ - 1) / CH_IQ_SAMPLES_PER_READ;
  406fee:	1d3b      	adds	r3, r7, #4
  406ff0:	881b      	ldrh	r3, [r3, #0]
  406ff2:	333f      	adds	r3, #63	; 0x3f
  406ff4:	2b00      	cmp	r3, #0
  406ff6:	da00      	bge.n	406ffa <ch_common_get_amplitude_data+0x46>
  406ff8:	333f      	adds	r3, #63	; 0x3f
  406ffa:	119b      	asrs	r3, r3, #6
  406ffc:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117

	/* Validate mode (only blocking mode is supported) and sample count/offset */
	if ((mode != CH_IO_MODE_BLOCK) || (start_sample + num_samples > dev_ptr->max_samples)) {
  407000:	f897 3130 	ldrb.w	r3, [r7, #304]	; 0x130
  407004:	2b00      	cmp	r3, #0
  407006:	d10a      	bne.n	40701e <ch_common_get_amplitude_data+0x6a>
  407008:	1dbb      	adds	r3, r7, #6
  40700a:	881a      	ldrh	r2, [r3, #0]
  40700c:	1d3b      	adds	r3, r7, #4
  40700e:	881b      	ldrh	r3, [r3, #0]
  407010:	4413      	add	r3, r2
  407012:	f107 020c 	add.w	r2, r7, #12
  407016:	6812      	ldr	r2, [r2, #0]
  407018:	8c52      	ldrh	r2, [r2, #34]	; 0x22
  40701a:	4293      	cmp	r3, r2
  40701c:	dd52      	ble.n	4070c4 <ch_common_get_amplitude_data+0x110>
		error = 1;
  40701e:	2301      	movs	r3, #1
  407020:	f887 311d 	strb.w	r3, [r7, #285]	; 0x11d
	}

	while (!error && (chunks_left-- > 0)) {
  407024:	e04e      	b.n	4070c4 <ch_common_get_amplitude_data+0x110>

		/* Read I/Q data */
		if (samples_left > CH_IQ_SAMPLES_PER_READ) {
  407026:	f8b7 3118 	ldrh.w	r3, [r7, #280]	; 0x118
  40702a:	2b40      	cmp	r3, #64	; 0x40
  40702c:	d903      	bls.n	407036 <ch_common_get_amplitude_data+0x82>
			samples_in_chunk = CH_IQ_SAMPLES_PER_READ;
  40702e:	2340      	movs	r3, #64	; 0x40
  407030:	f8a7 311e 	strh.w	r3, [r7, #286]	; 0x11e
  407034:	e003      	b.n	40703e <ch_common_get_amplitude_data+0x8a>
		} else {
			samples_in_chunk = samples_left;
  407036:	f8b7 3118 	ldrh.w	r3, [r7, #280]	; 0x118
  40703a:	f8a7 311e 	strh.w	r3, [r7, #286]	; 0x11e
		}

		samples_left -= samples_in_chunk;			// adjust remaining sample count for next pass
  40703e:	f8b7 2118 	ldrh.w	r2, [r7, #280]	; 0x118
  407042:	f8b7 311e 	ldrh.w	r3, [r7, #286]	; 0x11e
  407046:	1ad3      	subs	r3, r2, r3
  407048:	f8a7 3118 	strh.w	r3, [r7, #280]	; 0x118

		error = get_sample_data(dev_ptr, iq_buf, sample_num, samples_in_chunk, mode, sizeof(ch_iq_sample_t));
  40704c:	f8b7 411e 	ldrh.w	r4, [r7, #286]	; 0x11e
  407050:	f8b7 211a 	ldrh.w	r2, [r7, #282]	; 0x11a
  407054:	f107 0114 	add.w	r1, r7, #20
  407058:	f107 000c 	add.w	r0, r7, #12
  40705c:	2304      	movs	r3, #4
  40705e:	9301      	str	r3, [sp, #4]
  407060:	f897 3130 	ldrb.w	r3, [r7, #304]	; 0x130
  407064:	9300      	str	r3, [sp, #0]
  407066:	4623      	mov	r3, r4
  407068:	6800      	ldr	r0, [r0, #0]
  40706a:	4c20      	ldr	r4, [pc, #128]	; (4070ec <ch_common_get_amplitude_data+0x138>)
  40706c:	47a0      	blx	r4
  40706e:	4603      	mov	r3, r0
  407070:	f887 311d 	strb.w	r3, [r7, #285]	; 0x11d
		if (error) {
  407074:	f897 311d 	ldrb.w	r3, [r7, #285]	; 0x11d
  407078:	2b00      	cmp	r3, #0
  40707a:	d12f      	bne.n	4070dc <ch_common_get_amplitude_data+0x128>
			break;
		}

		/* Calculate amplitudes and store in user buffer */
		for (uint16_t idx = 0; idx < samples_in_chunk; idx++) {
  40707c:	2300      	movs	r3, #0
  40707e:	f8a7 3114 	strh.w	r3, [r7, #276]	; 0x114
  407082:	e019      	b.n	4070b8 <ch_common_get_amplitude_data+0x104>
			buf_ptr[sample_num++] = ch_iq_to_amplitude(&iq_buf[idx]);
  407084:	f8b7 311a 	ldrh.w	r3, [r7, #282]	; 0x11a
  407088:	1c5a      	adds	r2, r3, #1
  40708a:	f8a7 211a 	strh.w	r2, [r7, #282]	; 0x11a
  40708e:	005b      	lsls	r3, r3, #1
  407090:	f107 0208 	add.w	r2, r7, #8
  407094:	6812      	ldr	r2, [r2, #0]
  407096:	18d4      	adds	r4, r2, r3
  407098:	f8b7 3114 	ldrh.w	r3, [r7, #276]	; 0x114
  40709c:	f107 0214 	add.w	r2, r7, #20
  4070a0:	009b      	lsls	r3, r3, #2
  4070a2:	4413      	add	r3, r2
  4070a4:	4618      	mov	r0, r3
  4070a6:	4b12      	ldr	r3, [pc, #72]	; (4070f0 <ch_common_get_amplitude_data+0x13c>)
  4070a8:	4798      	blx	r3
  4070aa:	4603      	mov	r3, r0
  4070ac:	8023      	strh	r3, [r4, #0]
		for (uint16_t idx = 0; idx < samples_in_chunk; idx++) {
  4070ae:	f8b7 3114 	ldrh.w	r3, [r7, #276]	; 0x114
  4070b2:	3301      	adds	r3, #1
  4070b4:	f8a7 3114 	strh.w	r3, [r7, #276]	; 0x114
  4070b8:	f8b7 2114 	ldrh.w	r2, [r7, #276]	; 0x114
  4070bc:	f8b7 311e 	ldrh.w	r3, [r7, #286]	; 0x11e
  4070c0:	429a      	cmp	r2, r3
  4070c2:	d3df      	bcc.n	407084 <ch_common_get_amplitude_data+0xd0>
	while (!error && (chunks_left-- > 0)) {
  4070c4:	f897 311d 	ldrb.w	r3, [r7, #285]	; 0x11d
  4070c8:	2b00      	cmp	r3, #0
  4070ca:	d108      	bne.n	4070de <ch_common_get_amplitude_data+0x12a>
  4070cc:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
  4070d0:	1e5a      	subs	r2, r3, #1
  4070d2:	f887 2117 	strb.w	r2, [r7, #279]	; 0x117
  4070d6:	2b00      	cmp	r3, #0
  4070d8:	d1a5      	bne.n	407026 <ch_common_get_amplitude_data+0x72>
  4070da:	e000      	b.n	4070de <ch_common_get_amplitude_data+0x12a>
			break;
  4070dc:	bf00      	nop
		}

	}

	return error;
  4070de:	f897 311d 	ldrb.w	r3, [r7, #285]	; 0x11d
}
  4070e2:	4618      	mov	r0, r3
  4070e4:	f507 7792 	add.w	r7, r7, #292	; 0x124
  4070e8:	46bd      	mov	sp, r7
  4070ea:	bd90      	pop	{r4, r7, pc}
  4070ec:	00406c71 	.word	0x00406c71
  4070f0:	00405e45 	.word	0x00405e45

004070f4 <ch_common_set_rx_holdoff>:

	return (ch_time_plan_t) time_plan;
}


uint8_t ch_common_set_rx_holdoff(ch_dev_t *dev_ptr, uint16_t num_samples) {
  4070f4:	b580      	push	{r7, lr}
  4070f6:	b084      	sub	sp, #16
  4070f8:	af00      	add	r7, sp, #0
  4070fa:	6078      	str	r0, [r7, #4]
  4070fc:	460b      	mov	r3, r1
  4070fe:	807b      	strh	r3, [r7, #2]
	uint8_t rx_holdoff_reg;
	uint16_t reg_value;
	uint8_t ret_val = RET_OK;
  407100:	2300      	movs	r3, #0
  407102:	72fb      	strb	r3, [r7, #11]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  407104:	687b      	ldr	r3, [r7, #4]
  407106:	8b9b      	ldrh	r3, [r3, #28]
  407108:	2b65      	cmp	r3, #101	; 0x65
  40710a:	d104      	bne.n	407116 <ch_common_set_rx_holdoff+0x22>
		rx_holdoff_reg = CH101_COMMON_REG_RX_HOLDOFF;
  40710c:	2311      	movs	r3, #17
  40710e:	73fb      	strb	r3, [r7, #15]
		reg_value = num_samples;
  407110:	887b      	ldrh	r3, [r7, #2]
  407112:	81bb      	strh	r3, [r7, #12]
  407114:	e004      	b.n	407120 <ch_common_set_rx_holdoff+0x2c>
	} else {
		rx_holdoff_reg = CH201_COMMON_REG_RX_HOLDOFF;
  407116:	2311      	movs	r3, #17
  407118:	73fb      	strb	r3, [r7, #15]
		reg_value = (num_samples / 2);			// CH201 value is 1/2 actual sample count
  40711a:	887b      	ldrh	r3, [r7, #2]
  40711c:	085b      	lsrs	r3, r3, #1
  40711e:	81bb      	strh	r3, [r7, #12]
	}

	if (dev_ptr->sensor_connected) {
  407120:	687b      	ldr	r3, [r7, #4]
  407122:	7fdb      	ldrb	r3, [r3, #31]
  407124:	2b00      	cmp	r3, #0
  407126:	d00e      	beq.n	407146 <ch_common_set_rx_holdoff+0x52>
		ret_val |= chdrv_write_byte(dev_ptr, rx_holdoff_reg, (uint8_t) reg_value);
  407128:	7bfb      	ldrb	r3, [r7, #15]
  40712a:	b29b      	uxth	r3, r3
  40712c:	89ba      	ldrh	r2, [r7, #12]
  40712e:	b2d2      	uxtb	r2, r2
  407130:	4619      	mov	r1, r3
  407132:	6878      	ldr	r0, [r7, #4]
  407134:	4b06      	ldr	r3, [pc, #24]	; (407150 <ch_common_set_rx_holdoff+0x5c>)
  407136:	4798      	blx	r3
  407138:	4603      	mov	r3, r0
  40713a:	b25a      	sxtb	r2, r3
  40713c:	f997 300b 	ldrsb.w	r3, [r7, #11]
  407140:	4313      	orrs	r3, r2
  407142:	b25b      	sxtb	r3, r3
  407144:	72fb      	strb	r3, [r7, #11]
	}

	return ret_val;
  407146:	7afb      	ldrb	r3, [r7, #11]
}
  407148:	4618      	mov	r0, r3
  40714a:	3710      	adds	r7, #16
  40714c:	46bd      	mov	sp, r7
  40714e:	bd80      	pop	{r7, pc}
  407150:	00407335 	.word	0x00407335

00407154 <ch_common_get_rx_holdoff>:


uint16_t ch_common_get_rx_holdoff(ch_dev_t *dev_ptr) {
  407154:	b580      	push	{r7, lr}
  407156:	b084      	sub	sp, #16
  407158:	af00      	add	r7, sp, #0
  40715a:	6078      	str	r0, [r7, #4]
	uint8_t rx_holdoff_reg;
	uint8_t reg_val;
	uint16_t rx_holdoff = 0;
  40715c:	2300      	movs	r3, #0
  40715e:	81bb      	strh	r3, [r7, #12]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  407160:	687b      	ldr	r3, [r7, #4]
  407162:	8b9b      	ldrh	r3, [r3, #28]
  407164:	2b65      	cmp	r3, #101	; 0x65
  407166:	d102      	bne.n	40716e <ch_common_get_rx_holdoff+0x1a>
		rx_holdoff_reg = CH101_COMMON_REG_RX_HOLDOFF;
  407168:	2311      	movs	r3, #17
  40716a:	73fb      	strb	r3, [r7, #15]
  40716c:	e001      	b.n	407172 <ch_common_get_rx_holdoff+0x1e>
	} else {
		rx_holdoff_reg = CH201_COMMON_REG_RX_HOLDOFF;
  40716e:	2311      	movs	r3, #17
  407170:	73fb      	strb	r3, [r7, #15]
	}

	if (dev_ptr->sensor_connected) {
  407172:	687b      	ldr	r3, [r7, #4]
  407174:	7fdb      	ldrb	r3, [r3, #31]
  407176:	2b00      	cmp	r3, #0
  407178:	d007      	beq.n	40718a <ch_common_get_rx_holdoff+0x36>
		chdrv_read_byte(dev_ptr, rx_holdoff_reg, &reg_val);
  40717a:	7bfb      	ldrb	r3, [r7, #15]
  40717c:	b29b      	uxth	r3, r3
  40717e:	f107 020b 	add.w	r2, r7, #11
  407182:	4619      	mov	r1, r3
  407184:	6878      	ldr	r0, [r7, #4]
  407186:	4b08      	ldr	r3, [pc, #32]	; (4071a8 <ch_common_get_rx_holdoff+0x54>)
  407188:	4798      	blx	r3
	}

	rx_holdoff = (uint16_t) reg_val;
  40718a:	7afb      	ldrb	r3, [r7, #11]
  40718c:	81bb      	strh	r3, [r7, #12]

	if (dev_ptr->part_number == CH201_PART_NUMBER) {
  40718e:	687b      	ldr	r3, [r7, #4]
  407190:	8b9b      	ldrh	r3, [r3, #28]
  407192:	2bc9      	cmp	r3, #201	; 0xc9
  407194:	d102      	bne.n	40719c <ch_common_get_rx_holdoff+0x48>
		rx_holdoff *= 2;			// CH201 reports 1/2 actual sample count
  407196:	89bb      	ldrh	r3, [r7, #12]
  407198:	005b      	lsls	r3, r3, #1
  40719a:	81bb      	strh	r3, [r7, #12]
	}

	return rx_holdoff;	
  40719c:	89bb      	ldrh	r3, [r7, #12]
}
  40719e:	4618      	mov	r0, r3
  4071a0:	3710      	adds	r7, #16
  4071a2:	46bd      	mov	sp, r7
  4071a4:	bd80      	pop	{r7, pc}
  4071a6:	bf00      	nop
  4071a8:	004073b1 	.word	0x004073b1

004071ac <ch_common_set_rx_low_gain>:

uint8_t	ch_common_set_rx_low_gain(ch_dev_t *dev_ptr, uint16_t num_samples) {
  4071ac:	b580      	push	{r7, lr}
  4071ae:	b084      	sub	sp, #16
  4071b0:	af00      	add	r7, sp, #0
  4071b2:	6078      	str	r0, [r7, #4]
  4071b4:	460b      	mov	r3, r1
  4071b6:	807b      	strh	r3, [r7, #2]
	uint8_t rx_lowgain_reg;
	uint8_t reg_value;
	uint8_t ret_val = 0;
  4071b8:	2300      	movs	r3, #0
  4071ba:	737b      	strb	r3, [r7, #13]

	if (num_samples > dev_ptr->num_rx_samples - 1) {		// do not extend past end of active range
  4071bc:	887a      	ldrh	r2, [r7, #2]
  4071be:	687b      	ldr	r3, [r7, #4]
  4071c0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  4071c2:	3b01      	subs	r3, #1
  4071c4:	429a      	cmp	r2, r3
  4071c6:	dd03      	ble.n	4071d0 <ch_common_set_rx_low_gain+0x24>
		num_samples = (dev_ptr->num_rx_samples - 1);
  4071c8:	687b      	ldr	r3, [r7, #4]
  4071ca:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  4071cc:	3b01      	subs	r3, #1
  4071ce:	807b      	strh	r3, [r7, #2]
	}

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  4071d0:	687b      	ldr	r3, [r7, #4]
  4071d2:	8b9b      	ldrh	r3, [r3, #28]
  4071d4:	2b65      	cmp	r3, #101	; 0x65
  4071d6:	d102      	bne.n	4071de <ch_common_set_rx_low_gain+0x32>
		ret_val = 1;		// error - not supported on CH101
  4071d8:	2301      	movs	r3, #1
  4071da:	737b      	strb	r3, [r7, #13]
  4071dc:	e005      	b.n	4071ea <ch_common_set_rx_low_gain+0x3e>
	} else {
		rx_lowgain_reg = CH201_COMMON_REG_LOW_GAIN_RXLEN;
  4071de:	2304      	movs	r3, #4
  4071e0:	73fb      	strb	r3, [r7, #15]
		reg_value = (num_samples / 2);			// CH201 value is 1/2 actual sample count
  4071e2:	887b      	ldrh	r3, [r7, #2]
  4071e4:	085b      	lsrs	r3, r3, #1
  4071e6:	b29b      	uxth	r3, r3
  4071e8:	73bb      	strb	r3, [r7, #14]
	}

	if (ret_val == 0) {
  4071ea:	7b7b      	ldrb	r3, [r7, #13]
  4071ec:	2b00      	cmp	r3, #0
  4071ee:	d108      	bne.n	407202 <ch_common_set_rx_low_gain+0x56>
		ret_val = chdrv_write_byte(dev_ptr, rx_lowgain_reg, reg_value);
  4071f0:	7bfb      	ldrb	r3, [r7, #15]
  4071f2:	b29b      	uxth	r3, r3
  4071f4:	7bba      	ldrb	r2, [r7, #14]
  4071f6:	4619      	mov	r1, r3
  4071f8:	6878      	ldr	r0, [r7, #4]
  4071fa:	4b04      	ldr	r3, [pc, #16]	; (40720c <ch_common_set_rx_low_gain+0x60>)
  4071fc:	4798      	blx	r3
  4071fe:	4603      	mov	r3, r0
  407200:	737b      	strb	r3, [r7, #13]
	}

	return ret_val;
  407202:	7b7b      	ldrb	r3, [r7, #13]
}
  407204:	4618      	mov	r0, r3
  407206:	3710      	adds	r7, #16
  407208:	46bd      	mov	sp, r7
  40720a:	bd80      	pop	{r7, pc}
  40720c:	00407335 	.word	0x00407335

00407210 <ch_common_get_rx_low_gain>:

uint16_t	ch_common_get_rx_low_gain(ch_dev_t *dev_ptr) {
  407210:	b580      	push	{r7, lr}
  407212:	b084      	sub	sp, #16
  407214:	af00      	add	r7, sp, #0
  407216:	6078      	str	r0, [r7, #4]
	uint8_t reg_value = 0;
  407218:	2300      	movs	r3, #0
  40721a:	737b      	strb	r3, [r7, #13]
	uint16_t num_samples = 0;
  40721c:	2300      	movs	r3, #0
  40721e:	81fb      	strh	r3, [r7, #14]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  407220:	687b      	ldr	r3, [r7, #4]
  407222:	8b9b      	ldrh	r3, [r3, #28]
  407224:	2b65      	cmp	r3, #101	; 0x65
  407226:	d102      	bne.n	40722e <ch_common_get_rx_low_gain+0x1e>
		num_samples = 0;		// error - not supported on CH101
  407228:	2300      	movs	r3, #0
  40722a:	81fb      	strh	r3, [r7, #14]
  40722c:	e00a      	b.n	407244 <ch_common_get_rx_low_gain+0x34>
	} else {
		chdrv_read_byte(dev_ptr, CH201_COMMON_REG_LOW_GAIN_RXLEN, &reg_value);
  40722e:	f107 030d 	add.w	r3, r7, #13
  407232:	461a      	mov	r2, r3
  407234:	2104      	movs	r1, #4
  407236:	6878      	ldr	r0, [r7, #4]
  407238:	4b05      	ldr	r3, [pc, #20]	; (407250 <ch_common_get_rx_low_gain+0x40>)
  40723a:	4798      	blx	r3

		num_samples = reg_value * 2;					// actual sample count is 2x register value
  40723c:	7b7b      	ldrb	r3, [r7, #13]
  40723e:	b29b      	uxth	r3, r3
  407240:	005b      	lsls	r3, r3, #1
  407242:	81fb      	strh	r3, [r7, #14]
	}

	return num_samples;	
  407244:	89fb      	ldrh	r3, [r7, #14]
}
  407246:	4618      	mov	r0, r3
  407248:	3710      	adds	r7, #16
  40724a:	46bd      	mov	sp, r7
  40724c:	bd80      	pop	{r7, pc}
  40724e:	bf00      	nop
  407250:	004073b1 	.word	0x004073b1

00407254 <ch_common_get_tx_length>:
		ret_val = chdrv_write_byte(dev_ptr, CH201_COMMON_REG_TX_LENGTH, num_cycles);
	}
	return ret_val;
}

uint8_t	ch_common_get_tx_length(ch_dev_t *dev_ptr) {
  407254:	b580      	push	{r7, lr}
  407256:	b084      	sub	sp, #16
  407258:	af00      	add	r7, sp, #0
  40725a:	6078      	str	r0, [r7, #4]
	uint8_t num_cycles = 0;
  40725c:	2300      	movs	r3, #0
  40725e:	73fb      	strb	r3, [r7, #15]

	if (dev_ptr->part_number == CH101_PART_NUMBER) {
  407260:	687b      	ldr	r3, [r7, #4]
  407262:	8b9b      	ldrh	r3, [r3, #28]
  407264:	2b65      	cmp	r3, #101	; 0x65
  407266:	d102      	bne.n	40726e <ch_common_get_tx_length+0x1a>
		num_cycles = 1;		// error - not supported on CH101
  407268:	2301      	movs	r3, #1
  40726a:	73fb      	strb	r3, [r7, #15]
  40726c:	e006      	b.n	40727c <ch_common_get_tx_length+0x28>
	} else {
		chdrv_read_byte(dev_ptr, CH201_COMMON_REG_TX_LENGTH, &num_cycles);
  40726e:	f107 030f 	add.w	r3, r7, #15
  407272:	461a      	mov	r2, r3
  407274:	2110      	movs	r1, #16
  407276:	6878      	ldr	r0, [r7, #4]
  407278:	4b03      	ldr	r3, [pc, #12]	; (407288 <ch_common_get_tx_length+0x34>)
  40727a:	4798      	blx	r3
	}

	return num_cycles;	
  40727c:	7bfb      	ldrb	r3, [r7, #15]
}
  40727e:	4618      	mov	r0, r3
  407280:	3710      	adds	r7, #16
  407282:	46bd      	mov	sp, r7
  407284:	bd80      	pop	{r7, pc}
  407286:	bf00      	nop
  407288:	004073b1 	.word	0x004073b1

0040728c <chdrv_prog_i2c_write>:
 * \return 0 if successful, non-zero otherwise
 *
 * This function writes bytes to the device using the programming I2C address.  The
 * PROG line for the device must have been asserted before this function is called.
 */
int chdrv_prog_i2c_write(ch_dev_t *dev_ptr, uint8_t *message, uint16_t len) {
  40728c:	b580      	push	{r7, lr}
  40728e:	b086      	sub	sp, #24
  407290:	af00      	add	r7, sp, #0
  407292:	60f8      	str	r0, [r7, #12]
  407294:	60b9      	str	r1, [r7, #8]
  407296:	4613      	mov	r3, r2
  407298:	80fb      	strh	r3, [r7, #6]

	dev_ptr->i2c_address = CH_I2C_ADDR_PROG;
  40729a:	68fb      	ldr	r3, [r7, #12]
  40729c:	2245      	movs	r2, #69	; 0x45
  40729e:	761a      	strb	r2, [r3, #24]
	int ch_err = chbsp_i2c_write(dev_ptr, message, len);
  4072a0:	88fb      	ldrh	r3, [r7, #6]
  4072a2:	461a      	mov	r2, r3
  4072a4:	68b9      	ldr	r1, [r7, #8]
  4072a6:	68f8      	ldr	r0, [r7, #12]
  4072a8:	4b05      	ldr	r3, [pc, #20]	; (4072c0 <chdrv_prog_i2c_write+0x34>)
  4072aa:	4798      	blx	r3
  4072ac:	6178      	str	r0, [r7, #20]
	dev_ptr->i2c_address = dev_ptr->app_i2c_address;
  4072ae:	68fb      	ldr	r3, [r7, #12]
  4072b0:	7e5a      	ldrb	r2, [r3, #25]
  4072b2:	68fb      	ldr	r3, [r7, #12]
  4072b4:	761a      	strb	r2, [r3, #24]

	return ch_err;
  4072b6:	697b      	ldr	r3, [r7, #20]
}
  4072b8:	4618      	mov	r0, r3
  4072ba:	3718      	adds	r7, #24
  4072bc:	46bd      	mov	sp, r7
  4072be:	bd80      	pop	{r7, pc}
  4072c0:	004027d1 	.word	0x004027d1

004072c4 <chdrv_prog_i2c_read>:
 * \return 0 if successful, non-zero otherwise
 *
 * This function reads bytes from the device using the programming I2C address.  The
 * PROG line for the device must have been asserted before this function is called.
 */
int chdrv_prog_i2c_read(ch_dev_t *dev_ptr, uint8_t *message, uint16_t len) {
  4072c4:	b580      	push	{r7, lr}
  4072c6:	b086      	sub	sp, #24
  4072c8:	af00      	add	r7, sp, #0
  4072ca:	60f8      	str	r0, [r7, #12]
  4072cc:	60b9      	str	r1, [r7, #8]
  4072ce:	4613      	mov	r3, r2
  4072d0:	80fb      	strh	r3, [r7, #6]

	dev_ptr->i2c_address = CH_I2C_ADDR_PROG;
  4072d2:	68fb      	ldr	r3, [r7, #12]
  4072d4:	2245      	movs	r2, #69	; 0x45
  4072d6:	761a      	strb	r2, [r3, #24]
	int ch_err = chbsp_i2c_read(dev_ptr, message, len);
  4072d8:	88fb      	ldrh	r3, [r7, #6]
  4072da:	461a      	mov	r2, r3
  4072dc:	68b9      	ldr	r1, [r7, #8]
  4072de:	68f8      	ldr	r0, [r7, #12]
  4072e0:	4b05      	ldr	r3, [pc, #20]	; (4072f8 <chdrv_prog_i2c_read+0x34>)
  4072e2:	4798      	blx	r3
  4072e4:	6178      	str	r0, [r7, #20]
	dev_ptr->i2c_address = dev_ptr->app_i2c_address;
  4072e6:	68fb      	ldr	r3, [r7, #12]
  4072e8:	7e5a      	ldrb	r2, [r3, #25]
  4072ea:	68fb      	ldr	r3, [r7, #12]
  4072ec:	761a      	strb	r2, [r3, #24]

	return ch_err;
  4072ee:	697b      	ldr	r3, [r7, #20]
}
  4072f0:	4618      	mov	r0, r3
  4072f2:	3718      	adds	r7, #24
  4072f4:	46bd      	mov	sp, r7
  4072f6:	bd80      	pop	{r7, pc}
  4072f8:	004028bd 	.word	0x004028bd

004072fc <chdrv_prog_i2c_read_nb>:
 *
 * This function temporarily changes the device I2C address to the low-level programming
 * interface, and issues a non-blocking read request. The PROG line for the device must have 
 * been asserted before this function is called.
 */
int chdrv_prog_i2c_read_nb(ch_dev_t *dev_ptr, uint8_t *message, uint16_t len) {
  4072fc:	b580      	push	{r7, lr}
  4072fe:	b086      	sub	sp, #24
  407300:	af00      	add	r7, sp, #0
  407302:	60f8      	str	r0, [r7, #12]
  407304:	60b9      	str	r1, [r7, #8]
  407306:	4613      	mov	r3, r2
  407308:	80fb      	strh	r3, [r7, #6]

	dev_ptr->i2c_address = CH_I2C_ADDR_PROG;
  40730a:	68fb      	ldr	r3, [r7, #12]
  40730c:	2245      	movs	r2, #69	; 0x45
  40730e:	761a      	strb	r2, [r3, #24]
	int ch_err = chbsp_i2c_read_nb(dev_ptr, message, len);
  407310:	88fb      	ldrh	r3, [r7, #6]
  407312:	461a      	mov	r2, r3
  407314:	68b9      	ldr	r1, [r7, #8]
  407316:	68f8      	ldr	r0, [r7, #12]
  407318:	4b05      	ldr	r3, [pc, #20]	; (407330 <chdrv_prog_i2c_read_nb+0x34>)
  40731a:	4798      	blx	r3
  40731c:	6178      	str	r0, [r7, #20]
	dev_ptr->i2c_address = dev_ptr->app_i2c_address;
  40731e:	68fb      	ldr	r3, [r7, #12]
  407320:	7e5a      	ldrb	r2, [r3, #25]
  407322:	68fb      	ldr	r3, [r7, #12]
  407324:	761a      	strb	r2, [r3, #24]

	return ch_err;
  407326:	697b      	ldr	r3, [r7, #20]
}
  407328:	4618      	mov	r0, r3
  40732a:	3718      	adds	r7, #24
  40732c:	46bd      	mov	sp, r7
  40732e:	bd80      	pop	{r7, pc}
  407330:	004029a5 	.word	0x004029a5

00407334 <chdrv_write_byte>:
 * \param mem_addr 		sensor memory/register address
 * \param data_value	data value to transmit
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_write_byte(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t data_value) {
  407334:	b590      	push	{r4, r7, lr}
  407336:	b085      	sub	sp, #20
  407338:	af00      	add	r7, sp, #0
  40733a:	6078      	str	r0, [r7, #4]
  40733c:	460b      	mov	r3, r1
  40733e:	807b      	strh	r3, [r7, #2]
  407340:	4613      	mov	r3, r2
  407342:	707b      	strb	r3, [r7, #1]
	uint8_t message[] = { sizeof(data_value), data_value };		// insert byte count (1) at start of data
  407344:	2301      	movs	r3, #1
  407346:	723b      	strb	r3, [r7, #8]
  407348:	787b      	ldrb	r3, [r7, #1]
  40734a:	727b      	strb	r3, [r7, #9]

	int ch_err = chbsp_i2c_mem_write(dev_ptr, mem_addr, message, sizeof(message));
  40734c:	f107 0208 	add.w	r2, r7, #8
  407350:	8879      	ldrh	r1, [r7, #2]
  407352:	2302      	movs	r3, #2
  407354:	6878      	ldr	r0, [r7, #4]
  407356:	4c04      	ldr	r4, [pc, #16]	; (407368 <chdrv_write_byte+0x34>)
  407358:	47a0      	blx	r4
  40735a:	60f8      	str	r0, [r7, #12]

	return ch_err;
  40735c:	68fb      	ldr	r3, [r7, #12]
}
  40735e:	4618      	mov	r0, r3
  407360:	3714      	adds	r7, #20
  407362:	46bd      	mov	sp, r7
  407364:	bd90      	pop	{r4, r7, pc}
  407366:	bf00      	nop
  407368:	00402831 	.word	0x00402831

0040736c <chdrv_write_word>:
 * \param reg_addr 	sensor register address
 * \param data 		data value to transmit
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_write_word(ch_dev_t *dev_ptr, uint16_t mem_addr, uint16_t data_value) {
  40736c:	b590      	push	{r4, r7, lr}
  40736e:	b085      	sub	sp, #20
  407370:	af00      	add	r7, sp, #0
  407372:	6078      	str	r0, [r7, #4]
  407374:	460b      	mov	r3, r1
  407376:	807b      	strh	r3, [r7, #2]
  407378:	4613      	mov	r3, r2
  40737a:	803b      	strh	r3, [r7, #0]
	// First we write the register address, then the number of bytes we're writing

	// Place byte count (2) in first byte of message
	// Sensor is little-endian, so LSB goes in at the lower address
	uint8_t message[] = { sizeof(data_value), (uint8_t) data_value, (uint8_t) (data_value >> 8) }; 
  40737c:	2302      	movs	r3, #2
  40737e:	723b      	strb	r3, [r7, #8]
  407380:	883b      	ldrh	r3, [r7, #0]
  407382:	b2db      	uxtb	r3, r3
  407384:	727b      	strb	r3, [r7, #9]
  407386:	883b      	ldrh	r3, [r7, #0]
  407388:	0a1b      	lsrs	r3, r3, #8
  40738a:	b29b      	uxth	r3, r3
  40738c:	b2db      	uxtb	r3, r3
  40738e:	72bb      	strb	r3, [r7, #10]

	int ch_err = chbsp_i2c_mem_write(dev_ptr, mem_addr, message, sizeof(message));
  407390:	f107 0208 	add.w	r2, r7, #8
  407394:	8879      	ldrh	r1, [r7, #2]
  407396:	2303      	movs	r3, #3
  407398:	6878      	ldr	r0, [r7, #4]
  40739a:	4c04      	ldr	r4, [pc, #16]	; (4073ac <chdrv_write_word+0x40>)
  40739c:	47a0      	blx	r4
  40739e:	60f8      	str	r0, [r7, #12]

	return ch_err;
  4073a0:	68fb      	ldr	r3, [r7, #12]
}
  4073a2:	4618      	mov	r0, r3
  4073a4:	3714      	adds	r7, #20
  4073a6:	46bd      	mov	sp, r7
  4073a8:	bd90      	pop	{r4, r7, pc}
  4073aa:	bf00      	nop
  4073ac:	00402831 	.word	0x00402831

004073b0 <chdrv_read_byte>:
 * \param mem_addr 	sensor memory/register address
 * \param data 		pointer to receive buffer
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_read_byte(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t *data) {
  4073b0:	b590      	push	{r4, r7, lr}
  4073b2:	b085      	sub	sp, #20
  4073b4:	af00      	add	r7, sp, #0
  4073b6:	60f8      	str	r0, [r7, #12]
  4073b8:	460b      	mov	r3, r1
  4073ba:	607a      	str	r2, [r7, #4]
  4073bc:	817b      	strh	r3, [r7, #10]

	return (chbsp_i2c_mem_read(dev_ptr, mem_addr, data, 1));
  4073be:	8979      	ldrh	r1, [r7, #10]
  4073c0:	2301      	movs	r3, #1
  4073c2:	687a      	ldr	r2, [r7, #4]
  4073c4:	68f8      	ldr	r0, [r7, #12]
  4073c6:	4c03      	ldr	r4, [pc, #12]	; (4073d4 <chdrv_read_byte+0x24>)
  4073c8:	47a0      	blx	r4
  4073ca:	4603      	mov	r3, r0
}
  4073cc:	4618      	mov	r0, r3
  4073ce:	3714      	adds	r7, #20
  4073d0:	46bd      	mov	sp, r7
  4073d2:	bd90      	pop	{r4, r7, pc}
  4073d4:	0040292d 	.word	0x0040292d

004073d8 <chdrv_burst_read>:
 * \param data 		pointer to receive buffer
 * \param len 		number of bytes to read
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_burst_read(ch_dev_t *dev_ptr, uint16_t mem_addr, uint8_t *data, uint16_t num_bytes) {
  4073d8:	b590      	push	{r4, r7, lr}
  4073da:	b085      	sub	sp, #20
  4073dc:	af00      	add	r7, sp, #0
  4073de:	60f8      	str	r0, [r7, #12]
  4073e0:	607a      	str	r2, [r7, #4]
  4073e2:	461a      	mov	r2, r3
  4073e4:	460b      	mov	r3, r1
  4073e6:	817b      	strh	r3, [r7, #10]
  4073e8:	4613      	mov	r3, r2
  4073ea:	813b      	strh	r3, [r7, #8]

	return (chbsp_i2c_mem_read(dev_ptr, mem_addr, data, num_bytes));
  4073ec:	893b      	ldrh	r3, [r7, #8]
  4073ee:	8979      	ldrh	r1, [r7, #10]
  4073f0:	687a      	ldr	r2, [r7, #4]
  4073f2:	68f8      	ldr	r0, [r7, #12]
  4073f4:	4c03      	ldr	r4, [pc, #12]	; (407404 <chdrv_burst_read+0x2c>)
  4073f6:	47a0      	blx	r4
  4073f8:	4603      	mov	r3, r0
}
  4073fa:	4618      	mov	r0, r3
  4073fc:	3714      	adds	r7, #20
  4073fe:	46bd      	mov	sp, r7
  407400:	bd90      	pop	{r4, r7, pc}
  407402:	bf00      	nop
  407404:	0040292d 	.word	0x0040292d

00407408 <chdrv_read_word>:
 * \param mem_addr 	sensor memory/register address
 * \param data 		pointer to receive buffer
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_read_word(ch_dev_t *dev_ptr, uint16_t mem_addr, uint16_t * data) {
  407408:	b590      	push	{r4, r7, lr}
  40740a:	b085      	sub	sp, #20
  40740c:	af00      	add	r7, sp, #0
  40740e:	60f8      	str	r0, [r7, #12]
  407410:	460b      	mov	r3, r1
  407412:	607a      	str	r2, [r7, #4]
  407414:	817b      	strh	r3, [r7, #10]
	//
	return (chbsp_i2c_mem_read(dev_ptr, mem_addr, (uint8_t *) data, 2));
  407416:	8979      	ldrh	r1, [r7, #10]
  407418:	2302      	movs	r3, #2
  40741a:	687a      	ldr	r2, [r7, #4]
  40741c:	68f8      	ldr	r0, [r7, #12]
  40741e:	4c03      	ldr	r4, [pc, #12]	; (40742c <chdrv_read_word+0x24>)
  407420:	47a0      	blx	r4
  407422:	4603      	mov	r3, r0
}
  407424:	4618      	mov	r0, r3
  407426:	3714      	adds	r7, #20
  407428:	46bd      	mov	sp, r7
  40742a:	bd90      	pop	{r4, r7, pc}
  40742c:	0040292d 	.word	0x0040292d

00407430 <chdrv_group_measure_rtc>:
 *
 * \note The calibration pulse is sent to all devices in the group at the same time.  Therefore 
 * all connected devices will see the same reference pulse length.
 * 
 */
void chdrv_group_measure_rtc(ch_group_t *grp_ptr) {
  407430:	b580      	push	{r7, lr}
  407432:	b084      	sub	sp, #16
  407434:	af00      	add	r7, sp, #0
  407436:	6078      	str	r0, [r7, #4]
	uint8_t i;
	const uint32_t pulselength = grp_ptr->rtc_cal_pulse_ms;
  407438:	687b      	ldr	r3, [r7, #4]
  40743a:	88db      	ldrh	r3, [r3, #6]
  40743c:	60bb      	str	r3, [r7, #8]
	/* Configure the host's side of the IO pin as a low output */
	chbsp_group_io_clear(grp_ptr);
  40743e:	6878      	ldr	r0, [r7, #4]
  407440:	4b41      	ldr	r3, [pc, #260]	; (407548 <chdrv_group_measure_rtc+0x118>)
  407442:	4798      	blx	r3
	chbsp_group_set_io_dir_out(grp_ptr);
  407444:	6878      	ldr	r0, [r7, #4]
  407446:	4b41      	ldr	r3, [pc, #260]	; (40754c <chdrv_group_measure_rtc+0x11c>)
  407448:	4798      	blx	r3

	/* Set up RTC calibration */
	for (i = 0; i < grp_ptr->num_ports; i++) {
  40744a:	2300      	movs	r3, #0
  40744c:	73fb      	strb	r3, [r7, #15]
  40744e:	e017      	b.n	407480 <chdrv_group_measure_rtc+0x50>
		if (grp_ptr->device[i]->sensor_connected) {
  407450:	7bfa      	ldrb	r2, [r7, #15]
  407452:	687b      	ldr	r3, [r7, #4]
  407454:	3206      	adds	r2, #6
  407456:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40745a:	7fdb      	ldrb	r3, [r3, #31]
  40745c:	2b00      	cmp	r3, #0
  40745e:	d00c      	beq.n	40747a <chdrv_group_measure_rtc+0x4a>
			grp_ptr->device[i]->prepare_pulse_timer(grp_ptr->device[i]);
  407460:	7bfa      	ldrb	r2, [r7, #15]
  407462:	687b      	ldr	r3, [r7, #4]
  407464:	3206      	adds	r2, #6
  407466:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40746a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40746c:	7bf9      	ldrb	r1, [r7, #15]
  40746e:	687a      	ldr	r2, [r7, #4]
  407470:	3106      	adds	r1, #6
  407472:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  407476:	4610      	mov	r0, r2
  407478:	4798      	blx	r3
	for (i = 0; i < grp_ptr->num_ports; i++) {
  40747a:	7bfb      	ldrb	r3, [r7, #15]
  40747c:	3301      	adds	r3, #1
  40747e:	73fb      	strb	r3, [r7, #15]
  407480:	687b      	ldr	r3, [r7, #4]
  407482:	781b      	ldrb	r3, [r3, #0]
  407484:	7bfa      	ldrb	r2, [r7, #15]
  407486:	429a      	cmp	r2, r3
  407488:	d3e2      	bcc.n	407450 <chdrv_group_measure_rtc+0x20>
		}
	}

	/* Trigger a pulse on the IO pin */
	chbsp_group_io_set(grp_ptr);
  40748a:	6878      	ldr	r0, [r7, #4]
  40748c:	4b30      	ldr	r3, [pc, #192]	; (407550 <chdrv_group_measure_rtc+0x120>)
  40748e:	4798      	blx	r3
	chbsp_delay_ms(pulselength);
  407490:	68b8      	ldr	r0, [r7, #8]
  407492:	4b30      	ldr	r3, [pc, #192]	; (407554 <chdrv_group_measure_rtc+0x124>)
  407494:	4798      	blx	r3
	chbsp_group_io_clear(grp_ptr);
  407496:	6878      	ldr	r0, [r7, #4]
  407498:	4b2b      	ldr	r3, [pc, #172]	; (407548 <chdrv_group_measure_rtc+0x118>)
  40749a:	4798      	blx	r3

	/* Keep the IO low for at least 50 us to allow the ASIC FW to deactivate the PT logic.
	   It will be set as input later once we will expect INT from the CHx01. */
	chbsp_delay_us(100);
  40749c:	2064      	movs	r0, #100	; 0x64
  40749e:	4b2e      	ldr	r3, [pc, #184]	; (407558 <chdrv_group_measure_rtc+0x128>)
  4074a0:	4798      	blx	r3

	for (i = 0; i < grp_ptr->num_ports; i++) {
  4074a2:	2300      	movs	r3, #0
  4074a4:	73fb      	strb	r3, [r7, #15]
  4074a6:	e046      	b.n	407536 <chdrv_group_measure_rtc+0x106>
		if (grp_ptr->device[i]->sensor_connected) {
  4074a8:	7bfa      	ldrb	r2, [r7, #15]
  4074aa:	687b      	ldr	r3, [r7, #4]
  4074ac:	3206      	adds	r2, #6
  4074ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4074b2:	7fdb      	ldrb	r3, [r3, #31]
  4074b4:	2b00      	cmp	r3, #0
  4074b6:	d03b      	beq.n	407530 <chdrv_group_measure_rtc+0x100>
			grp_ptr->device[i]->store_pt_result(grp_ptr->device[i]);
  4074b8:	7bfa      	ldrb	r2, [r7, #15]
  4074ba:	687b      	ldr	r3, [r7, #4]
  4074bc:	3206      	adds	r2, #6
  4074be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4074c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4074c4:	7bf9      	ldrb	r1, [r7, #15]
  4074c6:	687a      	ldr	r2, [r7, #4]
  4074c8:	3106      	adds	r1, #6
  4074ca:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  4074ce:	4610      	mov	r0, r2
  4074d0:	4798      	blx	r3
			grp_ptr->device[i]->store_op_freq(grp_ptr->device[i]);
  4074d2:	7bfa      	ldrb	r2, [r7, #15]
  4074d4:	687b      	ldr	r3, [r7, #4]
  4074d6:	3206      	adds	r2, #6
  4074d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4074dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4074de:	7bf9      	ldrb	r1, [r7, #15]
  4074e0:	687a      	ldr	r2, [r7, #4]
  4074e2:	3106      	adds	r1, #6
  4074e4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  4074e8:	4610      	mov	r0, r2
  4074ea:	4798      	blx	r3
			if (grp_ptr->device[i]->store_bandwidth != NULL) {
  4074ec:	7bfa      	ldrb	r2, [r7, #15]
  4074ee:	687b      	ldr	r3, [r7, #4]
  4074f0:	3206      	adds	r2, #6
  4074f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4074f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  4074f8:	2b00      	cmp	r3, #0
  4074fa:	d00c      	beq.n	407516 <chdrv_group_measure_rtc+0xe6>
				grp_ptr->device[i]->store_bandwidth(grp_ptr->device[i]);
  4074fc:	7bfa      	ldrb	r2, [r7, #15]
  4074fe:	687b      	ldr	r3, [r7, #4]
  407500:	3206      	adds	r2, #6
  407502:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  407506:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  407508:	7bf9      	ldrb	r1, [r7, #15]
  40750a:	687a      	ldr	r2, [r7, #4]
  40750c:	3106      	adds	r1, #6
  40750e:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  407512:	4610      	mov	r0, r2
  407514:	4798      	blx	r3
			}
			grp_ptr->device[i]->store_scalefactor(grp_ptr->device[i]);
  407516:	7bfa      	ldrb	r2, [r7, #15]
  407518:	687b      	ldr	r3, [r7, #4]
  40751a:	3206      	adds	r2, #6
  40751c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  407520:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  407522:	7bf9      	ldrb	r1, [r7, #15]
  407524:	687a      	ldr	r2, [r7, #4]
  407526:	3106      	adds	r1, #6
  407528:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  40752c:	4610      	mov	r0, r2
  40752e:	4798      	blx	r3
	for (i = 0; i < grp_ptr->num_ports; i++) {
  407530:	7bfb      	ldrb	r3, [r7, #15]
  407532:	3301      	adds	r3, #1
  407534:	73fb      	strb	r3, [r7, #15]
  407536:	687b      	ldr	r3, [r7, #4]
  407538:	781b      	ldrb	r3, [r3, #0]
  40753a:	7bfa      	ldrb	r2, [r7, #15]
  40753c:	429a      	cmp	r2, r3
  40753e:	d3b3      	bcc.n	4074a8 <chdrv_group_measure_rtc+0x78>
		}
	}
}
  407540:	bf00      	nop
  407542:	3710      	adds	r7, #16
  407544:	46bd      	mov	sp, r7
  407546:	bd80      	pop	{r7, pc}
  407548:	004023a9 	.word	0x004023a9
  40754c:	0040217d 	.word	0x0040217d
  407550:	00402429 	.word	0x00402429
  407554:	004026b9 	.word	0x004026b9
  407558:	00402611 	.word	0x00402611

0040755c <chdrv_group_i2c_queue>:
 * \param data 		pointer to buffer to receive data or containing data to send
 *
 * \return 0 if successful, non-zero otherwise
 */
int chdrv_group_i2c_queue(ch_group_t *grp_ptr, ch_dev_t *dev_ptr, uint8_t rd_wrb, uint8_t type, 
						  uint16_t addr, uint16_t nbytes, uint8_t *data) {
  40755c:	b580      	push	{r7, lr}
  40755e:	b088      	sub	sp, #32
  407560:	af00      	add	r7, sp, #0
  407562:	60f8      	str	r0, [r7, #12]
  407564:	60b9      	str	r1, [r7, #8]
  407566:	4611      	mov	r1, r2
  407568:	461a      	mov	r2, r3
  40756a:	460b      	mov	r3, r1
  40756c:	71fb      	strb	r3, [r7, #7]
  40756e:	4613      	mov	r3, r2
  407570:	71bb      	strb	r3, [r7, #6]

	uint8_t bus_num = ch_get_i2c_bus(dev_ptr);
  407572:	68b8      	ldr	r0, [r7, #8]
  407574:	4b1e      	ldr	r3, [pc, #120]	; (4075f0 <chdrv_group_i2c_queue+0x94>)
  407576:	4798      	blx	r3
  407578:	4603      	mov	r3, r0
  40757a:	76fb      	strb	r3, [r7, #27]
	int	ret_val;

	chdrv_i2c_queue_t *q = &(grp_ptr->i2c_queue[bus_num]);
  40757c:	7efa      	ldrb	r2, [r7, #27]
  40757e:	4613      	mov	r3, r2
  407580:	011b      	lsls	r3, r3, #4
  407582:	4413      	add	r3, r2
  407584:	009b      	lsls	r3, r3, #2
  407586:	3328      	adds	r3, #40	; 0x28
  407588:	68fa      	ldr	r2, [r7, #12]
  40758a:	4413      	add	r3, r2
  40758c:	3304      	adds	r3, #4
  40758e:	617b      	str	r3, [r7, #20]
	chdrv_i2c_transaction_t *t = &(q->transaction[q->len]);
  407590:	697b      	ldr	r3, [r7, #20]
  407592:	789b      	ldrb	r3, [r3, #2]
  407594:	011b      	lsls	r3, r3, #4
  407596:	697a      	ldr	r2, [r7, #20]
  407598:	4413      	add	r3, r2
  40759a:	3304      	adds	r3, #4
  40759c:	613b      	str	r3, [r7, #16]

	if (q->len < CHDRV_MAX_I2C_QUEUE_LENGTH) {
  40759e:	697b      	ldr	r3, [r7, #20]
  4075a0:	789b      	ldrb	r3, [r3, #2]
  4075a2:	2b03      	cmp	r3, #3
  4075a4:	d81d      	bhi.n	4075e2 <chdrv_group_i2c_queue+0x86>
		t->databuf = data;
  4075a6:	693b      	ldr	r3, [r7, #16]
  4075a8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  4075aa:	60da      	str	r2, [r3, #12]
		t->dev_ptr = dev_ptr;
  4075ac:	693b      	ldr	r3, [r7, #16]
  4075ae:	68ba      	ldr	r2, [r7, #8]
  4075b0:	609a      	str	r2, [r3, #8]
		t->addr = addr;
  4075b2:	693b      	ldr	r3, [r7, #16]
  4075b4:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  4075b6:	809a      	strh	r2, [r3, #4]
		t->nbytes = nbytes;
  4075b8:	693b      	ldr	r3, [r7, #16]
  4075ba:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
  4075bc:	80da      	strh	r2, [r3, #6]
		t->rd_wrb = rd_wrb;
  4075be:	693b      	ldr	r3, [r7, #16]
  4075c0:	79fa      	ldrb	r2, [r7, #7]
  4075c2:	705a      	strb	r2, [r3, #1]
		t->type = type;
  4075c4:	693b      	ldr	r3, [r7, #16]
  4075c6:	79ba      	ldrb	r2, [r7, #6]
  4075c8:	701a      	strb	r2, [r3, #0]
		t->xfer_num = 0;
  4075ca:	693b      	ldr	r3, [r7, #16]
  4075cc:	2200      	movs	r2, #0
  4075ce:	709a      	strb	r2, [r3, #2]
		q->len++;
  4075d0:	697b      	ldr	r3, [r7, #20]
  4075d2:	789b      	ldrb	r3, [r3, #2]
  4075d4:	3301      	adds	r3, #1
  4075d6:	b2da      	uxtb	r2, r3
  4075d8:	697b      	ldr	r3, [r7, #20]
  4075da:	709a      	strb	r2, [r3, #2]
		ret_val = 0;
  4075dc:	2300      	movs	r3, #0
  4075de:	61fb      	str	r3, [r7, #28]
  4075e0:	e001      	b.n	4075e6 <chdrv_group_i2c_queue+0x8a>
	} else {
		ret_val = 1;
  4075e2:	2301      	movs	r3, #1
  4075e4:	61fb      	str	r3, [r7, #28]
	}

	return ret_val;
  4075e6:	69fb      	ldr	r3, [r7, #28]
}
  4075e8:	4618      	mov	r0, r3
  4075ea:	3720      	adds	r7, #32
  4075ec:	46bd      	mov	sp, r7
  4075ee:	bd80      	pop	{r7, pc}
  4075f0:	00405b55 	.word	0x00405b55

004075f4 <chdrv_group_i2c_irq_handler>:
 *
 * Call this function once from your I2C interrupt handler each time it executes.
 * It will call the user's callback routine (grp_ptr->io_complete_callback) when all transactions 
 * are complete.
 */
void chdrv_group_i2c_irq_handler(ch_group_t *grp_ptr, uint8_t i2c_bus_index) {
  4075f4:	b5b0      	push	{r4, r5, r7, lr}
  4075f6:	b08c      	sub	sp, #48	; 0x30
  4075f8:	af00      	add	r7, sp, #0
  4075fa:	6078      	str	r0, [r7, #4]
  4075fc:	460b      	mov	r3, r1
  4075fe:	70fb      	strb	r3, [r7, #3]
	int i;
	int transactions_pending;
	chdrv_i2c_queue_t *q = &(grp_ptr->i2c_queue[i2c_bus_index]);
  407600:	78fa      	ldrb	r2, [r7, #3]
  407602:	4613      	mov	r3, r2
  407604:	011b      	lsls	r3, r3, #4
  407606:	4413      	add	r3, r2
  407608:	009b      	lsls	r3, r3, #2
  40760a:	3328      	adds	r3, #40	; 0x28
  40760c:	687a      	ldr	r2, [r7, #4]
  40760e:	4413      	add	r3, r2
  407610:	3304      	adds	r3, #4
  407612:	61fb      	str	r3, [r7, #28]
	chdrv_i2c_transaction_t *t = &(q->transaction[q->idx]);
  407614:	69fb      	ldr	r3, [r7, #28]
  407616:	78db      	ldrb	r3, [r3, #3]
  407618:	011b      	lsls	r3, r3, #4
  40761a:	69fa      	ldr	r2, [r7, #28]
  40761c:	4413      	add	r3, r2
  40761e:	3304      	adds	r3, #4
  407620:	61bb      	str	r3, [r7, #24]
	ch_dev_t *dev_ptr = q->transaction[q->idx].dev_ptr;
  407622:	69fb      	ldr	r3, [r7, #28]
  407624:	78db      	ldrb	r3, [r3, #3]
  407626:	69fa      	ldr	r2, [r7, #28]
  407628:	011b      	lsls	r3, r3, #4
  40762a:	4413      	add	r3, r2
  40762c:	330c      	adds	r3, #12
  40762e:	681b      	ldr	r3, [r3, #0]
  407630:	627b      	str	r3, [r7, #36]	; 0x24


    chbsp_program_disable(dev_ptr);					// de-assert PROG pin, possibly only briefly
  407632:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407634:	4b93      	ldr	r3, [pc, #588]	; (407884 <chdrv_group_i2c_irq_handler+0x290>)
  407636:	4798      	blx	r3

    if (q->idx < q->len) {
  407638:	69fb      	ldr	r3, [r7, #28]
  40763a:	78da      	ldrb	r2, [r3, #3]
  40763c:	69fb      	ldr	r3, [r7, #28]
  40763e:	789b      	ldrb	r3, [r3, #2]
  407640:	429a      	cmp	r2, r3
  407642:	f080 80bf 	bcs.w	4077c4 <chdrv_group_i2c_irq_handler+0x1d0>
    	dev_ptr = q->transaction[q->idx].dev_ptr;
  407646:	69fb      	ldr	r3, [r7, #28]
  407648:	78db      	ldrb	r3, [r3, #3]
  40764a:	69fa      	ldr	r2, [r7, #28]
  40764c:	011b      	lsls	r3, r3, #4
  40764e:	4413      	add	r3, r2
  407650:	330c      	adds	r3, #12
  407652:	681b      	ldr	r3, [r3, #0]
  407654:	627b      	str	r3, [r7, #36]	; 0x24
		q->running = 1;
  407656:	69fb      	ldr	r3, [r7, #28]
  407658:	2201      	movs	r2, #1
  40765a:	705a      	strb	r2, [r3, #1]

		if (t->type == CHDRV_NB_TRANS_TYPE_EXTERNAL) {
  40765c:	69bb      	ldr	r3, [r7, #24]
  40765e:	781b      	ldrb	r3, [r3, #0]
  407660:	2b02      	cmp	r3, #2
  407662:	d10f      	bne.n	407684 <chdrv_group_i2c_irq_handler+0x90>
			/* Externally-requested transfer */

			(q->idx)++;
  407664:	69fb      	ldr	r3, [r7, #28]
  407666:	78db      	ldrb	r3, [r3, #3]
  407668:	3301      	adds	r3, #1
  40766a:	b2da      	uxtb	r2, r3
  40766c:	69fb      	ldr	r3, [r7, #28]
  40766e:	70da      	strb	r2, [r3, #3]
			chbsp_external_i2c_irq_handler(t);
  407670:	69b8      	ldr	r0, [r7, #24]
  407672:	4b85      	ldr	r3, [pc, #532]	; (407888 <chdrv_group_i2c_irq_handler+0x294>)
  407674:	4798      	blx	r3
    		t->xfer_num++;			// count this transfer
  407676:	69bb      	ldr	r3, [r7, #24]
  407678:	789b      	ldrb	r3, [r3, #2]
  40767a:	3301      	adds	r3, #1
  40767c:	b2da      	uxtb	r2, r3
  40767e:	69bb      	ldr	r3, [r7, #24]
  407680:	709a      	strb	r2, [r3, #2]
  407682:	e09c      	b.n	4077be <chdrv_group_i2c_irq_handler+0x1ca>

		} else if (t->type == CHDRV_NB_TRANS_TYPE_PROG) {
  407684:	69bb      	ldr	r3, [r7, #24]
  407686:	781b      	ldrb	r3, [r3, #0]
  407688:	2b01      	cmp	r3, #1
  40768a:	d16d      	bne.n	407768 <chdrv_group_i2c_irq_handler+0x174>
			/* Programming interface transfer */

			/* programming interface has max transfer size - check if still more to do during this transaction */
			uint8_t total_xfers = (t->nbytes + (CH_PROG_XFER_SIZE - 1)) / CH_PROG_XFER_SIZE;
  40768c:	69bb      	ldr	r3, [r7, #24]
  40768e:	88db      	ldrh	r3, [r3, #6]
  407690:	33ff      	adds	r3, #255	; 0xff
  407692:	2b00      	cmp	r3, #0
  407694:	da00      	bge.n	407698 <chdrv_group_i2c_irq_handler+0xa4>
  407696:	33ff      	adds	r3, #255	; 0xff
  407698:	121b      	asrs	r3, r3, #8
  40769a:	75fb      	strb	r3, [r7, #23]


			if (t->xfer_num < total_xfers) {
  40769c:	69bb      	ldr	r3, [r7, #24]
  40769e:	789b      	ldrb	r3, [r3, #2]
  4076a0:	7dfa      	ldrb	r2, [r7, #23]
  4076a2:	429a      	cmp	r2, r3
  4076a4:	f240 808b 	bls.w	4077be <chdrv_group_i2c_irq_handler+0x1ca>
				/* still need to complete this transaction */

				uint16_t bytes_left;
				uint16_t xfer_bytes;

				bytes_left = (t->nbytes - (t->xfer_num * CH_PROG_XFER_SIZE));
  4076a8:	69bb      	ldr	r3, [r7, #24]
  4076aa:	88da      	ldrh	r2, [r3, #6]
  4076ac:	69bb      	ldr	r3, [r7, #24]
  4076ae:	789b      	ldrb	r3, [r3, #2]
  4076b0:	b29b      	uxth	r3, r3
  4076b2:	021b      	lsls	r3, r3, #8
  4076b4:	b29b      	uxth	r3, r3
  4076b6:	1ad3      	subs	r3, r2, r3
  4076b8:	82bb      	strh	r3, [r7, #20]

				if (t->rd_wrb) {			// only read operations supported for now
  4076ba:	69bb      	ldr	r3, [r7, #24]
  4076bc:	785b      	ldrb	r3, [r3, #1]
  4076be:	2b00      	cmp	r3, #0
  4076c0:	d040      	beq.n	407744 <chdrv_group_i2c_irq_handler+0x150>

					if (grp_ptr->i2c_drv_flags & I2C_DRV_FLAG_RESET_AFTER_NB) {
  4076c2:	687b      	ldr	r3, [r7, #4]
  4076c4:	889b      	ldrh	r3, [r3, #4]
  4076c6:	f003 0301 	and.w	r3, r3, #1
  4076ca:	2b00      	cmp	r3, #0
  4076cc:	d002      	beq.n	4076d4 <chdrv_group_i2c_irq_handler+0xe0>
			    		chbsp_i2c_reset(dev_ptr);					// reset I2C bus if BSP says it's needed */
  4076ce:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4076d0:	4b6e      	ldr	r3, [pc, #440]	; (40788c <chdrv_group_i2c_irq_handler+0x298>)
  4076d2:	4798      	blx	r3
					}

					chbsp_program_enable(dev_ptr);					// assert PROG pin
  4076d4:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4076d6:	4b6e      	ldr	r3, [pc, #440]	; (407890 <chdrv_group_i2c_irq_handler+0x29c>)
  4076d8:	4798      	blx	r3

	        		uint8_t message[] = { (0x80 | CH_PROG_REG_CTL), 0x09 };      // read burst command
  4076da:	4b6e      	ldr	r3, [pc, #440]	; (407894 <chdrv_group_i2c_irq_handler+0x2a0>)
  4076dc:	881b      	ldrh	r3, [r3, #0]
  4076de:	81bb      	strh	r3, [r7, #12]

	        		if (bytes_left > CH_PROG_XFER_SIZE) {
  4076e0:	8abb      	ldrh	r3, [r7, #20]
  4076e2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  4076e6:	d903      	bls.n	4076f0 <chdrv_group_i2c_irq_handler+0xfc>
	                		xfer_bytes = CH_PROG_XFER_SIZE;
  4076e8:	f44f 7380 	mov.w	r3, #256	; 0x100
  4076ec:	847b      	strh	r3, [r7, #34]	; 0x22
  4076ee:	e001      	b.n	4076f4 <chdrv_group_i2c_irq_handler+0x100>
	        		} else {
	                		xfer_bytes = bytes_left;
  4076f0:	8abb      	ldrh	r3, [r7, #20]
  4076f2:	847b      	strh	r3, [r7, #34]	; 0x22
	        		}
	        		chdrv_prog_write(dev_ptr, CH_PROG_REG_ADDR, (t->addr + (t->xfer_num * CH_PROG_XFER_SIZE)));
  4076f4:	69bb      	ldr	r3, [r7, #24]
  4076f6:	889a      	ldrh	r2, [r3, #4]
  4076f8:	69bb      	ldr	r3, [r7, #24]
  4076fa:	789b      	ldrb	r3, [r3, #2]
  4076fc:	b29b      	uxth	r3, r3
  4076fe:	021b      	lsls	r3, r3, #8
  407700:	b29b      	uxth	r3, r3
  407702:	4413      	add	r3, r2
  407704:	b29b      	uxth	r3, r3
  407706:	461a      	mov	r2, r3
  407708:	2105      	movs	r1, #5
  40770a:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40770c:	4b62      	ldr	r3, [pc, #392]	; (407898 <chdrv_group_i2c_irq_handler+0x2a4>)
  40770e:	4798      	blx	r3
	        		chdrv_prog_write(dev_ptr, CH_PROG_REG_CNT, (xfer_bytes - 1));
  407710:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  407712:	3b01      	subs	r3, #1
  407714:	b29b      	uxth	r3, r3
  407716:	461a      	mov	r2, r3
  407718:	2107      	movs	r1, #7
  40771a:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40771c:	4b5e      	ldr	r3, [pc, #376]	; (407898 <chdrv_group_i2c_irq_handler+0x2a4>)
  40771e:	4798      	blx	r3
	        		(void) chdrv_prog_i2c_write(dev_ptr, message, sizeof(message));
  407720:	f107 030c 	add.w	r3, r7, #12
  407724:	2202      	movs	r2, #2
  407726:	4619      	mov	r1, r3
  407728:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40772a:	4b5c      	ldr	r3, [pc, #368]	; (40789c <chdrv_group_i2c_irq_handler+0x2a8>)
  40772c:	4798      	blx	r3
	        		(void) chdrv_prog_i2c_read_nb(dev_ptr, (t->databuf + (t->xfer_num * CH_PROG_XFER_SIZE)), xfer_bytes);
  40772e:	69bb      	ldr	r3, [r7, #24]
  407730:	68db      	ldr	r3, [r3, #12]
  407732:	69ba      	ldr	r2, [r7, #24]
  407734:	7892      	ldrb	r2, [r2, #2]
  407736:	0212      	lsls	r2, r2, #8
  407738:	4413      	add	r3, r2
  40773a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
  40773c:	4619      	mov	r1, r3
  40773e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407740:	4b57      	ldr	r3, [pc, #348]	; (4078a0 <chdrv_group_i2c_irq_handler+0x2ac>)
  407742:	4798      	blx	r3
				}

	    		t->xfer_num++;			// count this transfer
  407744:	69bb      	ldr	r3, [r7, #24]
  407746:	789b      	ldrb	r3, [r3, #2]
  407748:	3301      	adds	r3, #1
  40774a:	b2da      	uxtb	r2, r3
  40774c:	69bb      	ldr	r3, [r7, #24]
  40774e:	709a      	strb	r2, [r3, #2]

	    		/* if this is the last transfer in this transaction, advance queue index */
	    		if (t->xfer_num >= total_xfers) {
  407750:	69bb      	ldr	r3, [r7, #24]
  407752:	789b      	ldrb	r3, [r3, #2]
  407754:	7dfa      	ldrb	r2, [r7, #23]
  407756:	429a      	cmp	r2, r3
  407758:	d831      	bhi.n	4077be <chdrv_group_i2c_irq_handler+0x1ca>
					(q->idx)++;
  40775a:	69fb      	ldr	r3, [r7, #28]
  40775c:	78db      	ldrb	r3, [r3, #3]
  40775e:	3301      	adds	r3, #1
  407760:	b2da      	uxtb	r2, r3
  407762:	69fb      	ldr	r3, [r7, #28]
  407764:	70da      	strb	r2, [r3, #3]
  407766:	e02a      	b.n	4077be <chdrv_group_i2c_irq_handler+0x1ca>

			}

		} else {
			/* Standard transfer */
			if (t->rd_wrb) {
  407768:	69bb      	ldr	r3, [r7, #24]
  40776a:	785b      	ldrb	r3, [r3, #1]
  40776c:	2b00      	cmp	r3, #0
  40776e:	d010      	beq.n	407792 <chdrv_group_i2c_irq_handler+0x19e>
				(q->idx)++;
  407770:	69fb      	ldr	r3, [r7, #28]
  407772:	78db      	ldrb	r3, [r3, #3]
  407774:	3301      	adds	r3, #1
  407776:	b2da      	uxtb	r2, r3
  407778:	69fb      	ldr	r3, [r7, #28]
  40777a:	70da      	strb	r2, [r3, #3]
				//printf("Sensor %u end IQ transfer: %lu \n", ch_get_dev_num(dev_ptr), (uint32_t) time_get_in_us());
				chbsp_i2c_mem_read_nb(t->dev_ptr, t->addr, t->databuf, t->nbytes);
  40777c:	69bb      	ldr	r3, [r7, #24]
  40777e:	6898      	ldr	r0, [r3, #8]
  407780:	69bb      	ldr	r3, [r7, #24]
  407782:	8899      	ldrh	r1, [r3, #4]
  407784:	69bb      	ldr	r3, [r7, #24]
  407786:	68da      	ldr	r2, [r3, #12]
  407788:	69bb      	ldr	r3, [r7, #24]
  40778a:	88db      	ldrh	r3, [r3, #6]
  40778c:	4c45      	ldr	r4, [pc, #276]	; (4078a4 <chdrv_group_i2c_irq_handler+0x2b0>)
  40778e:	47a0      	blx	r4
  407790:	e00f      	b.n	4077b2 <chdrv_group_i2c_irq_handler+0x1be>

			} else {
				
				(q->idx)++;
  407792:	69fb      	ldr	r3, [r7, #28]
  407794:	78db      	ldrb	r3, [r3, #3]
  407796:	3301      	adds	r3, #1
  407798:	b2da      	uxtb	r2, r3
  40779a:	69fb      	ldr	r3, [r7, #28]
  40779c:	70da      	strb	r2, [r3, #3]
				chbsp_i2c_mem_write_nb(t->dev_ptr, t->addr, t->databuf, t->nbytes);
  40779e:	69bb      	ldr	r3, [r7, #24]
  4077a0:	6898      	ldr	r0, [r3, #8]
  4077a2:	69bb      	ldr	r3, [r7, #24]
  4077a4:	8899      	ldrh	r1, [r3, #4]
  4077a6:	69bb      	ldr	r3, [r7, #24]
  4077a8:	68da      	ldr	r2, [r3, #12]
  4077aa:	69bb      	ldr	r3, [r7, #24]
  4077ac:	88db      	ldrh	r3, [r3, #6]
  4077ae:	4c3e      	ldr	r4, [pc, #248]	; (4078a8 <chdrv_group_i2c_irq_handler+0x2b4>)
  4077b0:	47a0      	blx	r4
			}
    		t->xfer_num++;			// count this transfer
  4077b2:	69bb      	ldr	r3, [r7, #24]
  4077b4:	789b      	ldrb	r3, [r3, #2]
  4077b6:	3301      	adds	r3, #1
  4077b8:	b2da      	uxtb	r2, r3
  4077ba:	69bb      	ldr	r3, [r7, #24]
  4077bc:	709a      	strb	r2, [r3, #2]
		}
		transactions_pending = 1;
  4077be:	2301      	movs	r3, #1
  4077c0:	62bb      	str	r3, [r7, #40]	; 0x28
  4077c2:	e04e      	b.n	407862 <chdrv_group_i2c_irq_handler+0x26e>
	} else {
		if (q->idx >= 1) {
  4077c4:	69fb      	ldr	r3, [r7, #28]
  4077c6:	78db      	ldrb	r3, [r3, #3]
  4077c8:	2b00      	cmp	r3, #0
  4077ca:	d017      	beq.n	4077fc <chdrv_group_i2c_irq_handler+0x208>
			dev_ptr = q->transaction[(q->idx - 1)].dev_ptr;		// get dev_ptr for previous completed transaction
  4077cc:	69fb      	ldr	r3, [r7, #28]
  4077ce:	78db      	ldrb	r3, [r3, #3]
  4077d0:	3b01      	subs	r3, #1
  4077d2:	69fa      	ldr	r2, [r7, #28]
  4077d4:	011b      	lsls	r3, r3, #4
  4077d6:	4413      	add	r3, r2
  4077d8:	330c      	adds	r3, #12
  4077da:	681b      	ldr	r3, [r3, #0]
  4077dc:	627b      	str	r3, [r7, #36]	; 0x24
			if (dev_ptr != NULL) {
  4077de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4077e0:	2b00      	cmp	r3, #0
  4077e2:	d00b      	beq.n	4077fc <chdrv_group_i2c_irq_handler+0x208>
			    chbsp_program_disable(dev_ptr);					// de-assert PROG pin for completed transaction
  4077e4:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4077e6:	4b27      	ldr	r3, [pc, #156]	; (407884 <chdrv_group_i2c_irq_handler+0x290>)
  4077e8:	4798      	blx	r3

					if (grp_ptr->i2c_drv_flags & I2C_DRV_FLAG_RESET_AFTER_NB) {
  4077ea:	687b      	ldr	r3, [r7, #4]
  4077ec:	889b      	ldrh	r3, [r3, #4]
  4077ee:	f003 0301 	and.w	r3, r3, #1
  4077f2:	2b00      	cmp	r3, #0
  4077f4:	d002      	beq.n	4077fc <chdrv_group_i2c_irq_handler+0x208>
			    		chbsp_i2c_reset(dev_ptr);				// reset I2C bus if BSP requires it
  4077f6:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4077f8:	4b24      	ldr	r3, [pc, #144]	; (40788c <chdrv_group_i2c_irq_handler+0x298>)
  4077fa:	4798      	blx	r3
					}
			}
		}
		
		q->len = 0;
  4077fc:	69fb      	ldr	r3, [r7, #28]
  4077fe:	2200      	movs	r2, #0
  407800:	709a      	strb	r2, [r3, #2]
		q->idx = 0;
  407802:	69fb      	ldr	r3, [r7, #28]
  407804:	2200      	movs	r2, #0
  407806:	70da      	strb	r2, [r3, #3]
		q->running = 0;
  407808:	69fb      	ldr	r3, [r7, #28]
  40780a:	2200      	movs	r2, #0
  40780c:	705a      	strb	r2, [r3, #1]
		transactions_pending = 0;
  40780e:	2300      	movs	r3, #0
  407810:	62bb      	str	r3, [r7, #40]	; 0x28
		printf("Sensor %u end IQ transfer: %lu \n", ch_get_dev_num(dev_ptr), (uint32_t) time_get_in_us());
  407812:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407814:	4b25      	ldr	r3, [pc, #148]	; (4078ac <chdrv_group_i2c_irq_handler+0x2b8>)
  407816:	4798      	blx	r3
  407818:	4603      	mov	r3, r0
  40781a:	461d      	mov	r5, r3
  40781c:	4b24      	ldr	r3, [pc, #144]	; (4078b0 <chdrv_group_i2c_irq_handler+0x2bc>)
  40781e:	4798      	blx	r3
  407820:	4603      	mov	r3, r0
  407822:	460c      	mov	r4, r1
  407824:	461a      	mov	r2, r3
  407826:	4629      	mov	r1, r5
  407828:	4822      	ldr	r0, [pc, #136]	; (4078b4 <chdrv_group_i2c_irq_handler+0x2c0>)
  40782a:	4b23      	ldr	r3, [pc, #140]	; (4078b8 <chdrv_group_i2c_irq_handler+0x2c4>)
  40782c:	4798      	blx	r3
		for (i = 0; i < grp_ptr->num_i2c_buses; i++) {
  40782e:	2300      	movs	r3, #0
  407830:	62fb      	str	r3, [r7, #44]	; 0x2c
  407832:	e010      	b.n	407856 <chdrv_group_i2c_irq_handler+0x262>
			if (grp_ptr->i2c_queue[i].len) {
  407834:	6879      	ldr	r1, [r7, #4]
  407836:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  407838:	4613      	mov	r3, r2
  40783a:	011b      	lsls	r3, r3, #4
  40783c:	4413      	add	r3, r2
  40783e:	009b      	lsls	r3, r3, #2
  407840:	440b      	add	r3, r1
  407842:	332e      	adds	r3, #46	; 0x2e
  407844:	781b      	ldrb	r3, [r3, #0]
  407846:	2b00      	cmp	r3, #0
  407848:	d002      	beq.n	407850 <chdrv_group_i2c_irq_handler+0x25c>
				transactions_pending = 1;
  40784a:	2301      	movs	r3, #1
  40784c:	62bb      	str	r3, [r7, #40]	; 0x28
				break;
  40784e:	e008      	b.n	407862 <chdrv_group_i2c_irq_handler+0x26e>
		for (i = 0; i < grp_ptr->num_i2c_buses; i++) {
  407850:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  407852:	3301      	adds	r3, #1
  407854:	62fb      	str	r3, [r7, #44]	; 0x2c
  407856:	687b      	ldr	r3, [r7, #4]
  407858:	785b      	ldrb	r3, [r3, #1]
  40785a:	461a      	mov	r2, r3
  40785c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40785e:	429a      	cmp	r2, r3
  407860:	dce8      	bgt.n	407834 <chdrv_group_i2c_irq_handler+0x240>
			}
		}
	}

	if (!transactions_pending) {
  407862:	6abb      	ldr	r3, [r7, #40]	; 0x28
  407864:	2b00      	cmp	r3, #0
  407866:	d108      	bne.n	40787a <chdrv_group_i2c_irq_handler+0x286>
		ch_io_complete_callback_t func_ptr = grp_ptr->io_complete_callback;
  407868:	687b      	ldr	r3, [r7, #4]
  40786a:	695b      	ldr	r3, [r3, #20]
  40786c:	613b      	str	r3, [r7, #16]

		if (func_ptr != NULL) {
  40786e:	693b      	ldr	r3, [r7, #16]
  407870:	2b00      	cmp	r3, #0
  407872:	d002      	beq.n	40787a <chdrv_group_i2c_irq_handler+0x286>
			(*func_ptr)(grp_ptr);
  407874:	693b      	ldr	r3, [r7, #16]
  407876:	6878      	ldr	r0, [r7, #4]
  407878:	4798      	blx	r3
		}
	}

}
  40787a:	bf00      	nop
  40787c:	3730      	adds	r7, #48	; 0x30
  40787e:	46bd      	mov	sp, r7
  407880:	bdb0      	pop	{r4, r5, r7, pc}
  407882:	bf00      	nop
  407884:	0040210d 	.word	0x0040210d
  407888:	004058c3 	.word	0x004058c3
  40788c:	00402c39 	.word	0x00402c39
  407890:	004020d5 	.word	0x004020d5
  407894:	0040dc84 	.word	0x0040dc84
  407898:	00407aad 	.word	0x00407aad
  40789c:	0040728d 	.word	0x0040728d
  4078a0:	004072fd 	.word	0x004072fd
  4078a4:	00402add 	.word	0x00402add
  4078a8:	00402899 	.word	0x00402899
  4078ac:	00405b01 	.word	0x00405b01
  4078b0:	00400af9 	.word	0x00400af9
  4078b4:	0040dc60 	.word	0x0040dc60
  4078b8:	00409ee9 	.word	0x00409ee9

004078bc <chdrv_wait_for_lock>:
 * \return 0 if startup sequence finished, non-zero if startup sequence timed out or sensor is not connected
 *
 * After the sensor is programmed, it executes an internal start-up and self-test sequence. This function waits the
 * specified time in milliseconds for the sensor to finish this sequence.
 */
int chdrv_wait_for_lock(ch_dev_t *dev_ptr, uint16_t timeout_ms) {
  4078bc:	b590      	push	{r4, r7, lr}
  4078be:	b099      	sub	sp, #100	; 0x64
  4078c0:	af00      	add	r7, sp, #0
  4078c2:	6078      	str	r0, [r7, #4]
  4078c4:	460b      	mov	r3, r1
  4078c6:	807b      	strh	r3, [r7, #2]
	uint32_t start_time = chbsp_timestamp_ms();
  4078c8:	4b1d      	ldr	r3, [pc, #116]	; (407940 <chdrv_wait_for_lock+0x84>)
  4078ca:	4798      	blx	r3
  4078cc:	65b8      	str	r0, [r7, #88]	; 0x58
	int ch_err = !(dev_ptr->sensor_connected);
  4078ce:	687b      	ldr	r3, [r7, #4]
  4078d0:	7fdb      	ldrb	r3, [r3, #31]
  4078d2:	2b00      	cmp	r3, #0
  4078d4:	bf0c      	ite	eq
  4078d6:	2301      	moveq	r3, #1
  4078d8:	2300      	movne	r3, #0
  4078da:	b2db      	uxtb	r3, r3
  4078dc:	65fb      	str	r3, [r7, #92]	; 0x5c

	while (!ch_err && !(dev_ptr->get_locked_state(dev_ptr))) {
  4078de:	e00e      	b.n	4078fe <chdrv_wait_for_lock+0x42>
		chbsp_delay_ms(10);
  4078e0:	200a      	movs	r0, #10
  4078e2:	4b18      	ldr	r3, [pc, #96]	; (407944 <chdrv_wait_for_lock+0x88>)
  4078e4:	4798      	blx	r3
		ch_err = ((chbsp_timestamp_ms() - start_time) > timeout_ms);
  4078e6:	4b16      	ldr	r3, [pc, #88]	; (407940 <chdrv_wait_for_lock+0x84>)
  4078e8:	4798      	blx	r3
  4078ea:	4602      	mov	r2, r0
  4078ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  4078ee:	1ad2      	subs	r2, r2, r3
  4078f0:	887b      	ldrh	r3, [r7, #2]
  4078f2:	429a      	cmp	r2, r3
  4078f4:	bf8c      	ite	hi
  4078f6:	2301      	movhi	r3, #1
  4078f8:	2300      	movls	r3, #0
  4078fa:	b2db      	uxtb	r3, r3
  4078fc:	65fb      	str	r3, [r7, #92]	; 0x5c
	while (!ch_err && !(dev_ptr->get_locked_state(dev_ptr))) {
  4078fe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407900:	2b00      	cmp	r3, #0
  407902:	d106      	bne.n	407912 <chdrv_wait_for_lock+0x56>
  407904:	687b      	ldr	r3, [r7, #4]
  407906:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  407908:	6878      	ldr	r0, [r7, #4]
  40790a:	4798      	blx	r3
  40790c:	4603      	mov	r3, r0
  40790e:	2b00      	cmp	r3, #0
  407910:	d0e6      	beq.n	4078e0 <chdrv_wait_for_lock+0x24>
	}

#ifdef CHDRV_DEBUG
	if (ch_err) {
  407912:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407914:	2b00      	cmp	r3, #0
  407916:	d00d      	beq.n	407934 <chdrv_wait_for_lock+0x78>
		char cbuf[80];
		snprintf(cbuf, sizeof(cbuf), "Sensor %hhu initialization timed out or missing\n", dev_ptr->io_index);
  407918:	687b      	ldr	r3, [r7, #4]
  40791a:	f893 3020 	ldrb.w	r3, [r3, #32]
  40791e:	f107 0008 	add.w	r0, r7, #8
  407922:	4a09      	ldr	r2, [pc, #36]	; (407948 <chdrv_wait_for_lock+0x8c>)
  407924:	2150      	movs	r1, #80	; 0x50
  407926:	4c09      	ldr	r4, [pc, #36]	; (40794c <chdrv_wait_for_lock+0x90>)
  407928:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  40792a:	f107 0308 	add.w	r3, r7, #8
  40792e:	4618      	mov	r0, r3
  407930:	4b07      	ldr	r3, [pc, #28]	; (407950 <chdrv_wait_for_lock+0x94>)
  407932:	4798      	blx	r3
	}
#endif

	return ch_err;
  407934:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
}
  407936:	4618      	mov	r0, r3
  407938:	3764      	adds	r7, #100	; 0x64
  40793a:	46bd      	mov	sp, r7
  40793c:	bd90      	pop	{r4, r7, pc}
  40793e:	bf00      	nop
  407940:	00402fc5 	.word	0x00402fc5
  407944:	004026b9 	.word	0x004026b9
  407948:	0040dc88 	.word	0x0040dc88
  40794c:	0040a085 	.word	0x0040a085
  407950:	00402fa9 	.word	0x00402fa9

00407954 <chdrv_group_wait_for_lock>:
 *
 * After each sensor is programmed, it executes an internal start-up and self-test sequence. This 
 * function waits for all sensor devices to finish this sequence.  For each device, the maximum 
 * time to wait is \a CHDRV_FREQLOCK_TIMEOUT_MS milliseconds.
 */
int chdrv_group_wait_for_lock(ch_group_t *grp_ptr) {
  407954:	b580      	push	{r7, lr}
  407956:	b086      	sub	sp, #24
  407958:	af00      	add	r7, sp, #0
  40795a:	6078      	str	r0, [r7, #4]
	int ch_err = 0;
  40795c:	2300      	movs	r3, #0
  40795e:	617b      	str	r3, [r7, #20]

	for (uint8_t i = 0; i < grp_ptr->num_ports; i++) {
  407960:	2300      	movs	r3, #0
  407962:	74fb      	strb	r3, [r7, #19]
  407964:	e014      	b.n	407990 <chdrv_group_wait_for_lock+0x3c>
		ch_dev_t *dev_ptr = grp_ptr->device[i];
  407966:	7cfa      	ldrb	r2, [r7, #19]
  407968:	687b      	ldr	r3, [r7, #4]
  40796a:	3206      	adds	r2, #6
  40796c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  407970:	60fb      	str	r3, [r7, #12]

		if (dev_ptr->sensor_connected) {
  407972:	68fb      	ldr	r3, [r7, #12]
  407974:	7fdb      	ldrb	r3, [r3, #31]
  407976:	2b00      	cmp	r3, #0
  407978:	d007      	beq.n	40798a <chdrv_group_wait_for_lock+0x36>
			ch_err |= chdrv_wait_for_lock(dev_ptr, CHDRV_FREQLOCK_TIMEOUT_MS);
  40797a:	2164      	movs	r1, #100	; 0x64
  40797c:	68f8      	ldr	r0, [r7, #12]
  40797e:	4b09      	ldr	r3, [pc, #36]	; (4079a4 <chdrv_group_wait_for_lock+0x50>)
  407980:	4798      	blx	r3
  407982:	4602      	mov	r2, r0
  407984:	697b      	ldr	r3, [r7, #20]
  407986:	4313      	orrs	r3, r2
  407988:	617b      	str	r3, [r7, #20]
	for (uint8_t i = 0; i < grp_ptr->num_ports; i++) {
  40798a:	7cfb      	ldrb	r3, [r7, #19]
  40798c:	3301      	adds	r3, #1
  40798e:	74fb      	strb	r3, [r7, #19]
  407990:	687b      	ldr	r3, [r7, #4]
  407992:	781b      	ldrb	r3, [r3, #0]
  407994:	7cfa      	ldrb	r2, [r7, #19]
  407996:	429a      	cmp	r2, r3
  407998:	d3e5      	bcc.n	407966 <chdrv_group_wait_for_lock+0x12>
		}
	}
	return ch_err;
  40799a:	697b      	ldr	r3, [r7, #20]
}
  40799c:	4618      	mov	r0, r3
  40799e:	3718      	adds	r7, #24
  4079a0:	46bd      	mov	sp, r7
  4079a2:	bd80      	pop	{r7, pc}
  4079a4:	004078bd 	.word	0x004078bd

004079a8 <chdrv_group_hw_trigger>:
 * \return 0 if success, non-zero if \a grp_ptr pointer is invalid
 *
 * This function starts a triggered measurement on each sensor in a group, by briefly asserting the INT line to each device.  
 * Each sensor must have already been placed in hardware triggered mode before this function is called.
 */
int chdrv_group_hw_trigger(ch_group_t *grp_ptr) {
  4079a8:	b580      	push	{r7, lr}
  4079aa:	b086      	sub	sp, #24
  4079ac:	af00      	add	r7, sp, #0
  4079ae:	6078      	str	r0, [r7, #4]
	int ch_err = !grp_ptr;
  4079b0:	687b      	ldr	r3, [r7, #4]
  4079b2:	2b00      	cmp	r3, #0
  4079b4:	bf0c      	ite	eq
  4079b6:	2301      	moveq	r3, #1
  4079b8:	2300      	movne	r3, #0
  4079ba:	b2db      	uxtb	r3, r3
  4079bc:	613b      	str	r3, [r7, #16]
	ch_dev_t *dev_ptr;
	uint8_t dev_num;

	if (!ch_err) {
  4079be:	693b      	ldr	r3, [r7, #16]
  4079c0:	2b00      	cmp	r3, #0
  4079c2:	d15e      	bne.n	407a82 <chdrv_group_hw_trigger+0xda>
		//Disable pin interrupt before triggering pulse
		chbsp_group_io_interrupt_disable(grp_ptr);
  4079c4:	6878      	ldr	r0, [r7, #4]
  4079c6:	4b31      	ldr	r3, [pc, #196]	; (407a8c <chdrv_group_hw_trigger+0xe4>)
  4079c8:	4798      	blx	r3

		// Set INT pin as output
		chbsp_group_set_io_dir_out(grp_ptr);
  4079ca:	6878      	ldr	r0, [r7, #4]
  4079cc:	4b30      	ldr	r3, [pc, #192]	; (407a90 <chdrv_group_hw_trigger+0xe8>)
  4079ce:	4798      	blx	r3

		if (grp_ptr->pretrig_delay_us == 0) {
  4079d0:	687b      	ldr	r3, [r7, #4]
  4079d2:	891b      	ldrh	r3, [r3, #8]
  4079d4:	2b00      	cmp	r3, #0
  4079d6:	d109      	bne.n	4079ec <chdrv_group_hw_trigger+0x44>
			/* No pre-trigger delay - trigger rx-only and tx/rx nodes together */
			chbsp_group_io_set(grp_ptr);
  4079d8:	6878      	ldr	r0, [r7, #4]
  4079da:	4b2e      	ldr	r3, [pc, #184]	; (407a94 <chdrv_group_hw_trigger+0xec>)
  4079dc:	4798      	blx	r3
			chbsp_delay_us(CHDRV_TRIGGER_PULSE_US);
  4079de:	2005      	movs	r0, #5
  4079e0:	4b2d      	ldr	r3, [pc, #180]	; (407a98 <chdrv_group_hw_trigger+0xf0>)
  4079e2:	4798      	blx	r3
			chbsp_group_io_clear(grp_ptr);
  4079e4:	6878      	ldr	r0, [r7, #4]
  4079e6:	4b2d      	ldr	r3, [pc, #180]	; (407a9c <chdrv_group_hw_trigger+0xf4>)
  4079e8:	4798      	blx	r3
  4079ea:	e041      	b.n	407a70 <chdrv_group_hw_trigger+0xc8>

		} else {
			/* Pre-trigger rx-only nodes, delay, then trigger tx/rx nodes */

			// Pre-trigger any rx-only nodes
			for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  4079ec:	2300      	movs	r3, #0
  4079ee:	75fb      	strb	r3, [r7, #23]
  4079f0:	e00f      	b.n	407a12 <chdrv_group_hw_trigger+0x6a>
				dev_ptr = grp_ptr->device[dev_num];
  4079f2:	7dfa      	ldrb	r2, [r7, #23]
  4079f4:	687b      	ldr	r3, [r7, #4]
  4079f6:	3206      	adds	r2, #6
  4079f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4079fc:	60fb      	str	r3, [r7, #12]

				if (dev_ptr->mode == CH_MODE_TRIGGERED_RX_ONLY) {	// if rx-only mode
  4079fe:	68fb      	ldr	r3, [r7, #12]
  407a00:	791b      	ldrb	r3, [r3, #4]
  407a02:	2b20      	cmp	r3, #32
  407a04:	d102      	bne.n	407a0c <chdrv_group_hw_trigger+0x64>
					chbsp_io_set(dev_ptr);							//  trigger this sensor
  407a06:	68f8      	ldr	r0, [r7, #12]
  407a08:	4b25      	ldr	r3, [pc, #148]	; (407aa0 <chdrv_group_hw_trigger+0xf8>)
  407a0a:	4798      	blx	r3
			for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  407a0c:	7dfb      	ldrb	r3, [r7, #23]
  407a0e:	3301      	adds	r3, #1
  407a10:	75fb      	strb	r3, [r7, #23]
  407a12:	687b      	ldr	r3, [r7, #4]
  407a14:	781b      	ldrb	r3, [r3, #0]
  407a16:	7dfa      	ldrb	r2, [r7, #23]
  407a18:	429a      	cmp	r2, r3
  407a1a:	d3ea      	bcc.n	4079f2 <chdrv_group_hw_trigger+0x4a>
				}
			}

			chbsp_delay_us(CHDRV_TRIGGER_PULSE_US);
  407a1c:	2005      	movs	r0, #5
  407a1e:	4b1e      	ldr	r3, [pc, #120]	; (407a98 <chdrv_group_hw_trigger+0xf0>)
  407a20:	4798      	blx	r3
			chbsp_group_io_clear(grp_ptr);
  407a22:	6878      	ldr	r0, [r7, #4]
  407a24:	4b1d      	ldr	r3, [pc, #116]	; (407a9c <chdrv_group_hw_trigger+0xf4>)
  407a26:	4798      	blx	r3

			// Delay before triggering tx/rx node(s)
			chbsp_delay_us(grp_ptr->pretrig_delay_us - (CHDRV_TRIGGER_PULSE_US + CHDRV_DELAY_OVERHEAD_US)); 
  407a28:	687b      	ldr	r3, [r7, #4]
  407a2a:	891b      	ldrh	r3, [r3, #8]
  407a2c:	3b11      	subs	r3, #17
  407a2e:	4618      	mov	r0, r3
  407a30:	4b19      	ldr	r3, [pc, #100]	; (407a98 <chdrv_group_hw_trigger+0xf0>)
  407a32:	4798      	blx	r3

			// Trigger any tx/rx nodes
			for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  407a34:	2300      	movs	r3, #0
  407a36:	75fb      	strb	r3, [r7, #23]
  407a38:	e00f      	b.n	407a5a <chdrv_group_hw_trigger+0xb2>
				dev_ptr = grp_ptr->device[dev_num];
  407a3a:	7dfa      	ldrb	r2, [r7, #23]
  407a3c:	687b      	ldr	r3, [r7, #4]
  407a3e:	3206      	adds	r2, #6
  407a40:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  407a44:	60fb      	str	r3, [r7, #12]

				if (dev_ptr->mode == CH_MODE_TRIGGERED_TX_RX) {		// if tx/rx mode
  407a46:	68fb      	ldr	r3, [r7, #12]
  407a48:	791b      	ldrb	r3, [r3, #4]
  407a4a:	2b10      	cmp	r3, #16
  407a4c:	d102      	bne.n	407a54 <chdrv_group_hw_trigger+0xac>
					chbsp_io_set(dev_ptr);							//  trigger this sensor
  407a4e:	68f8      	ldr	r0, [r7, #12]
  407a50:	4b13      	ldr	r3, [pc, #76]	; (407aa0 <chdrv_group_hw_trigger+0xf8>)
  407a52:	4798      	blx	r3
			for (dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  407a54:	7dfb      	ldrb	r3, [r7, #23]
  407a56:	3301      	adds	r3, #1
  407a58:	75fb      	strb	r3, [r7, #23]
  407a5a:	687b      	ldr	r3, [r7, #4]
  407a5c:	781b      	ldrb	r3, [r3, #0]
  407a5e:	7dfa      	ldrb	r2, [r7, #23]
  407a60:	429a      	cmp	r2, r3
  407a62:	d3ea      	bcc.n	407a3a <chdrv_group_hw_trigger+0x92>
				}
			}

			chbsp_delay_us(CHDRV_TRIGGER_PULSE_US);
  407a64:	2005      	movs	r0, #5
  407a66:	4b0c      	ldr	r3, [pc, #48]	; (407a98 <chdrv_group_hw_trigger+0xf0>)
  407a68:	4798      	blx	r3
			chbsp_group_io_clear(grp_ptr);
  407a6a:	6878      	ldr	r0, [r7, #4]
  407a6c:	4b0b      	ldr	r3, [pc, #44]	; (407a9c <chdrv_group_hw_trigger+0xf4>)
  407a6e:	4798      	blx	r3
		}

		// Delay a bit before re-enabling pin interrupt to avoid possibly triggering on falling-edge noise
		chbsp_delay_us(10);
  407a70:	200a      	movs	r0, #10
  407a72:	4b09      	ldr	r3, [pc, #36]	; (407a98 <chdrv_group_hw_trigger+0xf0>)
  407a74:	4798      	blx	r3

		chbsp_group_set_io_dir_in(grp_ptr);
  407a76:	6878      	ldr	r0, [r7, #4]
  407a78:	4b0a      	ldr	r3, [pc, #40]	; (407aa4 <chdrv_group_hw_trigger+0xfc>)
  407a7a:	4798      	blx	r3
		chbsp_group_io_interrupt_enable(grp_ptr);
  407a7c:	6878      	ldr	r0, [r7, #4]
  407a7e:	4b0a      	ldr	r3, [pc, #40]	; (407aa8 <chdrv_group_hw_trigger+0x100>)
  407a80:	4798      	blx	r3
	}
	return ch_err;
  407a82:	693b      	ldr	r3, [r7, #16]
}
  407a84:	4618      	mov	r0, r3
  407a86:	3718      	adds	r7, #24
  407a88:	46bd      	mov	sp, r7
  407a8a:	bd80      	pop	{r7, pc}
  407a8c:	00402555 	.word	0x00402555
  407a90:	0040217d 	.word	0x0040217d
  407a94:	00402429 	.word	0x00402429
  407a98:	00402611 	.word	0x00402611
  407a9c:	004023a9 	.word	0x004023a9
  407aa0:	004025dd 	.word	0x004025dd
  407aa4:	004021fd 	.word	0x004021fd
  407aa8:	004024a9 	.word	0x004024a9

00407aac <chdrv_prog_write>:
 *
 * \return 0 if write to sensor succeeded, non-zero otherwise
 *
 * This local function writes a value to a sensor programming register.
 */
int chdrv_prog_write(ch_dev_t *dev_ptr, uint8_t reg_addr, uint16_t data) {
  407aac:	b580      	push	{r7, lr}
  407aae:	b084      	sub	sp, #16
  407ab0:	af00      	add	r7, sp, #0
  407ab2:	6078      	str	r0, [r7, #4]
  407ab4:	460b      	mov	r3, r1
  407ab6:	70fb      	strb	r3, [r7, #3]
  407ab8:	4613      	mov	r3, r2
  407aba:	803b      	strh	r3, [r7, #0]
	/* Set register address write bit */
	reg_addr |= 0x80;
  407abc:	78fb      	ldrb	r3, [r7, #3]
  407abe:	f063 037f 	orn	r3, r3, #127	; 0x7f
  407ac2:	70fb      	strb	r3, [r7, #3]
	
	/* Write the register address, followed by the value to be written */
	uint8_t message[] = { reg_addr, (uint8_t) data, (uint8_t) (data >> 8) };
  407ac4:	78fb      	ldrb	r3, [r7, #3]
  407ac6:	733b      	strb	r3, [r7, #12]
  407ac8:	883b      	ldrh	r3, [r7, #0]
  407aca:	b2db      	uxtb	r3, r3
  407acc:	737b      	strb	r3, [r7, #13]
  407ace:	883b      	ldrh	r3, [r7, #0]
  407ad0:	0a1b      	lsrs	r3, r3, #8
  407ad2:	b29b      	uxth	r3, r3
  407ad4:	b2db      	uxtb	r3, r3
  407ad6:	73bb      	strb	r3, [r7, #14]

	/* For the 2-byte registers, we also need to also write MSB after the LSB */
	return chdrv_prog_i2c_write(dev_ptr, message, (1 + CH_PROG_SIZEOF(reg_addr)));
  407ad8:	78fb      	ldrb	r3, [r7, #3]
  407ada:	f003 0340 	and.w	r3, r3, #64	; 0x40
  407ade:	2b00      	cmp	r3, #0
  407ae0:	d001      	beq.n	407ae6 <chdrv_prog_write+0x3a>
  407ae2:	2202      	movs	r2, #2
  407ae4:	e000      	b.n	407ae8 <chdrv_prog_write+0x3c>
  407ae6:	2203      	movs	r2, #3
  407ae8:	f107 030c 	add.w	r3, r7, #12
  407aec:	4619      	mov	r1, r3
  407aee:	6878      	ldr	r0, [r7, #4]
  407af0:	4b03      	ldr	r3, [pc, #12]	; (407b00 <chdrv_prog_write+0x54>)
  407af2:	4798      	blx	r3
  407af4:	4603      	mov	r3, r0
}
  407af6:	4618      	mov	r0, r3
  407af8:	3710      	adds	r7, #16
  407afa:	46bd      	mov	sp, r7
  407afc:	bd80      	pop	{r7, pc}
  407afe:	bf00      	nop
  407b00:	0040728d 	.word	0x0040728d

00407b04 <chdrv_prog_mem_write>:
 * \return 0 if write to sensor succeeded, non-zero otherwise
 *
 * This function writes to sensor memory using the low-level programming interface.  The type 
 * of write is automatically determined based on data length and target address alignment.
 */
int chdrv_prog_mem_write(ch_dev_t *dev_ptr, uint16_t addr, uint8_t *message, uint16_t nbytes) {
  407b04:	b580      	push	{r7, lr}
  407b06:	b088      	sub	sp, #32
  407b08:	af00      	add	r7, sp, #0
  407b0a:	60f8      	str	r0, [r7, #12]
  407b0c:	607a      	str	r2, [r7, #4]
  407b0e:	461a      	mov	r2, r3
  407b10:	460b      	mov	r3, r1
  407b12:	817b      	strh	r3, [r7, #10]
  407b14:	4613      	mov	r3, r2
  407b16:	813b      	strh	r3, [r7, #8]
	int ch_err = (nbytes == 0);
  407b18:	893b      	ldrh	r3, [r7, #8]
  407b1a:	2b00      	cmp	r3, #0
  407b1c:	bf0c      	ite	eq
  407b1e:	2301      	moveq	r3, #1
  407b20:	2300      	movne	r3, #0
  407b22:	b2db      	uxtb	r3, r3
  407b24:	61fb      	str	r3, [r7, #28]

	if (!ch_err) {
  407b26:	69fb      	ldr	r3, [r7, #28]
  407b28:	2b00      	cmp	r3, #0
  407b2a:	d106      	bne.n	407b3a <chdrv_prog_mem_write+0x36>
		ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_ADDR, addr);
  407b2c:	897b      	ldrh	r3, [r7, #10]
  407b2e:	461a      	mov	r2, r3
  407b30:	2105      	movs	r1, #5
  407b32:	68f8      	ldr	r0, [r7, #12]
  407b34:	4b30      	ldr	r3, [pc, #192]	; (407bf8 <chdrv_prog_mem_write+0xf4>)
  407b36:	4798      	blx	r3
  407b38:	61f8      	str	r0, [r7, #28]
	}

	if (nbytes == 1 || (nbytes == 2 && !(addr & 1))) {
  407b3a:	893b      	ldrh	r3, [r7, #8]
  407b3c:	2b01      	cmp	r3, #1
  407b3e:	d007      	beq.n	407b50 <chdrv_prog_mem_write+0x4c>
  407b40:	893b      	ldrh	r3, [r7, #8]
  407b42:	2b02      	cmp	r3, #2
  407b44:	d12c      	bne.n	407ba0 <chdrv_prog_mem_write+0x9c>
  407b46:	897b      	ldrh	r3, [r7, #10]
  407b48:	f003 0301 	and.w	r3, r3, #1
  407b4c:	2b00      	cmp	r3, #0
  407b4e:	d127      	bne.n	407ba0 <chdrv_prog_mem_write+0x9c>
		uint16_t data = message[0] | (message[1] << 8);
  407b50:	687b      	ldr	r3, [r7, #4]
  407b52:	781b      	ldrb	r3, [r3, #0]
  407b54:	b21a      	sxth	r2, r3
  407b56:	687b      	ldr	r3, [r7, #4]
  407b58:	3301      	adds	r3, #1
  407b5a:	781b      	ldrb	r3, [r3, #0]
  407b5c:	021b      	lsls	r3, r3, #8
  407b5e:	b21b      	sxth	r3, r3
  407b60:	4313      	orrs	r3, r2
  407b62:	b21b      	sxth	r3, r3
  407b64:	837b      	strh	r3, [r7, #26]
		if (!ch_err) {
  407b66:	69fb      	ldr	r3, [r7, #28]
  407b68:	2b00      	cmp	r3, #0
  407b6a:	d106      	bne.n	407b7a <chdrv_prog_mem_write+0x76>
			ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_DATA, data);
  407b6c:	8b7b      	ldrh	r3, [r7, #26]
  407b6e:	461a      	mov	r2, r3
  407b70:	2106      	movs	r1, #6
  407b72:	68f8      	ldr	r0, [r7, #12]
  407b74:	4b20      	ldr	r3, [pc, #128]	; (407bf8 <chdrv_prog_mem_write+0xf4>)
  407b76:	4798      	blx	r3
  407b78:	61f8      	str	r0, [r7, #28]
		}
		if (!ch_err) {
  407b7a:	69fb      	ldr	r3, [r7, #28]
  407b7c:	2b00      	cmp	r3, #0
  407b7e:	d134      	bne.n	407bea <chdrv_prog_mem_write+0xe6>
			uint8_t opcode = (0x03 | ((nbytes == 1) ? 0x08 : 0x00));			// XXX need define
  407b80:	893b      	ldrh	r3, [r7, #8]
  407b82:	2b01      	cmp	r3, #1
  407b84:	d101      	bne.n	407b8a <chdrv_prog_mem_write+0x86>
  407b86:	230b      	movs	r3, #11
  407b88:	e000      	b.n	407b8c <chdrv_prog_mem_write+0x88>
  407b8a:	2303      	movs	r3, #3
  407b8c:	767b      	strb	r3, [r7, #25]

			ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_CTL, opcode);
  407b8e:	7e7b      	ldrb	r3, [r7, #25]
  407b90:	b29b      	uxth	r3, r3
  407b92:	461a      	mov	r2, r3
  407b94:	2144      	movs	r1, #68	; 0x44
  407b96:	68f8      	ldr	r0, [r7, #12]
  407b98:	4b17      	ldr	r3, [pc, #92]	; (407bf8 <chdrv_prog_mem_write+0xf4>)
  407b9a:	4798      	blx	r3
  407b9c:	61f8      	str	r0, [r7, #28]
	if (nbytes == 1 || (nbytes == 2 && !(addr & 1))) {
  407b9e:	e024      	b.n	407bea <chdrv_prog_mem_write+0xe6>
		}
	} else {
		const uint8_t burst_hdr[2] = {0xC4, 0x0B};			// XXX need define
  407ba0:	4b16      	ldr	r3, [pc, #88]	; (407bfc <chdrv_prog_mem_write+0xf8>)
  407ba2:	881b      	ldrh	r3, [r3, #0]
  407ba4:	82bb      	strh	r3, [r7, #20]

		if (!ch_err) {
  407ba6:	69fb      	ldr	r3, [r7, #28]
  407ba8:	2b00      	cmp	r3, #0
  407baa:	d108      	bne.n	407bbe <chdrv_prog_mem_write+0xba>
			ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_CNT, (nbytes - 1));
  407bac:	893b      	ldrh	r3, [r7, #8]
  407bae:	3b01      	subs	r3, #1
  407bb0:	b29b      	uxth	r3, r3
  407bb2:	461a      	mov	r2, r3
  407bb4:	2107      	movs	r1, #7
  407bb6:	68f8      	ldr	r0, [r7, #12]
  407bb8:	4b0f      	ldr	r3, [pc, #60]	; (407bf8 <chdrv_prog_mem_write+0xf4>)
  407bba:	4798      	blx	r3
  407bbc:	61f8      	str	r0, [r7, #28]
		}
		if (!ch_err) {
  407bbe:	69fb      	ldr	r3, [r7, #28]
  407bc0:	2b00      	cmp	r3, #0
  407bc2:	d107      	bne.n	407bd4 <chdrv_prog_mem_write+0xd0>
			ch_err = chdrv_prog_i2c_write(dev_ptr, (uint8_t *) burst_hdr, sizeof(burst_hdr));
  407bc4:	f107 0314 	add.w	r3, r7, #20
  407bc8:	2202      	movs	r2, #2
  407bca:	4619      	mov	r1, r3
  407bcc:	68f8      	ldr	r0, [r7, #12]
  407bce:	4b0c      	ldr	r3, [pc, #48]	; (407c00 <chdrv_prog_mem_write+0xfc>)
  407bd0:	4798      	blx	r3
  407bd2:	61f8      	str	r0, [r7, #28]
		}
		if (!ch_err) {
  407bd4:	69fb      	ldr	r3, [r7, #28]
  407bd6:	2b00      	cmp	r3, #0
  407bd8:	d108      	bne.n	407bec <chdrv_prog_mem_write+0xe8>
			ch_err = chdrv_prog_i2c_write(dev_ptr, message, nbytes);
  407bda:	893b      	ldrh	r3, [r7, #8]
  407bdc:	461a      	mov	r2, r3
  407bde:	6879      	ldr	r1, [r7, #4]
  407be0:	68f8      	ldr	r0, [r7, #12]
  407be2:	4b07      	ldr	r3, [pc, #28]	; (407c00 <chdrv_prog_mem_write+0xfc>)
  407be4:	4798      	blx	r3
  407be6:	61f8      	str	r0, [r7, #28]
  407be8:	e000      	b.n	407bec <chdrv_prog_mem_write+0xe8>
	if (nbytes == 1 || (nbytes == 2 && !(addr & 1))) {
  407bea:	bf00      	nop
		}
	}
	return ch_err;
  407bec:	69fb      	ldr	r3, [r7, #28]
}
  407bee:	4618      	mov	r0, r3
  407bf0:	3720      	adds	r7, #32
  407bf2:	46bd      	mov	sp, r7
  407bf4:	bd80      	pop	{r7, pc}
  407bf6:	bf00      	nop
  407bf8:	00407aad 	.word	0x00407aad
  407bfc:	0040dcbc 	.word	0x0040dcbc
  407c00:	0040728d 	.word	0x0040728d

00407c04 <chdrv_prog_read>:
 *
 * \return 0 if read from sensor succeeded, non-zero otherwise
 *
 * This local function reads a value from a sensor programming register.
 */
static int chdrv_prog_read(ch_dev_t *dev_ptr, uint8_t reg_addr, uint16_t *data) {
  407c04:	b580      	push	{r7, lr}
  407c06:	b088      	sub	sp, #32
  407c08:	af00      	add	r7, sp, #0
  407c0a:	60f8      	str	r0, [r7, #12]
  407c0c:	460b      	mov	r3, r1
  407c0e:	607a      	str	r2, [r7, #4]
  407c10:	72fb      	strb	r3, [r7, #11]
	uint8_t nbytes = CH_PROG_SIZEOF(reg_addr);
  407c12:	7afb      	ldrb	r3, [r7, #11]
  407c14:	f003 0340 	and.w	r3, r3, #64	; 0x40
  407c18:	2b00      	cmp	r3, #0
  407c1a:	d001      	beq.n	407c20 <chdrv_prog_read+0x1c>
  407c1c:	2301      	movs	r3, #1
  407c1e:	e000      	b.n	407c22 <chdrv_prog_read+0x1e>
  407c20:	2302      	movs	r3, #2
  407c22:	76fb      	strb	r3, [r7, #27]

	uint8_t read_data[2];
	uint8_t message[1] = { 0x7F & reg_addr };
  407c24:	7afb      	ldrb	r3, [r7, #11]
  407c26:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  407c2a:	b2db      	uxtb	r3, r3
  407c2c:	753b      	strb	r3, [r7, #20]

	int ch_err = chdrv_prog_i2c_write(dev_ptr, message, sizeof(message));
  407c2e:	f107 0314 	add.w	r3, r7, #20
  407c32:	2201      	movs	r2, #1
  407c34:	4619      	mov	r1, r3
  407c36:	68f8      	ldr	r0, [r7, #12]
  407c38:	4b14      	ldr	r3, [pc, #80]	; (407c8c <chdrv_prog_read+0x88>)
  407c3a:	4798      	blx	r3
  407c3c:	61f8      	str	r0, [r7, #28]

	if (!ch_err) {
  407c3e:	69fb      	ldr	r3, [r7, #28]
  407c40:	2b00      	cmp	r3, #0
  407c42:	d108      	bne.n	407c56 <chdrv_prog_read+0x52>
		ch_err = chdrv_prog_i2c_read(dev_ptr, read_data, nbytes);
  407c44:	7efb      	ldrb	r3, [r7, #27]
  407c46:	b29a      	uxth	r2, r3
  407c48:	f107 0318 	add.w	r3, r7, #24
  407c4c:	4619      	mov	r1, r3
  407c4e:	68f8      	ldr	r0, [r7, #12]
  407c50:	4b0f      	ldr	r3, [pc, #60]	; (407c90 <chdrv_prog_read+0x8c>)
  407c52:	4798      	blx	r3
  407c54:	61f8      	str	r0, [r7, #28]
	}

	if (!ch_err) {
  407c56:	69fb      	ldr	r3, [r7, #28]
  407c58:	2b00      	cmp	r3, #0
  407c5a:	d111      	bne.n	407c80 <chdrv_prog_read+0x7c>
		*data = read_data[0];
  407c5c:	7e3b      	ldrb	r3, [r7, #24]
  407c5e:	b29a      	uxth	r2, r3
  407c60:	687b      	ldr	r3, [r7, #4]
  407c62:	801a      	strh	r2, [r3, #0]
		if (nbytes > 1) {
  407c64:	7efb      	ldrb	r3, [r7, #27]
  407c66:	2b01      	cmp	r3, #1
  407c68:	d90a      	bls.n	407c80 <chdrv_prog_read+0x7c>
			*data |= (((uint16_t) read_data[1]) << 8);
  407c6a:	687b      	ldr	r3, [r7, #4]
  407c6c:	881b      	ldrh	r3, [r3, #0]
  407c6e:	b21a      	sxth	r2, r3
  407c70:	7e7b      	ldrb	r3, [r7, #25]
  407c72:	021b      	lsls	r3, r3, #8
  407c74:	b21b      	sxth	r3, r3
  407c76:	4313      	orrs	r3, r2
  407c78:	b21b      	sxth	r3, r3
  407c7a:	b29a      	uxth	r2, r3
  407c7c:	687b      	ldr	r3, [r7, #4]
  407c7e:	801a      	strh	r2, [r3, #0]
		}
	}

	return ch_err;
  407c80:	69fb      	ldr	r3, [r7, #28]
}
  407c82:	4618      	mov	r0, r3
  407c84:	3720      	adds	r7, #32
  407c86:	46bd      	mov	sp, r7
  407c88:	bd80      	pop	{r7, pc}
  407c8a:	bf00      	nop
  407c8c:	0040728d 	.word	0x0040728d
  407c90:	004072c5 	.word	0x004072c5

00407c94 <chdrv_write_firmware>:
 *
 * This local function writes the sensor firmware image to the device.
 */
/*!
 */
static int chdrv_write_firmware(ch_dev_t *dev_ptr) {
  407c94:	b5b0      	push	{r4, r5, r7, lr}
  407c96:	b09c      	sub	sp, #112	; 0x70
  407c98:	af02      	add	r7, sp, #8
  407c9a:	6078      	str	r0, [r7, #4]
	ch_fw_load_func_t func_ptr = dev_ptr->api_funcs.fw_load;	// pointer to firmware load function
  407c9c:	687b      	ldr	r3, [r7, #4]
  407c9e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  407ca0:	65fb      	str	r3, [r7, #92]	; 0x5c
	int ch_err = ((func_ptr == NULL) || (!dev_ptr->sensor_connected));
  407ca2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407ca4:	2b00      	cmp	r3, #0
  407ca6:	d003      	beq.n	407cb0 <chdrv_write_firmware+0x1c>
  407ca8:	687b      	ldr	r3, [r7, #4]
  407caa:	7fdb      	ldrb	r3, [r3, #31]
  407cac:	2b00      	cmp	r3, #0
  407cae:	d101      	bne.n	407cb4 <chdrv_write_firmware+0x20>
  407cb0:	2301      	movs	r3, #1
  407cb2:	e000      	b.n	407cb6 <chdrv_write_firmware+0x22>
  407cb4:	2300      	movs	r3, #0
  407cb6:	667b      	str	r3, [r7, #100]	; 0x64

#ifdef CHDRV_DEBUG
	char cbuf[80];
	uint32_t prog_time;

	if (!ch_err) {
  407cb8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407cba:	2b00      	cmp	r3, #0
  407cbc:	d110      	bne.n	407ce0 <chdrv_write_firmware+0x4c>
		snprintf(cbuf, sizeof(cbuf), "chdrv_write_firmware\n");
  407cbe:	f107 030c 	add.w	r3, r7, #12
  407cc2:	4a26      	ldr	r2, [pc, #152]	; (407d5c <chdrv_write_firmware+0xc8>)
  407cc4:	461c      	mov	r4, r3
  407cc6:	4615      	mov	r5, r2
  407cc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407cca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407ccc:	e895 0003 	ldmia.w	r5, {r0, r1}
  407cd0:	6020      	str	r0, [r4, #0]
  407cd2:	3404      	adds	r4, #4
  407cd4:	8021      	strh	r1, [r4, #0]
		chbsp_print_str(cbuf);
  407cd6:	f107 030c 	add.w	r3, r7, #12
  407cda:	4618      	mov	r0, r3
  407cdc:	4b20      	ldr	r3, [pc, #128]	; (407d60 <chdrv_write_firmware+0xcc>)
  407cde:	4798      	blx	r3
	}
#endif

	if (!ch_err) {
  407ce0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407ce2:	2b00      	cmp	r3, #0
  407ce4:	d11d      	bne.n	407d22 <chdrv_write_firmware+0x8e>
#ifdef CHDRV_DEBUG
		snprintf(cbuf, sizeof(cbuf), "Programming Chirp sensor...\n");
  407ce6:	f107 030c 	add.w	r3, r7, #12
  407cea:	4a1e      	ldr	r2, [pc, #120]	; (407d64 <chdrv_write_firmware+0xd0>)
  407cec:	461c      	mov	r4, r3
  407cee:	4615      	mov	r5, r2
  407cf0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407cf2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407cf4:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  407cf8:	c407      	stmia	r4!, {r0, r1, r2}
  407cfa:	7023      	strb	r3, [r4, #0]
		chbsp_print_str(cbuf);
  407cfc:	f107 030c 	add.w	r3, r7, #12
  407d00:	4618      	mov	r0, r3
  407d02:	4b17      	ldr	r3, [pc, #92]	; (407d60 <chdrv_write_firmware+0xcc>)
  407d04:	4798      	blx	r3
		prog_time = chbsp_timestamp_ms();
  407d06:	4b18      	ldr	r3, [pc, #96]	; (407d68 <chdrv_write_firmware+0xd4>)
  407d08:	4798      	blx	r3
  407d0a:	6638      	str	r0, [r7, #96]	; 0x60
#endif
		if (func_ptr != NULL) {
  407d0c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407d0e:	2b00      	cmp	r3, #0
  407d10:	d005      	beq.n	407d1e <chdrv_write_firmware+0x8a>
			ch_err = (*func_ptr)(dev_ptr);
  407d12:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407d14:	6878      	ldr	r0, [r7, #4]
  407d16:	4798      	blx	r3
  407d18:	4603      	mov	r3, r0
  407d1a:	667b      	str	r3, [r7, #100]	; 0x64
  407d1c:	e001      	b.n	407d22 <chdrv_write_firmware+0x8e>
		} else {
			ch_err = 1;			// indicate error
  407d1e:	2301      	movs	r3, #1
  407d20:	667b      	str	r3, [r7, #100]	; 0x64
		}
}

#ifdef CHDRV_DEBUG
	if (!ch_err) {
  407d22:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407d24:	2b00      	cmp	r3, #0
  407d26:	d114      	bne.n	407d52 <chdrv_write_firmware+0xbe>
		prog_time = chbsp_timestamp_ms() - prog_time;
  407d28:	4b0f      	ldr	r3, [pc, #60]	; (407d68 <chdrv_write_firmware+0xd4>)
  407d2a:	4798      	blx	r3
  407d2c:	4602      	mov	r2, r0
  407d2e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  407d30:	1ad3      	subs	r3, r2, r3
  407d32:	663b      	str	r3, [r7, #96]	; 0x60
		snprintf(cbuf, sizeof(cbuf), "Wrote %u bytes in %lu ms.\n", CH101_FW_SIZE, prog_time);
  407d34:	f107 000c 	add.w	r0, r7, #12
  407d38:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  407d3a:	9300      	str	r3, [sp, #0]
  407d3c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  407d40:	4a0a      	ldr	r2, [pc, #40]	; (407d6c <chdrv_write_firmware+0xd8>)
  407d42:	2150      	movs	r1, #80	; 0x50
  407d44:	4c0a      	ldr	r4, [pc, #40]	; (407d70 <chdrv_write_firmware+0xdc>)
  407d46:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  407d48:	f107 030c 	add.w	r3, r7, #12
  407d4c:	4618      	mov	r0, r3
  407d4e:	4b04      	ldr	r3, [pc, #16]	; (407d60 <chdrv_write_firmware+0xcc>)
  407d50:	4798      	blx	r3
	}
#endif

	return ch_err;
  407d52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
  407d54:	4618      	mov	r0, r3
  407d56:	3768      	adds	r7, #104	; 0x68
  407d58:	46bd      	mov	sp, r7
  407d5a:	bdb0      	pop	{r4, r5, r7, pc}
  407d5c:	0040dcc0 	.word	0x0040dcc0
  407d60:	00402fa9 	.word	0x00402fa9
  407d64:	0040dcd8 	.word	0x0040dcd8
  407d68:	00402fc5 	.word	0x00402fc5
  407d6c:	0040dcf8 	.word	0x0040dcf8
  407d70:	0040a085 	.word	0x0040a085

00407d74 <chdrv_init_ram>:
 *
 * \return 0 if memory write succeeded, non-zero otherwise
 *
 * This local function initializes memory locations in the Chirp sensor, as required by the firmware image.
 */
static int chdrv_init_ram(ch_dev_t *dev_ptr) {
  407d74:	b5b0      	push	{r4, r5, r7, lr}
  407d76:	b09c      	sub	sp, #112	; 0x70
  407d78:	af02      	add	r7, sp, #8
  407d7a:	6078      	str	r0, [r7, #4]
	int ch_err = ! dev_ptr || ! dev_ptr->sensor_connected;
  407d7c:	687b      	ldr	r3, [r7, #4]
  407d7e:	2b00      	cmp	r3, #0
  407d80:	d003      	beq.n	407d8a <chdrv_init_ram+0x16>
  407d82:	687b      	ldr	r3, [r7, #4]
  407d84:	7fdb      	ldrb	r3, [r3, #31]
  407d86:	2b00      	cmp	r3, #0
  407d88:	d101      	bne.n	407d8e <chdrv_init_ram+0x1a>
  407d8a:	2301      	movs	r3, #1
  407d8c:	e000      	b.n	407d90 <chdrv_init_ram+0x1c>
  407d8e:	2300      	movs	r3, #0
  407d90:	667b      	str	r3, [r7, #100]	; 0x64

#ifdef CHDRV_DEBUG
	char cbuf[80];
	uint32_t prog_time;
	if (!ch_err) {
  407d92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407d94:	2b00      	cmp	r3, #0
  407d96:	d10c      	bne.n	407db2 <chdrv_init_ram+0x3e>
		snprintf(cbuf, sizeof(cbuf), "chdrv_init_ram\n");
  407d98:	f107 030c 	add.w	r3, r7, #12
  407d9c:	4a2e      	ldr	r2, [pc, #184]	; (407e58 <chdrv_init_ram+0xe4>)
  407d9e:	461c      	mov	r4, r3
  407da0:	4613      	mov	r3, r2
  407da2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  407da4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		chbsp_print_str(cbuf);
  407da8:	f107 030c 	add.w	r3, r7, #12
  407dac:	4618      	mov	r0, r3
  407dae:	4b2b      	ldr	r3, [pc, #172]	; (407e5c <chdrv_init_ram+0xe8>)
  407db0:	4798      	blx	r3
	}
#endif

	if ((!ch_err) && (dev_ptr->get_fw_ram_init_size() != 0)) {		// if size is not zero, ram init data exists
  407db2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407db4:	2b00      	cmp	r3, #0
  407db6:	d14a      	bne.n	407e4e <chdrv_init_ram+0xda>
  407db8:	687b      	ldr	r3, [r7, #4]
  407dba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  407dbc:	4798      	blx	r3
  407dbe:	4603      	mov	r3, r0
  407dc0:	2b00      	cmp	r3, #0
  407dc2:	d044      	beq.n	407e4e <chdrv_init_ram+0xda>
		uint16_t ram_address;
		uint16_t ram_bytecount;

		ram_address = dev_ptr->get_fw_ram_init_addr();
  407dc4:	687b      	ldr	r3, [r7, #4]
  407dc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  407dc8:	4798      	blx	r3
  407dca:	4603      	mov	r3, r0
  407dcc:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
		ram_bytecount = dev_ptr->get_fw_ram_init_size();
  407dd0:	687b      	ldr	r3, [r7, #4]
  407dd2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  407dd4:	4798      	blx	r3
  407dd6:	4603      	mov	r3, r0
  407dd8:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

		if (!ch_err) {
  407ddc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407dde:	2b00      	cmp	r3, #0
  407de0:	d135      	bne.n	407e4e <chdrv_init_ram+0xda>
#ifdef CHDRV_DEBUG
			snprintf(cbuf, sizeof(cbuf), "Loading RAM init data...\n");
  407de2:	f107 030c 	add.w	r3, r7, #12
  407de6:	4a1e      	ldr	r2, [pc, #120]	; (407e60 <chdrv_init_ram+0xec>)
  407de8:	461c      	mov	r4, r3
  407dea:	4615      	mov	r5, r2
  407dec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  407dee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  407df0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  407df4:	c403      	stmia	r4!, {r0, r1}
  407df6:	8022      	strh	r2, [r4, #0]
			chbsp_print_str(cbuf);
  407df8:	f107 030c 	add.w	r3, r7, #12
  407dfc:	4618      	mov	r0, r3
  407dfe:	4b17      	ldr	r3, [pc, #92]	; (407e5c <chdrv_init_ram+0xe8>)
  407e00:	4798      	blx	r3
			prog_time = chbsp_timestamp_ms();
  407e02:	4b18      	ldr	r3, [pc, #96]	; (407e64 <chdrv_init_ram+0xf0>)
  407e04:	4798      	blx	r3
  407e06:	65f8      	str	r0, [r7, #92]	; 0x5c
#endif
			ch_err = chdrv_prog_mem_write(dev_ptr, ram_address, (uint8_t *) dev_ptr->ram_init, ram_bytecount);
  407e08:	687b      	ldr	r3, [r7, #4]
  407e0a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  407e0c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  407e10:	f8b7 1062 	ldrh.w	r1, [r7, #98]	; 0x62
  407e14:	6878      	ldr	r0, [r7, #4]
  407e16:	4c14      	ldr	r4, [pc, #80]	; (407e68 <chdrv_init_ram+0xf4>)
  407e18:	47a0      	blx	r4
  407e1a:	6678      	str	r0, [r7, #100]	; 0x64
#ifdef CHDRV_DEBUG
			if (!ch_err) {
  407e1c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407e1e:	2b00      	cmp	r3, #0
  407e20:	d115      	bne.n	407e4e <chdrv_init_ram+0xda>
				prog_time = chbsp_timestamp_ms() - prog_time;
  407e22:	4b10      	ldr	r3, [pc, #64]	; (407e64 <chdrv_init_ram+0xf0>)
  407e24:	4798      	blx	r3
  407e26:	4602      	mov	r2, r0
  407e28:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407e2a:	1ad3      	subs	r3, r2, r3
  407e2c:	65fb      	str	r3, [r7, #92]	; 0x5c
				snprintf(cbuf, sizeof(cbuf), "Wrote %u bytes in %lu ms.\n", ram_bytecount, prog_time);
  407e2e:	f8b7 2060 	ldrh.w	r2, [r7, #96]	; 0x60
  407e32:	f107 000c 	add.w	r0, r7, #12
  407e36:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407e38:	9300      	str	r3, [sp, #0]
  407e3a:	4613      	mov	r3, r2
  407e3c:	4a0b      	ldr	r2, [pc, #44]	; (407e6c <chdrv_init_ram+0xf8>)
  407e3e:	2150      	movs	r1, #80	; 0x50
  407e40:	4c0b      	ldr	r4, [pc, #44]	; (407e70 <chdrv_init_ram+0xfc>)
  407e42:	47a0      	blx	r4
				chbsp_print_str(cbuf);
  407e44:	f107 030c 	add.w	r3, r7, #12
  407e48:	4618      	mov	r0, r3
  407e4a:	4b04      	ldr	r3, [pc, #16]	; (407e5c <chdrv_init_ram+0xe8>)
  407e4c:	4798      	blx	r3
			}
#endif
		}
	}
	return ch_err;
  407e4e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
  407e50:	4618      	mov	r0, r3
  407e52:	3768      	adds	r7, #104	; 0x68
  407e54:	46bd      	mov	sp, r7
  407e56:	bdb0      	pop	{r4, r5, r7, pc}
  407e58:	0040dd14 	.word	0x0040dd14
  407e5c:	00402fa9 	.word	0x00402fa9
  407e60:	0040dd24 	.word	0x0040dd24
  407e64:	00402fc5 	.word	0x00402fc5
  407e68:	00407b05 	.word	0x00407b05
  407e6c:	0040dcf8 	.word	0x0040dcf8
  407e70:	0040a085 	.word	0x0040a085

00407e74 <chdrv_reset_and_halt>:
 *
 * This function resets and halts a sensor device by writing to the control registers.
 *
 * In order for the device to respond, the PROG pin for the device must be asserted before this function is called. 
 */
static int chdrv_reset_and_halt(ch_dev_t * dev_ptr) {
  407e74:	b580      	push	{r7, lr}
  407e76:	b084      	sub	sp, #16
  407e78:	af00      	add	r7, sp, #0
  407e7a:	6078      	str	r0, [r7, #4]
	int ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_CPU, 0x40);    	// reset asic			// XXX need define
  407e7c:	2240      	movs	r2, #64	; 0x40
  407e7e:	2142      	movs	r1, #66	; 0x42
  407e80:	6878      	ldr	r0, [r7, #4]
  407e82:	4b08      	ldr	r3, [pc, #32]	; (407ea4 <chdrv_reset_and_halt+0x30>)
  407e84:	4798      	blx	r3
  407e86:	60f8      	str	r0, [r7, #12]

	ch_err |= chdrv_prog_write(dev_ptr, CH_PROG_REG_CPU, 0x11);   		// halt asic and disable watchdog;			// XXX need define
  407e88:	2211      	movs	r2, #17
  407e8a:	2142      	movs	r1, #66	; 0x42
  407e8c:	6878      	ldr	r0, [r7, #4]
  407e8e:	4b05      	ldr	r3, [pc, #20]	; (407ea4 <chdrv_reset_and_halt+0x30>)
  407e90:	4798      	blx	r3
  407e92:	4602      	mov	r2, r0
  407e94:	68fb      	ldr	r3, [r7, #12]
  407e96:	4313      	orrs	r3, r2
  407e98:	60fb      	str	r3, [r7, #12]

	return ch_err;
  407e9a:	68fb      	ldr	r3, [r7, #12]
}
  407e9c:	4618      	mov	r0, r3
  407e9e:	3710      	adds	r7, #16
  407ea0:	46bd      	mov	sp, r7
  407ea2:	bd80      	pop	{r7, pc}
  407ea4:	00407aad 	.word	0x00407aad

00407ea8 <chdrv_prog_ping>:
 * This function checks for a sensor sensor on the I2C bus by attempting to reset, halt, and read from the device using
 * the programming interface I2C address (0x45). 
 *
 * In order for the device to respond, the PROG pin for the device must be asserted before this function is called. 
 */
int chdrv_prog_ping(ch_dev_t *dev_ptr) {
  407ea8:	b590      	push	{r4, r7, lr}
  407eaa:	b099      	sub	sp, #100	; 0x64
  407eac:	af00      	add	r7, sp, #0
  407eae:	6078      	str	r0, [r7, #4]
	// Try a dummy write to the sensor to make sure it's connected and working
	uint16_t tmp;
	int ch_err;

    ch_err = chdrv_reset_and_halt(dev_ptr);
  407eb0:	6878      	ldr	r0, [r7, #4]
  407eb2:	4b14      	ldr	r3, [pc, #80]	; (407f04 <chdrv_prog_ping+0x5c>)
  407eb4:	4798      	blx	r3
  407eb6:	65f8      	str	r0, [r7, #92]	; 0x5c

    ch_err |= chdrv_prog_read(dev_ptr, CH_PROG_REG_PING, &tmp);
  407eb8:	f107 035a 	add.w	r3, r7, #90	; 0x5a
  407ebc:	461a      	mov	r2, r3
  407ebe:	2100      	movs	r1, #0
  407ec0:	6878      	ldr	r0, [r7, #4]
  407ec2:	4b11      	ldr	r3, [pc, #68]	; (407f08 <chdrv_prog_ping+0x60>)
  407ec4:	4798      	blx	r3
  407ec6:	4602      	mov	r2, r0
  407ec8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407eca:	4313      	orrs	r3, r2
  407ecc:	65fb      	str	r3, [r7, #92]	; 0x5c

#ifdef CHDRV_DEBUG
	if (!ch_err) {
  407ece:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407ed0:	2b00      	cmp	r3, #0
  407ed2:	d10c      	bne.n	407eee <chdrv_prog_ping+0x46>
		char cbuf[80];
		snprintf(cbuf, sizeof(cbuf), "Test I2C read: %04X\n", tmp);
  407ed4:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
  407ed8:	f107 0008 	add.w	r0, r7, #8
  407edc:	4a0b      	ldr	r2, [pc, #44]	; (407f0c <chdrv_prog_ping+0x64>)
  407ede:	2150      	movs	r1, #80	; 0x50
  407ee0:	4c0b      	ldr	r4, [pc, #44]	; (407f10 <chdrv_prog_ping+0x68>)
  407ee2:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  407ee4:	f107 0308 	add.w	r3, r7, #8
  407ee8:	4618      	mov	r0, r3
  407eea:	4b0a      	ldr	r3, [pc, #40]	; (407f14 <chdrv_prog_ping+0x6c>)
  407eec:	4798      	blx	r3
	}
#endif

	return !(ch_err);
  407eee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  407ef0:	2b00      	cmp	r3, #0
  407ef2:	bf0c      	ite	eq
  407ef4:	2301      	moveq	r3, #1
  407ef6:	2300      	movne	r3, #0
  407ef8:	b2db      	uxtb	r3, r3
}
  407efa:	4618      	mov	r0, r3
  407efc:	3764      	adds	r7, #100	; 0x64
  407efe:	46bd      	mov	sp, r7
  407f00:	bd90      	pop	{r4, r7, pc}
  407f02:	bf00      	nop
  407f04:	00407e75 	.word	0x00407e75
  407f08:	00407c05 	.word	0x00407c05
  407f0c:	0040dd40 	.word	0x0040dd40
  407f10:	0040a085 	.word	0x0040a085
  407f14:	00402fa9 	.word	0x00402fa9

00407f18 <chdrv_detect_and_program>:
 * Once started, the sensor device will begin an internal initialization and self-test sequence.  The \a chdrv_wait_for_lock()
 * function may be used to wait for this sequence to complete.
 *
 * \note This routine will leave the PROG pin de-asserted when it completes.
 */
int chdrv_detect_and_program(ch_dev_t *dev_ptr) {
  407f18:	b590      	push	{r4, r7, lr}
  407f1a:	b09b      	sub	sp, #108	; 0x6c
  407f1c:	af00      	add	r7, sp, #0
  407f1e:	6078      	str	r0, [r7, #4]
	int ch_err = ! dev_ptr;
  407f20:	687b      	ldr	r3, [r7, #4]
  407f22:	2b00      	cmp	r3, #0
  407f24:	bf0c      	ite	eq
  407f26:	2301      	moveq	r3, #1
  407f28:	2300      	movne	r3, #0
  407f2a:	b2db      	uxtb	r3, r3
  407f2c:	667b      	str	r3, [r7, #100]	; 0x64
	if (ch_err) {
  407f2e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407f30:	2b00      	cmp	r3, #0
  407f32:	d001      	beq.n	407f38 <chdrv_detect_and_program+0x20>
		return ch_err;
  407f34:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407f36:	e0bc      	b.n	4080b2 <chdrv_detect_and_program+0x19a>
	}

	chbsp_program_enable(dev_ptr);					// assert PROG pin
  407f38:	6878      	ldr	r0, [r7, #4]
  407f3a:	4b60      	ldr	r3, [pc, #384]	; (4080bc <chdrv_detect_and_program+0x1a4>)
  407f3c:	4798      	blx	r3

	if (chdrv_prog_ping(dev_ptr)) {					// if device found
  407f3e:	6878      	ldr	r0, [r7, #4]
  407f40:	4b5f      	ldr	r3, [pc, #380]	; (4080c0 <chdrv_detect_and_program+0x1a8>)
  407f42:	4798      	blx	r3
  407f44:	4603      	mov	r3, r0
  407f46:	2b00      	cmp	r3, #0
  407f48:	f000 809d 	beq.w	408086 <chdrv_detect_and_program+0x16e>
		dev_ptr->sensor_connected = 1;
  407f4c:	687b      	ldr	r3, [r7, #4]
  407f4e:	2201      	movs	r2, #1
  407f50:	77da      	strb	r2, [r3, #31]

		// Call device discovery hook routine, if any
		chdrv_discovery_hook_t hook_ptr = dev_ptr->group->disco_hook;
  407f52:	687b      	ldr	r3, [r7, #4]
  407f54:	681b      	ldr	r3, [r3, #0]
  407f56:	68db      	ldr	r3, [r3, #12]
  407f58:	663b      	str	r3, [r7, #96]	; 0x60
		if (hook_ptr != NULL) {
  407f5a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  407f5c:	2b00      	cmp	r3, #0
  407f5e:	d004      	beq.n	407f6a <chdrv_detect_and_program+0x52>
			ch_err = (*hook_ptr)(dev_ptr);		// hook routine can return error, will abort device init
  407f60:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  407f62:	6878      	ldr	r0, [r7, #4]
  407f64:	4798      	blx	r3
  407f66:	4603      	mov	r3, r0
  407f68:	667b      	str	r3, [r7, #100]	; 0x64
		}

#ifdef CHDRV_DEBUG
		char cbuf[80];
		if (!ch_err) {
  407f6a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407f6c:	2b00      	cmp	r3, #0
  407f6e:	d118      	bne.n	407fa2 <chdrv_detect_and_program+0x8a>
			uint16_t prog_stat = UINT16_MAX;
  407f70:	f64f 73ff 	movw	r3, #65535	; 0xffff
  407f74:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
			ch_err = chdrv_prog_read(dev_ptr, CH_PROG_REG_STAT, &prog_stat);
  407f78:	f107 035e 	add.w	r3, r7, #94	; 0x5e
  407f7c:	461a      	mov	r2, r3
  407f7e:	2143      	movs	r1, #67	; 0x43
  407f80:	6878      	ldr	r0, [r7, #4]
  407f82:	4b50      	ldr	r3, [pc, #320]	; (4080c4 <chdrv_detect_and_program+0x1ac>)
  407f84:	4798      	blx	r3
  407f86:	6678      	str	r0, [r7, #100]	; 0x64
			snprintf(cbuf, sizeof(cbuf), "PROG_STAT: 0x%02X\n", prog_stat);
  407f88:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  407f8c:	f107 000c 	add.w	r0, r7, #12
  407f90:	4a4d      	ldr	r2, [pc, #308]	; (4080c8 <chdrv_detect_and_program+0x1b0>)
  407f92:	2150      	movs	r1, #80	; 0x50
  407f94:	4c4d      	ldr	r4, [pc, #308]	; (4080cc <chdrv_detect_and_program+0x1b4>)
  407f96:	47a0      	blx	r4
			chbsp_print_str(cbuf);
  407f98:	f107 030c 	add.w	r3, r7, #12
  407f9c:	4618      	mov	r0, r3
  407f9e:	4b4c      	ldr	r3, [pc, #304]	; (4080d0 <chdrv_detect_and_program+0x1b8>)
  407fa0:	4798      	blx	r3
		}
#endif

		ch_err = chdrv_init_ram(dev_ptr) ||                // init ram values
  407fa2:	6878      	ldr	r0, [r7, #4]
  407fa4:	4b4b      	ldr	r3, [pc, #300]	; (4080d4 <chdrv_detect_and_program+0x1bc>)
  407fa6:	4798      	blx	r3
  407fa8:	4603      	mov	r3, r0
				 chdrv_write_firmware(dev_ptr) ||          // transfer program
  407faa:	2b00      	cmp	r3, #0
  407fac:	d10b      	bne.n	407fc6 <chdrv_detect_and_program+0xae>
  407fae:	6878      	ldr	r0, [r7, #4]
  407fb0:	4b49      	ldr	r3, [pc, #292]	; (4080d8 <chdrv_detect_and_program+0x1c0>)
  407fb2:	4798      	blx	r3
  407fb4:	4603      	mov	r3, r0
		ch_err = chdrv_init_ram(dev_ptr) ||                // init ram values
  407fb6:	2b00      	cmp	r3, #0
  407fb8:	d105      	bne.n	407fc6 <chdrv_detect_and_program+0xae>
				 chdrv_reset_and_halt(dev_ptr); 			// reset asic, since it was running mystery code before halt
  407fba:	6878      	ldr	r0, [r7, #4]
  407fbc:	4b47      	ldr	r3, [pc, #284]	; (4080dc <chdrv_detect_and_program+0x1c4>)
  407fbe:	4798      	blx	r3
  407fc0:	4603      	mov	r3, r0
				 chdrv_write_firmware(dev_ptr) ||          // transfer program
  407fc2:	2b00      	cmp	r3, #0
  407fc4:	d001      	beq.n	407fca <chdrv_detect_and_program+0xb2>
  407fc6:	2301      	movs	r3, #1
  407fc8:	e000      	b.n	407fcc <chdrv_detect_and_program+0xb4>
  407fca:	2300      	movs	r3, #0
		ch_err = chdrv_init_ram(dev_ptr) ||                // init ram values
  407fcc:	667b      	str	r3, [r7, #100]	; 0x64

#ifdef CHDRV_DEBUG
		if (!ch_err) {
  407fce:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407fd0:	2b00      	cmp	r3, #0
  407fd2:	d10c      	bne.n	407fee <chdrv_detect_and_program+0xd6>
			snprintf(cbuf, sizeof(cbuf), "Changing I2C address to %u\n", dev_ptr->i2c_address);
  407fd4:	687b      	ldr	r3, [r7, #4]
  407fd6:	7e1b      	ldrb	r3, [r3, #24]
  407fd8:	f107 000c 	add.w	r0, r7, #12
  407fdc:	4a40      	ldr	r2, [pc, #256]	; (4080e0 <chdrv_detect_and_program+0x1c8>)
  407fde:	2150      	movs	r1, #80	; 0x50
  407fe0:	4c3a      	ldr	r4, [pc, #232]	; (4080cc <chdrv_detect_and_program+0x1b4>)
  407fe2:	47a0      	blx	r4
			chbsp_print_str(cbuf);
  407fe4:	f107 030c 	add.w	r3, r7, #12
  407fe8:	4618      	mov	r0, r3
  407fea:	4b39      	ldr	r3, [pc, #228]	; (4080d0 <chdrv_detect_and_program+0x1b8>)
  407fec:	4798      	blx	r3
		}
#endif

		if (!ch_err ) {
  407fee:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  407ff0:	2b00      	cmp	r3, #0
  407ff2:	d109      	bne.n	408008 <chdrv_detect_and_program+0xf0>
			ch_err = chdrv_prog_mem_write(dev_ptr, 0x01C5, &dev_ptr->i2c_address, 1);			// XXX need define
  407ff4:	687b      	ldr	r3, [r7, #4]
  407ff6:	f103 0218 	add.w	r2, r3, #24
  407ffa:	2301      	movs	r3, #1
  407ffc:	f240 11c5 	movw	r1, #453	; 0x1c5
  408000:	6878      	ldr	r0, [r7, #4]
  408002:	4c38      	ldr	r4, [pc, #224]	; (4080e4 <chdrv_detect_and_program+0x1cc>)
  408004:	47a0      	blx	r4
  408006:	6678      	str	r0, [r7, #100]	; 0x64
		}

		/* Run charge pumps */
		if (!ch_err) {
  408008:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40800a:	2b00      	cmp	r3, #0
  40800c:	d131      	bne.n	408072 <chdrv_detect_and_program+0x15a>
			uint16_t write_val;
			write_val = 0x0200;			// XXX need defines
  40800e:	f44f 7300 	mov.w	r3, #512	; 0x200
  408012:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            ch_err |= chdrv_prog_mem_write(dev_ptr, 0x01A6, (uint8_t *)&write_val, 2);		// PMUT.CNTRL4 = HVVSS_FON
  408016:	f107 025c 	add.w	r2, r7, #92	; 0x5c
  40801a:	2302      	movs	r3, #2
  40801c:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
  408020:	6878      	ldr	r0, [r7, #4]
  408022:	4c30      	ldr	r4, [pc, #192]	; (4080e4 <chdrv_detect_and_program+0x1cc>)
  408024:	47a0      	blx	r4
  408026:	4602      	mov	r2, r0
  408028:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40802a:	4313      	orrs	r3, r2
  40802c:	667b      	str	r3, [r7, #100]	; 0x64
			chbsp_delay_ms(5);
  40802e:	2005      	movs	r0, #5
  408030:	4b2d      	ldr	r3, [pc, #180]	; (4080e8 <chdrv_detect_and_program+0x1d0>)
  408032:	4798      	blx	r3
			write_val = 0x0600;
  408034:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  408038:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            ch_err = chdrv_prog_mem_write(dev_ptr, 0x01A6, (uint8_t *)&write_val, 2);		// PMUT.CNTRL4 = (HVVSS_FON | HVVDD_FON)
  40803c:	f107 025c 	add.w	r2, r7, #92	; 0x5c
  408040:	2302      	movs	r3, #2
  408042:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
  408046:	6878      	ldr	r0, [r7, #4]
  408048:	4c26      	ldr	r4, [pc, #152]	; (4080e4 <chdrv_detect_and_program+0x1cc>)
  40804a:	47a0      	blx	r4
  40804c:	6678      	str	r0, [r7, #100]	; 0x64
			chbsp_delay_ms(5);
  40804e:	2005      	movs	r0, #5
  408050:	4b25      	ldr	r3, [pc, #148]	; (4080e8 <chdrv_detect_and_program+0x1d0>)
  408052:	4798      	blx	r3
			write_val = 0x0000;
  408054:	2300      	movs	r3, #0
  408056:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
			ch_err |= chdrv_prog_mem_write(dev_ptr, 0x01A6, (uint8_t *)&write_val, 2);		// PMUT.CNTRL4 = 0
  40805a:	f107 025c 	add.w	r2, r7, #92	; 0x5c
  40805e:	2302      	movs	r3, #2
  408060:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
  408064:	6878      	ldr	r0, [r7, #4]
  408066:	4c1f      	ldr	r4, [pc, #124]	; (4080e4 <chdrv_detect_and_program+0x1cc>)
  408068:	47a0      	blx	r4
  40806a:	4602      	mov	r2, r0
  40806c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40806e:	4313      	orrs	r3, r2
  408070:	667b      	str	r3, [r7, #100]	; 0x64
		}

		if (!ch_err ) {
  408072:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  408074:	2b00      	cmp	r3, #0
  408076:	d109      	bne.n	40808c <chdrv_detect_and_program+0x174>
			ch_err = chdrv_prog_write(dev_ptr, CH_PROG_REG_CPU, 2);	// Exit programming mode and run the chip
  408078:	2202      	movs	r2, #2
  40807a:	2142      	movs	r1, #66	; 0x42
  40807c:	6878      	ldr	r0, [r7, #4]
  40807e:	4b1b      	ldr	r3, [pc, #108]	; (4080ec <chdrv_detect_and_program+0x1d4>)
  408080:	4798      	blx	r3
  408082:	6678      	str	r0, [r7, #100]	; 0x64
  408084:	e002      	b.n	40808c <chdrv_detect_and_program+0x174>
		}
	} else {
		dev_ptr->sensor_connected = 0;				// prog_ping failed - no device found
  408086:	687b      	ldr	r3, [r7, #4]
  408088:	2200      	movs	r2, #0
  40808a:	77da      	strb	r2, [r3, #31]
	}

	chbsp_program_disable(dev_ptr);				// de-assert PROG pin
  40808c:	6878      	ldr	r0, [r7, #4]
  40808e:	4b18      	ldr	r3, [pc, #96]	; (4080f0 <chdrv_detect_and_program+0x1d8>)
  408090:	4798      	blx	r3

	if (ch_err) { 								// if error, reinitialize I2C bus associated with this device
  408092:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  408094:	2b00      	cmp	r3, #0
  408096:	d005      	beq.n	4080a4 <chdrv_detect_and_program+0x18c>
		chbsp_debug_toggle(CHDRV_DEBUG_PIN_NUM);
  408098:	2000      	movs	r0, #0
  40809a:	4b16      	ldr	r3, [pc, #88]	; (4080f4 <chdrv_detect_and_program+0x1dc>)
  40809c:	4798      	blx	r3
		chbsp_i2c_reset(dev_ptr);
  40809e:	6878      	ldr	r0, [r7, #4]
  4080a0:	4b15      	ldr	r3, [pc, #84]	; (4080f8 <chdrv_detect_and_program+0x1e0>)
  4080a2:	4798      	blx	r3
	}

	if (ch_err) {
  4080a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  4080a6:	2b00      	cmp	r3, #0
  4080a8:	d002      	beq.n	4080b0 <chdrv_detect_and_program+0x198>
		dev_ptr->sensor_connected = 0;     		// only marked as connected if no errors
  4080aa:	687b      	ldr	r3, [r7, #4]
  4080ac:	2200      	movs	r2, #0
  4080ae:	77da      	strb	r2, [r3, #31]
	}

	return ch_err;
  4080b0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
  4080b2:	4618      	mov	r0, r3
  4080b4:	376c      	adds	r7, #108	; 0x6c
  4080b6:	46bd      	mov	sp, r7
  4080b8:	bd90      	pop	{r4, r7, pc}
  4080ba:	bf00      	nop
  4080bc:	004020d5 	.word	0x004020d5
  4080c0:	00407ea9 	.word	0x00407ea9
  4080c4:	00407c05 	.word	0x00407c05
  4080c8:	0040dd58 	.word	0x0040dd58
  4080cc:	0040a085 	.word	0x0040a085
  4080d0:	00402fa9 	.word	0x00402fa9
  4080d4:	00407d75 	.word	0x00407d75
  4080d8:	00407c95 	.word	0x00407c95
  4080dc:	00407e75 	.word	0x00407e75
  4080e0:	0040dd6c 	.word	0x0040dd6c
  4080e4:	00407b05 	.word	0x00407b05
  4080e8:	004026b9 	.word	0x004026b9
  4080ec:	00407aad 	.word	0x00407aad
  4080f0:	0040210d 	.word	0x0040210d
  4080f4:	004058ad 	.word	0x004058ad
  4080f8:	00402c39 	.word	0x00402c39

004080fc <chdrv_set_idle>:
 * on the given bus are halted in programming mode (i.e. PROG line is asserted).
 *
 * \note This routine writes to all devices simultaneously, so I2C signalling (i.e. ack's) on the bus may be driven by multiple
 * slaves at once.
 */
int chdrv_set_idle(ch_dev_t * dev_ptr) {
  4080fc:	b590      	push	{r4, r7, lr}
  4080fe:	b087      	sub	sp, #28
  408100:	af00      	add	r7, sp, #0
  408102:	6078      	str	r0, [r7, #4]
	const uint16_t idle_loop[2] = {0x4003,0xFFFC}; 		// XXX need define
  408104:	4b13      	ldr	r3, [pc, #76]	; (408154 <chdrv_set_idle+0x58>)
  408106:	681b      	ldr	r3, [r3, #0]
  408108:	613b      	str	r3, [r7, #16]

	int ch_err = chdrv_prog_mem_write(dev_ptr, 0xFFFC, (uint8_t *) &idle_loop[0], sizeof(idle_loop));
  40810a:	f107 0210 	add.w	r2, r7, #16
  40810e:	2304      	movs	r3, #4
  408110:	f64f 71fc 	movw	r1, #65532	; 0xfffc
  408114:	6878      	ldr	r0, [r7, #4]
  408116:	4c10      	ldr	r4, [pc, #64]	; (408158 <chdrv_set_idle+0x5c>)
  408118:	47a0      	blx	r4
  40811a:	6178      	str	r0, [r7, #20]
	if (!ch_err) {
  40811c:	697b      	ldr	r3, [r7, #20]
  40811e:	2b00      	cmp	r3, #0
  408120:	d103      	bne.n	40812a <chdrv_set_idle+0x2e>
		ch_err = chdrv_reset_and_halt(dev_ptr);
  408122:	6878      	ldr	r0, [r7, #4]
  408124:	4b0d      	ldr	r3, [pc, #52]	; (40815c <chdrv_set_idle+0x60>)
  408126:	4798      	blx	r3
  408128:	6178      	str	r0, [r7, #20]
	}

	// keep wdt stopped after we exit programming mode
	uint16_t val = 0x5a80;			// XXX need define
  40812a:	f44f 43b5 	mov.w	r3, #23168	; 0x5a80
  40812e:	81fb      	strh	r3, [r7, #14]
	if (!ch_err) {
  408130:	697b      	ldr	r3, [r7, #20]
  408132:	2b00      	cmp	r3, #0
  408134:	d108      	bne.n	408148 <chdrv_set_idle+0x4c>
		ch_err = chdrv_prog_mem_write(dev_ptr, 0x0120, (uint8_t *)&val, sizeof(val));			// XXX need define
  408136:	f107 020e 	add.w	r2, r7, #14
  40813a:	2302      	movs	r3, #2
  40813c:	f44f 7190 	mov.w	r1, #288	; 0x120
  408140:	6878      	ldr	r0, [r7, #4]
  408142:	4c05      	ldr	r4, [pc, #20]	; (408158 <chdrv_set_idle+0x5c>)
  408144:	47a0      	blx	r4
  408146:	6178      	str	r0, [r7, #20]
	}

	return ch_err;
  408148:	697b      	ldr	r3, [r7, #20]
}
  40814a:	4618      	mov	r0, r3
  40814c:	371c      	adds	r7, #28
  40814e:	46bd      	mov	sp, r7
  408150:	bd90      	pop	{r4, r7, pc}
  408152:	bf00      	nop
  408154:	0040dd88 	.word	0x0040dd88
  408158:	00407b05 	.word	0x00407b05
  40815c:	00407e75 	.word	0x00407e75

00408160 <chdrv_group_detect_and_program>:
 * Once started, each sensor device will begin an internal initialization and self-test sequence.  The 
 * \a chdrv_group_wait_for_lock() function may be used to wait for this sequence to complete on all devices in the group.
 *
 * \note This routine will leave the PROG pin de-asserted for all devices in the group when it completes.
 */
int chdrv_group_detect_and_program(ch_group_t *grp_ptr) {
  408160:	b580      	push	{r7, lr}
  408162:	b086      	sub	sp, #24
  408164:	af00      	add	r7, sp, #0
  408166:	6078      	str	r0, [r7, #4]
	int ch_err = 0;
  408168:	2300      	movs	r3, #0
  40816a:	617b      	str	r3, [r7, #20]

	for (uint8_t i = 0; i < grp_ptr->num_ports; i++) {
  40816c:	2300      	movs	r3, #0
  40816e:	74fb      	strb	r3, [r7, #19]
  408170:	e01c      	b.n	4081ac <chdrv_group_detect_and_program+0x4c>
		ch_dev_t *dev_ptr = grp_ptr->device[i];
  408172:	7cfa      	ldrb	r2, [r7, #19]
  408174:	687b      	ldr	r3, [r7, #4]
  408176:	3206      	adds	r2, #6
  408178:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40817c:	60fb      	str	r3, [r7, #12]

		ch_err = chdrv_detect_and_program(dev_ptr);
  40817e:	68f8      	ldr	r0, [r7, #12]
  408180:	4b10      	ldr	r3, [pc, #64]	; (4081c4 <chdrv_group_detect_and_program+0x64>)
  408182:	4798      	blx	r3
  408184:	6178      	str	r0, [r7, #20]

		if (!ch_err && dev_ptr->sensor_connected) {
  408186:	697b      	ldr	r3, [r7, #20]
  408188:	2b00      	cmp	r3, #0
  40818a:	d109      	bne.n	4081a0 <chdrv_group_detect_and_program+0x40>
  40818c:	68fb      	ldr	r3, [r7, #12]
  40818e:	7fdb      	ldrb	r3, [r3, #31]
  408190:	2b00      	cmp	r3, #0
  408192:	d005      	beq.n	4081a0 <chdrv_group_detect_and_program+0x40>
			grp_ptr->sensor_count++;
  408194:	687b      	ldr	r3, [r7, #4]
  408196:	789b      	ldrb	r3, [r3, #2]
  408198:	3301      	adds	r3, #1
  40819a:	b2da      	uxtb	r2, r3
  40819c:	687b      	ldr	r3, [r7, #4]
  40819e:	709a      	strb	r2, [r3, #2]
		}

		if (ch_err) {
  4081a0:	697b      	ldr	r3, [r7, #20]
  4081a2:	2b00      	cmp	r3, #0
  4081a4:	d108      	bne.n	4081b8 <chdrv_group_detect_and_program+0x58>
	for (uint8_t i = 0; i < grp_ptr->num_ports; i++) {
  4081a6:	7cfb      	ldrb	r3, [r7, #19]
  4081a8:	3301      	adds	r3, #1
  4081aa:	74fb      	strb	r3, [r7, #19]
  4081ac:	687b      	ldr	r3, [r7, #4]
  4081ae:	781b      	ldrb	r3, [r3, #0]
  4081b0:	7cfa      	ldrb	r2, [r7, #19]
  4081b2:	429a      	cmp	r2, r3
  4081b4:	d3dd      	bcc.n	408172 <chdrv_group_detect_and_program+0x12>
  4081b6:	e000      	b.n	4081ba <chdrv_group_detect_and_program+0x5a>
			break;
  4081b8:	bf00      	nop
		}
	}
	return ch_err;
  4081ba:	697b      	ldr	r3, [r7, #20]
}
  4081bc:	4618      	mov	r0, r3
  4081be:	3718      	adds	r7, #24
  4081c0:	46bd      	mov	sp, r7
  4081c2:	bd80      	pop	{r7, pc}
  4081c4:	00407f19 	.word	0x00407f19

004081c8 <chdrv_group_prepare>:
 *
 * \return 0 if hardware initialization is successful, non-zero otherwise
 *
 * This function is called internally by \a chdrv_group_start().
 */
int chdrv_group_prepare(ch_group_t* grp_ptr) {
  4081c8:	b580      	push	{r7, lr}
  4081ca:	b084      	sub	sp, #16
  4081cc:	af00      	add	r7, sp, #0
  4081ce:	6078      	str	r0, [r7, #4]
	int ch_err = ! grp_ptr;
  4081d0:	687b      	ldr	r3, [r7, #4]
  4081d2:	2b00      	cmp	r3, #0
  4081d4:	bf0c      	ite	eq
  4081d6:	2301      	moveq	r3, #1
  4081d8:	2300      	movne	r3, #0
  4081da:	b2db      	uxtb	r3, r3
  4081dc:	60fb      	str	r3, [r7, #12]
	uint8_t i;

	if (!ch_err) {
  4081de:	68fb      	ldr	r3, [r7, #12]
  4081e0:	2b00      	cmp	r3, #0
  4081e2:	d13b      	bne.n	40825c <chdrv_group_prepare+0x94>
		grp_ptr->sensor_count = 0;
  4081e4:	687b      	ldr	r3, [r7, #4]
  4081e6:	2200      	movs	r2, #0
  4081e8:	709a      	strb	r2, [r3, #2]

		for (i = 0; i < grp_ptr->num_i2c_buses; i++) {
  4081ea:	2300      	movs	r3, #0
  4081ec:	72fb      	strb	r3, [r7, #11]
  4081ee:	e02a      	b.n	408246 <chdrv_group_prepare+0x7e>
			grp_ptr->i2c_queue[i].len = 0;
  4081f0:	7afa      	ldrb	r2, [r7, #11]
  4081f2:	6879      	ldr	r1, [r7, #4]
  4081f4:	4613      	mov	r3, r2
  4081f6:	011b      	lsls	r3, r3, #4
  4081f8:	4413      	add	r3, r2
  4081fa:	009b      	lsls	r3, r3, #2
  4081fc:	440b      	add	r3, r1
  4081fe:	332e      	adds	r3, #46	; 0x2e
  408200:	2200      	movs	r2, #0
  408202:	701a      	strb	r2, [r3, #0]
			grp_ptr->i2c_queue[i].idx = 0;
  408204:	7afa      	ldrb	r2, [r7, #11]
  408206:	6879      	ldr	r1, [r7, #4]
  408208:	4613      	mov	r3, r2
  40820a:	011b      	lsls	r3, r3, #4
  40820c:	4413      	add	r3, r2
  40820e:	009b      	lsls	r3, r3, #2
  408210:	440b      	add	r3, r1
  408212:	332f      	adds	r3, #47	; 0x2f
  408214:	2200      	movs	r2, #0
  408216:	701a      	strb	r2, [r3, #0]
			grp_ptr->i2c_queue[i].read_pending = 0;
  408218:	7afa      	ldrb	r2, [r7, #11]
  40821a:	6879      	ldr	r1, [r7, #4]
  40821c:	4613      	mov	r3, r2
  40821e:	011b      	lsls	r3, r3, #4
  408220:	4413      	add	r3, r2
  408222:	009b      	lsls	r3, r3, #2
  408224:	440b      	add	r3, r1
  408226:	332c      	adds	r3, #44	; 0x2c
  408228:	2200      	movs	r2, #0
  40822a:	701a      	strb	r2, [r3, #0]
			grp_ptr->i2c_queue[i].running = 0;
  40822c:	7afa      	ldrb	r2, [r7, #11]
  40822e:	6879      	ldr	r1, [r7, #4]
  408230:	4613      	mov	r3, r2
  408232:	011b      	lsls	r3, r3, #4
  408234:	4413      	add	r3, r2
  408236:	009b      	lsls	r3, r3, #2
  408238:	440b      	add	r3, r1
  40823a:	332d      	adds	r3, #45	; 0x2d
  40823c:	2200      	movs	r2, #0
  40823e:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < grp_ptr->num_i2c_buses; i++) {
  408240:	7afb      	ldrb	r3, [r7, #11]
  408242:	3301      	adds	r3, #1
  408244:	72fb      	strb	r3, [r7, #11]
  408246:	687b      	ldr	r3, [r7, #4]
  408248:	785b      	ldrb	r3, [r3, #1]
  40824a:	7afa      	ldrb	r2, [r7, #11]
  40824c:	429a      	cmp	r2, r3
  40824e:	d3cf      	bcc.n	4081f0 <chdrv_group_prepare+0x28>
		}

		chbsp_group_pin_init(grp_ptr);
  408250:	6878      	ldr	r0, [r7, #4]
  408252:	4b05      	ldr	r3, [pc, #20]	; (408268 <chdrv_group_prepare+0xa0>)
  408254:	4798      	blx	r3

		ch_err = chbsp_i2c_init();
  408256:	4b05      	ldr	r3, [pc, #20]	; (40826c <chdrv_group_prepare+0xa4>)
  408258:	4798      	blx	r3
  40825a:	60f8      	str	r0, [r7, #12]
	}

	return ch_err;
  40825c:	68fb      	ldr	r3, [r7, #12]
}
  40825e:	4618      	mov	r0, r3
  408260:	3710      	adds	r7, #16
  408262:	46bd      	mov	sp, r7
  408264:	bd80      	pop	{r7, pc}
  408266:	bf00      	nop
  408268:	0040227d 	.word	0x0040227d
  40826c:	00402771 	.word	0x00402771

00408270 <chdrv_group_start>:
 *
 * This function assumes firmware-specific initialization has already been performed for each a ch_dev_t
 * descriptor for each sensor in the group.  See \a ch_init().
 */
#define CH_PROG_XFER_RETRY 4
int chdrv_group_start(ch_group_t *grp_ptr) {
  408270:	b5b0      	push	{r4, r5, r7, lr}
  408272:	b0a2      	sub	sp, #136	; 0x88
  408274:	af02      	add	r7, sp, #8
  408276:	6078      	str	r0, [r7, #4]
	int ch_err = ! grp_ptr;
  408278:	687b      	ldr	r3, [r7, #4]
  40827a:	2b00      	cmp	r3, #0
  40827c:	bf0c      	ite	eq
  40827e:	2301      	moveq	r3, #1
  408280:	2300      	movne	r3, #0
  408282:	b2db      	uxtb	r3, r3
  408284:	67fb      	str	r3, [r7, #124]	; 0x7c
	int i;
	uint8_t prog_tries = 0;
  408286:	2300      	movs	r3, #0
  408288:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
#ifdef CHDRV_DEBUG
	char cbuf[80];
	const uint32_t start_time = chbsp_timestamp_ms();
  40828c:	4b9c      	ldr	r3, [pc, #624]	; (408500 <chdrv_group_start+0x290>)
  40828e:	4798      	blx	r3
  408290:	6678      	str	r0, [r7, #100]	; 0x64
#endif

	if (!ch_err) {
  408292:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  408294:	2b00      	cmp	r3, #0
  408296:	d103      	bne.n	4082a0 <chdrv_group_start+0x30>
		ch_err = chdrv_group_prepare(grp_ptr);
  408298:	6878      	ldr	r0, [r7, #4]
  40829a:	4b9a      	ldr	r3, [pc, #616]	; (408504 <chdrv_group_start+0x294>)
  40829c:	4798      	blx	r3
  40829e:	67f8      	str	r0, [r7, #124]	; 0x7c
	}

	if (ch_err) {
  4082a0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4082a2:	2b00      	cmp	r3, #0
  4082a4:	d001      	beq.n	4082aa <chdrv_group_start+0x3a>
		return ch_err;
  4082a6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4082a8:	e176      	b.n	408598 <chdrv_group_start+0x328>
	}

RESET_AND_LOAD:
	do {
		chbsp_reset_assert();
  4082aa:	4b97      	ldr	r3, [pc, #604]	; (408508 <chdrv_group_start+0x298>)
  4082ac:	4798      	blx	r3
		for (i = 0; i < grp_ptr->num_ports; i++) {
  4082ae:	2300      	movs	r3, #0
  4082b0:	67bb      	str	r3, [r7, #120]	; 0x78
  4082b2:	e00a      	b.n	4082ca <chdrv_group_start+0x5a>
			chbsp_program_enable(grp_ptr->device[i]);
  4082b4:	687b      	ldr	r3, [r7, #4]
  4082b6:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4082b8:	3206      	adds	r2, #6
  4082ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4082be:	4618      	mov	r0, r3
  4082c0:	4b92      	ldr	r3, [pc, #584]	; (40850c <chdrv_group_start+0x29c>)
  4082c2:	4798      	blx	r3
		for (i = 0; i < grp_ptr->num_ports; i++) {
  4082c4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  4082c6:	3301      	adds	r3, #1
  4082c8:	67bb      	str	r3, [r7, #120]	; 0x78
  4082ca:	687b      	ldr	r3, [r7, #4]
  4082cc:	781b      	ldrb	r3, [r3, #0]
  4082ce:	461a      	mov	r2, r3
  4082d0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  4082d2:	429a      	cmp	r2, r3
  4082d4:	dcee      	bgt.n	4082b4 <chdrv_group_start+0x44>
		}
		chbsp_delay_ms(1);
  4082d6:	2001      	movs	r0, #1
  4082d8:	4b8d      	ldr	r3, [pc, #564]	; (408510 <chdrv_group_start+0x2a0>)
  4082da:	4798      	blx	r3
		chbsp_reset_release();
  4082dc:	4b8d      	ldr	r3, [pc, #564]	; (408514 <chdrv_group_start+0x2a4>)
  4082de:	4798      	blx	r3

		 /* For every i2c bus, set the devices idle in parallel, then disable programming mode for all devices on that bus
		  * This is kludgey because we don't have a great way of iterating over the i2c buses */
		ch_dev_t * c_prev = grp_ptr->device[0];
  4082e0:	687b      	ldr	r3, [r7, #4]
  4082e2:	699b      	ldr	r3, [r3, #24]
  4082e4:	673b      	str	r3, [r7, #112]	; 0x70
		chdrv_set_idle(c_prev);
  4082e6:	6f38      	ldr	r0, [r7, #112]	; 0x70
  4082e8:	4b8b      	ldr	r3, [pc, #556]	; (408518 <chdrv_group_start+0x2a8>)
  4082ea:	4798      	blx	r3
		for (i = 0; i < grp_ptr->num_ports; i++) {
  4082ec:	2300      	movs	r3, #0
  4082ee:	67bb      	str	r3, [r7, #120]	; 0x78
  4082f0:	e018      	b.n	408324 <chdrv_group_start+0xb4>
			ch_dev_t * c = grp_ptr->device[i];
  4082f2:	687b      	ldr	r3, [r7, #4]
  4082f4:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4082f6:	3206      	adds	r2, #6
  4082f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4082fc:	663b      	str	r3, [r7, #96]	; 0x60

			if (c->i2c_bus_index != c_prev->i2c_bus_index) {
  4082fe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  408300:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
  408304:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  408306:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  40830a:	429a      	cmp	r2, r3
  40830c:	d002      	beq.n	408314 <chdrv_group_start+0xa4>
				chdrv_set_idle(c);
  40830e:	6e38      	ldr	r0, [r7, #96]	; 0x60
  408310:	4b81      	ldr	r3, [pc, #516]	; (408518 <chdrv_group_start+0x2a8>)
  408312:	4798      	blx	r3
			}

			chbsp_program_disable(c);
  408314:	6e38      	ldr	r0, [r7, #96]	; 0x60
  408316:	4b81      	ldr	r3, [pc, #516]	; (40851c <chdrv_group_start+0x2ac>)
  408318:	4798      	blx	r3
			c_prev = c;
  40831a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  40831c:	673b      	str	r3, [r7, #112]	; 0x70
		for (i = 0; i < grp_ptr->num_ports; i++) {
  40831e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  408320:	3301      	adds	r3, #1
  408322:	67bb      	str	r3, [r7, #120]	; 0x78
  408324:	687b      	ldr	r3, [r7, #4]
  408326:	781b      	ldrb	r3, [r3, #0]
  408328:	461a      	mov	r2, r3
  40832a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  40832c:	429a      	cmp	r2, r3
  40832e:	dce0      	bgt.n	4082f2 <chdrv_group_start+0x82>
		}

		ch_err = chdrv_group_detect_and_program(grp_ptr);
  408330:	6878      	ldr	r0, [r7, #4]
  408332:	4b7b      	ldr	r3, [pc, #492]	; (408520 <chdrv_group_start+0x2b0>)
  408334:	4798      	blx	r3
  408336:	67f8      	str	r0, [r7, #124]	; 0x7c

	} while (ch_err && prog_tries++ < CH_PROG_XFER_RETRY);
  408338:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40833a:	2b00      	cmp	r3, #0
  40833c:	d006      	beq.n	40834c <chdrv_group_start+0xdc>
  40833e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
  408342:	1c5a      	adds	r2, r3, #1
  408344:	f887 2077 	strb.w	r2, [r7, #119]	; 0x77
  408348:	2b03      	cmp	r3, #3
  40834a:	d9ae      	bls.n	4082aa <chdrv_group_start+0x3a>

	if (!ch_err) {
  40834c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40834e:	2b00      	cmp	r3, #0
  408350:	d161      	bne.n	408416 <chdrv_group_start+0x1a6>
		ch_err = (grp_ptr->sensor_count == 0);
  408352:	687b      	ldr	r3, [r7, #4]
  408354:	789b      	ldrb	r3, [r3, #2]
  408356:	2b00      	cmp	r3, #0
  408358:	bf0c      	ite	eq
  40835a:	2301      	moveq	r3, #1
  40835c:	2300      	movne	r3, #0
  40835e:	b2db      	uxtb	r3, r3
  408360:	67fb      	str	r3, [r7, #124]	; 0x7c
#ifdef CHDRV_DEBUG
		if (ch_err) {
  408362:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  408364:	2b00      	cmp	r3, #0
  408366:	d012      	beq.n	40838e <chdrv_group_start+0x11e>
			snprintf(cbuf, sizeof(cbuf), "No Chirp sensor devices are responding\n");
  408368:	f107 030c 	add.w	r3, r7, #12
  40836c:	4a6d      	ldr	r2, [pc, #436]	; (408524 <chdrv_group_start+0x2b4>)
  40836e:	461c      	mov	r4, r3
  408370:	4615      	mov	r5, r2
  408372:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408374:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  408376:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  408378:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  40837a:	e895 0003 	ldmia.w	r5, {r0, r1}
  40837e:	e884 0003 	stmia.w	r4, {r0, r1}
			chbsp_print_str(cbuf);
  408382:	f107 030c 	add.w	r3, r7, #12
  408386:	4618      	mov	r0, r3
  408388:	4b67      	ldr	r3, [pc, #412]	; (408528 <chdrv_group_start+0x2b8>)
  40838a:	4798      	blx	r3
  40838c:	e043      	b.n	408416 <chdrv_group_start+0x1a6>
		} else {
			snprintf(cbuf, sizeof(cbuf), "Sensor count: %u, %lu ms.\n", grp_ptr->sensor_count, chbsp_timestamp_ms() - start_time);
  40838e:	687b      	ldr	r3, [r7, #4]
  408390:	789b      	ldrb	r3, [r3, #2]
  408392:	461c      	mov	r4, r3
  408394:	4b5a      	ldr	r3, [pc, #360]	; (408500 <chdrv_group_start+0x290>)
  408396:	4798      	blx	r3
  408398:	4602      	mov	r2, r0
  40839a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  40839c:	1ad3      	subs	r3, r2, r3
  40839e:	f107 000c 	add.w	r0, r7, #12
  4083a2:	9300      	str	r3, [sp, #0]
  4083a4:	4623      	mov	r3, r4
  4083a6:	4a61      	ldr	r2, [pc, #388]	; (40852c <chdrv_group_start+0x2bc>)
  4083a8:	2150      	movs	r1, #80	; 0x50
  4083aa:	4c61      	ldr	r4, [pc, #388]	; (408530 <chdrv_group_start+0x2c0>)
  4083ac:	47a0      	blx	r4
			chbsp_print_str(cbuf);
  4083ae:	f107 030c 	add.w	r3, r7, #12
  4083b2:	4618      	mov	r0, r3
  4083b4:	4b5c      	ldr	r3, [pc, #368]	; (408528 <chdrv_group_start+0x2b8>)
  4083b6:	4798      	blx	r3
			for (i = 0; i < grp_ptr->num_ports; i++) {
  4083b8:	2300      	movs	r3, #0
  4083ba:	67bb      	str	r3, [r7, #120]	; 0x78
  4083bc:	e025      	b.n	40840a <chdrv_group_start+0x19a>
				if (grp_ptr->device[i]->sensor_connected)
  4083be:	687b      	ldr	r3, [r7, #4]
  4083c0:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4083c2:	3206      	adds	r2, #6
  4083c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4083c8:	7fdb      	ldrb	r3, [r3, #31]
  4083ca:	2b00      	cmp	r3, #0
  4083cc:	d01a      	beq.n	408404 <chdrv_group_start+0x194>
				{
					snprintf(cbuf, sizeof(cbuf), "Chirp sensor initialized on I2C addr %u:%u.\n", 
							 grp_ptr->device[i]->i2c_bus_index, grp_ptr->device[i]->i2c_address);
  4083ce:	687b      	ldr	r3, [r7, #4]
  4083d0:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4083d2:	3206      	adds	r2, #6
  4083d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4083d8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
					snprintf(cbuf, sizeof(cbuf), "Chirp sensor initialized on I2C addr %u:%u.\n", 
  4083dc:	4619      	mov	r1, r3
							 grp_ptr->device[i]->i2c_bus_index, grp_ptr->device[i]->i2c_address);
  4083de:	687b      	ldr	r3, [r7, #4]
  4083e0:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4083e2:	3206      	adds	r2, #6
  4083e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4083e8:	7e1b      	ldrb	r3, [r3, #24]
					snprintf(cbuf, sizeof(cbuf), "Chirp sensor initialized on I2C addr %u:%u.\n", 
  4083ea:	f107 000c 	add.w	r0, r7, #12
  4083ee:	9300      	str	r3, [sp, #0]
  4083f0:	460b      	mov	r3, r1
  4083f2:	4a50      	ldr	r2, [pc, #320]	; (408534 <chdrv_group_start+0x2c4>)
  4083f4:	2150      	movs	r1, #80	; 0x50
  4083f6:	4c4e      	ldr	r4, [pc, #312]	; (408530 <chdrv_group_start+0x2c0>)
  4083f8:	47a0      	blx	r4
					chbsp_print_str(cbuf);
  4083fa:	f107 030c 	add.w	r3, r7, #12
  4083fe:	4618      	mov	r0, r3
  408400:	4b49      	ldr	r3, [pc, #292]	; (408528 <chdrv_group_start+0x2b8>)
  408402:	4798      	blx	r3
			for (i = 0; i < grp_ptr->num_ports; i++) {
  408404:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  408406:	3301      	adds	r3, #1
  408408:	67bb      	str	r3, [r7, #120]	; 0x78
  40840a:	687b      	ldr	r3, [r7, #4]
  40840c:	781b      	ldrb	r3, [r3, #0]
  40840e:	461a      	mov	r2, r3
  408410:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  408412:	429a      	cmp	r2, r3
  408414:	dcd3      	bgt.n	4083be <chdrv_group_start+0x14e>
			}
		}
#endif
	}

	if (!ch_err) {
  408416:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  408418:	2b00      	cmp	r3, #0
  40841a:	d10e      	bne.n	40843a <chdrv_group_start+0x1ca>
		ch_err = chdrv_group_wait_for_lock(grp_ptr);
  40841c:	6878      	ldr	r0, [r7, #4]
  40841e:	4b46      	ldr	r3, [pc, #280]	; (408538 <chdrv_group_start+0x2c8>)
  408420:	4798      	blx	r3
  408422:	67f8      	str	r0, [r7, #124]	; 0x7c
		if(ch_err && prog_tries++ < CH_PROG_XFER_RETRY+1) {
  408424:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  408426:	2b00      	cmp	r3, #0
  408428:	d007      	beq.n	40843a <chdrv_group_start+0x1ca>
  40842a:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
  40842e:	1c5a      	adds	r2, r3, #1
  408430:	f887 2077 	strb.w	r2, [r7, #119]	; 0x77
  408434:	2b04      	cmp	r3, #4
  408436:	d800      	bhi.n	40843a <chdrv_group_start+0x1ca>
			goto RESET_AND_LOAD;
  408438:	e737      	b.n	4082aa <chdrv_group_start+0x3a>
		}
	}

	if (!ch_err) {
  40843a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40843c:	2b00      	cmp	r3, #0
  40843e:	d14a      	bne.n	4084d6 <chdrv_group_start+0x266>
#ifdef CHDRV_DEBUG
		snprintf(cbuf, sizeof(cbuf), "Frequency locked, %lu ms\n", chbsp_timestamp_ms() - start_time);
  408440:	4b2f      	ldr	r3, [pc, #188]	; (408500 <chdrv_group_start+0x290>)
  408442:	4798      	blx	r3
  408444:	4602      	mov	r2, r0
  408446:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  408448:	1ad3      	subs	r3, r2, r3
  40844a:	f107 000c 	add.w	r0, r7, #12
  40844e:	4a3b      	ldr	r2, [pc, #236]	; (40853c <chdrv_group_start+0x2cc>)
  408450:	2150      	movs	r1, #80	; 0x50
  408452:	4c37      	ldr	r4, [pc, #220]	; (408530 <chdrv_group_start+0x2c0>)
  408454:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  408456:	f107 030c 	add.w	r3, r7, #12
  40845a:	4618      	mov	r0, r3
  40845c:	4b32      	ldr	r3, [pc, #200]	; (408528 <chdrv_group_start+0x2b8>)
  40845e:	4798      	blx	r3
#endif

		chbsp_delay_ms(1);
  408460:	2001      	movs	r0, #1
  408462:	4b2b      	ldr	r3, [pc, #172]	; (408510 <chdrv_group_start+0x2a0>)
  408464:	4798      	blx	r3
		
		chdrv_group_measure_rtc(grp_ptr);
  408466:	6878      	ldr	r0, [r7, #4]
  408468:	4b35      	ldr	r3, [pc, #212]	; (408540 <chdrv_group_start+0x2d0>)
  40846a:	4798      	blx	r3

#ifdef CHDRV_DEBUG
		snprintf(cbuf, sizeof(cbuf), "RTC calibrated, %lu ms\n", chbsp_timestamp_ms() - start_time);
  40846c:	4b24      	ldr	r3, [pc, #144]	; (408500 <chdrv_group_start+0x290>)
  40846e:	4798      	blx	r3
  408470:	4602      	mov	r2, r0
  408472:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  408474:	1ad3      	subs	r3, r2, r3
  408476:	f107 000c 	add.w	r0, r7, #12
  40847a:	4a32      	ldr	r2, [pc, #200]	; (408544 <chdrv_group_start+0x2d4>)
  40847c:	2150      	movs	r1, #80	; 0x50
  40847e:	4c2c      	ldr	r4, [pc, #176]	; (408530 <chdrv_group_start+0x2c0>)
  408480:	47a0      	blx	r4
		chbsp_print_str(cbuf);
  408482:	f107 030c 	add.w	r3, r7, #12
  408486:	4618      	mov	r0, r3
  408488:	4b27      	ldr	r3, [pc, #156]	; (408528 <chdrv_group_start+0x2b8>)
  40848a:	4798      	blx	r3

		for (i = 0; i < grp_ptr->num_ports; i++) {
  40848c:	2300      	movs	r3, #0
  40848e:	67bb      	str	r3, [r7, #120]	; 0x78
  408490:	e01b      	b.n	4084ca <chdrv_group_start+0x25a>
			if (grp_ptr->device[i]->sensor_connected)
  408492:	687b      	ldr	r3, [r7, #4]
  408494:	6fba      	ldr	r2, [r7, #120]	; 0x78
  408496:	3206      	adds	r2, #6
  408498:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40849c:	7fdb      	ldrb	r3, [r3, #31]
  40849e:	2b00      	cmp	r3, #0
  4084a0:	d010      	beq.n	4084c4 <chdrv_group_start+0x254>
			{
				snprintf(cbuf, sizeof(cbuf), "Cal result: %u\n", grp_ptr->device[i]->rtc_cal_result);
  4084a2:	687b      	ldr	r3, [r7, #4]
  4084a4:	6fba      	ldr	r2, [r7, #120]	; 0x78
  4084a6:	3206      	adds	r2, #6
  4084a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4084ac:	89db      	ldrh	r3, [r3, #14]
  4084ae:	f107 000c 	add.w	r0, r7, #12
  4084b2:	4a25      	ldr	r2, [pc, #148]	; (408548 <chdrv_group_start+0x2d8>)
  4084b4:	2150      	movs	r1, #80	; 0x50
  4084b6:	4c1e      	ldr	r4, [pc, #120]	; (408530 <chdrv_group_start+0x2c0>)
  4084b8:	47a0      	blx	r4
				chbsp_print_str(cbuf);
  4084ba:	f107 030c 	add.w	r3, r7, #12
  4084be:	4618      	mov	r0, r3
  4084c0:	4b19      	ldr	r3, [pc, #100]	; (408528 <chdrv_group_start+0x2b8>)
  4084c2:	4798      	blx	r3
		for (i = 0; i < grp_ptr->num_ports; i++) {
  4084c4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  4084c6:	3301      	adds	r3, #1
  4084c8:	67bb      	str	r3, [r7, #120]	; 0x78
  4084ca:	687b      	ldr	r3, [r7, #4]
  4084cc:	781b      	ldrb	r3, [r3, #0]
  4084ce:	461a      	mov	r2, r3
  4084d0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  4084d2:	429a      	cmp	r2, r3
  4084d4:	dcdd      	bgt.n	408492 <chdrv_group_start+0x222>
		}
#endif
	}

	/* Put counts of connected devices per bus in group struct */
	for (int bus_num = 0; bus_num < grp_ptr->num_i2c_buses; bus_num++) {
  4084d6:	2300      	movs	r3, #0
  4084d8:	66fb      	str	r3, [r7, #108]	; 0x6c
  4084da:	e008      	b.n	4084ee <chdrv_group_start+0x27e>
		grp_ptr->num_connected[bus_num] = 0;						// init all counts
  4084dc:	687a      	ldr	r2, [r7, #4]
  4084de:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4084e0:	4413      	add	r3, r2
  4084e2:	3328      	adds	r3, #40	; 0x28
  4084e4:	2200      	movs	r2, #0
  4084e6:	701a      	strb	r2, [r3, #0]
	for (int bus_num = 0; bus_num < grp_ptr->num_i2c_buses; bus_num++) {
  4084e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4084ea:	3301      	adds	r3, #1
  4084ec:	66fb      	str	r3, [r7, #108]	; 0x6c
  4084ee:	687b      	ldr	r3, [r7, #4]
  4084f0:	785b      	ldrb	r3, [r3, #1]
  4084f2:	461a      	mov	r2, r3
  4084f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4084f6:	429a      	cmp	r2, r3
  4084f8:	dcf0      	bgt.n	4084dc <chdrv_group_start+0x26c>
	}

	for (int dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  4084fa:	2300      	movs	r3, #0
  4084fc:	66bb      	str	r3, [r7, #104]	; 0x68
  4084fe:	e044      	b.n	40858a <chdrv_group_start+0x31a>
  408500:	00402fc5 	.word	0x00402fc5
  408504:	004081c9 	.word	0x004081c9
  408508:	004020ad 	.word	0x004020ad
  40850c:	004020d5 	.word	0x004020d5
  408510:	004026b9 	.word	0x004026b9
  408514:	004020c1 	.word	0x004020c1
  408518:	004080fd 	.word	0x004080fd
  40851c:	0040210d 	.word	0x0040210d
  408520:	00408161 	.word	0x00408161
  408524:	0040dd8c 	.word	0x0040dd8c
  408528:	00402fa9 	.word	0x00402fa9
  40852c:	0040ddb4 	.word	0x0040ddb4
  408530:	0040a085 	.word	0x0040a085
  408534:	0040ddd0 	.word	0x0040ddd0
  408538:	00407955 	.word	0x00407955
  40853c:	0040de00 	.word	0x0040de00
  408540:	00407431 	.word	0x00407431
  408544:	0040de1c 	.word	0x0040de1c
  408548:	0040de34 	.word	0x0040de34
		ch_dev_t *dev_ptr = grp_ptr->device[dev_num];
  40854c:	687b      	ldr	r3, [r7, #4]
  40854e:	6eba      	ldr	r2, [r7, #104]	; 0x68
  408550:	3206      	adds	r2, #6
  408552:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  408556:	65fb      	str	r3, [r7, #92]	; 0x5c

		if (dev_ptr->sensor_connected) {
  408558:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  40855a:	7fdb      	ldrb	r3, [r3, #31]
  40855c:	2b00      	cmp	r3, #0
  40855e:	d011      	beq.n	408584 <chdrv_group_start+0x314>
			grp_ptr->num_connected[dev_ptr->i2c_bus_index] += 1;	// count one more on this bus
  408560:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  408562:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  408566:	4619      	mov	r1, r3
  408568:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  40856a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  40856e:	461a      	mov	r2, r3
  408570:	687b      	ldr	r3, [r7, #4]
  408572:	4413      	add	r3, r2
  408574:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  408578:	3301      	adds	r3, #1
  40857a:	b2da      	uxtb	r2, r3
  40857c:	687b      	ldr	r3, [r7, #4]
  40857e:	440b      	add	r3, r1
  408580:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	for (int dev_num = 0; dev_num < grp_ptr->num_ports; dev_num++) {
  408584:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  408586:	3301      	adds	r3, #1
  408588:	66bb      	str	r3, [r7, #104]	; 0x68
  40858a:	687b      	ldr	r3, [r7, #4]
  40858c:	781b      	ldrb	r3, [r3, #0]
  40858e:	461a      	mov	r2, r3
  408590:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  408592:	429a      	cmp	r2, r3
  408594:	dcda      	bgt.n	40854c <chdrv_group_start+0x2dc>
		}
	}

	return ch_err;
  408596:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
}
  408598:	4618      	mov	r0, r3
  40859a:	3780      	adds	r7, #128	; 0x80
  40859c:	46bd      	mov	sp, r7
  40859e:	bdb0      	pop	{r4, r5, r7, pc}

004085a0 <chdrv_pretrigger_delay_set>:
 * This function sets a delay interval that will be inserted between triggering rx-only sensor
 * and tx/rx sensors.  This delay allows the rx-only sensor(s) to settle from any startup disruption
 * (e.g. PMUT "ringdown") before the ultrasound pulse is generated by the tx node.
 *
 */
void chdrv_pretrigger_delay_set(ch_group_t *grp_ptr, uint16_t delay_us){
  4085a0:	b480      	push	{r7}
  4085a2:	b083      	sub	sp, #12
  4085a4:	af00      	add	r7, sp, #0
  4085a6:	6078      	str	r0, [r7, #4]
  4085a8:	460b      	mov	r3, r1
  4085aa:	807b      	strh	r3, [r7, #2]

	grp_ptr->pretrig_delay_us = delay_us;
  4085ac:	687b      	ldr	r3, [r7, #4]
  4085ae:	887a      	ldrh	r2, [r7, #2]
  4085b0:	811a      	strh	r2, [r3, #8]
}
  4085b2:	bf00      	nop
  4085b4:	370c      	adds	r7, #12
  4085b6:	46bd      	mov	sp, r7
  4085b8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4085bc:	4770      	bx	lr

004085be <FP_sqrt>:
 */
 
#include <ch_math_utils.h>

fixed_t FP_sqrt(fixed_t x)
{
  4085be:	b480      	push	{r7}
  4085c0:	b087      	sub	sp, #28
  4085c2:	af00      	add	r7, sp, #0
  4085c4:	6078      	str	r0, [r7, #4]
	uint32_t t, q, b, r;
	r = x;
  4085c6:	687b      	ldr	r3, [r7, #4]
  4085c8:	60fb      	str	r3, [r7, #12]
	b = 0x40000000;
  4085ca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4085ce:	613b      	str	r3, [r7, #16]
	q = 0;
  4085d0:	2300      	movs	r3, #0
  4085d2:	617b      	str	r3, [r7, #20]
	while( b > 0x40 )
  4085d4:	e015      	b.n	408602 <FP_sqrt+0x44>
	{
		t = q + b;
  4085d6:	697a      	ldr	r2, [r7, #20]
  4085d8:	693b      	ldr	r3, [r7, #16]
  4085da:	4413      	add	r3, r2
  4085dc:	60bb      	str	r3, [r7, #8]
		if( r >= t )
  4085de:	68fa      	ldr	r2, [r7, #12]
  4085e0:	68bb      	ldr	r3, [r7, #8]
  4085e2:	429a      	cmp	r2, r3
  4085e4:	d307      	bcc.n	4085f6 <FP_sqrt+0x38>
		{
			r -= t;
  4085e6:	68fa      	ldr	r2, [r7, #12]
  4085e8:	68bb      	ldr	r3, [r7, #8]
  4085ea:	1ad3      	subs	r3, r2, r3
  4085ec:	60fb      	str	r3, [r7, #12]
			q = t + b; // equivalent to q += 2*b
  4085ee:	68ba      	ldr	r2, [r7, #8]
  4085f0:	693b      	ldr	r3, [r7, #16]
  4085f2:	4413      	add	r3, r2
  4085f4:	617b      	str	r3, [r7, #20]
		}
		r <<= 1;
  4085f6:	68fb      	ldr	r3, [r7, #12]
  4085f8:	005b      	lsls	r3, r3, #1
  4085fa:	60fb      	str	r3, [r7, #12]
		b >>= 1;
  4085fc:	693b      	ldr	r3, [r7, #16]
  4085fe:	085b      	lsrs	r3, r3, #1
  408600:	613b      	str	r3, [r7, #16]
	while( b > 0x40 )
  408602:	693b      	ldr	r3, [r7, #16]
  408604:	2b40      	cmp	r3, #64	; 0x40
  408606:	d8e6      	bhi.n	4085d6 <FP_sqrt+0x18>
	}
	q >>= 8;
  408608:	697b      	ldr	r3, [r7, #20]
  40860a:	0a1b      	lsrs	r3, r3, #8
  40860c:	617b      	str	r3, [r7, #20]
	return q;
  40860e:	697b      	ldr	r3, [r7, #20]
}
  408610:	4618      	mov	r0, r3
  408612:	371c      	adds	r7, #28
  408614:	46bd      	mov	sp, r7
  408616:	f85d 7b04 	ldr.w	r7, [sp], #4
  40861a:	4770      	bx	lr

0040861c <FP_log2>:

fixed_t FP_log2(fixed_t x)
{
  40861c:	b480      	push	{r7}
  40861e:	b087      	sub	sp, #28
  408620:	af00      	add	r7, sp, #0
  408622:	6078      	str	r0, [r7, #4]
	// This implementation is based on Clay. S. Turner's fast binary logarithm
	// algorithm[1].
	fixed_t b = 1U << (FRACT_BITS - 1);
  408624:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408628:	617b      	str	r3, [r7, #20]
	fixed_t y = 0;
  40862a:	2300      	movs	r3, #0
  40862c:	613b      	str	r3, [r7, #16]
	size_t i;
	fixed_t z;
	if (x == 0) {
  40862e:	687b      	ldr	r3, [r7, #4]
  408630:	2b00      	cmp	r3, #0
  408632:	d108      	bne.n	408646 <FP_log2+0x2a>
		return 0; // represents negative infinity
  408634:	2300      	movs	r3, #0
  408636:	e037      	b.n	4086a8 <FP_log2+0x8c>
	}
	while (x < 1U << FRACT_BITS) {
		x <<= 1;
  408638:	687b      	ldr	r3, [r7, #4]
  40863a:	005b      	lsls	r3, r3, #1
  40863c:	607b      	str	r3, [r7, #4]
		y -= 1U << FRACT_BITS;
  40863e:	693b      	ldr	r3, [r7, #16]
  408640:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
  408644:	613b      	str	r3, [r7, #16]
	while (x < 1U << FRACT_BITS) {
  408646:	687b      	ldr	r3, [r7, #4]
  408648:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  40864c:	d3f4      	bcc.n	408638 <FP_log2+0x1c>
	}
	while (x >= 2U << FRACT_BITS) {
  40864e:	e006      	b.n	40865e <FP_log2+0x42>
		x >>= 1;
  408650:	687b      	ldr	r3, [r7, #4]
  408652:	085b      	lsrs	r3, r3, #1
  408654:	607b      	str	r3, [r7, #4]
		y += 1U << FRACT_BITS;
  408656:	693b      	ldr	r3, [r7, #16]
  408658:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  40865c:	613b      	str	r3, [r7, #16]
	while (x >= 2U << FRACT_BITS) {
  40865e:	687b      	ldr	r3, [r7, #4]
  408660:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  408664:	d2f4      	bcs.n	408650 <FP_log2+0x34>
	}
	z = x;
  408666:	687b      	ldr	r3, [r7, #4]
  408668:	60bb      	str	r3, [r7, #8]
	for (i = 0; i < FRACT_BITS; i++) {
  40866a:	2300      	movs	r3, #0
  40866c:	60fb      	str	r3, [r7, #12]
  40866e:	e017      	b.n	4086a0 <FP_log2+0x84>
		z = FIXEDMUL(z, z);// >> FRACT_BITS;
  408670:	68bb      	ldr	r3, [r7, #8]
  408672:	0a1b      	lsrs	r3, r3, #8
  408674:	68ba      	ldr	r2, [r7, #8]
  408676:	0a12      	lsrs	r2, r2, #8
  408678:	fb02 f303 	mul.w	r3, r2, r3
  40867c:	60bb      	str	r3, [r7, #8]
		if (z >= 2U << FRACT_BITS) {
  40867e:	68bb      	ldr	r3, [r7, #8]
  408680:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  408684:	d306      	bcc.n	408694 <FP_log2+0x78>
			z >>= 1;
  408686:	68bb      	ldr	r3, [r7, #8]
  408688:	085b      	lsrs	r3, r3, #1
  40868a:	60bb      	str	r3, [r7, #8]
			y += b;
  40868c:	693a      	ldr	r2, [r7, #16]
  40868e:	697b      	ldr	r3, [r7, #20]
  408690:	4413      	add	r3, r2
  408692:	613b      	str	r3, [r7, #16]
		}
		b >>= 1;
  408694:	697b      	ldr	r3, [r7, #20]
  408696:	085b      	lsrs	r3, r3, #1
  408698:	617b      	str	r3, [r7, #20]
	for (i = 0; i < FRACT_BITS; i++) {
  40869a:	68fb      	ldr	r3, [r7, #12]
  40869c:	3301      	adds	r3, #1
  40869e:	60fb      	str	r3, [r7, #12]
  4086a0:	68fb      	ldr	r3, [r7, #12]
  4086a2:	2b0f      	cmp	r3, #15
  4086a4:	d9e4      	bls.n	408670 <FP_log2+0x54>
	}
	return y;
  4086a6:	693b      	ldr	r3, [r7, #16]
}
  4086a8:	4618      	mov	r0, r3
  4086aa:	371c      	adds	r7, #28
  4086ac:	46bd      	mov	sp, r7
  4086ae:	f85d 7b04 	ldr.w	r7, [sp], #4
  4086b2:	4770      	bx	lr

004086b4 <FP_log>:

fixed_t FP_log(fixed_t x)
{
  4086b4:	b580      	push	{r7, lr}
  4086b6:	b084      	sub	sp, #16
  4086b8:	af00      	add	r7, sp, #0
  4086ba:	6078      	str	r0, [r7, #4]
	fixed_t y;

	// macro value is in Q1.31 fomat, but we use Q16.  shift in two steps to keep multiply precision
	y = FIXEDMUL(FP_log2(x), (INV_LOG2_E_Q1DOT31 >> Q31_TO_Q16_SHIFT_1));
  4086bc:	6878      	ldr	r0, [r7, #4]
  4086be:	4b08      	ldr	r3, [pc, #32]	; (4086e0 <FP_log+0x2c>)
  4086c0:	4798      	blx	r3
  4086c2:	4603      	mov	r3, r0
  4086c4:	0a1b      	lsrs	r3, r3, #8
  4086c6:	f241 622e 	movw	r2, #5678	; 0x162e
  4086ca:	fb02 f303 	mul.w	r3, r2, r3
  4086ce:	60fb      	str	r3, [r7, #12]
	y >>= Q31_TO_Q16_SHIFT_2;
  4086d0:	68fb      	ldr	r3, [r7, #12]
  4086d2:	095b      	lsrs	r3, r3, #5
  4086d4:	60fb      	str	r3, [r7, #12]

	return y;
  4086d6:	68fb      	ldr	r3, [r7, #12]
}
  4086d8:	4618      	mov	r0, r3
  4086da:	3710      	adds	r7, #16
  4086dc:	46bd      	mov	sp, r7
  4086de:	bd80      	pop	{r7, pc}
  4086e0:	0040861d 	.word	0x0040861d

004086e4 <sqrt_int32>:
 *
 * Algorithm and code Author Christophe Meessen 1993. 
 * Initially published in usenet comp.lang.c, Thu, 28 Jan 1993 08:35:23 GMT
 */
int32_t sqrt_int32( int32_t v )
{
  4086e4:	b480      	push	{r7}
  4086e6:	b087      	sub	sp, #28
  4086e8:	af00      	add	r7, sp, #0
  4086ea:	6078      	str	r0, [r7, #4]
    uint32_t t, q, b, r;
    r = v;           // r = v - x
  4086ec:	687b      	ldr	r3, [r7, #4]
  4086ee:	60fb      	str	r3, [r7, #12]
    b = 0x40000000;  // a
  4086f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4086f4:	613b      	str	r3, [r7, #16]
    q = 0;           // 2ax
  4086f6:	2300      	movs	r3, #0
  4086f8:	617b      	str	r3, [r7, #20]
    while( b > 0 )
  4086fa:	e015      	b.n	408728 <sqrt_int32+0x44>
    {
        t = q + b;   // t = 2ax + a
  4086fc:	697a      	ldr	r2, [r7, #20]
  4086fe:	693b      	ldr	r3, [r7, #16]
  408700:	4413      	add	r3, r2
  408702:	60bb      	str	r3, [r7, #8]
        q >>= 1;     // if a' = a/2, then q' = q/2
  408704:	697b      	ldr	r3, [r7, #20]
  408706:	085b      	lsrs	r3, r3, #1
  408708:	617b      	str	r3, [r7, #20]
        if( r >= t ) // if (v - x) >= 2ax + a
  40870a:	68fa      	ldr	r2, [r7, #12]
  40870c:	68bb      	ldr	r3, [r7, #8]
  40870e:	429a      	cmp	r2, r3
  408710:	d307      	bcc.n	408722 <sqrt_int32+0x3e>
        {
            r -= t;  // r' = (v - x) - (2ax + a)
  408712:	68fa      	ldr	r2, [r7, #12]
  408714:	68bb      	ldr	r3, [r7, #8]
  408716:	1ad3      	subs	r3, r2, r3
  408718:	60fb      	str	r3, [r7, #12]
            q += b;  // if x' = (x + a) then ax' = ax + a, thus q' = q' + b
  40871a:	697a      	ldr	r2, [r7, #20]
  40871c:	693b      	ldr	r3, [r7, #16]
  40871e:	4413      	add	r3, r2
  408720:	617b      	str	r3, [r7, #20]
        }
        b >>= 2;     // if a' = a/2, then b' = b / 4
  408722:	693b      	ldr	r3, [r7, #16]
  408724:	089b      	lsrs	r3, r3, #2
  408726:	613b      	str	r3, [r7, #16]
    while( b > 0 )
  408728:	693b      	ldr	r3, [r7, #16]
  40872a:	2b00      	cmp	r3, #0
  40872c:	d1e6      	bne.n	4086fc <sqrt_int32+0x18>
    }
    return q;
  40872e:	697b      	ldr	r3, [r7, #20]
}
  408730:	4618      	mov	r0, r3
  408732:	371c      	adds	r7, #28
  408734:	46bd      	mov	sp, r7
  408736:	f85d 7b04 	ldr.w	r7, [sp], #4
  40873a:	4770      	bx	lr

0040873c <NVIC_EnableIRQ>:
{
  40873c:	b480      	push	{r7}
  40873e:	b083      	sub	sp, #12
  408740:	af00      	add	r7, sp, #0
  408742:	4603      	mov	r3, r0
  408744:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  408746:	4909      	ldr	r1, [pc, #36]	; (40876c <NVIC_EnableIRQ+0x30>)
  408748:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40874c:	095b      	lsrs	r3, r3, #5
  40874e:	79fa      	ldrb	r2, [r7, #7]
  408750:	f002 021f 	and.w	r2, r2, #31
  408754:	2001      	movs	r0, #1
  408756:	fa00 f202 	lsl.w	r2, r0, r2
  40875a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40875e:	bf00      	nop
  408760:	370c      	adds	r7, #12
  408762:	46bd      	mov	sp, r7
  408764:	f85d 7b04 	ldr.w	r7, [sp], #4
  408768:	4770      	bx	lr
  40876a:	bf00      	nop
  40876c:	e000e100 	.word	0xe000e100

00408770 <NVIC_DisableIRQ>:
{
  408770:	b480      	push	{r7}
  408772:	b083      	sub	sp, #12
  408774:	af00      	add	r7, sp, #0
  408776:	4603      	mov	r3, r0
  408778:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  40877a:	4909      	ldr	r1, [pc, #36]	; (4087a0 <NVIC_DisableIRQ+0x30>)
  40877c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  408780:	095b      	lsrs	r3, r3, #5
  408782:	79fa      	ldrb	r2, [r7, #7]
  408784:	f002 021f 	and.w	r2, r2, #31
  408788:	2001      	movs	r0, #1
  40878a:	fa00 f202 	lsl.w	r2, r0, r2
  40878e:	3320      	adds	r3, #32
  408790:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  408794:	bf00      	nop
  408796:	370c      	adds	r7, #12
  408798:	46bd      	mov	sp, r7
  40879a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40879e:	4770      	bx	lr
  4087a0:	e000e100 	.word	0xe000e100

004087a4 <NVIC_ClearPendingIRQ>:
{
  4087a4:	b480      	push	{r7}
  4087a6:	b083      	sub	sp, #12
  4087a8:	af00      	add	r7, sp, #0
  4087aa:	4603      	mov	r3, r0
  4087ac:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4087ae:	4909      	ldr	r1, [pc, #36]	; (4087d4 <NVIC_ClearPendingIRQ+0x30>)
  4087b0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4087b4:	095b      	lsrs	r3, r3, #5
  4087b6:	79fa      	ldrb	r2, [r7, #7]
  4087b8:	f002 021f 	and.w	r2, r2, #31
  4087bc:	2001      	movs	r0, #1
  4087be:	fa00 f202 	lsl.w	r2, r0, r2
  4087c2:	3360      	adds	r3, #96	; 0x60
  4087c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  4087c8:	bf00      	nop
  4087ca:	370c      	adds	r7, #12
  4087cc:	46bd      	mov	sp, r7
  4087ce:	f85d 7b04 	ldr.w	r7, [sp], #4
  4087d2:	4770      	bx	lr
  4087d4:	e000e100 	.word	0xe000e100

004087d8 <NVIC_SetPriority>:
{
  4087d8:	b480      	push	{r7}
  4087da:	b083      	sub	sp, #12
  4087dc:	af00      	add	r7, sp, #0
  4087de:	4603      	mov	r3, r0
  4087e0:	6039      	str	r1, [r7, #0]
  4087e2:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4087e4:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4087e8:	2b00      	cmp	r3, #0
  4087ea:	da0b      	bge.n	408804 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4087ec:	490d      	ldr	r1, [pc, #52]	; (408824 <NVIC_SetPriority+0x4c>)
  4087ee:	79fb      	ldrb	r3, [r7, #7]
  4087f0:	f003 030f 	and.w	r3, r3, #15
  4087f4:	3b04      	subs	r3, #4
  4087f6:	683a      	ldr	r2, [r7, #0]
  4087f8:	b2d2      	uxtb	r2, r2
  4087fa:	0112      	lsls	r2, r2, #4
  4087fc:	b2d2      	uxtb	r2, r2
  4087fe:	440b      	add	r3, r1
  408800:	761a      	strb	r2, [r3, #24]
}
  408802:	e009      	b.n	408818 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  408804:	4908      	ldr	r1, [pc, #32]	; (408828 <NVIC_SetPriority+0x50>)
  408806:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40880a:	683a      	ldr	r2, [r7, #0]
  40880c:	b2d2      	uxtb	r2, r2
  40880e:	0112      	lsls	r2, r2, #4
  408810:	b2d2      	uxtb	r2, r2
  408812:	440b      	add	r3, r1
  408814:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  408818:	bf00      	nop
  40881a:	370c      	adds	r7, #12
  40881c:	46bd      	mov	sp, r7
  40881e:	f85d 7b04 	ldr.w	r7, [sp], #4
  408822:	4770      	bx	lr
  408824:	e000ed00 	.word	0xe000ed00
  408828:	e000e100 	.word	0xe000e100

0040882c <osc_get_rate>:
{
  40882c:	b480      	push	{r7}
  40882e:	b083      	sub	sp, #12
  408830:	af00      	add	r7, sp, #0
  408832:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  408834:	687b      	ldr	r3, [r7, #4]
  408836:	2b07      	cmp	r3, #7
  408838:	d825      	bhi.n	408886 <osc_get_rate+0x5a>
  40883a:	a201      	add	r2, pc, #4	; (adr r2, 408840 <osc_get_rate+0x14>)
  40883c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408840:	00408861 	.word	0x00408861
  408844:	00408867 	.word	0x00408867
  408848:	0040886d 	.word	0x0040886d
  40884c:	00408873 	.word	0x00408873
  408850:	00408877 	.word	0x00408877
  408854:	0040887b 	.word	0x0040887b
  408858:	0040887f 	.word	0x0040887f
  40885c:	00408883 	.word	0x00408883
		return OSC_SLCK_32K_RC_HZ;
  408860:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  408864:	e010      	b.n	408888 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  408866:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40886a:	e00d      	b.n	408888 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  40886c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408870:	e00a      	b.n	408888 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  408872:	4b08      	ldr	r3, [pc, #32]	; (408894 <osc_get_rate+0x68>)
  408874:	e008      	b.n	408888 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  408876:	4b08      	ldr	r3, [pc, #32]	; (408898 <osc_get_rate+0x6c>)
  408878:	e006      	b.n	408888 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  40887a:	4b08      	ldr	r3, [pc, #32]	; (40889c <osc_get_rate+0x70>)
  40887c:	e004      	b.n	408888 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  40887e:	2300      	movs	r3, #0
  408880:	e002      	b.n	408888 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  408882:	2300      	movs	r3, #0
  408884:	e000      	b.n	408888 <osc_get_rate+0x5c>
	return 0;
  408886:	2300      	movs	r3, #0
}
  408888:	4618      	mov	r0, r3
  40888a:	370c      	adds	r7, #12
  40888c:	46bd      	mov	sp, r7
  40888e:	f85d 7b04 	ldr.w	r7, [sp], #4
  408892:	4770      	bx	lr
  408894:	007a1200 	.word	0x007a1200
  408898:	00f42400 	.word	0x00f42400
  40889c:	016e3600 	.word	0x016e3600

004088a0 <sysclk_get_main_hz>:
{
  4088a0:	b580      	push	{r7, lr}
  4088a2:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4088a4:	2001      	movs	r0, #1
  4088a6:	4b04      	ldr	r3, [pc, #16]	; (4088b8 <sysclk_get_main_hz+0x18>)
  4088a8:	4798      	blx	r3
  4088aa:	4602      	mov	r2, r0
  4088ac:	f640 634e 	movw	r3, #3662	; 0xe4e
  4088b0:	fb03 f302 	mul.w	r3, r3, r2
}
  4088b4:	4618      	mov	r0, r3
  4088b6:	bd80      	pop	{r7, pc}
  4088b8:	0040882d 	.word	0x0040882d

004088bc <sysclk_get_peripheral_hz>:
{
  4088bc:	b580      	push	{r7, lr}
  4088be:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4088c0:	4b02      	ldr	r3, [pc, #8]	; (4088cc <sysclk_get_peripheral_hz+0x10>)
  4088c2:	4798      	blx	r3
  4088c4:	4603      	mov	r3, r0
}
  4088c6:	4618      	mov	r0, r3
  4088c8:	bd80      	pop	{r7, pc}
  4088ca:	bf00      	nop
  4088cc:	004088a1 	.word	0x004088a1

004088d0 <i2c_master_initialize1>:

 twi_options_t opt;
 twi_packet_t packet_tx, packet_rx;

void i2c_master_initialize1(void)
{
  4088d0:	b580      	push	{r7, lr}
  4088d2:	af00      	add	r7, sp, #0
	/* Insert application code here, after the board has been initialized. */
	/* Enable the peripheral and set TWI mode. */
	flexcom_enable(BOARD_FLEXCOM_TWI1);
  4088d4:	4810      	ldr	r0, [pc, #64]	; (408918 <i2c_master_initialize1+0x48>)
  4088d6:	4b11      	ldr	r3, [pc, #68]	; (40891c <i2c_master_initialize1+0x4c>)
  4088d8:	4798      	blx	r3
	flexcom_set_opmode(BOARD_FLEXCOM_TWI1, FLEXCOM_TWI);
  4088da:	2103      	movs	r1, #3
  4088dc:	480e      	ldr	r0, [pc, #56]	; (408918 <i2c_master_initialize1+0x48>)
  4088de:	4b10      	ldr	r3, [pc, #64]	; (408920 <i2c_master_initialize1+0x50>)
  4088e0:	4798      	blx	r3
	
	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
  4088e2:	4b10      	ldr	r3, [pc, #64]	; (408924 <i2c_master_initialize1+0x54>)
  4088e4:	4798      	blx	r3
  4088e6:	4602      	mov	r2, r0
  4088e8:	4b0f      	ldr	r3, [pc, #60]	; (408928 <i2c_master_initialize1+0x58>)
  4088ea:	601a      	str	r2, [r3, #0]
	opt.speed = TWI_CLK;
  4088ec:	4b0e      	ldr	r3, [pc, #56]	; (408928 <i2c_master_initialize1+0x58>)
  4088ee:	4a0f      	ldr	r2, [pc, #60]	; (40892c <i2c_master_initialize1+0x5c>)
  4088f0:	605a      	str	r2, [r3, #4]

	//const char str1[] = "-E-\tTWI master initialization failed.\r\n";

	//twi_master_init(BOARD_BASE_TWI, &opt);
	if (twi_master_init(BOARD_BASE_TWI1, &opt) != TWI_SUCCESS) {
  4088f2:	490d      	ldr	r1, [pc, #52]	; (408928 <i2c_master_initialize1+0x58>)
  4088f4:	480e      	ldr	r0, [pc, #56]	; (408930 <i2c_master_initialize1+0x60>)
  4088f6:	4b0f      	ldr	r3, [pc, #60]	; (408934 <i2c_master_initialize1+0x64>)
  4088f8:	4798      	blx	r3
		//usart_serial_write_packet(CONF_UART, (const uint8_t*)str1, sizeof(str1) - 1);
	}
	NVIC_DisableIRQ(FLEXCOM1_IRQn);
  4088fa:	2009      	movs	r0, #9
  4088fc:	4b0e      	ldr	r3, [pc, #56]	; (408938 <i2c_master_initialize1+0x68>)
  4088fe:	4798      	blx	r3
	NVIC_ClearPendingIRQ(FLEXCOM1_IRQn);
  408900:	2009      	movs	r0, #9
  408902:	4b0e      	ldr	r3, [pc, #56]	; (40893c <i2c_master_initialize1+0x6c>)
  408904:	4798      	blx	r3
	NVIC_SetPriority(FLEXCOM1_IRQn, 1);
  408906:	2101      	movs	r1, #1
  408908:	2009      	movs	r0, #9
  40890a:	4b0d      	ldr	r3, [pc, #52]	; (408940 <i2c_master_initialize1+0x70>)
  40890c:	4798      	blx	r3
	NVIC_EnableIRQ(FLEXCOM1_IRQn);
  40890e:	2009      	movs	r0, #9
  408910:	4b0c      	ldr	r3, [pc, #48]	; (408944 <i2c_master_initialize1+0x74>)
  408912:	4798      	blx	r3
} 
  408914:	bf00      	nop
  408916:	bd80      	pop	{r7, pc}
  408918:	40020000 	.word	0x40020000
  40891c:	00403925 	.word	0x00403925
  408920:	00403a8d 	.word	0x00403a8d
  408924:	004088bd 	.word	0x004088bd
  408928:	20002954 	.word	0x20002954
  40892c:	00061a80 	.word	0x00061a80
  408930:	40020600 	.word	0x40020600
  408934:	00404b7d 	.word	0x00404b7d
  408938:	00408771 	.word	0x00408771
  40893c:	004087a5 	.word	0x004087a5
  408940:	004087d9 	.word	0x004087d9
  408944:	0040873d 	.word	0x0040873d

00408948 <i2c_master_initialize3>:
 
void i2c_master_initialize3(void)
{
  408948:	b580      	push	{r7, lr}
  40894a:	af00      	add	r7, sp, #0
	/* Insert application code here, after the board has been initialized. */
	/* Enable the peripheral and set TWI mode. */
	flexcom_enable(BOARD_FLEXCOM_TWI3);
  40894c:	4810      	ldr	r0, [pc, #64]	; (408990 <i2c_master_initialize3+0x48>)
  40894e:	4b11      	ldr	r3, [pc, #68]	; (408994 <i2c_master_initialize3+0x4c>)
  408950:	4798      	blx	r3
	flexcom_set_opmode(BOARD_FLEXCOM_TWI3, FLEXCOM_TWI);
  408952:	2103      	movs	r1, #3
  408954:	480e      	ldr	r0, [pc, #56]	; (408990 <i2c_master_initialize3+0x48>)
  408956:	4b10      	ldr	r3, [pc, #64]	; (408998 <i2c_master_initialize3+0x50>)
  408958:	4798      	blx	r3
	
	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
  40895a:	4b10      	ldr	r3, [pc, #64]	; (40899c <i2c_master_initialize3+0x54>)
  40895c:	4798      	blx	r3
  40895e:	4602      	mov	r2, r0
  408960:	4b0f      	ldr	r3, [pc, #60]	; (4089a0 <i2c_master_initialize3+0x58>)
  408962:	601a      	str	r2, [r3, #0]
	opt.speed = TWI_CLK;
  408964:	4b0e      	ldr	r3, [pc, #56]	; (4089a0 <i2c_master_initialize3+0x58>)
  408966:	4a0f      	ldr	r2, [pc, #60]	; (4089a4 <i2c_master_initialize3+0x5c>)
  408968:	605a      	str	r2, [r3, #4]

	//const char str1[] = "-E-\tTWI master initialization failed.\r\n";

	//twi_master_init(BOARD_BASE_TWI, &opt);
	if (twi_master_init(BOARD_BASE_TWI3, &opt) != TWI_SUCCESS) {
  40896a:	490d      	ldr	r1, [pc, #52]	; (4089a0 <i2c_master_initialize3+0x58>)
  40896c:	480e      	ldr	r0, [pc, #56]	; (4089a8 <i2c_master_initialize3+0x60>)
  40896e:	4b0f      	ldr	r3, [pc, #60]	; (4089ac <i2c_master_initialize3+0x64>)
  408970:	4798      	blx	r3
		//usart_serial_write_packet(CONF_UART, (const uint8_t*)str1, sizeof(str1) - 1);
	}
	NVIC_DisableIRQ(FLEXCOM3_IRQn);
  408972:	2013      	movs	r0, #19
  408974:	4b0e      	ldr	r3, [pc, #56]	; (4089b0 <i2c_master_initialize3+0x68>)
  408976:	4798      	blx	r3
	NVIC_ClearPendingIRQ(FLEXCOM3_IRQn);
  408978:	2013      	movs	r0, #19
  40897a:	4b0e      	ldr	r3, [pc, #56]	; (4089b4 <i2c_master_initialize3+0x6c>)
  40897c:	4798      	blx	r3
	NVIC_SetPriority(FLEXCOM3_IRQn, 1);
  40897e:	2101      	movs	r1, #1
  408980:	2013      	movs	r0, #19
  408982:	4b0d      	ldr	r3, [pc, #52]	; (4089b8 <i2c_master_initialize3+0x70>)
  408984:	4798      	blx	r3
	NVIC_EnableIRQ(FLEXCOM3_IRQn);
  408986:	2013      	movs	r0, #19
  408988:	4b0c      	ldr	r3, [pc, #48]	; (4089bc <i2c_master_initialize3+0x74>)
  40898a:	4798      	blx	r3
}
  40898c:	bf00      	nop
  40898e:	bd80      	pop	{r7, pc}
  408990:	40018000 	.word	0x40018000
  408994:	00403925 	.word	0x00403925
  408998:	00403a8d 	.word	0x00403a8d
  40899c:	004088bd 	.word	0x004088bd
  4089a0:	20002954 	.word	0x20002954
  4089a4:	00061a80 	.word	0x00061a80
  4089a8:	40018600 	.word	0x40018600
  4089ac:	00404b7d 	.word	0x00404b7d
  4089b0:	00408771 	.word	0x00408771
  4089b4:	004087a5 	.word	0x004087a5
  4089b8:	004087d9 	.word	0x004087d9
  4089bc:	0040873d 	.word	0x0040873d

004089c0 <i2c_master_init>:

void i2c_master_init(void)
{
  4089c0:	b580      	push	{r7, lr}
  4089c2:	af00      	add	r7, sp, #0
	i2c_master_initialize1();
  4089c4:	4b0c      	ldr	r3, [pc, #48]	; (4089f8 <i2c_master_init+0x38>)
  4089c6:	4798      	blx	r3
	i2c_master_initialize3();
  4089c8:	4b0c      	ldr	r3, [pc, #48]	; (4089fc <i2c_master_init+0x3c>)
  4089ca:	4798      	blx	r3

	pio_pull_down(PIOA, PIO_PA3 | PIO_PA4, 0);
  4089cc:	2200      	movs	r2, #0
  4089ce:	2118      	movs	r1, #24
  4089d0:	480b      	ldr	r0, [pc, #44]	; (408a00 <i2c_master_init+0x40>)
  4089d2:	4b0c      	ldr	r3, [pc, #48]	; (408a04 <i2c_master_init+0x44>)
  4089d4:	4798      	blx	r3
	pio_pull_up(PIOA, PIO_PA3 | PIO_PA4, 0);
  4089d6:	2200      	movs	r2, #0
  4089d8:	2118      	movs	r1, #24
  4089da:	4809      	ldr	r0, [pc, #36]	; (408a00 <i2c_master_init+0x40>)
  4089dc:	4b0a      	ldr	r3, [pc, #40]	; (408a08 <i2c_master_init+0x48>)
  4089de:	4798      	blx	r3

	pio_pull_down(PIOB, PIO_PB2 | PIO_PB3, 0);
  4089e0:	2200      	movs	r2, #0
  4089e2:	210c      	movs	r1, #12
  4089e4:	4809      	ldr	r0, [pc, #36]	; (408a0c <i2c_master_init+0x4c>)
  4089e6:	4b07      	ldr	r3, [pc, #28]	; (408a04 <i2c_master_init+0x44>)
  4089e8:	4798      	blx	r3
	pio_pull_up(PIOB, PIO_PB2 | PIO_PB3, 0);
  4089ea:	2200      	movs	r2, #0
  4089ec:	210c      	movs	r1, #12
  4089ee:	4807      	ldr	r0, [pc, #28]	; (408a0c <i2c_master_init+0x4c>)
  4089f0:	4b05      	ldr	r3, [pc, #20]	; (408a08 <i2c_master_init+0x48>)
  4089f2:	4798      	blx	r3
}
  4089f4:	bf00      	nop
  4089f6:	bd80      	pop	{r7, pc}
  4089f8:	004088d1 	.word	0x004088d1
  4089fc:	00408949 	.word	0x00408949
  408a00:	400e0e00 	.word	0x400e0e00
  408a04:	00403da1 	.word	0x00403da1
  408a08:	00403b33 	.word	0x00403b33
  408a0c:	400e1000 	.word	0x400e1000

00408a10 <i2c_master_read_register1>:
	  flexcom_disable(BOARD_FLEXCOM_TWI3);
	  twi_disable_master_mode(BOARD_BASE_TWI3);
  }

unsigned long i2c_master_read_register1(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue)
 {
  408a10:	b580      	push	{r7, lr}
  408a12:	b088      	sub	sp, #32
  408a14:	af00      	add	r7, sp, #0
  408a16:	603b      	str	r3, [r7, #0]
  408a18:	4603      	mov	r3, r0
  408a1a:	71fb      	strb	r3, [r7, #7]
  408a1c:	460b      	mov	r3, r1
  408a1e:	71bb      	strb	r3, [r7, #6]
  408a20:	4613      	mov	r3, r2
  408a22:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_read;
	 
	 packet_read.chip = Address;
  408a24:	79fb      	ldrb	r3, [r7, #7]
  408a26:	773b      	strb	r3, [r7, #28]
	 packet_read.addr[0] = RegisterAddr;
  408a28:	79bb      	ldrb	r3, [r7, #6]
  408a2a:	733b      	strb	r3, [r7, #12]
	 packet_read.addr_length = 1;
  408a2c:	2301      	movs	r3, #1
  408a2e:	613b      	str	r3, [r7, #16]
	 packet_read.buffer = RegisterValue;
  408a30:	683b      	ldr	r3, [r7, #0]
  408a32:	617b      	str	r3, [r7, #20]
	 packet_read.length = RegisterLen;
  408a34:	88bb      	ldrh	r3, [r7, #4]
  408a36:	61bb      	str	r3, [r7, #24]
	 
	 if(twi_master_read((Twi*)BOARD_BASE_TWI1, &packet_read) == TWI_SUCCESS){
  408a38:	f107 030c 	add.w	r3, r7, #12
  408a3c:	4619      	mov	r1, r3
  408a3e:	4806      	ldr	r0, [pc, #24]	; (408a58 <i2c_master_read_register1+0x48>)
  408a40:	4b06      	ldr	r3, [pc, #24]	; (408a5c <i2c_master_read_register1+0x4c>)
  408a42:	4798      	blx	r3
  408a44:	4603      	mov	r3, r0
  408a46:	2b00      	cmp	r3, #0
  408a48:	d101      	bne.n	408a4e <i2c_master_read_register1+0x3e>
		 return TWI_SUCCESS;
  408a4a:	2300      	movs	r3, #0
  408a4c:	e000      	b.n	408a50 <i2c_master_read_register1+0x40>
	 }
	 return TWI_BUSY;
  408a4e:	2308      	movs	r3, #8
 }
  408a50:	4618      	mov	r0, r3
  408a52:	3720      	adds	r7, #32
  408a54:	46bd      	mov	sp, r7
  408a56:	bd80      	pop	{r7, pc}
  408a58:	40020600 	.word	0x40020600
  408a5c:	00404d31 	.word	0x00404d31

00408a60 <i2c_master_read_register1_raw>:
 unsigned long i2c_master_read_register1_raw(unsigned char Address, unsigned short len, unsigned char *data)
 {
  408a60:	b580      	push	{r7, lr}
  408a62:	b088      	sub	sp, #32
  408a64:	af00      	add	r7, sp, #0
  408a66:	4603      	mov	r3, r0
  408a68:	603a      	str	r2, [r7, #0]
  408a6a:	71fb      	strb	r3, [r7, #7]
  408a6c:	460b      	mov	r3, r1
  408a6e:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_read;
	 
	 packet_read.chip = Address; //address of I2C device to be accessed
  408a70:	79fb      	ldrb	r3, [r7, #7]
  408a72:	773b      	strb	r3, [r7, #28]
	 //packet_read.addr[0] = RegisterAddr;
	 packet_read.addr_length = 0; //no internal address
  408a74:	2300      	movs	r3, #0
  408a76:	613b      	str	r3, [r7, #16]
	 packet_read.buffer = data;
  408a78:	683b      	ldr	r3, [r7, #0]
  408a7a:	617b      	str	r3, [r7, #20]
	 packet_read.length = len;
  408a7c:	88bb      	ldrh	r3, [r7, #4]
  408a7e:	61bb      	str	r3, [r7, #24]
	 
	 if(twi_master_read((Twi*)BOARD_BASE_TWI1, &packet_read) == TWI_SUCCESS){
  408a80:	f107 030c 	add.w	r3, r7, #12
  408a84:	4619      	mov	r1, r3
  408a86:	4806      	ldr	r0, [pc, #24]	; (408aa0 <i2c_master_read_register1_raw+0x40>)
  408a88:	4b06      	ldr	r3, [pc, #24]	; (408aa4 <i2c_master_read_register1_raw+0x44>)
  408a8a:	4798      	blx	r3
  408a8c:	4603      	mov	r3, r0
  408a8e:	2b00      	cmp	r3, #0
  408a90:	d101      	bne.n	408a96 <i2c_master_read_register1_raw+0x36>
		 return TWI_SUCCESS;
  408a92:	2300      	movs	r3, #0
  408a94:	e000      	b.n	408a98 <i2c_master_read_register1_raw+0x38>
	 }
	 return TWI_BUSY;
  408a96:	2308      	movs	r3, #8
 }
  408a98:	4618      	mov	r0, r3
  408a9a:	3720      	adds	r7, #32
  408a9c:	46bd      	mov	sp, r7
  408a9e:	bd80      	pop	{r7, pc}
  408aa0:	40020600 	.word	0x40020600
  408aa4:	00404d31 	.word	0x00404d31

00408aa8 <i2c_master_read_register3>:
  
unsigned long i2c_master_read_register3(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue)
{
  408aa8:	b580      	push	{r7, lr}
  408aaa:	b088      	sub	sp, #32
  408aac:	af00      	add	r7, sp, #0
  408aae:	603b      	str	r3, [r7, #0]
  408ab0:	4603      	mov	r3, r0
  408ab2:	71fb      	strb	r3, [r7, #7]
  408ab4:	460b      	mov	r3, r1
  408ab6:	71bb      	strb	r3, [r7, #6]
  408ab8:	4613      	mov	r3, r2
  408aba:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_read;
	
	packet_read.chip = Address;
  408abc:	79fb      	ldrb	r3, [r7, #7]
  408abe:	773b      	strb	r3, [r7, #28]
	packet_read.addr[0] = RegisterAddr;
  408ac0:	79bb      	ldrb	r3, [r7, #6]
  408ac2:	733b      	strb	r3, [r7, #12]
	packet_read.addr_length = 1;
  408ac4:	2301      	movs	r3, #1
  408ac6:	613b      	str	r3, [r7, #16]
	packet_read.buffer = RegisterValue;
  408ac8:	683b      	ldr	r3, [r7, #0]
  408aca:	617b      	str	r3, [r7, #20]
	packet_read.length = RegisterLen;
  408acc:	88bb      	ldrh	r3, [r7, #4]
  408ace:	61bb      	str	r3, [r7, #24]
	
	if(twi_master_read((Twi*)BOARD_BASE_TWI3, &packet_read) == TWI_SUCCESS){
  408ad0:	f107 030c 	add.w	r3, r7, #12
  408ad4:	4619      	mov	r1, r3
  408ad6:	4806      	ldr	r0, [pc, #24]	; (408af0 <i2c_master_read_register3+0x48>)
  408ad8:	4b06      	ldr	r3, [pc, #24]	; (408af4 <i2c_master_read_register3+0x4c>)
  408ada:	4798      	blx	r3
  408adc:	4603      	mov	r3, r0
  408ade:	2b00      	cmp	r3, #0
  408ae0:	d101      	bne.n	408ae6 <i2c_master_read_register3+0x3e>
		return TWI_SUCCESS;
  408ae2:	2300      	movs	r3, #0
  408ae4:	e000      	b.n	408ae8 <i2c_master_read_register3+0x40>
	}
	return TWI_BUSY;
  408ae6:	2308      	movs	r3, #8
} 
  408ae8:	4618      	mov	r0, r3
  408aea:	3720      	adds	r7, #32
  408aec:	46bd      	mov	sp, r7
  408aee:	bd80      	pop	{r7, pc}
  408af0:	40018600 	.word	0x40018600
  408af4:	00404d31 	.word	0x00404d31

00408af8 <i2c_master_read_register3_raw>:
unsigned long i2c_master_read_register3_raw(unsigned char Address, unsigned short len, unsigned char *data)
{
  408af8:	b580      	push	{r7, lr}
  408afa:	b088      	sub	sp, #32
  408afc:	af00      	add	r7, sp, #0
  408afe:	4603      	mov	r3, r0
  408b00:	603a      	str	r2, [r7, #0]
  408b02:	71fb      	strb	r3, [r7, #7]
  408b04:	460b      	mov	r3, r1
  408b06:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_read;
	 
	packet_read.chip = Address; //address of I2C device to be accessed
  408b08:	79fb      	ldrb	r3, [r7, #7]
  408b0a:	773b      	strb	r3, [r7, #28]
	//packet_read.addr[0] = RegisterAddr;
	packet_read.addr_length = 0; //no internal address
  408b0c:	2300      	movs	r3, #0
  408b0e:	613b      	str	r3, [r7, #16]
	packet_read.buffer = data;
  408b10:	683b      	ldr	r3, [r7, #0]
  408b12:	617b      	str	r3, [r7, #20]
	packet_read.length = len;
  408b14:	88bb      	ldrh	r3, [r7, #4]
  408b16:	61bb      	str	r3, [r7, #24]
	 
	if(twi_master_read((Twi*)BOARD_BASE_TWI3, &packet_read) == TWI_SUCCESS){
  408b18:	f107 030c 	add.w	r3, r7, #12
  408b1c:	4619      	mov	r1, r3
  408b1e:	4806      	ldr	r0, [pc, #24]	; (408b38 <i2c_master_read_register3_raw+0x40>)
  408b20:	4b06      	ldr	r3, [pc, #24]	; (408b3c <i2c_master_read_register3_raw+0x44>)
  408b22:	4798      	blx	r3
  408b24:	4603      	mov	r3, r0
  408b26:	2b00      	cmp	r3, #0
  408b28:	d101      	bne.n	408b2e <i2c_master_read_register3_raw+0x36>
		return TWI_SUCCESS;
  408b2a:	2300      	movs	r3, #0
  408b2c:	e000      	b.n	408b30 <i2c_master_read_register3_raw+0x38>
	}
	return TWI_BUSY;
  408b2e:	2308      	movs	r3, #8
}
  408b30:	4618      	mov	r0, r3
  408b32:	3720      	adds	r7, #32
  408b34:	46bd      	mov	sp, r7
  408b36:	bd80      	pop	{r7, pc}
  408b38:	40018600 	.word	0x40018600
  408b3c:	00404d31 	.word	0x00404d31

00408b40 <i2c_master_write_register1>:

 unsigned long i2c_master_write_register1(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue)
 {
  408b40:	b580      	push	{r7, lr}
  408b42:	b088      	sub	sp, #32
  408b44:	af00      	add	r7, sp, #0
  408b46:	603b      	str	r3, [r7, #0]
  408b48:	4603      	mov	r3, r0
  408b4a:	71fb      	strb	r3, [r7, #7]
  408b4c:	460b      	mov	r3, r1
  408b4e:	71bb      	strb	r3, [r7, #6]
  408b50:	4613      	mov	r3, r2
  408b52:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_write;

	 packet_write.chip = Address;
  408b54:	79fb      	ldrb	r3, [r7, #7]
  408b56:	773b      	strb	r3, [r7, #28]
	 packet_write.addr[0] = RegisterAddr;
  408b58:	79bb      	ldrb	r3, [r7, #6]
  408b5a:	733b      	strb	r3, [r7, #12]
	 packet_write.addr_length = 1;
  408b5c:	2301      	movs	r3, #1
  408b5e:	613b      	str	r3, [r7, #16]
	 packet_write.buffer = RegisterValue;
  408b60:	683b      	ldr	r3, [r7, #0]
  408b62:	617b      	str	r3, [r7, #20]
	 packet_write.length = RegisterLen;
  408b64:	88bb      	ldrh	r3, [r7, #4]
  408b66:	61bb      	str	r3, [r7, #24]

	 return twi_master_write((Twi*)BOARD_BASE_TWI1, &packet_write);
  408b68:	f107 030c 	add.w	r3, r7, #12
  408b6c:	4619      	mov	r1, r3
  408b6e:	4804      	ldr	r0, [pc, #16]	; (408b80 <i2c_master_write_register1+0x40>)
  408b70:	4b04      	ldr	r3, [pc, #16]	; (408b84 <i2c_master_write_register1+0x44>)
  408b72:	4798      	blx	r3
  408b74:	4603      	mov	r3, r0
 }
  408b76:	4618      	mov	r0, r3
  408b78:	3720      	adds	r7, #32
  408b7a:	46bd      	mov	sp, r7
  408b7c:	bd80      	pop	{r7, pc}
  408b7e:	bf00      	nop
  408b80:	40020600 	.word	0x40020600
  408b84:	00404e3d 	.word	0x00404e3d

00408b88 <i2c_master_write_register1_raw>:
 unsigned long i2c_master_write_register1_raw(unsigned char Address, unsigned short len, unsigned char *data)
 {
  408b88:	b580      	push	{r7, lr}
  408b8a:	b088      	sub	sp, #32
  408b8c:	af00      	add	r7, sp, #0
  408b8e:	4603      	mov	r3, r0
  408b90:	603a      	str	r2, [r7, #0]
  408b92:	71fb      	strb	r3, [r7, #7]
  408b94:	460b      	mov	r3, r1
  408b96:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_write;

	 packet_write.chip = Address; //address of I2C device to be accessed
  408b98:	79fb      	ldrb	r3, [r7, #7]
  408b9a:	773b      	strb	r3, [r7, #28]
	 //packet_write.addr[0] = RegisterAddr;
	 packet_write.addr_length = 0; //no internal address
  408b9c:	2300      	movs	r3, #0
  408b9e:	613b      	str	r3, [r7, #16]
	 packet_write.buffer = data;
  408ba0:	683b      	ldr	r3, [r7, #0]
  408ba2:	617b      	str	r3, [r7, #20]
	 packet_write.length = len;
  408ba4:	88bb      	ldrh	r3, [r7, #4]
  408ba6:	61bb      	str	r3, [r7, #24]

	 return twi_master_write((Twi*)BOARD_BASE_TWI1, &packet_write);
  408ba8:	f107 030c 	add.w	r3, r7, #12
  408bac:	4619      	mov	r1, r3
  408bae:	4804      	ldr	r0, [pc, #16]	; (408bc0 <i2c_master_write_register1_raw+0x38>)
  408bb0:	4b04      	ldr	r3, [pc, #16]	; (408bc4 <i2c_master_write_register1_raw+0x3c>)
  408bb2:	4798      	blx	r3
  408bb4:	4603      	mov	r3, r0
 }
  408bb6:	4618      	mov	r0, r3
  408bb8:	3720      	adds	r7, #32
  408bba:	46bd      	mov	sp, r7
  408bbc:	bd80      	pop	{r7, pc}
  408bbe:	bf00      	nop
  408bc0:	40020600 	.word	0x40020600
  408bc4:	00404e3d 	.word	0x00404e3d

00408bc8 <i2c_master_write_register3>:
 unsigned long i2c_master_write_register3(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue)
 {
  408bc8:	b580      	push	{r7, lr}
  408bca:	b088      	sub	sp, #32
  408bcc:	af00      	add	r7, sp, #0
  408bce:	603b      	str	r3, [r7, #0]
  408bd0:	4603      	mov	r3, r0
  408bd2:	71fb      	strb	r3, [r7, #7]
  408bd4:	460b      	mov	r3, r1
  408bd6:	71bb      	strb	r3, [r7, #6]
  408bd8:	4613      	mov	r3, r2
  408bda:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_write;

	 packet_write.chip = Address;
  408bdc:	79fb      	ldrb	r3, [r7, #7]
  408bde:	773b      	strb	r3, [r7, #28]
	 packet_write.addr[0] = RegisterAddr;
  408be0:	79bb      	ldrb	r3, [r7, #6]
  408be2:	733b      	strb	r3, [r7, #12]
	 packet_write.addr_length = 1;
  408be4:	2301      	movs	r3, #1
  408be6:	613b      	str	r3, [r7, #16]
	 packet_write.buffer = RegisterValue;
  408be8:	683b      	ldr	r3, [r7, #0]
  408bea:	617b      	str	r3, [r7, #20]
	 packet_write.length = RegisterLen;
  408bec:	88bb      	ldrh	r3, [r7, #4]
  408bee:	61bb      	str	r3, [r7, #24]

	 return twi_master_write((Twi*)BOARD_BASE_TWI3, &packet_write);
  408bf0:	f107 030c 	add.w	r3, r7, #12
  408bf4:	4619      	mov	r1, r3
  408bf6:	4804      	ldr	r0, [pc, #16]	; (408c08 <i2c_master_write_register3+0x40>)
  408bf8:	4b04      	ldr	r3, [pc, #16]	; (408c0c <i2c_master_write_register3+0x44>)
  408bfa:	4798      	blx	r3
  408bfc:	4603      	mov	r3, r0
 }
  408bfe:	4618      	mov	r0, r3
  408c00:	3720      	adds	r7, #32
  408c02:	46bd      	mov	sp, r7
  408c04:	bd80      	pop	{r7, pc}
  408c06:	bf00      	nop
  408c08:	40018600 	.word	0x40018600
  408c0c:	00404e3d 	.word	0x00404e3d

00408c10 <i2c_master_write_register3_raw>:
 unsigned long i2c_master_write_register3_raw(unsigned char Address, unsigned short len, unsigned char *data)
 {
  408c10:	b580      	push	{r7, lr}
  408c12:	b088      	sub	sp, #32
  408c14:	af00      	add	r7, sp, #0
  408c16:	4603      	mov	r3, r0
  408c18:	603a      	str	r2, [r7, #0]
  408c1a:	71fb      	strb	r3, [r7, #7]
  408c1c:	460b      	mov	r3, r1
  408c1e:	80bb      	strh	r3, [r7, #4]
	 twi_packet_t packet_write;

	 packet_write.chip = Address; //address of I2C device to be accessed
  408c20:	79fb      	ldrb	r3, [r7, #7]
  408c22:	773b      	strb	r3, [r7, #28]
	 //packet_write.addr[0] = RegisterAddr;
	 packet_write.addr_length = 0; //no internal address
  408c24:	2300      	movs	r3, #0
  408c26:	613b      	str	r3, [r7, #16]
	 packet_write.buffer = data;
  408c28:	683b      	ldr	r3, [r7, #0]
  408c2a:	617b      	str	r3, [r7, #20]
	 packet_write.length = len;
  408c2c:	88bb      	ldrh	r3, [r7, #4]
  408c2e:	61bb      	str	r3, [r7, #24]


	 return twi_master_write((Twi*)BOARD_BASE_TWI3, &packet_write);
  408c30:	f107 030c 	add.w	r3, r7, #12
  408c34:	4619      	mov	r1, r3
  408c36:	4804      	ldr	r0, [pc, #16]	; (408c48 <i2c_master_write_register3_raw+0x38>)
  408c38:	4b04      	ldr	r3, [pc, #16]	; (408c4c <i2c_master_write_register3_raw+0x3c>)
  408c3a:	4798      	blx	r3
  408c3c:	4603      	mov	r3, r0
  408c3e:	4618      	mov	r0, r3
  408c40:	3720      	adds	r7, #32
  408c42:	46bd      	mov	sp, r7
  408c44:	bd80      	pop	{r7, pc}
  408c46:	bf00      	nop
  408c48:	40018600 	.word	0x40018600
  408c4c:	00404e3d 	.word	0x00404e3d

00408c50 <osc_get_rate>:
{
  408c50:	b480      	push	{r7}
  408c52:	b083      	sub	sp, #12
  408c54:	af00      	add	r7, sp, #0
  408c56:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  408c58:	687b      	ldr	r3, [r7, #4]
  408c5a:	2b07      	cmp	r3, #7
  408c5c:	d825      	bhi.n	408caa <osc_get_rate+0x5a>
  408c5e:	a201      	add	r2, pc, #4	; (adr r2, 408c64 <osc_get_rate+0x14>)
  408c60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408c64:	00408c85 	.word	0x00408c85
  408c68:	00408c8b 	.word	0x00408c8b
  408c6c:	00408c91 	.word	0x00408c91
  408c70:	00408c97 	.word	0x00408c97
  408c74:	00408c9b 	.word	0x00408c9b
  408c78:	00408c9f 	.word	0x00408c9f
  408c7c:	00408ca3 	.word	0x00408ca3
  408c80:	00408ca7 	.word	0x00408ca7
		return OSC_SLCK_32K_RC_HZ;
  408c84:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  408c88:	e010      	b.n	408cac <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  408c8a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408c8e:	e00d      	b.n	408cac <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  408c90:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408c94:	e00a      	b.n	408cac <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  408c96:	4b08      	ldr	r3, [pc, #32]	; (408cb8 <osc_get_rate+0x68>)
  408c98:	e008      	b.n	408cac <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  408c9a:	4b08      	ldr	r3, [pc, #32]	; (408cbc <osc_get_rate+0x6c>)
  408c9c:	e006      	b.n	408cac <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  408c9e:	4b08      	ldr	r3, [pc, #32]	; (408cc0 <osc_get_rate+0x70>)
  408ca0:	e004      	b.n	408cac <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  408ca2:	2300      	movs	r3, #0
  408ca4:	e002      	b.n	408cac <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  408ca6:	2300      	movs	r3, #0
  408ca8:	e000      	b.n	408cac <osc_get_rate+0x5c>
	return 0;
  408caa:	2300      	movs	r3, #0
}
  408cac:	4618      	mov	r0, r3
  408cae:	370c      	adds	r7, #12
  408cb0:	46bd      	mov	sp, r7
  408cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
  408cb6:	4770      	bx	lr
  408cb8:	007a1200 	.word	0x007a1200
  408cbc:	00f42400 	.word	0x00f42400
  408cc0:	016e3600 	.word	0x016e3600

00408cc4 <sysclk_get_main_hz>:
{
  408cc4:	b580      	push	{r7, lr}
  408cc6:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  408cc8:	2001      	movs	r0, #1
  408cca:	4b04      	ldr	r3, [pc, #16]	; (408cdc <sysclk_get_main_hz+0x18>)
  408ccc:	4798      	blx	r3
  408cce:	4602      	mov	r2, r0
  408cd0:	f640 634e 	movw	r3, #3662	; 0xe4e
  408cd4:	fb03 f302 	mul.w	r3, r3, r2
}
  408cd8:	4618      	mov	r0, r3
  408cda:	bd80      	pop	{r7, pc}
  408cdc:	00408c51 	.word	0x00408c51

00408ce0 <sysclk_get_peripheral_hz>:
{
  408ce0:	b580      	push	{r7, lr}
  408ce2:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  408ce4:	4b02      	ldr	r3, [pc, #8]	; (408cf0 <sysclk_get_peripheral_hz+0x10>)
  408ce6:	4798      	blx	r3
  408ce8:	4603      	mov	r3, r0
}
  408cea:	4618      	mov	r0, r3
  408cec:	bd80      	pop	{r7, pc}
  408cee:	bf00      	nop
  408cf0:	00408cc5 	.word	0x00408cc5

00408cf4 <sysclk_enable_peripheral_clock>:
{
  408cf4:	b580      	push	{r7, lr}
  408cf6:	b082      	sub	sp, #8
  408cf8:	af00      	add	r7, sp, #0
  408cfa:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  408cfc:	6878      	ldr	r0, [r7, #4]
  408cfe:	4b03      	ldr	r3, [pc, #12]	; (408d0c <sysclk_enable_peripheral_clock+0x18>)
  408d00:	4798      	blx	r3
}
  408d02:	bf00      	nop
  408d04:	3708      	adds	r7, #8
  408d06:	46bd      	mov	sp, r7
  408d08:	bd80      	pop	{r7, pc}
  408d0a:	bf00      	nop
  408d0c:	00404459 	.word	0x00404459

00408d10 <ioport_disable_pin>:
{
  408d10:	b480      	push	{r7}
  408d12:	b089      	sub	sp, #36	; 0x24
  408d14:	af00      	add	r7, sp, #0
  408d16:	6078      	str	r0, [r7, #4]
  408d18:	687b      	ldr	r3, [r7, #4]
  408d1a:	61fb      	str	r3, [r7, #28]
  408d1c:	69fb      	ldr	r3, [r7, #28]
  408d1e:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  408d20:	69bb      	ldr	r3, [r7, #24]
  408d22:	095a      	lsrs	r2, r3, #5
  408d24:	69fb      	ldr	r3, [r7, #28]
  408d26:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  408d28:	697b      	ldr	r3, [r7, #20]
  408d2a:	f003 031f 	and.w	r3, r3, #31
  408d2e:	2101      	movs	r1, #1
  408d30:	fa01 f303 	lsl.w	r3, r1, r3
  408d34:	613a      	str	r2, [r7, #16]
  408d36:	60fb      	str	r3, [r7, #12]
  408d38:	693b      	ldr	r3, [r7, #16]
  408d3a:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  408d3c:	68bb      	ldr	r3, [r7, #8]
  408d3e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  408d42:	f203 7307 	addw	r3, r3, #1799	; 0x707
  408d46:	025b      	lsls	r3, r3, #9
  408d48:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  408d4a:	68fb      	ldr	r3, [r7, #12]
  408d4c:	6053      	str	r3, [r2, #4]
}
  408d4e:	bf00      	nop
  408d50:	3724      	adds	r7, #36	; 0x24
  408d52:	46bd      	mov	sp, r7
  408d54:	f85d 7b04 	ldr.w	r7, [sp], #4
  408d58:	4770      	bx	lr

00408d5a <ioport_disable_port>:
{
  408d5a:	b480      	push	{r7}
  408d5c:	b087      	sub	sp, #28
  408d5e:	af00      	add	r7, sp, #0
  408d60:	6078      	str	r0, [r7, #4]
  408d62:	6039      	str	r1, [r7, #0]
  408d64:	687b      	ldr	r3, [r7, #4]
  408d66:	617b      	str	r3, [r7, #20]
  408d68:	683b      	ldr	r3, [r7, #0]
  408d6a:	613b      	str	r3, [r7, #16]
  408d6c:	697b      	ldr	r3, [r7, #20]
  408d6e:	60fb      	str	r3, [r7, #12]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  408d70:	68fb      	ldr	r3, [r7, #12]
  408d72:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  408d76:	f203 7307 	addw	r3, r3, #1799	; 0x707
  408d7a:	025b      	lsls	r3, r3, #9
  408d7c:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  408d7e:	693b      	ldr	r3, [r7, #16]
  408d80:	6053      	str	r3, [r2, #4]
}
  408d82:	bf00      	nop
  408d84:	371c      	adds	r7, #28
  408d86:	46bd      	mov	sp, r7
  408d88:	f85d 7b04 	ldr.w	r7, [sp], #4
  408d8c:	4770      	bx	lr

00408d8e <ioport_set_port_mode>:
{
  408d8e:	b480      	push	{r7}
  408d90:	b08b      	sub	sp, #44	; 0x2c
  408d92:	af00      	add	r7, sp, #0
  408d94:	60f8      	str	r0, [r7, #12]
  408d96:	60b9      	str	r1, [r7, #8]
  408d98:	607a      	str	r2, [r7, #4]
  408d9a:	68fb      	ldr	r3, [r7, #12]
  408d9c:	627b      	str	r3, [r7, #36]	; 0x24
  408d9e:	68bb      	ldr	r3, [r7, #8]
  408da0:	623b      	str	r3, [r7, #32]
  408da2:	687b      	ldr	r3, [r7, #4]
  408da4:	61fb      	str	r3, [r7, #28]
  408da6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408da8:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  408daa:	69bb      	ldr	r3, [r7, #24]
  408dac:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  408db0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  408db4:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  408db6:	617b      	str	r3, [r7, #20]
	if (mode & IOPORT_MODE_PULLUP) {
  408db8:	69fb      	ldr	r3, [r7, #28]
  408dba:	f003 0308 	and.w	r3, r3, #8
  408dbe:	2b00      	cmp	r3, #0
  408dc0:	d003      	beq.n	408dca <ioport_set_port_mode+0x3c>
		base->PIO_PUER = mask;
  408dc2:	697b      	ldr	r3, [r7, #20]
  408dc4:	6a3a      	ldr	r2, [r7, #32]
  408dc6:	665a      	str	r2, [r3, #100]	; 0x64
  408dc8:	e002      	b.n	408dd0 <ioport_set_port_mode+0x42>
		base->PIO_PUDR = mask;
  408dca:	697b      	ldr	r3, [r7, #20]
  408dcc:	6a3a      	ldr	r2, [r7, #32]
  408dce:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  408dd0:	69fb      	ldr	r3, [r7, #28]
  408dd2:	f003 0310 	and.w	r3, r3, #16
  408dd6:	2b00      	cmp	r3, #0
  408dd8:	d004      	beq.n	408de4 <ioport_set_port_mode+0x56>
		base->PIO_PPDER = mask;
  408dda:	697b      	ldr	r3, [r7, #20]
  408ddc:	6a3a      	ldr	r2, [r7, #32]
  408dde:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  408de2:	e003      	b.n	408dec <ioport_set_port_mode+0x5e>
		base->PIO_PPDDR = mask;
  408de4:	697b      	ldr	r3, [r7, #20]
  408de6:	6a3a      	ldr	r2, [r7, #32]
  408de8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  408dec:	69fb      	ldr	r3, [r7, #28]
  408dee:	f003 0320 	and.w	r3, r3, #32
  408df2:	2b00      	cmp	r3, #0
  408df4:	d003      	beq.n	408dfe <ioport_set_port_mode+0x70>
		base->PIO_MDER = mask;
  408df6:	697b      	ldr	r3, [r7, #20]
  408df8:	6a3a      	ldr	r2, [r7, #32]
  408dfa:	651a      	str	r2, [r3, #80]	; 0x50
  408dfc:	e002      	b.n	408e04 <ioport_set_port_mode+0x76>
		base->PIO_MDDR = mask;
  408dfe:	697b      	ldr	r3, [r7, #20]
  408e00:	6a3a      	ldr	r2, [r7, #32]
  408e02:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  408e04:	69fb      	ldr	r3, [r7, #28]
  408e06:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  408e0a:	2b00      	cmp	r3, #0
  408e0c:	d003      	beq.n	408e16 <ioport_set_port_mode+0x88>
		base->PIO_IFER = mask;
  408e0e:	697b      	ldr	r3, [r7, #20]
  408e10:	6a3a      	ldr	r2, [r7, #32]
  408e12:	621a      	str	r2, [r3, #32]
  408e14:	e002      	b.n	408e1c <ioport_set_port_mode+0x8e>
		base->PIO_IFDR = mask;
  408e16:	697b      	ldr	r3, [r7, #20]
  408e18:	6a3a      	ldr	r2, [r7, #32]
  408e1a:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  408e1c:	69fb      	ldr	r3, [r7, #28]
  408e1e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  408e22:	2b00      	cmp	r3, #0
  408e24:	d004      	beq.n	408e30 <ioport_set_port_mode+0xa2>
		base->PIO_IFSCER = mask;
  408e26:	697b      	ldr	r3, [r7, #20]
  408e28:	6a3a      	ldr	r2, [r7, #32]
  408e2a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  408e2e:	e003      	b.n	408e38 <ioport_set_port_mode+0xaa>
		base->PIO_IFSCDR = mask;
  408e30:	697b      	ldr	r3, [r7, #20]
  408e32:	6a3a      	ldr	r2, [r7, #32]
  408e34:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  408e38:	69fb      	ldr	r3, [r7, #28]
  408e3a:	f003 0301 	and.w	r3, r3, #1
  408e3e:	2b00      	cmp	r3, #0
  408e40:	d006      	beq.n	408e50 <ioport_set_port_mode+0xc2>
		base->PIO_ABCDSR[0] |= mask;
  408e42:	697b      	ldr	r3, [r7, #20]
  408e44:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408e46:	6a3b      	ldr	r3, [r7, #32]
  408e48:	431a      	orrs	r2, r3
  408e4a:	697b      	ldr	r3, [r7, #20]
  408e4c:	671a      	str	r2, [r3, #112]	; 0x70
  408e4e:	e006      	b.n	408e5e <ioport_set_port_mode+0xd0>
		base->PIO_ABCDSR[0] &= ~mask;
  408e50:	697b      	ldr	r3, [r7, #20]
  408e52:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408e54:	6a3b      	ldr	r3, [r7, #32]
  408e56:	43db      	mvns	r3, r3
  408e58:	401a      	ands	r2, r3
  408e5a:	697b      	ldr	r3, [r7, #20]
  408e5c:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  408e5e:	69fb      	ldr	r3, [r7, #28]
  408e60:	f003 0302 	and.w	r3, r3, #2
  408e64:	2b00      	cmp	r3, #0
  408e66:	d006      	beq.n	408e76 <ioport_set_port_mode+0xe8>
		base->PIO_ABCDSR[1] |= mask;
  408e68:	697b      	ldr	r3, [r7, #20]
  408e6a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  408e6c:	6a3b      	ldr	r3, [r7, #32]
  408e6e:	431a      	orrs	r2, r3
  408e70:	697b      	ldr	r3, [r7, #20]
  408e72:	675a      	str	r2, [r3, #116]	; 0x74
}
  408e74:	e006      	b.n	408e84 <ioport_set_port_mode+0xf6>
		base->PIO_ABCDSR[1] &= ~mask;
  408e76:	697b      	ldr	r3, [r7, #20]
  408e78:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  408e7a:	6a3b      	ldr	r3, [r7, #32]
  408e7c:	43db      	mvns	r3, r3
  408e7e:	401a      	ands	r2, r3
  408e80:	697b      	ldr	r3, [r7, #20]
  408e82:	675a      	str	r2, [r3, #116]	; 0x74
  408e84:	bf00      	nop
  408e86:	372c      	adds	r7, #44	; 0x2c
  408e88:	46bd      	mov	sp, r7
  408e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
  408e8e:	4770      	bx	lr

00408e90 <ioport_set_pin_mode>:
{
  408e90:	b480      	push	{r7}
  408e92:	b08d      	sub	sp, #52	; 0x34
  408e94:	af00      	add	r7, sp, #0
  408e96:	6078      	str	r0, [r7, #4]
  408e98:	6039      	str	r1, [r7, #0]
  408e9a:	687b      	ldr	r3, [r7, #4]
  408e9c:	62fb      	str	r3, [r7, #44]	; 0x2c
  408e9e:	683b      	ldr	r3, [r7, #0]
  408ea0:	62bb      	str	r3, [r7, #40]	; 0x28
  408ea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408ea4:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  408ea6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  408ea8:	095a      	lsrs	r2, r3, #5
  408eaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  408eac:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  408eae:	6a3b      	ldr	r3, [r7, #32]
  408eb0:	f003 031f 	and.w	r3, r3, #31
  408eb4:	2101      	movs	r1, #1
  408eb6:	fa01 f303 	lsl.w	r3, r1, r3
  408eba:	61fa      	str	r2, [r7, #28]
  408ebc:	61bb      	str	r3, [r7, #24]
  408ebe:	6abb      	ldr	r3, [r7, #40]	; 0x28
  408ec0:	617b      	str	r3, [r7, #20]
  408ec2:	69fb      	ldr	r3, [r7, #28]
  408ec4:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  408ec6:	693b      	ldr	r3, [r7, #16]
  408ec8:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  408ecc:	f203 7307 	addw	r3, r3, #1799	; 0x707
  408ed0:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  408ed2:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  408ed4:	697b      	ldr	r3, [r7, #20]
  408ed6:	f003 0308 	and.w	r3, r3, #8
  408eda:	2b00      	cmp	r3, #0
  408edc:	d003      	beq.n	408ee6 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  408ede:	68fb      	ldr	r3, [r7, #12]
  408ee0:	69ba      	ldr	r2, [r7, #24]
  408ee2:	665a      	str	r2, [r3, #100]	; 0x64
  408ee4:	e002      	b.n	408eec <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  408ee6:	68fb      	ldr	r3, [r7, #12]
  408ee8:	69ba      	ldr	r2, [r7, #24]
  408eea:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  408eec:	697b      	ldr	r3, [r7, #20]
  408eee:	f003 0310 	and.w	r3, r3, #16
  408ef2:	2b00      	cmp	r3, #0
  408ef4:	d004      	beq.n	408f00 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  408ef6:	68fb      	ldr	r3, [r7, #12]
  408ef8:	69ba      	ldr	r2, [r7, #24]
  408efa:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  408efe:	e003      	b.n	408f08 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  408f00:	68fb      	ldr	r3, [r7, #12]
  408f02:	69ba      	ldr	r2, [r7, #24]
  408f04:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  408f08:	697b      	ldr	r3, [r7, #20]
  408f0a:	f003 0320 	and.w	r3, r3, #32
  408f0e:	2b00      	cmp	r3, #0
  408f10:	d003      	beq.n	408f1a <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  408f12:	68fb      	ldr	r3, [r7, #12]
  408f14:	69ba      	ldr	r2, [r7, #24]
  408f16:	651a      	str	r2, [r3, #80]	; 0x50
  408f18:	e002      	b.n	408f20 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  408f1a:	68fb      	ldr	r3, [r7, #12]
  408f1c:	69ba      	ldr	r2, [r7, #24]
  408f1e:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  408f20:	697b      	ldr	r3, [r7, #20]
  408f22:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  408f26:	2b00      	cmp	r3, #0
  408f28:	d003      	beq.n	408f32 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  408f2a:	68fb      	ldr	r3, [r7, #12]
  408f2c:	69ba      	ldr	r2, [r7, #24]
  408f2e:	621a      	str	r2, [r3, #32]
  408f30:	e002      	b.n	408f38 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  408f32:	68fb      	ldr	r3, [r7, #12]
  408f34:	69ba      	ldr	r2, [r7, #24]
  408f36:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  408f38:	697b      	ldr	r3, [r7, #20]
  408f3a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  408f3e:	2b00      	cmp	r3, #0
  408f40:	d004      	beq.n	408f4c <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  408f42:	68fb      	ldr	r3, [r7, #12]
  408f44:	69ba      	ldr	r2, [r7, #24]
  408f46:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  408f4a:	e003      	b.n	408f54 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  408f4c:	68fb      	ldr	r3, [r7, #12]
  408f4e:	69ba      	ldr	r2, [r7, #24]
  408f50:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  408f54:	697b      	ldr	r3, [r7, #20]
  408f56:	f003 0301 	and.w	r3, r3, #1
  408f5a:	2b00      	cmp	r3, #0
  408f5c:	d006      	beq.n	408f6c <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  408f5e:	68fb      	ldr	r3, [r7, #12]
  408f60:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408f62:	69bb      	ldr	r3, [r7, #24]
  408f64:	431a      	orrs	r2, r3
  408f66:	68fb      	ldr	r3, [r7, #12]
  408f68:	671a      	str	r2, [r3, #112]	; 0x70
  408f6a:	e006      	b.n	408f7a <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  408f6c:	68fb      	ldr	r3, [r7, #12]
  408f6e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408f70:	69bb      	ldr	r3, [r7, #24]
  408f72:	43db      	mvns	r3, r3
  408f74:	401a      	ands	r2, r3
  408f76:	68fb      	ldr	r3, [r7, #12]
  408f78:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  408f7a:	697b      	ldr	r3, [r7, #20]
  408f7c:	f003 0302 	and.w	r3, r3, #2
  408f80:	2b00      	cmp	r3, #0
  408f82:	d006      	beq.n	408f92 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  408f84:	68fb      	ldr	r3, [r7, #12]
  408f86:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  408f88:	69bb      	ldr	r3, [r7, #24]
  408f8a:	431a      	orrs	r2, r3
  408f8c:	68fb      	ldr	r3, [r7, #12]
  408f8e:	675a      	str	r2, [r3, #116]	; 0x74
}
  408f90:	e006      	b.n	408fa0 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  408f92:	68fb      	ldr	r3, [r7, #12]
  408f94:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  408f96:	69bb      	ldr	r3, [r7, #24]
  408f98:	43db      	mvns	r3, r3
  408f9a:	401a      	ands	r2, r3
  408f9c:	68fb      	ldr	r3, [r7, #12]
  408f9e:	675a      	str	r2, [r3, #116]	; 0x74
  408fa0:	bf00      	nop
  408fa2:	3734      	adds	r7, #52	; 0x34
  408fa4:	46bd      	mov	sp, r7
  408fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
  408faa:	4770      	bx	lr

00408fac <usart_serial_init>:
 * \param opt      Options needed to set up RS232 communication (see
 * \ref usart_options_t).
 */
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
  408fac:	b580      	push	{r7, lr}
  408fae:	b088      	sub	sp, #32
  408fb0:	af00      	add	r7, sp, #0
  408fb2:	6078      	str	r0, [r7, #4]
  408fb4:	6039      	str	r1, [r7, #0]
	uart_settings.ul_baudrate = opt->baudrate;
	uart_settings.ul_mode = opt->paritytype;
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
  408fb6:	683b      	ldr	r3, [r7, #0]
  408fb8:	681b      	ldr	r3, [r3, #0]
  408fba:	60bb      	str	r3, [r7, #8]
	usart_settings.char_length = opt->charlength;
  408fbc:	683b      	ldr	r3, [r7, #0]
  408fbe:	685b      	ldr	r3, [r3, #4]
  408fc0:	60fb      	str	r3, [r7, #12]
	usart_settings.parity_type = opt->paritytype;
  408fc2:	683b      	ldr	r3, [r7, #0]
  408fc4:	689b      	ldr	r3, [r3, #8]
  408fc6:	613b      	str	r3, [r7, #16]
	usart_settings.stop_bits= opt->stopbits;
  408fc8:	683b      	ldr	r3, [r7, #0]
  408fca:	68db      	ldr	r3, [r3, #12]
  408fcc:	617b      	str	r3, [r7, #20]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  408fce:	2300      	movs	r3, #0
  408fd0:	61bb      	str	r3, [r7, #24]
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  408fd2:	687b      	ldr	r3, [r7, #4]
  408fd4:	4a69      	ldr	r2, [pc, #420]	; (40917c <usart_serial_init+0x1d0>)
  408fd6:	4293      	cmp	r3, r2
  408fd8:	d115      	bne.n	409006 <usart_serial_init+0x5a>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM0);
  408fda:	4869      	ldr	r0, [pc, #420]	; (409180 <usart_serial_init+0x1d4>)
  408fdc:	4b69      	ldr	r3, [pc, #420]	; (409184 <usart_serial_init+0x1d8>)
  408fde:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM0, FLEXCOM_USART);
  408fe0:	2101      	movs	r1, #1
  408fe2:	4867      	ldr	r0, [pc, #412]	; (409180 <usart_serial_init+0x1d4>)
  408fe4:	4b68      	ldr	r3, [pc, #416]	; (409188 <usart_serial_init+0x1dc>)
  408fe6:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART0);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  408fe8:	4b68      	ldr	r3, [pc, #416]	; (40918c <usart_serial_init+0x1e0>)
  408fea:	4798      	blx	r3
  408fec:	4602      	mov	r2, r0
  408fee:	f107 0308 	add.w	r3, r7, #8
  408ff2:	4619      	mov	r1, r3
  408ff4:	6878      	ldr	r0, [r7, #4]
  408ff6:	4b66      	ldr	r3, [pc, #408]	; (409190 <usart_serial_init+0x1e4>)
  408ff8:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  408ffa:	6878      	ldr	r0, [r7, #4]
  408ffc:	4b65      	ldr	r3, [pc, #404]	; (409194 <usart_serial_init+0x1e8>)
  408ffe:	4798      	blx	r3
		usart_enable_rx(p_usart);
  409000:	6878      	ldr	r0, [r7, #4]
  409002:	4b65      	ldr	r3, [pc, #404]	; (409198 <usart_serial_init+0x1ec>)
  409004:	4798      	blx	r3
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  409006:	687b      	ldr	r3, [r7, #4]
  409008:	4a64      	ldr	r2, [pc, #400]	; (40919c <usart_serial_init+0x1f0>)
  40900a:	4293      	cmp	r3, r2
  40900c:	d115      	bne.n	40903a <usart_serial_init+0x8e>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM1);
  40900e:	4864      	ldr	r0, [pc, #400]	; (4091a0 <usart_serial_init+0x1f4>)
  409010:	4b5c      	ldr	r3, [pc, #368]	; (409184 <usart_serial_init+0x1d8>)
  409012:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM1, FLEXCOM_USART);
  409014:	2101      	movs	r1, #1
  409016:	4862      	ldr	r0, [pc, #392]	; (4091a0 <usart_serial_init+0x1f4>)
  409018:	4b5b      	ldr	r3, [pc, #364]	; (409188 <usart_serial_init+0x1dc>)
  40901a:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART1);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  40901c:	4b5b      	ldr	r3, [pc, #364]	; (40918c <usart_serial_init+0x1e0>)
  40901e:	4798      	blx	r3
  409020:	4602      	mov	r2, r0
  409022:	f107 0308 	add.w	r3, r7, #8
  409026:	4619      	mov	r1, r3
  409028:	6878      	ldr	r0, [r7, #4]
  40902a:	4b59      	ldr	r3, [pc, #356]	; (409190 <usart_serial_init+0x1e4>)
  40902c:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  40902e:	6878      	ldr	r0, [r7, #4]
  409030:	4b58      	ldr	r3, [pc, #352]	; (409194 <usart_serial_init+0x1e8>)
  409032:	4798      	blx	r3
		usart_enable_rx(p_usart);
  409034:	6878      	ldr	r0, [r7, #4]
  409036:	4b58      	ldr	r3, [pc, #352]	; (409198 <usart_serial_init+0x1ec>)
  409038:	4798      	blx	r3
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  40903a:	687b      	ldr	r3, [r7, #4]
  40903c:	4a59      	ldr	r2, [pc, #356]	; (4091a4 <usart_serial_init+0x1f8>)
  40903e:	4293      	cmp	r3, r2
  409040:	d115      	bne.n	40906e <usart_serial_init+0xc2>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM2);
  409042:	4859      	ldr	r0, [pc, #356]	; (4091a8 <usart_serial_init+0x1fc>)
  409044:	4b4f      	ldr	r3, [pc, #316]	; (409184 <usart_serial_init+0x1d8>)
  409046:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM2, FLEXCOM_USART);
  409048:	2101      	movs	r1, #1
  40904a:	4857      	ldr	r0, [pc, #348]	; (4091a8 <usart_serial_init+0x1fc>)
  40904c:	4b4e      	ldr	r3, [pc, #312]	; (409188 <usart_serial_init+0x1dc>)
  40904e:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART2);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  409050:	4b4e      	ldr	r3, [pc, #312]	; (40918c <usart_serial_init+0x1e0>)
  409052:	4798      	blx	r3
  409054:	4602      	mov	r2, r0
  409056:	f107 0308 	add.w	r3, r7, #8
  40905a:	4619      	mov	r1, r3
  40905c:	6878      	ldr	r0, [r7, #4]
  40905e:	4b4c      	ldr	r3, [pc, #304]	; (409190 <usart_serial_init+0x1e4>)
  409060:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  409062:	6878      	ldr	r0, [r7, #4]
  409064:	4b4b      	ldr	r3, [pc, #300]	; (409194 <usart_serial_init+0x1e8>)
  409066:	4798      	blx	r3
		usart_enable_rx(p_usart);
  409068:	6878      	ldr	r0, [r7, #4]
  40906a:	4b4b      	ldr	r3, [pc, #300]	; (409198 <usart_serial_init+0x1ec>)
  40906c:	4798      	blx	r3
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  40906e:	687b      	ldr	r3, [r7, #4]
  409070:	4a4e      	ldr	r2, [pc, #312]	; (4091ac <usart_serial_init+0x200>)
  409072:	4293      	cmp	r3, r2
  409074:	d115      	bne.n	4090a2 <usart_serial_init+0xf6>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM3);
  409076:	484e      	ldr	r0, [pc, #312]	; (4091b0 <usart_serial_init+0x204>)
  409078:	4b42      	ldr	r3, [pc, #264]	; (409184 <usart_serial_init+0x1d8>)
  40907a:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM3, FLEXCOM_USART);
  40907c:	2101      	movs	r1, #1
  40907e:	484c      	ldr	r0, [pc, #304]	; (4091b0 <usart_serial_init+0x204>)
  409080:	4b41      	ldr	r3, [pc, #260]	; (409188 <usart_serial_init+0x1dc>)
  409082:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART3);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  409084:	4b41      	ldr	r3, [pc, #260]	; (40918c <usart_serial_init+0x1e0>)
  409086:	4798      	blx	r3
  409088:	4602      	mov	r2, r0
  40908a:	f107 0308 	add.w	r3, r7, #8
  40908e:	4619      	mov	r1, r3
  409090:	6878      	ldr	r0, [r7, #4]
  409092:	4b3f      	ldr	r3, [pc, #252]	; (409190 <usart_serial_init+0x1e4>)
  409094:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  409096:	6878      	ldr	r0, [r7, #4]
  409098:	4b3e      	ldr	r3, [pc, #248]	; (409194 <usart_serial_init+0x1e8>)
  40909a:	4798      	blx	r3
		usart_enable_rx(p_usart);
  40909c:	6878      	ldr	r0, [r7, #4]
  40909e:	4b3e      	ldr	r3, [pc, #248]	; (409198 <usart_serial_init+0x1ec>)
  4090a0:	4798      	blx	r3
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  4090a2:	687b      	ldr	r3, [r7, #4]
  4090a4:	4a43      	ldr	r2, [pc, #268]	; (4091b4 <usart_serial_init+0x208>)
  4090a6:	4293      	cmp	r3, r2
  4090a8:	d115      	bne.n	4090d6 <usart_serial_init+0x12a>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM4);
  4090aa:	4843      	ldr	r0, [pc, #268]	; (4091b8 <usart_serial_init+0x20c>)
  4090ac:	4b35      	ldr	r3, [pc, #212]	; (409184 <usart_serial_init+0x1d8>)
  4090ae:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM4, FLEXCOM_USART);
  4090b0:	2101      	movs	r1, #1
  4090b2:	4841      	ldr	r0, [pc, #260]	; (4091b8 <usart_serial_init+0x20c>)
  4090b4:	4b34      	ldr	r3, [pc, #208]	; (409188 <usart_serial_init+0x1dc>)
  4090b6:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART4);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  4090b8:	4b34      	ldr	r3, [pc, #208]	; (40918c <usart_serial_init+0x1e0>)
  4090ba:	4798      	blx	r3
  4090bc:	4602      	mov	r2, r0
  4090be:	f107 0308 	add.w	r3, r7, #8
  4090c2:	4619      	mov	r1, r3
  4090c4:	6878      	ldr	r0, [r7, #4]
  4090c6:	4b32      	ldr	r3, [pc, #200]	; (409190 <usart_serial_init+0x1e4>)
  4090c8:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  4090ca:	6878      	ldr	r0, [r7, #4]
  4090cc:	4b31      	ldr	r3, [pc, #196]	; (409194 <usart_serial_init+0x1e8>)
  4090ce:	4798      	blx	r3
		usart_enable_rx(p_usart);
  4090d0:	6878      	ldr	r0, [r7, #4]
  4090d2:	4b31      	ldr	r3, [pc, #196]	; (409198 <usart_serial_init+0x1ec>)
  4090d4:	4798      	blx	r3
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  4090d6:	687b      	ldr	r3, [r7, #4]
  4090d8:	4a38      	ldr	r2, [pc, #224]	; (4091bc <usart_serial_init+0x210>)
  4090da:	4293      	cmp	r3, r2
  4090dc:	d115      	bne.n	40910a <usart_serial_init+0x15e>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM5);
  4090de:	4838      	ldr	r0, [pc, #224]	; (4091c0 <usart_serial_init+0x214>)
  4090e0:	4b28      	ldr	r3, [pc, #160]	; (409184 <usart_serial_init+0x1d8>)
  4090e2:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM5, FLEXCOM_USART);
  4090e4:	2101      	movs	r1, #1
  4090e6:	4836      	ldr	r0, [pc, #216]	; (4091c0 <usart_serial_init+0x214>)
  4090e8:	4b27      	ldr	r3, [pc, #156]	; (409188 <usart_serial_init+0x1dc>)
  4090ea:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART5);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  4090ec:	4b27      	ldr	r3, [pc, #156]	; (40918c <usart_serial_init+0x1e0>)
  4090ee:	4798      	blx	r3
  4090f0:	4602      	mov	r2, r0
  4090f2:	f107 0308 	add.w	r3, r7, #8
  4090f6:	4619      	mov	r1, r3
  4090f8:	6878      	ldr	r0, [r7, #4]
  4090fa:	4b25      	ldr	r3, [pc, #148]	; (409190 <usart_serial_init+0x1e4>)
  4090fc:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  4090fe:	6878      	ldr	r0, [r7, #4]
  409100:	4b24      	ldr	r3, [pc, #144]	; (409194 <usart_serial_init+0x1e8>)
  409102:	4798      	blx	r3
		usart_enable_rx(p_usart);
  409104:	6878      	ldr	r0, [r7, #4]
  409106:	4b24      	ldr	r3, [pc, #144]	; (409198 <usart_serial_init+0x1ec>)
  409108:	4798      	blx	r3
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  40910a:	687b      	ldr	r3, [r7, #4]
  40910c:	4a2d      	ldr	r2, [pc, #180]	; (4091c4 <usart_serial_init+0x218>)
  40910e:	4293      	cmp	r3, r2
  409110:	d115      	bne.n	40913e <usart_serial_init+0x192>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM6);
  409112:	482d      	ldr	r0, [pc, #180]	; (4091c8 <usart_serial_init+0x21c>)
  409114:	4b1b      	ldr	r3, [pc, #108]	; (409184 <usart_serial_init+0x1d8>)
  409116:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM6, FLEXCOM_USART);
  409118:	2101      	movs	r1, #1
  40911a:	482b      	ldr	r0, [pc, #172]	; (4091c8 <usart_serial_init+0x21c>)
  40911c:	4b1a      	ldr	r3, [pc, #104]	; (409188 <usart_serial_init+0x1dc>)
  40911e:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART6);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  409120:	4b1a      	ldr	r3, [pc, #104]	; (40918c <usart_serial_init+0x1e0>)
  409122:	4798      	blx	r3
  409124:	4602      	mov	r2, r0
  409126:	f107 0308 	add.w	r3, r7, #8
  40912a:	4619      	mov	r1, r3
  40912c:	6878      	ldr	r0, [r7, #4]
  40912e:	4b18      	ldr	r3, [pc, #96]	; (409190 <usart_serial_init+0x1e4>)
  409130:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  409132:	6878      	ldr	r0, [r7, #4]
  409134:	4b17      	ldr	r3, [pc, #92]	; (409194 <usart_serial_init+0x1e8>)
  409136:	4798      	blx	r3
		usart_enable_rx(p_usart);
  409138:	6878      	ldr	r0, [r7, #4]
  40913a:	4b17      	ldr	r3, [pc, #92]	; (409198 <usart_serial_init+0x1ec>)
  40913c:	4798      	blx	r3
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  40913e:	687b      	ldr	r3, [r7, #4]
  409140:	4a22      	ldr	r2, [pc, #136]	; (4091cc <usart_serial_init+0x220>)
  409142:	4293      	cmp	r3, r2
  409144:	d115      	bne.n	409172 <usart_serial_init+0x1c6>
#if (!SAM4L)
#if (SAMG55)
		flexcom_enable(FLEXCOM7);
  409146:	4822      	ldr	r0, [pc, #136]	; (4091d0 <usart_serial_init+0x224>)
  409148:	4b0e      	ldr	r3, [pc, #56]	; (409184 <usart_serial_init+0x1d8>)
  40914a:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM7, FLEXCOM_USART);
  40914c:	2101      	movs	r1, #1
  40914e:	4820      	ldr	r0, [pc, #128]	; (4091d0 <usart_serial_init+0x224>)
  409150:	4b0d      	ldr	r3, [pc, #52]	; (409188 <usart_serial_init+0x1dc>)
  409152:	4798      	blx	r3
#else
		sysclk_enable_peripheral_clock(ID_USART7);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  409154:	4b0d      	ldr	r3, [pc, #52]	; (40918c <usart_serial_init+0x1e0>)
  409156:	4798      	blx	r3
  409158:	4602      	mov	r2, r0
  40915a:	f107 0308 	add.w	r3, r7, #8
  40915e:	4619      	mov	r1, r3
  409160:	6878      	ldr	r0, [r7, #4]
  409162:	4b0b      	ldr	r3, [pc, #44]	; (409190 <usart_serial_init+0x1e4>)
  409164:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  409166:	6878      	ldr	r0, [r7, #4]
  409168:	4b0a      	ldr	r3, [pc, #40]	; (409194 <usart_serial_init+0x1e8>)
  40916a:	4798      	blx	r3
		usart_enable_rx(p_usart);
  40916c:	6878      	ldr	r0, [r7, #4]
  40916e:	4b0a      	ldr	r3, [pc, #40]	; (409198 <usart_serial_init+0x1ec>)
  409170:	4798      	blx	r3
	}
# endif

#endif /* ifdef USART */

}
  409172:	bf00      	nop
  409174:	3720      	adds	r7, #32
  409176:	46bd      	mov	sp, r7
  409178:	bd80      	pop	{r7, pc}
  40917a:	bf00      	nop
  40917c:	4000c200 	.word	0x4000c200
  409180:	4000c000 	.word	0x4000c000
  409184:	00403925 	.word	0x00403925
  409188:	00403a8d 	.word	0x00403a8d
  40918c:	00408ce1 	.word	0x00408ce1
  409190:	004050e1 	.word	0x004050e1
  409194:	00405165 	.word	0x00405165
  409198:	00405199 	.word	0x00405199
  40919c:	40020200 	.word	0x40020200
  4091a0:	40020000 	.word	0x40020000
  4091a4:	40024200 	.word	0x40024200
  4091a8:	40024000 	.word	0x40024000
  4091ac:	40018200 	.word	0x40018200
  4091b0:	40018000 	.word	0x40018000
  4091b4:	4001c200 	.word	0x4001c200
  4091b8:	4001c000 	.word	0x4001c000
  4091bc:	40008200 	.word	0x40008200
  4091c0:	40008000 	.word	0x40008000
  4091c4:	40040200 	.word	0x40040200
  4091c8:	40040000 	.word	0x40040000
  4091cc:	40034200 	.word	0x40034200
  4091d0:	40034000 	.word	0x40034000

004091d4 <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  4091d4:	b580      	push	{r7, lr}
  4091d6:	b082      	sub	sp, #8
  4091d8:	af00      	add	r7, sp, #0
  4091da:	6078      	str	r0, [r7, #4]
  4091dc:	460b      	mov	r3, r1
  4091de:	70fb      	strb	r3, [r7, #3]
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  4091e0:	687b      	ldr	r3, [r7, #4]
  4091e2:	4a3e      	ldr	r2, [pc, #248]	; (4092dc <usart_serial_putchar+0x108>)
  4091e4:	4293      	cmp	r3, r2
  4091e6:	d10a      	bne.n	4091fe <usart_serial_putchar+0x2a>
		while (usart_write(p_usart, c)!=0);
  4091e8:	bf00      	nop
  4091ea:	78fb      	ldrb	r3, [r7, #3]
  4091ec:	4619      	mov	r1, r3
  4091ee:	6878      	ldr	r0, [r7, #4]
  4091f0:	4b3b      	ldr	r3, [pc, #236]	; (4092e0 <usart_serial_putchar+0x10c>)
  4091f2:	4798      	blx	r3
  4091f4:	4603      	mov	r3, r0
  4091f6:	2b00      	cmp	r3, #0
  4091f8:	d1f7      	bne.n	4091ea <usart_serial_putchar+0x16>
		return 1;
  4091fa:	2301      	movs	r3, #1
  4091fc:	e069      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  4091fe:	687b      	ldr	r3, [r7, #4]
  409200:	4a38      	ldr	r2, [pc, #224]	; (4092e4 <usart_serial_putchar+0x110>)
  409202:	4293      	cmp	r3, r2
  409204:	d10a      	bne.n	40921c <usart_serial_putchar+0x48>
		while (usart_write(p_usart, c)!=0);
  409206:	bf00      	nop
  409208:	78fb      	ldrb	r3, [r7, #3]
  40920a:	4619      	mov	r1, r3
  40920c:	6878      	ldr	r0, [r7, #4]
  40920e:	4b34      	ldr	r3, [pc, #208]	; (4092e0 <usart_serial_putchar+0x10c>)
  409210:	4798      	blx	r3
  409212:	4603      	mov	r3, r0
  409214:	2b00      	cmp	r3, #0
  409216:	d1f7      	bne.n	409208 <usart_serial_putchar+0x34>
		return 1;
  409218:	2301      	movs	r3, #1
  40921a:	e05a      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  40921c:	687b      	ldr	r3, [r7, #4]
  40921e:	4a32      	ldr	r2, [pc, #200]	; (4092e8 <usart_serial_putchar+0x114>)
  409220:	4293      	cmp	r3, r2
  409222:	d10a      	bne.n	40923a <usart_serial_putchar+0x66>
		while (usart_write(p_usart, c)!=0);
  409224:	bf00      	nop
  409226:	78fb      	ldrb	r3, [r7, #3]
  409228:	4619      	mov	r1, r3
  40922a:	6878      	ldr	r0, [r7, #4]
  40922c:	4b2c      	ldr	r3, [pc, #176]	; (4092e0 <usart_serial_putchar+0x10c>)
  40922e:	4798      	blx	r3
  409230:	4603      	mov	r3, r0
  409232:	2b00      	cmp	r3, #0
  409234:	d1f7      	bne.n	409226 <usart_serial_putchar+0x52>
		return 1;
  409236:	2301      	movs	r3, #1
  409238:	e04b      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  40923a:	687b      	ldr	r3, [r7, #4]
  40923c:	4a2b      	ldr	r2, [pc, #172]	; (4092ec <usart_serial_putchar+0x118>)
  40923e:	4293      	cmp	r3, r2
  409240:	d10a      	bne.n	409258 <usart_serial_putchar+0x84>
		while (usart_write(p_usart, c)!=0);
  409242:	bf00      	nop
  409244:	78fb      	ldrb	r3, [r7, #3]
  409246:	4619      	mov	r1, r3
  409248:	6878      	ldr	r0, [r7, #4]
  40924a:	4b25      	ldr	r3, [pc, #148]	; (4092e0 <usart_serial_putchar+0x10c>)
  40924c:	4798      	blx	r3
  40924e:	4603      	mov	r3, r0
  409250:	2b00      	cmp	r3, #0
  409252:	d1f7      	bne.n	409244 <usart_serial_putchar+0x70>
		return 1;
  409254:	2301      	movs	r3, #1
  409256:	e03c      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  409258:	687b      	ldr	r3, [r7, #4]
  40925a:	4a25      	ldr	r2, [pc, #148]	; (4092f0 <usart_serial_putchar+0x11c>)
  40925c:	4293      	cmp	r3, r2
  40925e:	d10a      	bne.n	409276 <usart_serial_putchar+0xa2>
		while (usart_write(p_usart, c)!=0);
  409260:	bf00      	nop
  409262:	78fb      	ldrb	r3, [r7, #3]
  409264:	4619      	mov	r1, r3
  409266:	6878      	ldr	r0, [r7, #4]
  409268:	4b1d      	ldr	r3, [pc, #116]	; (4092e0 <usart_serial_putchar+0x10c>)
  40926a:	4798      	blx	r3
  40926c:	4603      	mov	r3, r0
  40926e:	2b00      	cmp	r3, #0
  409270:	d1f7      	bne.n	409262 <usart_serial_putchar+0x8e>
		return 1;
  409272:	2301      	movs	r3, #1
  409274:	e02d      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  409276:	687b      	ldr	r3, [r7, #4]
  409278:	4a1e      	ldr	r2, [pc, #120]	; (4092f4 <usart_serial_putchar+0x120>)
  40927a:	4293      	cmp	r3, r2
  40927c:	d10a      	bne.n	409294 <usart_serial_putchar+0xc0>
		while (usart_write(p_usart, c)!=0);
  40927e:	bf00      	nop
  409280:	78fb      	ldrb	r3, [r7, #3]
  409282:	4619      	mov	r1, r3
  409284:	6878      	ldr	r0, [r7, #4]
  409286:	4b16      	ldr	r3, [pc, #88]	; (4092e0 <usart_serial_putchar+0x10c>)
  409288:	4798      	blx	r3
  40928a:	4603      	mov	r3, r0
  40928c:	2b00      	cmp	r3, #0
  40928e:	d1f7      	bne.n	409280 <usart_serial_putchar+0xac>
		return 1;
  409290:	2301      	movs	r3, #1
  409292:	e01e      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  409294:	687b      	ldr	r3, [r7, #4]
  409296:	4a18      	ldr	r2, [pc, #96]	; (4092f8 <usart_serial_putchar+0x124>)
  409298:	4293      	cmp	r3, r2
  40929a:	d10a      	bne.n	4092b2 <usart_serial_putchar+0xde>
		while (usart_write(p_usart, c)!=0);
  40929c:	bf00      	nop
  40929e:	78fb      	ldrb	r3, [r7, #3]
  4092a0:	4619      	mov	r1, r3
  4092a2:	6878      	ldr	r0, [r7, #4]
  4092a4:	4b0e      	ldr	r3, [pc, #56]	; (4092e0 <usart_serial_putchar+0x10c>)
  4092a6:	4798      	blx	r3
  4092a8:	4603      	mov	r3, r0
  4092aa:	2b00      	cmp	r3, #0
  4092ac:	d1f7      	bne.n	40929e <usart_serial_putchar+0xca>
		return 1;
  4092ae:	2301      	movs	r3, #1
  4092b0:	e00f      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  4092b2:	687b      	ldr	r3, [r7, #4]
  4092b4:	4a11      	ldr	r2, [pc, #68]	; (4092fc <usart_serial_putchar+0x128>)
  4092b6:	4293      	cmp	r3, r2
  4092b8:	d10a      	bne.n	4092d0 <usart_serial_putchar+0xfc>
		while (usart_write(p_usart, c)!=0);
  4092ba:	bf00      	nop
  4092bc:	78fb      	ldrb	r3, [r7, #3]
  4092be:	4619      	mov	r1, r3
  4092c0:	6878      	ldr	r0, [r7, #4]
  4092c2:	4b07      	ldr	r3, [pc, #28]	; (4092e0 <usart_serial_putchar+0x10c>)
  4092c4:	4798      	blx	r3
  4092c6:	4603      	mov	r3, r0
  4092c8:	2b00      	cmp	r3, #0
  4092ca:	d1f7      	bne.n	4092bc <usart_serial_putchar+0xe8>
		return 1;
  4092cc:	2301      	movs	r3, #1
  4092ce:	e000      	b.n	4092d2 <usart_serial_putchar+0xfe>
	}
# endif
#endif /* ifdef USART */

	return 0;
  4092d0:	2300      	movs	r3, #0
}
  4092d2:	4618      	mov	r0, r3
  4092d4:	3708      	adds	r7, #8
  4092d6:	46bd      	mov	sp, r7
  4092d8:	bd80      	pop	{r7, pc}
  4092da:	bf00      	nop
  4092dc:	4000c200 	.word	0x4000c200
  4092e0:	00405239 	.word	0x00405239
  4092e4:	40020200 	.word	0x40020200
  4092e8:	40024200 	.word	0x40024200
  4092ec:	40018200 	.word	0x40018200
  4092f0:	4001c200 	.word	0x4001c200
  4092f4:	40008200 	.word	0x40008200
  4092f8:	40040200 	.word	0x40040200
  4092fc:	40034200 	.word	0x40034200

00409300 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  409300:	b580      	push	{r7, lr}
  409302:	b084      	sub	sp, #16
  409304:	af00      	add	r7, sp, #0
  409306:	6078      	str	r0, [r7, #4]
  409308:	6039      	str	r1, [r7, #0]
	uint32_t val = 0;
  40930a:	2300      	movs	r3, #0
  40930c:	60fb      	str	r3, [r7, #12]
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  40930e:	687b      	ldr	r3, [r7, #4]
  409310:	4a49      	ldr	r2, [pc, #292]	; (409438 <usart_serial_getchar+0x138>)
  409312:	4293      	cmp	r3, r2
  409314:	d10d      	bne.n	409332 <usart_serial_getchar+0x32>
		while (usart_read(p_usart, &val));
  409316:	bf00      	nop
  409318:	f107 030c 	add.w	r3, r7, #12
  40931c:	4619      	mov	r1, r3
  40931e:	6878      	ldr	r0, [r7, #4]
  409320:	4b46      	ldr	r3, [pc, #280]	; (40943c <usart_serial_getchar+0x13c>)
  409322:	4798      	blx	r3
  409324:	4603      	mov	r3, r0
  409326:	2b00      	cmp	r3, #0
  409328:	d1f6      	bne.n	409318 <usart_serial_getchar+0x18>
		*data = (uint8_t)(val & 0xFF);
  40932a:	68fb      	ldr	r3, [r7, #12]
  40932c:	b2da      	uxtb	r2, r3
  40932e:	683b      	ldr	r3, [r7, #0]
  409330:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  409332:	687b      	ldr	r3, [r7, #4]
  409334:	4a42      	ldr	r2, [pc, #264]	; (409440 <usart_serial_getchar+0x140>)
  409336:	4293      	cmp	r3, r2
  409338:	d10d      	bne.n	409356 <usart_serial_getchar+0x56>
		while (usart_read(p_usart, &val));
  40933a:	bf00      	nop
  40933c:	f107 030c 	add.w	r3, r7, #12
  409340:	4619      	mov	r1, r3
  409342:	6878      	ldr	r0, [r7, #4]
  409344:	4b3d      	ldr	r3, [pc, #244]	; (40943c <usart_serial_getchar+0x13c>)
  409346:	4798      	blx	r3
  409348:	4603      	mov	r3, r0
  40934a:	2b00      	cmp	r3, #0
  40934c:	d1f6      	bne.n	40933c <usart_serial_getchar+0x3c>
		*data = (uint8_t)(val & 0xFF);
  40934e:	68fb      	ldr	r3, [r7, #12]
  409350:	b2da      	uxtb	r2, r3
  409352:	683b      	ldr	r3, [r7, #0]
  409354:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  409356:	687b      	ldr	r3, [r7, #4]
  409358:	4a3a      	ldr	r2, [pc, #232]	; (409444 <usart_serial_getchar+0x144>)
  40935a:	4293      	cmp	r3, r2
  40935c:	d10d      	bne.n	40937a <usart_serial_getchar+0x7a>
		while (usart_read(p_usart, &val));
  40935e:	bf00      	nop
  409360:	f107 030c 	add.w	r3, r7, #12
  409364:	4619      	mov	r1, r3
  409366:	6878      	ldr	r0, [r7, #4]
  409368:	4b34      	ldr	r3, [pc, #208]	; (40943c <usart_serial_getchar+0x13c>)
  40936a:	4798      	blx	r3
  40936c:	4603      	mov	r3, r0
  40936e:	2b00      	cmp	r3, #0
  409370:	d1f6      	bne.n	409360 <usart_serial_getchar+0x60>
		*data = (uint8_t)(val & 0xFF);
  409372:	68fb      	ldr	r3, [r7, #12]
  409374:	b2da      	uxtb	r2, r3
  409376:	683b      	ldr	r3, [r7, #0]
  409378:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  40937a:	687b      	ldr	r3, [r7, #4]
  40937c:	4a32      	ldr	r2, [pc, #200]	; (409448 <usart_serial_getchar+0x148>)
  40937e:	4293      	cmp	r3, r2
  409380:	d10d      	bne.n	40939e <usart_serial_getchar+0x9e>
		while (usart_read(p_usart, &val));
  409382:	bf00      	nop
  409384:	f107 030c 	add.w	r3, r7, #12
  409388:	4619      	mov	r1, r3
  40938a:	6878      	ldr	r0, [r7, #4]
  40938c:	4b2b      	ldr	r3, [pc, #172]	; (40943c <usart_serial_getchar+0x13c>)
  40938e:	4798      	blx	r3
  409390:	4603      	mov	r3, r0
  409392:	2b00      	cmp	r3, #0
  409394:	d1f6      	bne.n	409384 <usart_serial_getchar+0x84>
		*data = (uint8_t)(val & 0xFF);
  409396:	68fb      	ldr	r3, [r7, #12]
  409398:	b2da      	uxtb	r2, r3
  40939a:	683b      	ldr	r3, [r7, #0]
  40939c:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  40939e:	687b      	ldr	r3, [r7, #4]
  4093a0:	4a2a      	ldr	r2, [pc, #168]	; (40944c <usart_serial_getchar+0x14c>)
  4093a2:	4293      	cmp	r3, r2
  4093a4:	d10d      	bne.n	4093c2 <usart_serial_getchar+0xc2>
		while (usart_read(p_usart, &val));
  4093a6:	bf00      	nop
  4093a8:	f107 030c 	add.w	r3, r7, #12
  4093ac:	4619      	mov	r1, r3
  4093ae:	6878      	ldr	r0, [r7, #4]
  4093b0:	4b22      	ldr	r3, [pc, #136]	; (40943c <usart_serial_getchar+0x13c>)
  4093b2:	4798      	blx	r3
  4093b4:	4603      	mov	r3, r0
  4093b6:	2b00      	cmp	r3, #0
  4093b8:	d1f6      	bne.n	4093a8 <usart_serial_getchar+0xa8>
		*data = (uint8_t)(val & 0xFF);
  4093ba:	68fb      	ldr	r3, [r7, #12]
  4093bc:	b2da      	uxtb	r2, r3
  4093be:	683b      	ldr	r3, [r7, #0]
  4093c0:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  4093c2:	687b      	ldr	r3, [r7, #4]
  4093c4:	4a22      	ldr	r2, [pc, #136]	; (409450 <usart_serial_getchar+0x150>)
  4093c6:	4293      	cmp	r3, r2
  4093c8:	d10d      	bne.n	4093e6 <usart_serial_getchar+0xe6>
		while (usart_read(p_usart, &val));
  4093ca:	bf00      	nop
  4093cc:	f107 030c 	add.w	r3, r7, #12
  4093d0:	4619      	mov	r1, r3
  4093d2:	6878      	ldr	r0, [r7, #4]
  4093d4:	4b19      	ldr	r3, [pc, #100]	; (40943c <usart_serial_getchar+0x13c>)
  4093d6:	4798      	blx	r3
  4093d8:	4603      	mov	r3, r0
  4093da:	2b00      	cmp	r3, #0
  4093dc:	d1f6      	bne.n	4093cc <usart_serial_getchar+0xcc>
		*data = (uint8_t)(val & 0xFF);
  4093de:	68fb      	ldr	r3, [r7, #12]
  4093e0:	b2da      	uxtb	r2, r3
  4093e2:	683b      	ldr	r3, [r7, #0]
  4093e4:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  4093e6:	687b      	ldr	r3, [r7, #4]
  4093e8:	4a1a      	ldr	r2, [pc, #104]	; (409454 <usart_serial_getchar+0x154>)
  4093ea:	4293      	cmp	r3, r2
  4093ec:	d10d      	bne.n	40940a <usart_serial_getchar+0x10a>
		while (usart_read(p_usart, &val));
  4093ee:	bf00      	nop
  4093f0:	f107 030c 	add.w	r3, r7, #12
  4093f4:	4619      	mov	r1, r3
  4093f6:	6878      	ldr	r0, [r7, #4]
  4093f8:	4b10      	ldr	r3, [pc, #64]	; (40943c <usart_serial_getchar+0x13c>)
  4093fa:	4798      	blx	r3
  4093fc:	4603      	mov	r3, r0
  4093fe:	2b00      	cmp	r3, #0
  409400:	d1f6      	bne.n	4093f0 <usart_serial_getchar+0xf0>
		*data = (uint8_t)(val & 0xFF);
  409402:	68fb      	ldr	r3, [r7, #12]
  409404:	b2da      	uxtb	r2, r3
  409406:	683b      	ldr	r3, [r7, #0]
  409408:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  40940a:	687b      	ldr	r3, [r7, #4]
  40940c:	4a12      	ldr	r2, [pc, #72]	; (409458 <usart_serial_getchar+0x158>)
  40940e:	4293      	cmp	r3, r2
  409410:	d10d      	bne.n	40942e <usart_serial_getchar+0x12e>
		while (usart_read(p_usart, &val));
  409412:	bf00      	nop
  409414:	f107 030c 	add.w	r3, r7, #12
  409418:	4619      	mov	r1, r3
  40941a:	6878      	ldr	r0, [r7, #4]
  40941c:	4b07      	ldr	r3, [pc, #28]	; (40943c <usart_serial_getchar+0x13c>)
  40941e:	4798      	blx	r3
  409420:	4603      	mov	r3, r0
  409422:	2b00      	cmp	r3, #0
  409424:	d1f6      	bne.n	409414 <usart_serial_getchar+0x114>
		*data = (uint8_t)(val & 0xFF);
  409426:	68fb      	ldr	r3, [r7, #12]
  409428:	b2da      	uxtb	r2, r3
  40942a:	683b      	ldr	r3, [r7, #0]
  40942c:	701a      	strb	r2, [r3, #0]
	}
# endif
#endif /* ifdef USART */

}
  40942e:	bf00      	nop
  409430:	3710      	adds	r7, #16
  409432:	46bd      	mov	sp, r7
  409434:	bd80      	pop	{r7, pc}
  409436:	bf00      	nop
  409438:	4000c200 	.word	0x4000c200
  40943c:	0040526b 	.word	0x0040526b
  409440:	40020200 	.word	0x40020200
  409444:	40024200 	.word	0x40024200
  409448:	40018200 	.word	0x40018200
  40944c:	4001c200 	.word	0x4001c200
  409450:	40008200 	.word	0x40008200
  409454:	40040200 	.word	0x40040200
  409458:	40034200 	.word	0x40034200

0040945c <stdio_serial_init>:
 * \param usart       Base address of the USART instance.
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
  40945c:	b580      	push	{r7, lr}
  40945e:	b082      	sub	sp, #8
  409460:	af00      	add	r7, sp, #0
  409462:	6078      	str	r0, [r7, #4]
  409464:	6039      	str	r1, [r7, #0]
	stdio_base = (void *)usart;
  409466:	4a0f      	ldr	r2, [pc, #60]	; (4094a4 <stdio_serial_init+0x48>)
  409468:	687b      	ldr	r3, [r7, #4]
  40946a:	6013      	str	r3, [r2, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  40946c:	4b0e      	ldr	r3, [pc, #56]	; (4094a8 <stdio_serial_init+0x4c>)
  40946e:	4a0f      	ldr	r2, [pc, #60]	; (4094ac <stdio_serial_init+0x50>)
  409470:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  409472:	4b0f      	ldr	r3, [pc, #60]	; (4094b0 <stdio_serial_init+0x54>)
  409474:	4a0f      	ldr	r2, [pc, #60]	; (4094b4 <stdio_serial_init+0x58>)
  409476:	601a      	str	r2, [r3, #0]
# if (XMEGA || MEGA_RF)
	usart_serial_init((USART_t *)usart,opt);
# elif UC3
	usart_serial_init(usart,(usart_serial_options_t *)opt);
# elif SAM
	usart_serial_init((Usart *)usart,(usart_serial_options_t *)opt);
  409478:	6839      	ldr	r1, [r7, #0]
  40947a:	6878      	ldr	r0, [r7, #4]
  40947c:	4b0e      	ldr	r3, [pc, #56]	; (4094b8 <stdio_serial_init+0x5c>)
  40947e:	4798      	blx	r3
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  409480:	4b0e      	ldr	r3, [pc, #56]	; (4094bc <stdio_serial_init+0x60>)
  409482:	681b      	ldr	r3, [r3, #0]
  409484:	689b      	ldr	r3, [r3, #8]
  409486:	2100      	movs	r1, #0
  409488:	4618      	mov	r0, r3
  40948a:	4b0d      	ldr	r3, [pc, #52]	; (4094c0 <stdio_serial_init+0x64>)
  40948c:	4798      	blx	r3
	setbuf(stdin, NULL);
  40948e:	4b0b      	ldr	r3, [pc, #44]	; (4094bc <stdio_serial_init+0x60>)
  409490:	681b      	ldr	r3, [r3, #0]
  409492:	685b      	ldr	r3, [r3, #4]
  409494:	2100      	movs	r1, #0
  409496:	4618      	mov	r0, r3
  409498:	4b09      	ldr	r3, [pc, #36]	; (4094c0 <stdio_serial_init+0x64>)
  40949a:	4798      	blx	r3
	// and AVR GCC library:
	// - printf() emits one character at a time.
	// - getchar() requests only 1 byte to exit.
#  endif
# endif
}
  40949c:	bf00      	nop
  40949e:	3708      	adds	r7, #8
  4094a0:	46bd      	mov	sp, r7
  4094a2:	bd80      	pop	{r7, pc}
  4094a4:	200028c8 	.word	0x200028c8
  4094a8:	200028c4 	.word	0x200028c4
  4094ac:	004091d5 	.word	0x004091d5
  4094b0:	200028c0 	.word	0x200028c0
  4094b4:	00409301 	.word	0x00409301
  4094b8:	00408fad 	.word	0x00408fad
  4094bc:	20000178 	.word	0x20000178
  4094c0:	00409f19 	.word	0x00409f19

004094c4 <FLEXCOM0_Handler>:
#include "time.h"

uint32_t startTime = 0;

void FLEXCOM0_Handler(void)
{
  4094c4:	b590      	push	{r4, r7, lr}
  4094c6:	b083      	sub	sp, #12
  4094c8:	af00      	add	r7, sp, #0
	uint32_t dw_status = usart_get_status(USART0);
  4094ca:	480e      	ldr	r0, [pc, #56]	; (409504 <FLEXCOM0_Handler+0x40>)
  4094cc:	4b0e      	ldr	r3, [pc, #56]	; (409508 <FLEXCOM0_Handler+0x44>)
  4094ce:	4798      	blx	r3
  4094d0:	6078      	str	r0, [r7, #4]
	//printf("Interrupt: %lu\n", dw_status);
	if (dw_status & US_CSR_ENDTX){
  4094d2:	687b      	ldr	r3, [r7, #4]
  4094d4:	f003 0310 	and.w	r3, r3, #16
  4094d8:	2b00      	cmp	r3, #0
  4094da:	d00f      	beq.n	4094fc <FLEXCOM0_Handler+0x38>
		printf("Finish TX in time: %lu \n", (uint32_t) time_get_in_us() - startTime);
  4094dc:	4b0b      	ldr	r3, [pc, #44]	; (40950c <FLEXCOM0_Handler+0x48>)
  4094de:	4798      	blx	r3
  4094e0:	4603      	mov	r3, r0
  4094e2:	460c      	mov	r4, r1
  4094e4:	461a      	mov	r2, r3
  4094e6:	4b0a      	ldr	r3, [pc, #40]	; (409510 <FLEXCOM0_Handler+0x4c>)
  4094e8:	681b      	ldr	r3, [r3, #0]
  4094ea:	1ad3      	subs	r3, r2, r3
  4094ec:	4619      	mov	r1, r3
  4094ee:	4809      	ldr	r0, [pc, #36]	; (409514 <FLEXCOM0_Handler+0x50>)
  4094f0:	4b09      	ldr	r3, [pc, #36]	; (409518 <FLEXCOM0_Handler+0x54>)
  4094f2:	4798      	blx	r3
		usart_disable_interrupt(USART0, US_IER_ENDTX);
  4094f4:	2110      	movs	r1, #16
  4094f6:	4803      	ldr	r0, [pc, #12]	; (409504 <FLEXCOM0_Handler+0x40>)
  4094f8:	4b08      	ldr	r3, [pc, #32]	; (40951c <FLEXCOM0_Handler+0x58>)
  4094fa:	4798      	blx	r3
	}
}
  4094fc:	bf00      	nop
  4094fe:	370c      	adds	r7, #12
  409500:	46bd      	mov	sp, r7
  409502:	bd90      	pop	{r4, r7, pc}
  409504:	4000c200 	.word	0x4000c200
  409508:	004051e9 	.word	0x004051e9
  40950c:	00400af9 	.word	0x00400af9
  409510:	20000434 	.word	0x20000434
  409514:	0040de44 	.word	0x0040de44
  409518:	00409ee9 	.word	0x00409ee9
  40951c:	004051cd 	.word	0x004051cd

00409520 <configure_console>:
		ioport_disable_pin(pin);\
	} while (0)

/* Use the EDBG console for debug */
void configure_console(void)
{
  409520:	b590      	push	{r4, r7, lr}
  409522:	b085      	sub	sp, #20
  409524:	af00      	add	r7, sp, #0
	/*ioport_set_port_peripheral_mode(IOPORT_PIOB, PIO_PB0B_TXD6 | PIO_PB1B_RXD6, IOPORT_MODE_MUX_B);
	ioport_set_pin_peripheral_mode(IOPORT_CREATE_PIN(PIOB, 1), IOPORT_MODE_MUX_B);
	ioport_set_pin_peripheral_mode(IOPORT_CREATE_PIN(PIOB, 0), IOPORT_MODE_MUX_B);*/

	/* USART7 / EDBG */
	ioport_set_port_peripheral_mode(PINS_USART7_PORT, PINS_USART7, PINS_USART7_FLAGS);
  409526:	2201      	movs	r2, #1
  409528:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40952c:	2000      	movs	r0, #0
  40952e:	4b18      	ldr	r3, [pc, #96]	; (409590 <configure_console+0x70>)
  409530:	4798      	blx	r3
  409532:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  409536:	2000      	movs	r0, #0
  409538:	4b16      	ldr	r3, [pc, #88]	; (409594 <configure_console+0x74>)
  40953a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(IOPORT_CREATE_PIN(PIOA, 27), PINS_USART7_FLAGS);
  40953c:	2101      	movs	r1, #1
  40953e:	201b      	movs	r0, #27
  409540:	4b15      	ldr	r3, [pc, #84]	; (409598 <configure_console+0x78>)
  409542:	4798      	blx	r3
  409544:	201b      	movs	r0, #27
  409546:	4b15      	ldr	r3, [pc, #84]	; (40959c <configure_console+0x7c>)
  409548:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(IOPORT_CREATE_PIN(PIOA, 28), PINS_USART7_FLAGS);
  40954a:	2101      	movs	r1, #1
  40954c:	201c      	movs	r0, #28
  40954e:	4b12      	ldr	r3, [pc, #72]	; (409598 <configure_console+0x78>)
  409550:	4798      	blx	r3
  409552:	201c      	movs	r0, #28
  409554:	4b11      	ldr	r3, [pc, #68]	; (40959c <configure_console+0x7c>)
  409556:	4798      	blx	r3

	const usart_serial_options_t uart_serial_options = {
  409558:	4b11      	ldr	r3, [pc, #68]	; (4095a0 <configure_console+0x80>)
  40955a:	463c      	mov	r4, r7
  40955c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  40955e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		.paritytype = CONF_UART_PARITY,
		.stopbits = CONF_UART_STOP_BITS,
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONF_UART_ID);
  409562:	2007      	movs	r0, #7
  409564:	4b0f      	ldr	r3, [pc, #60]	; (4095a4 <configure_console+0x84>)
  409566:	4798      	blx	r3
	usart_serial_init(CONF_UART, (usart_serial_options_t *)&uart_serial_options);
  409568:	463b      	mov	r3, r7
  40956a:	4619      	mov	r1, r3
  40956c:	480e      	ldr	r0, [pc, #56]	; (4095a8 <configure_console+0x88>)
  40956e:	4b0f      	ldr	r3, [pc, #60]	; (4095ac <configure_console+0x8c>)
  409570:	4798      	blx	r3

	stdio_serial_init(CONF_UART, &uart_serial_options);
  409572:	463b      	mov	r3, r7
  409574:	4619      	mov	r1, r3
  409576:	480c      	ldr	r0, [pc, #48]	; (4095a8 <configure_console+0x88>)
  409578:	4b0d      	ldr	r3, [pc, #52]	; (4095b0 <configure_console+0x90>)
  40957a:	4798      	blx	r3

	usart_enable_rx(CONF_UART);
  40957c:	480a      	ldr	r0, [pc, #40]	; (4095a8 <configure_console+0x88>)
  40957e:	4b0d      	ldr	r3, [pc, #52]	; (4095b4 <configure_console+0x94>)
  409580:	4798      	blx	r3
	usart_enable_tx(CONF_UART);
  409582:	4809      	ldr	r0, [pc, #36]	; (4095a8 <configure_console+0x88>)
  409584:	4b0c      	ldr	r3, [pc, #48]	; (4095b8 <configure_console+0x98>)
  409586:	4798      	blx	r3

	/* no IRQ on console UART */

  409588:	bf00      	nop
  40958a:	3714      	adds	r7, #20
  40958c:	46bd      	mov	sp, r7
  40958e:	bd90      	pop	{r4, r7, pc}
  409590:	00408d8f 	.word	0x00408d8f
  409594:	00408d5b 	.word	0x00408d5b
  409598:	00408e91 	.word	0x00408e91
  40959c:	00408d11 	.word	0x00408d11
  4095a0:	0040de84 	.word	0x0040de84
  4095a4:	00408cf5 	.word	0x00408cf5
  4095a8:	40034200 	.word	0x40034200
  4095ac:	00408fad 	.word	0x00408fad
  4095b0:	0040945d 	.word	0x0040945d
  4095b4:	00405199 	.word	0x00405199
  4095b8:	00405165 	.word	0x00405165

004095bc <__libc_init_array>:
  4095bc:	b570      	push	{r4, r5, r6, lr}
  4095be:	4e0d      	ldr	r6, [pc, #52]	; (4095f4 <__libc_init_array+0x38>)
  4095c0:	4c0d      	ldr	r4, [pc, #52]	; (4095f8 <__libc_init_array+0x3c>)
  4095c2:	1ba4      	subs	r4, r4, r6
  4095c4:	10a4      	asrs	r4, r4, #2
  4095c6:	2500      	movs	r5, #0
  4095c8:	42a5      	cmp	r5, r4
  4095ca:	d109      	bne.n	4095e0 <__libc_init_array+0x24>
  4095cc:	4e0b      	ldr	r6, [pc, #44]	; (4095fc <__libc_init_array+0x40>)
  4095ce:	4c0c      	ldr	r4, [pc, #48]	; (409600 <__libc_init_array+0x44>)
  4095d0:	f004 fdc2 	bl	40e158 <_init>
  4095d4:	1ba4      	subs	r4, r4, r6
  4095d6:	10a4      	asrs	r4, r4, #2
  4095d8:	2500      	movs	r5, #0
  4095da:	42a5      	cmp	r5, r4
  4095dc:	d105      	bne.n	4095ea <__libc_init_array+0x2e>
  4095de:	bd70      	pop	{r4, r5, r6, pc}
  4095e0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4095e4:	4798      	blx	r3
  4095e6:	3501      	adds	r5, #1
  4095e8:	e7ee      	b.n	4095c8 <__libc_init_array+0xc>
  4095ea:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4095ee:	4798      	blx	r3
  4095f0:	3501      	adds	r5, #1
  4095f2:	e7f2      	b.n	4095da <__libc_init_array+0x1e>
  4095f4:	0040e164 	.word	0x0040e164
  4095f8:	0040e164 	.word	0x0040e164
  4095fc:	0040e164 	.word	0x0040e164
  409600:	0040e168 	.word	0x0040e168

00409604 <memcpy>:
  409604:	b510      	push	{r4, lr}
  409606:	1e43      	subs	r3, r0, #1
  409608:	440a      	add	r2, r1
  40960a:	4291      	cmp	r1, r2
  40960c:	d100      	bne.n	409610 <memcpy+0xc>
  40960e:	bd10      	pop	{r4, pc}
  409610:	f811 4b01 	ldrb.w	r4, [r1], #1
  409614:	f803 4f01 	strb.w	r4, [r3, #1]!
  409618:	e7f7      	b.n	40960a <memcpy+0x6>

0040961a <memset>:
  40961a:	4402      	add	r2, r0
  40961c:	4603      	mov	r3, r0
  40961e:	4293      	cmp	r3, r2
  409620:	d100      	bne.n	409624 <memset+0xa>
  409622:	4770      	bx	lr
  409624:	f803 1b01 	strb.w	r1, [r3], #1
  409628:	e7f9      	b.n	40961e <memset+0x4>

0040962a <__cvt>:
  40962a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40962e:	b088      	sub	sp, #32
  409630:	2b00      	cmp	r3, #0
  409632:	9f14      	ldr	r7, [sp, #80]	; 0x50
  409634:	9912      	ldr	r1, [sp, #72]	; 0x48
  409636:	9d10      	ldr	r5, [sp, #64]	; 0x40
  409638:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
  40963c:	461e      	mov	r6, r3
  40963e:	f027 0720 	bic.w	r7, r7, #32
  409642:	bfbb      	ittet	lt
  409644:	f103 4300 	addlt.w	r3, r3, #2147483648	; 0x80000000
  409648:	461e      	movlt	r6, r3
  40964a:	2300      	movge	r3, #0
  40964c:	232d      	movlt	r3, #45	; 0x2d
  40964e:	2f46      	cmp	r7, #70	; 0x46
  409650:	4614      	mov	r4, r2
  409652:	700b      	strb	r3, [r1, #0]
  409654:	d004      	beq.n	409660 <__cvt+0x36>
  409656:	2f45      	cmp	r7, #69	; 0x45
  409658:	d100      	bne.n	40965c <__cvt+0x32>
  40965a:	3501      	adds	r5, #1
  40965c:	2302      	movs	r3, #2
  40965e:	e000      	b.n	409662 <__cvt+0x38>
  409660:	2303      	movs	r3, #3
  409662:	aa07      	add	r2, sp, #28
  409664:	9204      	str	r2, [sp, #16]
  409666:	aa06      	add	r2, sp, #24
  409668:	9203      	str	r2, [sp, #12]
  40966a:	e88d 0428 	stmia.w	sp, {r3, r5, sl}
  40966e:	4622      	mov	r2, r4
  409670:	4633      	mov	r3, r6
  409672:	f000 fdd1 	bl	40a218 <_dtoa_r>
  409676:	2f47      	cmp	r7, #71	; 0x47
  409678:	4680      	mov	r8, r0
  40967a:	d102      	bne.n	409682 <__cvt+0x58>
  40967c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40967e:	07db      	lsls	r3, r3, #31
  409680:	d526      	bpl.n	4096d0 <__cvt+0xa6>
  409682:	2f46      	cmp	r7, #70	; 0x46
  409684:	eb08 0905 	add.w	r9, r8, r5
  409688:	d111      	bne.n	4096ae <__cvt+0x84>
  40968a:	f898 3000 	ldrb.w	r3, [r8]
  40968e:	2b30      	cmp	r3, #48	; 0x30
  409690:	d10a      	bne.n	4096a8 <__cvt+0x7e>
  409692:	2200      	movs	r2, #0
  409694:	2300      	movs	r3, #0
  409696:	4620      	mov	r0, r4
  409698:	4631      	mov	r1, r6
  40969a:	f003 f9f7 	bl	40ca8c <__aeabi_dcmpeq>
  40969e:	b918      	cbnz	r0, 4096a8 <__cvt+0x7e>
  4096a0:	f1c5 0501 	rsb	r5, r5, #1
  4096a4:	f8ca 5000 	str.w	r5, [sl]
  4096a8:	f8da 3000 	ldr.w	r3, [sl]
  4096ac:	4499      	add	r9, r3
  4096ae:	2200      	movs	r2, #0
  4096b0:	2300      	movs	r3, #0
  4096b2:	4620      	mov	r0, r4
  4096b4:	4631      	mov	r1, r6
  4096b6:	f003 f9e9 	bl	40ca8c <__aeabi_dcmpeq>
  4096ba:	b938      	cbnz	r0, 4096cc <__cvt+0xa2>
  4096bc:	2230      	movs	r2, #48	; 0x30
  4096be:	9b07      	ldr	r3, [sp, #28]
  4096c0:	4599      	cmp	r9, r3
  4096c2:	d905      	bls.n	4096d0 <__cvt+0xa6>
  4096c4:	1c59      	adds	r1, r3, #1
  4096c6:	9107      	str	r1, [sp, #28]
  4096c8:	701a      	strb	r2, [r3, #0]
  4096ca:	e7f8      	b.n	4096be <__cvt+0x94>
  4096cc:	f8cd 901c 	str.w	r9, [sp, #28]
  4096d0:	9b07      	ldr	r3, [sp, #28]
  4096d2:	9a15      	ldr	r2, [sp, #84]	; 0x54
  4096d4:	eba3 0308 	sub.w	r3, r3, r8
  4096d8:	4640      	mov	r0, r8
  4096da:	6013      	str	r3, [r2, #0]
  4096dc:	b008      	add	sp, #32
  4096de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

004096e2 <__exponent>:
  4096e2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  4096e4:	4603      	mov	r3, r0
  4096e6:	2900      	cmp	r1, #0
  4096e8:	bfb8      	it	lt
  4096ea:	4249      	neglt	r1, r1
  4096ec:	f803 2b02 	strb.w	r2, [r3], #2
  4096f0:	bfb4      	ite	lt
  4096f2:	222d      	movlt	r2, #45	; 0x2d
  4096f4:	222b      	movge	r2, #43	; 0x2b
  4096f6:	2909      	cmp	r1, #9
  4096f8:	7042      	strb	r2, [r0, #1]
  4096fa:	dd20      	ble.n	40973e <__exponent+0x5c>
  4096fc:	f10d 0207 	add.w	r2, sp, #7
  409700:	4617      	mov	r7, r2
  409702:	260a      	movs	r6, #10
  409704:	fb91 f5f6 	sdiv	r5, r1, r6
  409708:	fb06 1115 	mls	r1, r6, r5, r1
  40970c:	3130      	adds	r1, #48	; 0x30
  40970e:	2d09      	cmp	r5, #9
  409710:	f802 1c01 	strb.w	r1, [r2, #-1]
  409714:	f102 34ff 	add.w	r4, r2, #4294967295
  409718:	4629      	mov	r1, r5
  40971a:	dc09      	bgt.n	409730 <__exponent+0x4e>
  40971c:	3130      	adds	r1, #48	; 0x30
  40971e:	3a02      	subs	r2, #2
  409720:	f804 1c01 	strb.w	r1, [r4, #-1]
  409724:	42ba      	cmp	r2, r7
  409726:	461c      	mov	r4, r3
  409728:	d304      	bcc.n	409734 <__exponent+0x52>
  40972a:	1a20      	subs	r0, r4, r0
  40972c:	b003      	add	sp, #12
  40972e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  409730:	4622      	mov	r2, r4
  409732:	e7e7      	b.n	409704 <__exponent+0x22>
  409734:	f812 1b01 	ldrb.w	r1, [r2], #1
  409738:	f803 1b01 	strb.w	r1, [r3], #1
  40973c:	e7f2      	b.n	409724 <__exponent+0x42>
  40973e:	2230      	movs	r2, #48	; 0x30
  409740:	461c      	mov	r4, r3
  409742:	4411      	add	r1, r2
  409744:	f804 2b02 	strb.w	r2, [r4], #2
  409748:	7059      	strb	r1, [r3, #1]
  40974a:	e7ee      	b.n	40972a <__exponent+0x48>

0040974c <_printf_float>:
  40974c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  409750:	b091      	sub	sp, #68	; 0x44
  409752:	460c      	mov	r4, r1
  409754:	9f1a      	ldr	r7, [sp, #104]	; 0x68
  409756:	4693      	mov	fp, r2
  409758:	461e      	mov	r6, r3
  40975a:	4605      	mov	r5, r0
  40975c:	f001 fcaa 	bl	40b0b4 <_localeconv_r>
  409760:	6803      	ldr	r3, [r0, #0]
  409762:	9309      	str	r3, [sp, #36]	; 0x24
  409764:	4618      	mov	r0, r3
  409766:	f000 fcc1 	bl	40a0ec <strlen>
  40976a:	2300      	movs	r3, #0
  40976c:	930e      	str	r3, [sp, #56]	; 0x38
  40976e:	683b      	ldr	r3, [r7, #0]
  409770:	900a      	str	r0, [sp, #40]	; 0x28
  409772:	3307      	adds	r3, #7
  409774:	f023 0307 	bic.w	r3, r3, #7
  409778:	f103 0208 	add.w	r2, r3, #8
  40977c:	f894 8018 	ldrb.w	r8, [r4, #24]
  409780:	f8d4 a000 	ldr.w	sl, [r4]
  409784:	603a      	str	r2, [r7, #0]
  409786:	e9d3 2300 	ldrd	r2, r3, [r3]
  40978a:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
  40978e:	f8d4 904c 	ldr.w	r9, [r4, #76]	; 0x4c
  409792:	6ca7      	ldr	r7, [r4, #72]	; 0x48
  409794:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
  409798:	930b      	str	r3, [sp, #44]	; 0x2c
  40979a:	f04f 32ff 	mov.w	r2, #4294967295
  40979e:	4ba6      	ldr	r3, [pc, #664]	; (409a38 <_printf_float+0x2ec>)
  4097a0:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4097a2:	4638      	mov	r0, r7
  4097a4:	f003 f9a4 	bl	40caf0 <__aeabi_dcmpun>
  4097a8:	2800      	cmp	r0, #0
  4097aa:	f040 81f7 	bne.w	409b9c <_printf_float+0x450>
  4097ae:	f04f 32ff 	mov.w	r2, #4294967295
  4097b2:	4ba1      	ldr	r3, [pc, #644]	; (409a38 <_printf_float+0x2ec>)
  4097b4:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4097b6:	4638      	mov	r0, r7
  4097b8:	f003 f97c 	bl	40cab4 <__aeabi_dcmple>
  4097bc:	2800      	cmp	r0, #0
  4097be:	f040 81ed 	bne.w	409b9c <_printf_float+0x450>
  4097c2:	2200      	movs	r2, #0
  4097c4:	2300      	movs	r3, #0
  4097c6:	4638      	mov	r0, r7
  4097c8:	4649      	mov	r1, r9
  4097ca:	f003 f969 	bl	40caa0 <__aeabi_dcmplt>
  4097ce:	b110      	cbz	r0, 4097d6 <_printf_float+0x8a>
  4097d0:	232d      	movs	r3, #45	; 0x2d
  4097d2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  4097d6:	4b99      	ldr	r3, [pc, #612]	; (409a3c <_printf_float+0x2f0>)
  4097d8:	4f99      	ldr	r7, [pc, #612]	; (409a40 <_printf_float+0x2f4>)
  4097da:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
  4097de:	bf98      	it	ls
  4097e0:	461f      	movls	r7, r3
  4097e2:	2303      	movs	r3, #3
  4097e4:	6123      	str	r3, [r4, #16]
  4097e6:	f02a 0304 	bic.w	r3, sl, #4
  4097ea:	6023      	str	r3, [r4, #0]
  4097ec:	f04f 0900 	mov.w	r9, #0
  4097f0:	9600      	str	r6, [sp, #0]
  4097f2:	465b      	mov	r3, fp
  4097f4:	aa0f      	add	r2, sp, #60	; 0x3c
  4097f6:	4621      	mov	r1, r4
  4097f8:	4628      	mov	r0, r5
  4097fa:	f000 f9df 	bl	409bbc <_printf_common>
  4097fe:	3001      	adds	r0, #1
  409800:	f040 809a 	bne.w	409938 <_printf_float+0x1ec>
  409804:	f04f 30ff 	mov.w	r0, #4294967295
  409808:	b011      	add	sp, #68	; 0x44
  40980a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40980e:	6862      	ldr	r2, [r4, #4]
  409810:	1c53      	adds	r3, r2, #1
  409812:	a80e      	add	r0, sp, #56	; 0x38
  409814:	f44a 6380 	orr.w	r3, sl, #1024	; 0x400
  409818:	f10d 0e34 	add.w	lr, sp, #52	; 0x34
  40981c:	d141      	bne.n	4098a2 <_printf_float+0x156>
  40981e:	2206      	movs	r2, #6
  409820:	6062      	str	r2, [r4, #4]
  409822:	6023      	str	r3, [r4, #0]
  409824:	2100      	movs	r1, #0
  409826:	f10d 0233 	add.w	r2, sp, #51	; 0x33
  40982a:	9301      	str	r3, [sp, #4]
  40982c:	6863      	ldr	r3, [r4, #4]
  40982e:	9005      	str	r0, [sp, #20]
  409830:	9202      	str	r2, [sp, #8]
  409832:	9300      	str	r3, [sp, #0]
  409834:	463a      	mov	r2, r7
  409836:	464b      	mov	r3, r9
  409838:	9106      	str	r1, [sp, #24]
  40983a:	f8cd 8010 	str.w	r8, [sp, #16]
  40983e:	f8cd e00c 	str.w	lr, [sp, #12]
  409842:	4628      	mov	r0, r5
  409844:	f7ff fef1 	bl	40962a <__cvt>
  409848:	f008 03df 	and.w	r3, r8, #223	; 0xdf
  40984c:	2b47      	cmp	r3, #71	; 0x47
  40984e:	4607      	mov	r7, r0
  409850:	d109      	bne.n	409866 <_printf_float+0x11a>
  409852:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  409854:	1cd8      	adds	r0, r3, #3
  409856:	db02      	blt.n	40985e <_printf_float+0x112>
  409858:	6862      	ldr	r2, [r4, #4]
  40985a:	4293      	cmp	r3, r2
  40985c:	dd59      	ble.n	409912 <_printf_float+0x1c6>
  40985e:	f1a8 0802 	sub.w	r8, r8, #2
  409862:	fa5f f888 	uxtb.w	r8, r8
  409866:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
  40986a:	990d      	ldr	r1, [sp, #52]	; 0x34
  40986c:	d836      	bhi.n	4098dc <_printf_float+0x190>
  40986e:	3901      	subs	r1, #1
  409870:	4642      	mov	r2, r8
  409872:	f104 0050 	add.w	r0, r4, #80	; 0x50
  409876:	910d      	str	r1, [sp, #52]	; 0x34
  409878:	f7ff ff33 	bl	4096e2 <__exponent>
  40987c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  40987e:	1883      	adds	r3, r0, r2
  409880:	2a01      	cmp	r2, #1
  409882:	4681      	mov	r9, r0
  409884:	6123      	str	r3, [r4, #16]
  409886:	dc02      	bgt.n	40988e <_printf_float+0x142>
  409888:	6822      	ldr	r2, [r4, #0]
  40988a:	07d1      	lsls	r1, r2, #31
  40988c:	d501      	bpl.n	409892 <_printf_float+0x146>
  40988e:	3301      	adds	r3, #1
  409890:	6123      	str	r3, [r4, #16]
  409892:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
  409896:	2b00      	cmp	r3, #0
  409898:	d0aa      	beq.n	4097f0 <_printf_float+0xa4>
  40989a:	232d      	movs	r3, #45	; 0x2d
  40989c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  4098a0:	e7a6      	b.n	4097f0 <_printf_float+0xa4>
  4098a2:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
  4098a6:	d002      	beq.n	4098ae <_printf_float+0x162>
  4098a8:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
  4098ac:	d1b9      	bne.n	409822 <_printf_float+0xd6>
  4098ae:	b19a      	cbz	r2, 4098d8 <_printf_float+0x18c>
  4098b0:	2100      	movs	r1, #0
  4098b2:	9106      	str	r1, [sp, #24]
  4098b4:	f10d 0133 	add.w	r1, sp, #51	; 0x33
  4098b8:	e88d 000c 	stmia.w	sp, {r2, r3}
  4098bc:	6023      	str	r3, [r4, #0]
  4098be:	9005      	str	r0, [sp, #20]
  4098c0:	463a      	mov	r2, r7
  4098c2:	f8cd 8010 	str.w	r8, [sp, #16]
  4098c6:	f8cd e00c 	str.w	lr, [sp, #12]
  4098ca:	9102      	str	r1, [sp, #8]
  4098cc:	464b      	mov	r3, r9
  4098ce:	4628      	mov	r0, r5
  4098d0:	f7ff feab 	bl	40962a <__cvt>
  4098d4:	4607      	mov	r7, r0
  4098d6:	e7bc      	b.n	409852 <_printf_float+0x106>
  4098d8:	2201      	movs	r2, #1
  4098da:	e7a1      	b.n	409820 <_printf_float+0xd4>
  4098dc:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
  4098e0:	d119      	bne.n	409916 <_printf_float+0x1ca>
  4098e2:	2900      	cmp	r1, #0
  4098e4:	6863      	ldr	r3, [r4, #4]
  4098e6:	dd0c      	ble.n	409902 <_printf_float+0x1b6>
  4098e8:	6121      	str	r1, [r4, #16]
  4098ea:	b913      	cbnz	r3, 4098f2 <_printf_float+0x1a6>
  4098ec:	6822      	ldr	r2, [r4, #0]
  4098ee:	07d2      	lsls	r2, r2, #31
  4098f0:	d502      	bpl.n	4098f8 <_printf_float+0x1ac>
  4098f2:	3301      	adds	r3, #1
  4098f4:	440b      	add	r3, r1
  4098f6:	6123      	str	r3, [r4, #16]
  4098f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4098fa:	65a3      	str	r3, [r4, #88]	; 0x58
  4098fc:	f04f 0900 	mov.w	r9, #0
  409900:	e7c7      	b.n	409892 <_printf_float+0x146>
  409902:	b913      	cbnz	r3, 40990a <_printf_float+0x1be>
  409904:	6822      	ldr	r2, [r4, #0]
  409906:	07d0      	lsls	r0, r2, #31
  409908:	d501      	bpl.n	40990e <_printf_float+0x1c2>
  40990a:	3302      	adds	r3, #2
  40990c:	e7f3      	b.n	4098f6 <_printf_float+0x1aa>
  40990e:	2301      	movs	r3, #1
  409910:	e7f1      	b.n	4098f6 <_printf_float+0x1aa>
  409912:	f04f 0867 	mov.w	r8, #103	; 0x67
  409916:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  409918:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  40991a:	4293      	cmp	r3, r2
  40991c:	db05      	blt.n	40992a <_printf_float+0x1de>
  40991e:	6822      	ldr	r2, [r4, #0]
  409920:	6123      	str	r3, [r4, #16]
  409922:	07d1      	lsls	r1, r2, #31
  409924:	d5e8      	bpl.n	4098f8 <_printf_float+0x1ac>
  409926:	3301      	adds	r3, #1
  409928:	e7e5      	b.n	4098f6 <_printf_float+0x1aa>
  40992a:	2b00      	cmp	r3, #0
  40992c:	bfd4      	ite	le
  40992e:	f1c3 0302 	rsble	r3, r3, #2
  409932:	2301      	movgt	r3, #1
  409934:	4413      	add	r3, r2
  409936:	e7de      	b.n	4098f6 <_printf_float+0x1aa>
  409938:	6823      	ldr	r3, [r4, #0]
  40993a:	055a      	lsls	r2, r3, #21
  40993c:	d407      	bmi.n	40994e <_printf_float+0x202>
  40993e:	6923      	ldr	r3, [r4, #16]
  409940:	463a      	mov	r2, r7
  409942:	4659      	mov	r1, fp
  409944:	4628      	mov	r0, r5
  409946:	47b0      	blx	r6
  409948:	3001      	adds	r0, #1
  40994a:	d12a      	bne.n	4099a2 <_printf_float+0x256>
  40994c:	e75a      	b.n	409804 <_printf_float+0xb8>
  40994e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
  409952:	f240 80dc 	bls.w	409b0e <_printf_float+0x3c2>
  409956:	2200      	movs	r2, #0
  409958:	2300      	movs	r3, #0
  40995a:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
  40995e:	f003 f895 	bl	40ca8c <__aeabi_dcmpeq>
  409962:	2800      	cmp	r0, #0
  409964:	d039      	beq.n	4099da <_printf_float+0x28e>
  409966:	2301      	movs	r3, #1
  409968:	4a36      	ldr	r2, [pc, #216]	; (409a44 <_printf_float+0x2f8>)
  40996a:	4659      	mov	r1, fp
  40996c:	4628      	mov	r0, r5
  40996e:	47b0      	blx	r6
  409970:	3001      	adds	r0, #1
  409972:	f43f af47 	beq.w	409804 <_printf_float+0xb8>
  409976:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409978:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  40997a:	429a      	cmp	r2, r3
  40997c:	db02      	blt.n	409984 <_printf_float+0x238>
  40997e:	6823      	ldr	r3, [r4, #0]
  409980:	07d8      	lsls	r0, r3, #31
  409982:	d50e      	bpl.n	4099a2 <_printf_float+0x256>
  409984:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  409986:	9a09      	ldr	r2, [sp, #36]	; 0x24
  409988:	4659      	mov	r1, fp
  40998a:	4628      	mov	r0, r5
  40998c:	47b0      	blx	r6
  40998e:	3001      	adds	r0, #1
  409990:	f43f af38 	beq.w	409804 <_printf_float+0xb8>
  409994:	2700      	movs	r7, #0
  409996:	f104 081a 	add.w	r8, r4, #26
  40999a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  40999c:	3b01      	subs	r3, #1
  40999e:	429f      	cmp	r7, r3
  4099a0:	db11      	blt.n	4099c6 <_printf_float+0x27a>
  4099a2:	6823      	ldr	r3, [r4, #0]
  4099a4:	079f      	lsls	r7, r3, #30
  4099a6:	d508      	bpl.n	4099ba <_printf_float+0x26e>
  4099a8:	2700      	movs	r7, #0
  4099aa:	f104 0819 	add.w	r8, r4, #25
  4099ae:	68e3      	ldr	r3, [r4, #12]
  4099b0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4099b2:	1a9b      	subs	r3, r3, r2
  4099b4:	429f      	cmp	r7, r3
  4099b6:	f2c0 80e7 	blt.w	409b88 <_printf_float+0x43c>
  4099ba:	68e0      	ldr	r0, [r4, #12]
  4099bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4099be:	4298      	cmp	r0, r3
  4099c0:	bfb8      	it	lt
  4099c2:	4618      	movlt	r0, r3
  4099c4:	e720      	b.n	409808 <_printf_float+0xbc>
  4099c6:	2301      	movs	r3, #1
  4099c8:	4642      	mov	r2, r8
  4099ca:	4659      	mov	r1, fp
  4099cc:	4628      	mov	r0, r5
  4099ce:	47b0      	blx	r6
  4099d0:	3001      	adds	r0, #1
  4099d2:	f43f af17 	beq.w	409804 <_printf_float+0xb8>
  4099d6:	3701      	adds	r7, #1
  4099d8:	e7df      	b.n	40999a <_printf_float+0x24e>
  4099da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4099dc:	2b00      	cmp	r3, #0
  4099de:	dc33      	bgt.n	409a48 <_printf_float+0x2fc>
  4099e0:	2301      	movs	r3, #1
  4099e2:	4a18      	ldr	r2, [pc, #96]	; (409a44 <_printf_float+0x2f8>)
  4099e4:	4659      	mov	r1, fp
  4099e6:	4628      	mov	r0, r5
  4099e8:	47b0      	blx	r6
  4099ea:	3001      	adds	r0, #1
  4099ec:	f43f af0a 	beq.w	409804 <_printf_float+0xb8>
  4099f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4099f2:	b923      	cbnz	r3, 4099fe <_printf_float+0x2b2>
  4099f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4099f6:	b913      	cbnz	r3, 4099fe <_printf_float+0x2b2>
  4099f8:	6823      	ldr	r3, [r4, #0]
  4099fa:	07d9      	lsls	r1, r3, #31
  4099fc:	d5d1      	bpl.n	4099a2 <_printf_float+0x256>
  4099fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  409a00:	9a09      	ldr	r2, [sp, #36]	; 0x24
  409a02:	4659      	mov	r1, fp
  409a04:	4628      	mov	r0, r5
  409a06:	47b0      	blx	r6
  409a08:	3001      	adds	r0, #1
  409a0a:	f43f aefb 	beq.w	409804 <_printf_float+0xb8>
  409a0e:	f04f 0800 	mov.w	r8, #0
  409a12:	f104 091a 	add.w	r9, r4, #26
  409a16:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  409a18:	425b      	negs	r3, r3
  409a1a:	4598      	cmp	r8, r3
  409a1c:	db01      	blt.n	409a22 <_printf_float+0x2d6>
  409a1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409a20:	e78e      	b.n	409940 <_printf_float+0x1f4>
  409a22:	2301      	movs	r3, #1
  409a24:	464a      	mov	r2, r9
  409a26:	4659      	mov	r1, fp
  409a28:	4628      	mov	r0, r5
  409a2a:	47b0      	blx	r6
  409a2c:	3001      	adds	r0, #1
  409a2e:	f43f aee9 	beq.w	409804 <_printf_float+0xb8>
  409a32:	f108 0801 	add.w	r8, r8, #1
  409a36:	e7ee      	b.n	409a16 <_printf_float+0x2ca>
  409a38:	7fefffff 	.word	0x7fefffff
  409a3c:	0040de98 	.word	0x0040de98
  409a40:	0040de9c 	.word	0x0040de9c
  409a44:	0040dea8 	.word	0x0040dea8
  409a48:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  409a4a:	6da3      	ldr	r3, [r4, #88]	; 0x58
  409a4c:	429a      	cmp	r2, r3
  409a4e:	bfa8      	it	ge
  409a50:	461a      	movge	r2, r3
  409a52:	2a00      	cmp	r2, #0
  409a54:	4690      	mov	r8, r2
  409a56:	dc36      	bgt.n	409ac6 <_printf_float+0x37a>
  409a58:	f104 031a 	add.w	r3, r4, #26
  409a5c:	f04f 0a00 	mov.w	sl, #0
  409a60:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
  409a64:	930b      	str	r3, [sp, #44]	; 0x2c
  409a66:	f8d4 9058 	ldr.w	r9, [r4, #88]	; 0x58
  409a6a:	eba9 0308 	sub.w	r3, r9, r8
  409a6e:	459a      	cmp	sl, r3
  409a70:	db31      	blt.n	409ad6 <_printf_float+0x38a>
  409a72:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409a74:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  409a76:	429a      	cmp	r2, r3
  409a78:	db38      	blt.n	409aec <_printf_float+0x3a0>
  409a7a:	6823      	ldr	r3, [r4, #0]
  409a7c:	07da      	lsls	r2, r3, #31
  409a7e:	d435      	bmi.n	409aec <_printf_float+0x3a0>
  409a80:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409a82:	990d      	ldr	r1, [sp, #52]	; 0x34
  409a84:	eba3 0209 	sub.w	r2, r3, r9
  409a88:	eba3 0801 	sub.w	r8, r3, r1
  409a8c:	4590      	cmp	r8, r2
  409a8e:	bfa8      	it	ge
  409a90:	4690      	movge	r8, r2
  409a92:	f1b8 0f00 	cmp.w	r8, #0
  409a96:	dc31      	bgt.n	409afc <_printf_float+0x3b0>
  409a98:	2700      	movs	r7, #0
  409a9a:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
  409a9e:	f104 091a 	add.w	r9, r4, #26
  409aa2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  409aa4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409aa6:	1a9b      	subs	r3, r3, r2
  409aa8:	eba3 0308 	sub.w	r3, r3, r8
  409aac:	429f      	cmp	r7, r3
  409aae:	f6bf af78 	bge.w	4099a2 <_printf_float+0x256>
  409ab2:	2301      	movs	r3, #1
  409ab4:	464a      	mov	r2, r9
  409ab6:	4659      	mov	r1, fp
  409ab8:	4628      	mov	r0, r5
  409aba:	47b0      	blx	r6
  409abc:	3001      	adds	r0, #1
  409abe:	f43f aea1 	beq.w	409804 <_printf_float+0xb8>
  409ac2:	3701      	adds	r7, #1
  409ac4:	e7ed      	b.n	409aa2 <_printf_float+0x356>
  409ac6:	4613      	mov	r3, r2
  409ac8:	4659      	mov	r1, fp
  409aca:	463a      	mov	r2, r7
  409acc:	4628      	mov	r0, r5
  409ace:	47b0      	blx	r6
  409ad0:	3001      	adds	r0, #1
  409ad2:	d1c1      	bne.n	409a58 <_printf_float+0x30c>
  409ad4:	e696      	b.n	409804 <_printf_float+0xb8>
  409ad6:	2301      	movs	r3, #1
  409ad8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  409ada:	4659      	mov	r1, fp
  409adc:	4628      	mov	r0, r5
  409ade:	47b0      	blx	r6
  409ae0:	3001      	adds	r0, #1
  409ae2:	f43f ae8f 	beq.w	409804 <_printf_float+0xb8>
  409ae6:	f10a 0a01 	add.w	sl, sl, #1
  409aea:	e7bc      	b.n	409a66 <_printf_float+0x31a>
  409aec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  409aee:	9a09      	ldr	r2, [sp, #36]	; 0x24
  409af0:	4659      	mov	r1, fp
  409af2:	4628      	mov	r0, r5
  409af4:	47b0      	blx	r6
  409af6:	3001      	adds	r0, #1
  409af8:	d1c2      	bne.n	409a80 <_printf_float+0x334>
  409afa:	e683      	b.n	409804 <_printf_float+0xb8>
  409afc:	4643      	mov	r3, r8
  409afe:	eb07 0209 	add.w	r2, r7, r9
  409b02:	4659      	mov	r1, fp
  409b04:	4628      	mov	r0, r5
  409b06:	47b0      	blx	r6
  409b08:	3001      	adds	r0, #1
  409b0a:	d1c5      	bne.n	409a98 <_printf_float+0x34c>
  409b0c:	e67a      	b.n	409804 <_printf_float+0xb8>
  409b0e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  409b10:	2a01      	cmp	r2, #1
  409b12:	dc01      	bgt.n	409b18 <_printf_float+0x3cc>
  409b14:	07db      	lsls	r3, r3, #31
  409b16:	d534      	bpl.n	409b82 <_printf_float+0x436>
  409b18:	2301      	movs	r3, #1
  409b1a:	463a      	mov	r2, r7
  409b1c:	4659      	mov	r1, fp
  409b1e:	4628      	mov	r0, r5
  409b20:	47b0      	blx	r6
  409b22:	3001      	adds	r0, #1
  409b24:	f43f ae6e 	beq.w	409804 <_printf_float+0xb8>
  409b28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  409b2a:	9a09      	ldr	r2, [sp, #36]	; 0x24
  409b2c:	4659      	mov	r1, fp
  409b2e:	4628      	mov	r0, r5
  409b30:	47b0      	blx	r6
  409b32:	3001      	adds	r0, #1
  409b34:	f43f ae66 	beq.w	409804 <_printf_float+0xb8>
  409b38:	2200      	movs	r2, #0
  409b3a:	2300      	movs	r3, #0
  409b3c:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
  409b40:	f002 ffa4 	bl	40ca8c <__aeabi_dcmpeq>
  409b44:	b150      	cbz	r0, 409b5c <_printf_float+0x410>
  409b46:	2700      	movs	r7, #0
  409b48:	f104 081a 	add.w	r8, r4, #26
  409b4c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409b4e:	3b01      	subs	r3, #1
  409b50:	429f      	cmp	r7, r3
  409b52:	db0c      	blt.n	409b6e <_printf_float+0x422>
  409b54:	464b      	mov	r3, r9
  409b56:	f104 0250 	add.w	r2, r4, #80	; 0x50
  409b5a:	e6f2      	b.n	409942 <_printf_float+0x1f6>
  409b5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  409b5e:	1c7a      	adds	r2, r7, #1
  409b60:	3b01      	subs	r3, #1
  409b62:	4659      	mov	r1, fp
  409b64:	4628      	mov	r0, r5
  409b66:	47b0      	blx	r6
  409b68:	3001      	adds	r0, #1
  409b6a:	d1f3      	bne.n	409b54 <_printf_float+0x408>
  409b6c:	e64a      	b.n	409804 <_printf_float+0xb8>
  409b6e:	2301      	movs	r3, #1
  409b70:	4642      	mov	r2, r8
  409b72:	4659      	mov	r1, fp
  409b74:	4628      	mov	r0, r5
  409b76:	47b0      	blx	r6
  409b78:	3001      	adds	r0, #1
  409b7a:	f43f ae43 	beq.w	409804 <_printf_float+0xb8>
  409b7e:	3701      	adds	r7, #1
  409b80:	e7e4      	b.n	409b4c <_printf_float+0x400>
  409b82:	2301      	movs	r3, #1
  409b84:	463a      	mov	r2, r7
  409b86:	e7ec      	b.n	409b62 <_printf_float+0x416>
  409b88:	2301      	movs	r3, #1
  409b8a:	4642      	mov	r2, r8
  409b8c:	4659      	mov	r1, fp
  409b8e:	4628      	mov	r0, r5
  409b90:	47b0      	blx	r6
  409b92:	3001      	adds	r0, #1
  409b94:	f43f ae36 	beq.w	409804 <_printf_float+0xb8>
  409b98:	3701      	adds	r7, #1
  409b9a:	e708      	b.n	4099ae <_printf_float+0x262>
  409b9c:	463a      	mov	r2, r7
  409b9e:	464b      	mov	r3, r9
  409ba0:	4638      	mov	r0, r7
  409ba2:	4649      	mov	r1, r9
  409ba4:	f002 ffa4 	bl	40caf0 <__aeabi_dcmpun>
  409ba8:	2800      	cmp	r0, #0
  409baa:	f43f ae30 	beq.w	40980e <_printf_float+0xc2>
  409bae:	4b01      	ldr	r3, [pc, #4]	; (409bb4 <_printf_float+0x468>)
  409bb0:	4f01      	ldr	r7, [pc, #4]	; (409bb8 <_printf_float+0x46c>)
  409bb2:	e612      	b.n	4097da <_printf_float+0x8e>
  409bb4:	0040dea0 	.word	0x0040dea0
  409bb8:	0040dea4 	.word	0x0040dea4

00409bbc <_printf_common>:
  409bbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  409bc0:	4691      	mov	r9, r2
  409bc2:	461f      	mov	r7, r3
  409bc4:	688a      	ldr	r2, [r1, #8]
  409bc6:	690b      	ldr	r3, [r1, #16]
  409bc8:	f8dd 8020 	ldr.w	r8, [sp, #32]
  409bcc:	4293      	cmp	r3, r2
  409bce:	bfb8      	it	lt
  409bd0:	4613      	movlt	r3, r2
  409bd2:	f8c9 3000 	str.w	r3, [r9]
  409bd6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  409bda:	4606      	mov	r6, r0
  409bdc:	460c      	mov	r4, r1
  409bde:	b112      	cbz	r2, 409be6 <_printf_common+0x2a>
  409be0:	3301      	adds	r3, #1
  409be2:	f8c9 3000 	str.w	r3, [r9]
  409be6:	6823      	ldr	r3, [r4, #0]
  409be8:	0699      	lsls	r1, r3, #26
  409bea:	bf42      	ittt	mi
  409bec:	f8d9 3000 	ldrmi.w	r3, [r9]
  409bf0:	3302      	addmi	r3, #2
  409bf2:	f8c9 3000 	strmi.w	r3, [r9]
  409bf6:	6825      	ldr	r5, [r4, #0]
  409bf8:	f015 0506 	ands.w	r5, r5, #6
  409bfc:	d107      	bne.n	409c0e <_printf_common+0x52>
  409bfe:	f104 0a19 	add.w	sl, r4, #25
  409c02:	68e3      	ldr	r3, [r4, #12]
  409c04:	f8d9 2000 	ldr.w	r2, [r9]
  409c08:	1a9b      	subs	r3, r3, r2
  409c0a:	429d      	cmp	r5, r3
  409c0c:	db29      	blt.n	409c62 <_printf_common+0xa6>
  409c0e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  409c12:	6822      	ldr	r2, [r4, #0]
  409c14:	3300      	adds	r3, #0
  409c16:	bf18      	it	ne
  409c18:	2301      	movne	r3, #1
  409c1a:	0692      	lsls	r2, r2, #26
  409c1c:	d42e      	bmi.n	409c7c <_printf_common+0xc0>
  409c1e:	f104 0243 	add.w	r2, r4, #67	; 0x43
  409c22:	4639      	mov	r1, r7
  409c24:	4630      	mov	r0, r6
  409c26:	47c0      	blx	r8
  409c28:	3001      	adds	r0, #1
  409c2a:	d021      	beq.n	409c70 <_printf_common+0xb4>
  409c2c:	6823      	ldr	r3, [r4, #0]
  409c2e:	68e5      	ldr	r5, [r4, #12]
  409c30:	f8d9 2000 	ldr.w	r2, [r9]
  409c34:	f003 0306 	and.w	r3, r3, #6
  409c38:	2b04      	cmp	r3, #4
  409c3a:	bf08      	it	eq
  409c3c:	1aad      	subeq	r5, r5, r2
  409c3e:	68a3      	ldr	r3, [r4, #8]
  409c40:	6922      	ldr	r2, [r4, #16]
  409c42:	bf0c      	ite	eq
  409c44:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  409c48:	2500      	movne	r5, #0
  409c4a:	4293      	cmp	r3, r2
  409c4c:	bfc4      	itt	gt
  409c4e:	1a9b      	subgt	r3, r3, r2
  409c50:	18ed      	addgt	r5, r5, r3
  409c52:	f04f 0900 	mov.w	r9, #0
  409c56:	341a      	adds	r4, #26
  409c58:	454d      	cmp	r5, r9
  409c5a:	d11b      	bne.n	409c94 <_printf_common+0xd8>
  409c5c:	2000      	movs	r0, #0
  409c5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409c62:	2301      	movs	r3, #1
  409c64:	4652      	mov	r2, sl
  409c66:	4639      	mov	r1, r7
  409c68:	4630      	mov	r0, r6
  409c6a:	47c0      	blx	r8
  409c6c:	3001      	adds	r0, #1
  409c6e:	d103      	bne.n	409c78 <_printf_common+0xbc>
  409c70:	f04f 30ff 	mov.w	r0, #4294967295
  409c74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409c78:	3501      	adds	r5, #1
  409c7a:	e7c2      	b.n	409c02 <_printf_common+0x46>
  409c7c:	18e1      	adds	r1, r4, r3
  409c7e:	1c5a      	adds	r2, r3, #1
  409c80:	2030      	movs	r0, #48	; 0x30
  409c82:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  409c86:	4422      	add	r2, r4
  409c88:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  409c8c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  409c90:	3302      	adds	r3, #2
  409c92:	e7c4      	b.n	409c1e <_printf_common+0x62>
  409c94:	2301      	movs	r3, #1
  409c96:	4622      	mov	r2, r4
  409c98:	4639      	mov	r1, r7
  409c9a:	4630      	mov	r0, r6
  409c9c:	47c0      	blx	r8
  409c9e:	3001      	adds	r0, #1
  409ca0:	d0e6      	beq.n	409c70 <_printf_common+0xb4>
  409ca2:	f109 0901 	add.w	r9, r9, #1
  409ca6:	e7d7      	b.n	409c58 <_printf_common+0x9c>

00409ca8 <_printf_i>:
  409ca8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  409cac:	4617      	mov	r7, r2
  409cae:	7e0a      	ldrb	r2, [r1, #24]
  409cb0:	b085      	sub	sp, #20
  409cb2:	2a6e      	cmp	r2, #110	; 0x6e
  409cb4:	4698      	mov	r8, r3
  409cb6:	4606      	mov	r6, r0
  409cb8:	460c      	mov	r4, r1
  409cba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  409cbc:	f101 0e43 	add.w	lr, r1, #67	; 0x43
  409cc0:	f000 80bc 	beq.w	409e3c <_printf_i+0x194>
  409cc4:	d81a      	bhi.n	409cfc <_printf_i+0x54>
  409cc6:	2a63      	cmp	r2, #99	; 0x63
  409cc8:	d02e      	beq.n	409d28 <_printf_i+0x80>
  409cca:	d80a      	bhi.n	409ce2 <_printf_i+0x3a>
  409ccc:	2a00      	cmp	r2, #0
  409cce:	f000 80c8 	beq.w	409e62 <_printf_i+0x1ba>
  409cd2:	2a58      	cmp	r2, #88	; 0x58
  409cd4:	f000 808a 	beq.w	409dec <_printf_i+0x144>
  409cd8:	f104 0542 	add.w	r5, r4, #66	; 0x42
  409cdc:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  409ce0:	e02a      	b.n	409d38 <_printf_i+0x90>
  409ce2:	2a64      	cmp	r2, #100	; 0x64
  409ce4:	d001      	beq.n	409cea <_printf_i+0x42>
  409ce6:	2a69      	cmp	r2, #105	; 0x69
  409ce8:	d1f6      	bne.n	409cd8 <_printf_i+0x30>
  409cea:	6821      	ldr	r1, [r4, #0]
  409cec:	681a      	ldr	r2, [r3, #0]
  409cee:	f011 0f80 	tst.w	r1, #128	; 0x80
  409cf2:	d023      	beq.n	409d3c <_printf_i+0x94>
  409cf4:	1d11      	adds	r1, r2, #4
  409cf6:	6019      	str	r1, [r3, #0]
  409cf8:	6813      	ldr	r3, [r2, #0]
  409cfa:	e027      	b.n	409d4c <_printf_i+0xa4>
  409cfc:	2a73      	cmp	r2, #115	; 0x73
  409cfe:	f000 80b4 	beq.w	409e6a <_printf_i+0x1c2>
  409d02:	d808      	bhi.n	409d16 <_printf_i+0x6e>
  409d04:	2a6f      	cmp	r2, #111	; 0x6f
  409d06:	d02a      	beq.n	409d5e <_printf_i+0xb6>
  409d08:	2a70      	cmp	r2, #112	; 0x70
  409d0a:	d1e5      	bne.n	409cd8 <_printf_i+0x30>
  409d0c:	680a      	ldr	r2, [r1, #0]
  409d0e:	f042 0220 	orr.w	r2, r2, #32
  409d12:	600a      	str	r2, [r1, #0]
  409d14:	e003      	b.n	409d1e <_printf_i+0x76>
  409d16:	2a75      	cmp	r2, #117	; 0x75
  409d18:	d021      	beq.n	409d5e <_printf_i+0xb6>
  409d1a:	2a78      	cmp	r2, #120	; 0x78
  409d1c:	d1dc      	bne.n	409cd8 <_printf_i+0x30>
  409d1e:	2278      	movs	r2, #120	; 0x78
  409d20:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
  409d24:	496e      	ldr	r1, [pc, #440]	; (409ee0 <_printf_i+0x238>)
  409d26:	e064      	b.n	409df2 <_printf_i+0x14a>
  409d28:	681a      	ldr	r2, [r3, #0]
  409d2a:	f101 0542 	add.w	r5, r1, #66	; 0x42
  409d2e:	1d11      	adds	r1, r2, #4
  409d30:	6019      	str	r1, [r3, #0]
  409d32:	6813      	ldr	r3, [r2, #0]
  409d34:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  409d38:	2301      	movs	r3, #1
  409d3a:	e0a3      	b.n	409e84 <_printf_i+0x1dc>
  409d3c:	f011 0f40 	tst.w	r1, #64	; 0x40
  409d40:	f102 0104 	add.w	r1, r2, #4
  409d44:	6019      	str	r1, [r3, #0]
  409d46:	d0d7      	beq.n	409cf8 <_printf_i+0x50>
  409d48:	f9b2 3000 	ldrsh.w	r3, [r2]
  409d4c:	2b00      	cmp	r3, #0
  409d4e:	da03      	bge.n	409d58 <_printf_i+0xb0>
  409d50:	222d      	movs	r2, #45	; 0x2d
  409d52:	425b      	negs	r3, r3
  409d54:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
  409d58:	4962      	ldr	r1, [pc, #392]	; (409ee4 <_printf_i+0x23c>)
  409d5a:	220a      	movs	r2, #10
  409d5c:	e017      	b.n	409d8e <_printf_i+0xe6>
  409d5e:	6820      	ldr	r0, [r4, #0]
  409d60:	6819      	ldr	r1, [r3, #0]
  409d62:	f010 0f80 	tst.w	r0, #128	; 0x80
  409d66:	d003      	beq.n	409d70 <_printf_i+0xc8>
  409d68:	1d08      	adds	r0, r1, #4
  409d6a:	6018      	str	r0, [r3, #0]
  409d6c:	680b      	ldr	r3, [r1, #0]
  409d6e:	e006      	b.n	409d7e <_printf_i+0xd6>
  409d70:	f010 0f40 	tst.w	r0, #64	; 0x40
  409d74:	f101 0004 	add.w	r0, r1, #4
  409d78:	6018      	str	r0, [r3, #0]
  409d7a:	d0f7      	beq.n	409d6c <_printf_i+0xc4>
  409d7c:	880b      	ldrh	r3, [r1, #0]
  409d7e:	4959      	ldr	r1, [pc, #356]	; (409ee4 <_printf_i+0x23c>)
  409d80:	2a6f      	cmp	r2, #111	; 0x6f
  409d82:	bf14      	ite	ne
  409d84:	220a      	movne	r2, #10
  409d86:	2208      	moveq	r2, #8
  409d88:	2000      	movs	r0, #0
  409d8a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  409d8e:	6865      	ldr	r5, [r4, #4]
  409d90:	60a5      	str	r5, [r4, #8]
  409d92:	2d00      	cmp	r5, #0
  409d94:	f2c0 809c 	blt.w	409ed0 <_printf_i+0x228>
  409d98:	6820      	ldr	r0, [r4, #0]
  409d9a:	f020 0004 	bic.w	r0, r0, #4
  409d9e:	6020      	str	r0, [r4, #0]
  409da0:	2b00      	cmp	r3, #0
  409da2:	d13f      	bne.n	409e24 <_printf_i+0x17c>
  409da4:	2d00      	cmp	r5, #0
  409da6:	f040 8095 	bne.w	409ed4 <_printf_i+0x22c>
  409daa:	4675      	mov	r5, lr
  409dac:	2a08      	cmp	r2, #8
  409dae:	d10b      	bne.n	409dc8 <_printf_i+0x120>
  409db0:	6823      	ldr	r3, [r4, #0]
  409db2:	07da      	lsls	r2, r3, #31
  409db4:	d508      	bpl.n	409dc8 <_printf_i+0x120>
  409db6:	6923      	ldr	r3, [r4, #16]
  409db8:	6862      	ldr	r2, [r4, #4]
  409dba:	429a      	cmp	r2, r3
  409dbc:	bfde      	ittt	le
  409dbe:	2330      	movle	r3, #48	; 0x30
  409dc0:	f805 3c01 	strble.w	r3, [r5, #-1]
  409dc4:	f105 35ff 	addle.w	r5, r5, #4294967295
  409dc8:	ebae 0305 	sub.w	r3, lr, r5
  409dcc:	6123      	str	r3, [r4, #16]
  409dce:	f8cd 8000 	str.w	r8, [sp]
  409dd2:	463b      	mov	r3, r7
  409dd4:	aa03      	add	r2, sp, #12
  409dd6:	4621      	mov	r1, r4
  409dd8:	4630      	mov	r0, r6
  409dda:	f7ff feef 	bl	409bbc <_printf_common>
  409dde:	3001      	adds	r0, #1
  409de0:	d155      	bne.n	409e8e <_printf_i+0x1e6>
  409de2:	f04f 30ff 	mov.w	r0, #4294967295
  409de6:	b005      	add	sp, #20
  409de8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  409dec:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
  409df0:	493c      	ldr	r1, [pc, #240]	; (409ee4 <_printf_i+0x23c>)
  409df2:	6822      	ldr	r2, [r4, #0]
  409df4:	6818      	ldr	r0, [r3, #0]
  409df6:	f012 0f80 	tst.w	r2, #128	; 0x80
  409dfa:	f100 0504 	add.w	r5, r0, #4
  409dfe:	601d      	str	r5, [r3, #0]
  409e00:	d001      	beq.n	409e06 <_printf_i+0x15e>
  409e02:	6803      	ldr	r3, [r0, #0]
  409e04:	e002      	b.n	409e0c <_printf_i+0x164>
  409e06:	0655      	lsls	r5, r2, #25
  409e08:	d5fb      	bpl.n	409e02 <_printf_i+0x15a>
  409e0a:	8803      	ldrh	r3, [r0, #0]
  409e0c:	07d0      	lsls	r0, r2, #31
  409e0e:	bf44      	itt	mi
  409e10:	f042 0220 	orrmi.w	r2, r2, #32
  409e14:	6022      	strmi	r2, [r4, #0]
  409e16:	b91b      	cbnz	r3, 409e20 <_printf_i+0x178>
  409e18:	6822      	ldr	r2, [r4, #0]
  409e1a:	f022 0220 	bic.w	r2, r2, #32
  409e1e:	6022      	str	r2, [r4, #0]
  409e20:	2210      	movs	r2, #16
  409e22:	e7b1      	b.n	409d88 <_printf_i+0xe0>
  409e24:	4675      	mov	r5, lr
  409e26:	fbb3 f0f2 	udiv	r0, r3, r2
  409e2a:	fb02 3310 	mls	r3, r2, r0, r3
  409e2e:	5ccb      	ldrb	r3, [r1, r3]
  409e30:	f805 3d01 	strb.w	r3, [r5, #-1]!
  409e34:	4603      	mov	r3, r0
  409e36:	2800      	cmp	r0, #0
  409e38:	d1f5      	bne.n	409e26 <_printf_i+0x17e>
  409e3a:	e7b7      	b.n	409dac <_printf_i+0x104>
  409e3c:	6808      	ldr	r0, [r1, #0]
  409e3e:	681a      	ldr	r2, [r3, #0]
  409e40:	6949      	ldr	r1, [r1, #20]
  409e42:	f010 0f80 	tst.w	r0, #128	; 0x80
  409e46:	d004      	beq.n	409e52 <_printf_i+0x1aa>
  409e48:	1d10      	adds	r0, r2, #4
  409e4a:	6018      	str	r0, [r3, #0]
  409e4c:	6813      	ldr	r3, [r2, #0]
  409e4e:	6019      	str	r1, [r3, #0]
  409e50:	e007      	b.n	409e62 <_printf_i+0x1ba>
  409e52:	f010 0f40 	tst.w	r0, #64	; 0x40
  409e56:	f102 0004 	add.w	r0, r2, #4
  409e5a:	6018      	str	r0, [r3, #0]
  409e5c:	6813      	ldr	r3, [r2, #0]
  409e5e:	d0f6      	beq.n	409e4e <_printf_i+0x1a6>
  409e60:	8019      	strh	r1, [r3, #0]
  409e62:	2300      	movs	r3, #0
  409e64:	6123      	str	r3, [r4, #16]
  409e66:	4675      	mov	r5, lr
  409e68:	e7b1      	b.n	409dce <_printf_i+0x126>
  409e6a:	681a      	ldr	r2, [r3, #0]
  409e6c:	1d11      	adds	r1, r2, #4
  409e6e:	6019      	str	r1, [r3, #0]
  409e70:	6815      	ldr	r5, [r2, #0]
  409e72:	6862      	ldr	r2, [r4, #4]
  409e74:	2100      	movs	r1, #0
  409e76:	4628      	mov	r0, r5
  409e78:	f001 f99a 	bl	40b1b0 <memchr>
  409e7c:	b108      	cbz	r0, 409e82 <_printf_i+0x1da>
  409e7e:	1b40      	subs	r0, r0, r5
  409e80:	6060      	str	r0, [r4, #4]
  409e82:	6863      	ldr	r3, [r4, #4]
  409e84:	6123      	str	r3, [r4, #16]
  409e86:	2300      	movs	r3, #0
  409e88:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  409e8c:	e79f      	b.n	409dce <_printf_i+0x126>
  409e8e:	6923      	ldr	r3, [r4, #16]
  409e90:	462a      	mov	r2, r5
  409e92:	4639      	mov	r1, r7
  409e94:	4630      	mov	r0, r6
  409e96:	47c0      	blx	r8
  409e98:	3001      	adds	r0, #1
  409e9a:	d0a2      	beq.n	409de2 <_printf_i+0x13a>
  409e9c:	6823      	ldr	r3, [r4, #0]
  409e9e:	079b      	lsls	r3, r3, #30
  409ea0:	d507      	bpl.n	409eb2 <_printf_i+0x20a>
  409ea2:	2500      	movs	r5, #0
  409ea4:	f104 0919 	add.w	r9, r4, #25
  409ea8:	68e3      	ldr	r3, [r4, #12]
  409eaa:	9a03      	ldr	r2, [sp, #12]
  409eac:	1a9b      	subs	r3, r3, r2
  409eae:	429d      	cmp	r5, r3
  409eb0:	db05      	blt.n	409ebe <_printf_i+0x216>
  409eb2:	68e0      	ldr	r0, [r4, #12]
  409eb4:	9b03      	ldr	r3, [sp, #12]
  409eb6:	4298      	cmp	r0, r3
  409eb8:	bfb8      	it	lt
  409eba:	4618      	movlt	r0, r3
  409ebc:	e793      	b.n	409de6 <_printf_i+0x13e>
  409ebe:	2301      	movs	r3, #1
  409ec0:	464a      	mov	r2, r9
  409ec2:	4639      	mov	r1, r7
  409ec4:	4630      	mov	r0, r6
  409ec6:	47c0      	blx	r8
  409ec8:	3001      	adds	r0, #1
  409eca:	d08a      	beq.n	409de2 <_printf_i+0x13a>
  409ecc:	3501      	adds	r5, #1
  409ece:	e7eb      	b.n	409ea8 <_printf_i+0x200>
  409ed0:	2b00      	cmp	r3, #0
  409ed2:	d1a7      	bne.n	409e24 <_printf_i+0x17c>
  409ed4:	780b      	ldrb	r3, [r1, #0]
  409ed6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  409eda:	f104 0542 	add.w	r5, r4, #66	; 0x42
  409ede:	e765      	b.n	409dac <_printf_i+0x104>
  409ee0:	0040debb 	.word	0x0040debb
  409ee4:	0040deaa 	.word	0x0040deaa

00409ee8 <iprintf>:
  409ee8:	b40f      	push	{r0, r1, r2, r3}
  409eea:	4b0a      	ldr	r3, [pc, #40]	; (409f14 <iprintf+0x2c>)
  409eec:	b513      	push	{r0, r1, r4, lr}
  409eee:	681c      	ldr	r4, [r3, #0]
  409ef0:	b124      	cbz	r4, 409efc <iprintf+0x14>
  409ef2:	69a3      	ldr	r3, [r4, #24]
  409ef4:	b913      	cbnz	r3, 409efc <iprintf+0x14>
  409ef6:	4620      	mov	r0, r4
  409ef8:	f001 f852 	bl	40afa0 <__sinit>
  409efc:	ab05      	add	r3, sp, #20
  409efe:	9a04      	ldr	r2, [sp, #16]
  409f00:	68a1      	ldr	r1, [r4, #8]
  409f02:	9301      	str	r3, [sp, #4]
  409f04:	4620      	mov	r0, r4
  409f06:	f001 fea5 	bl	40bc54 <_vfiprintf_r>
  409f0a:	b002      	add	sp, #8
  409f0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  409f10:	b004      	add	sp, #16
  409f12:	4770      	bx	lr
  409f14:	20000178 	.word	0x20000178

00409f18 <setbuf>:
  409f18:	2900      	cmp	r1, #0
  409f1a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  409f1e:	bf0c      	ite	eq
  409f20:	2202      	moveq	r2, #2
  409f22:	2200      	movne	r2, #0
  409f24:	f000 b800 	b.w	409f28 <setvbuf>

00409f28 <setvbuf>:
  409f28:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  409f2c:	461d      	mov	r5, r3
  409f2e:	4b51      	ldr	r3, [pc, #324]	; (40a074 <setvbuf+0x14c>)
  409f30:	681e      	ldr	r6, [r3, #0]
  409f32:	4604      	mov	r4, r0
  409f34:	460f      	mov	r7, r1
  409f36:	4690      	mov	r8, r2
  409f38:	b126      	cbz	r6, 409f44 <setvbuf+0x1c>
  409f3a:	69b3      	ldr	r3, [r6, #24]
  409f3c:	b913      	cbnz	r3, 409f44 <setvbuf+0x1c>
  409f3e:	4630      	mov	r0, r6
  409f40:	f001 f82e 	bl	40afa0 <__sinit>
  409f44:	4b4c      	ldr	r3, [pc, #304]	; (40a078 <setvbuf+0x150>)
  409f46:	429c      	cmp	r4, r3
  409f48:	d152      	bne.n	409ff0 <setvbuf+0xc8>
  409f4a:	6874      	ldr	r4, [r6, #4]
  409f4c:	f1b8 0f02 	cmp.w	r8, #2
  409f50:	d006      	beq.n	409f60 <setvbuf+0x38>
  409f52:	f1b8 0f01 	cmp.w	r8, #1
  409f56:	f200 8089 	bhi.w	40a06c <setvbuf+0x144>
  409f5a:	2d00      	cmp	r5, #0
  409f5c:	f2c0 8086 	blt.w	40a06c <setvbuf+0x144>
  409f60:	4621      	mov	r1, r4
  409f62:	4630      	mov	r0, r6
  409f64:	f000 ffb2 	bl	40aecc <_fflush_r>
  409f68:	6b61      	ldr	r1, [r4, #52]	; 0x34
  409f6a:	b141      	cbz	r1, 409f7e <setvbuf+0x56>
  409f6c:	f104 0344 	add.w	r3, r4, #68	; 0x44
  409f70:	4299      	cmp	r1, r3
  409f72:	d002      	beq.n	409f7a <setvbuf+0x52>
  409f74:	4630      	mov	r0, r6
  409f76:	f001 fc49 	bl	40b80c <_free_r>
  409f7a:	2300      	movs	r3, #0
  409f7c:	6363      	str	r3, [r4, #52]	; 0x34
  409f7e:	2300      	movs	r3, #0
  409f80:	61a3      	str	r3, [r4, #24]
  409f82:	6063      	str	r3, [r4, #4]
  409f84:	89a3      	ldrh	r3, [r4, #12]
  409f86:	061b      	lsls	r3, r3, #24
  409f88:	d503      	bpl.n	409f92 <setvbuf+0x6a>
  409f8a:	6921      	ldr	r1, [r4, #16]
  409f8c:	4630      	mov	r0, r6
  409f8e:	f001 fc3d 	bl	40b80c <_free_r>
  409f92:	89a3      	ldrh	r3, [r4, #12]
  409f94:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  409f98:	f023 0303 	bic.w	r3, r3, #3
  409f9c:	f1b8 0f02 	cmp.w	r8, #2
  409fa0:	81a3      	strh	r3, [r4, #12]
  409fa2:	d05d      	beq.n	40a060 <setvbuf+0x138>
  409fa4:	ab01      	add	r3, sp, #4
  409fa6:	466a      	mov	r2, sp
  409fa8:	4621      	mov	r1, r4
  409faa:	4630      	mov	r0, r6
  409fac:	f001 f890 	bl	40b0d0 <__swhatbuf_r>
  409fb0:	89a3      	ldrh	r3, [r4, #12]
  409fb2:	4318      	orrs	r0, r3
  409fb4:	81a0      	strh	r0, [r4, #12]
  409fb6:	bb2d      	cbnz	r5, 40a004 <setvbuf+0xdc>
  409fb8:	9d00      	ldr	r5, [sp, #0]
  409fba:	4628      	mov	r0, r5
  409fbc:	f001 f8ec 	bl	40b198 <malloc>
  409fc0:	4607      	mov	r7, r0
  409fc2:	2800      	cmp	r0, #0
  409fc4:	d14e      	bne.n	40a064 <setvbuf+0x13c>
  409fc6:	f8dd 9000 	ldr.w	r9, [sp]
  409fca:	45a9      	cmp	r9, r5
  409fcc:	d13c      	bne.n	40a048 <setvbuf+0x120>
  409fce:	f04f 30ff 	mov.w	r0, #4294967295
  409fd2:	89a3      	ldrh	r3, [r4, #12]
  409fd4:	f043 0302 	orr.w	r3, r3, #2
  409fd8:	81a3      	strh	r3, [r4, #12]
  409fda:	2300      	movs	r3, #0
  409fdc:	60a3      	str	r3, [r4, #8]
  409fde:	f104 0347 	add.w	r3, r4, #71	; 0x47
  409fe2:	6023      	str	r3, [r4, #0]
  409fe4:	6123      	str	r3, [r4, #16]
  409fe6:	2301      	movs	r3, #1
  409fe8:	6163      	str	r3, [r4, #20]
  409fea:	b003      	add	sp, #12
  409fec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  409ff0:	4b22      	ldr	r3, [pc, #136]	; (40a07c <setvbuf+0x154>)
  409ff2:	429c      	cmp	r4, r3
  409ff4:	d101      	bne.n	409ffa <setvbuf+0xd2>
  409ff6:	68b4      	ldr	r4, [r6, #8]
  409ff8:	e7a8      	b.n	409f4c <setvbuf+0x24>
  409ffa:	4b21      	ldr	r3, [pc, #132]	; (40a080 <setvbuf+0x158>)
  409ffc:	429c      	cmp	r4, r3
  409ffe:	bf08      	it	eq
  40a000:	68f4      	ldreq	r4, [r6, #12]
  40a002:	e7a3      	b.n	409f4c <setvbuf+0x24>
  40a004:	2f00      	cmp	r7, #0
  40a006:	d0d8      	beq.n	409fba <setvbuf+0x92>
  40a008:	69b3      	ldr	r3, [r6, #24]
  40a00a:	b913      	cbnz	r3, 40a012 <setvbuf+0xea>
  40a00c:	4630      	mov	r0, r6
  40a00e:	f000 ffc7 	bl	40afa0 <__sinit>
  40a012:	f1b8 0f01 	cmp.w	r8, #1
  40a016:	bf08      	it	eq
  40a018:	89a3      	ldrheq	r3, [r4, #12]
  40a01a:	6027      	str	r7, [r4, #0]
  40a01c:	bf04      	itt	eq
  40a01e:	f043 0301 	orreq.w	r3, r3, #1
  40a022:	81a3      	strheq	r3, [r4, #12]
  40a024:	89a3      	ldrh	r3, [r4, #12]
  40a026:	6127      	str	r7, [r4, #16]
  40a028:	f013 0008 	ands.w	r0, r3, #8
  40a02c:	6165      	str	r5, [r4, #20]
  40a02e:	d01b      	beq.n	40a068 <setvbuf+0x140>
  40a030:	f013 0001 	ands.w	r0, r3, #1
  40a034:	bf18      	it	ne
  40a036:	426d      	negne	r5, r5
  40a038:	f04f 0300 	mov.w	r3, #0
  40a03c:	bf1d      	ittte	ne
  40a03e:	60a3      	strne	r3, [r4, #8]
  40a040:	61a5      	strne	r5, [r4, #24]
  40a042:	4618      	movne	r0, r3
  40a044:	60a5      	streq	r5, [r4, #8]
  40a046:	e7d0      	b.n	409fea <setvbuf+0xc2>
  40a048:	4648      	mov	r0, r9
  40a04a:	f001 f8a5 	bl	40b198 <malloc>
  40a04e:	4607      	mov	r7, r0
  40a050:	2800      	cmp	r0, #0
  40a052:	d0bc      	beq.n	409fce <setvbuf+0xa6>
  40a054:	89a3      	ldrh	r3, [r4, #12]
  40a056:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40a05a:	81a3      	strh	r3, [r4, #12]
  40a05c:	464d      	mov	r5, r9
  40a05e:	e7d3      	b.n	40a008 <setvbuf+0xe0>
  40a060:	2000      	movs	r0, #0
  40a062:	e7b6      	b.n	409fd2 <setvbuf+0xaa>
  40a064:	46a9      	mov	r9, r5
  40a066:	e7f5      	b.n	40a054 <setvbuf+0x12c>
  40a068:	60a0      	str	r0, [r4, #8]
  40a06a:	e7be      	b.n	409fea <setvbuf+0xc2>
  40a06c:	f04f 30ff 	mov.w	r0, #4294967295
  40a070:	e7bb      	b.n	409fea <setvbuf+0xc2>
  40a072:	bf00      	nop
  40a074:	20000178 	.word	0x20000178
  40a078:	0040defc 	.word	0x0040defc
  40a07c:	0040df1c 	.word	0x0040df1c
  40a080:	0040dedc 	.word	0x0040dedc

0040a084 <sniprintf>:
  40a084:	b40c      	push	{r2, r3}
  40a086:	b530      	push	{r4, r5, lr}
  40a088:	4b17      	ldr	r3, [pc, #92]	; (40a0e8 <sniprintf+0x64>)
  40a08a:	1e0c      	subs	r4, r1, #0
  40a08c:	b09d      	sub	sp, #116	; 0x74
  40a08e:	681d      	ldr	r5, [r3, #0]
  40a090:	da08      	bge.n	40a0a4 <sniprintf+0x20>
  40a092:	238b      	movs	r3, #139	; 0x8b
  40a094:	602b      	str	r3, [r5, #0]
  40a096:	f04f 30ff 	mov.w	r0, #4294967295
  40a09a:	b01d      	add	sp, #116	; 0x74
  40a09c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  40a0a0:	b002      	add	sp, #8
  40a0a2:	4770      	bx	lr
  40a0a4:	f44f 7302 	mov.w	r3, #520	; 0x208
  40a0a8:	f8ad 3014 	strh.w	r3, [sp, #20]
  40a0ac:	bf14      	ite	ne
  40a0ae:	f104 33ff 	addne.w	r3, r4, #4294967295
  40a0b2:	4623      	moveq	r3, r4
  40a0b4:	9304      	str	r3, [sp, #16]
  40a0b6:	9307      	str	r3, [sp, #28]
  40a0b8:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40a0bc:	9002      	str	r0, [sp, #8]
  40a0be:	9006      	str	r0, [sp, #24]
  40a0c0:	f8ad 3016 	strh.w	r3, [sp, #22]
  40a0c4:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40a0c6:	ab21      	add	r3, sp, #132	; 0x84
  40a0c8:	a902      	add	r1, sp, #8
  40a0ca:	4628      	mov	r0, r5
  40a0cc:	9301      	str	r3, [sp, #4]
  40a0ce:	f001 fca5 	bl	40ba1c <_svfiprintf_r>
  40a0d2:	1c43      	adds	r3, r0, #1
  40a0d4:	bfbc      	itt	lt
  40a0d6:	238b      	movlt	r3, #139	; 0x8b
  40a0d8:	602b      	strlt	r3, [r5, #0]
  40a0da:	2c00      	cmp	r4, #0
  40a0dc:	d0dd      	beq.n	40a09a <sniprintf+0x16>
  40a0de:	9b02      	ldr	r3, [sp, #8]
  40a0e0:	2200      	movs	r2, #0
  40a0e2:	701a      	strb	r2, [r3, #0]
  40a0e4:	e7d9      	b.n	40a09a <sniprintf+0x16>
  40a0e6:	bf00      	nop
  40a0e8:	20000178 	.word	0x20000178

0040a0ec <strlen>:
  40a0ec:	4603      	mov	r3, r0
  40a0ee:	f813 2b01 	ldrb.w	r2, [r3], #1
  40a0f2:	2a00      	cmp	r2, #0
  40a0f4:	d1fb      	bne.n	40a0ee <strlen+0x2>
  40a0f6:	1a18      	subs	r0, r3, r0
  40a0f8:	3801      	subs	r0, #1
  40a0fa:	4770      	bx	lr

0040a0fc <quorem>:
  40a0fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a100:	6903      	ldr	r3, [r0, #16]
  40a102:	690c      	ldr	r4, [r1, #16]
  40a104:	429c      	cmp	r4, r3
  40a106:	4680      	mov	r8, r0
  40a108:	f300 8082 	bgt.w	40a210 <quorem+0x114>
  40a10c:	3c01      	subs	r4, #1
  40a10e:	f101 0714 	add.w	r7, r1, #20
  40a112:	ea4f 0e84 	mov.w	lr, r4, lsl #2
  40a116:	f100 0614 	add.w	r6, r0, #20
  40a11a:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
  40a11e:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
  40a122:	eb06 030e 	add.w	r3, r6, lr
  40a126:	3501      	adds	r5, #1
  40a128:	eb07 090e 	add.w	r9, r7, lr
  40a12c:	9301      	str	r3, [sp, #4]
  40a12e:	fbb0 f5f5 	udiv	r5, r0, r5
  40a132:	b395      	cbz	r5, 40a19a <quorem+0x9e>
  40a134:	f04f 0a00 	mov.w	sl, #0
  40a138:	4638      	mov	r0, r7
  40a13a:	46b4      	mov	ip, r6
  40a13c:	46d3      	mov	fp, sl
  40a13e:	f850 2b04 	ldr.w	r2, [r0], #4
  40a142:	b293      	uxth	r3, r2
  40a144:	fb05 a303 	mla	r3, r5, r3, sl
  40a148:	ea4f 4a13 	mov.w	sl, r3, lsr #16
  40a14c:	b29b      	uxth	r3, r3
  40a14e:	ebab 0303 	sub.w	r3, fp, r3
  40a152:	0c12      	lsrs	r2, r2, #16
  40a154:	f8bc b000 	ldrh.w	fp, [ip]
  40a158:	fb05 a202 	mla	r2, r5, r2, sl
  40a15c:	fa13 f38b 	uxtah	r3, r3, fp
  40a160:	ea4f 4a12 	mov.w	sl, r2, lsr #16
  40a164:	fa1f fb82 	uxth.w	fp, r2
  40a168:	f8dc 2000 	ldr.w	r2, [ip]
  40a16c:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
  40a170:	eb02 4223 	add.w	r2, r2, r3, asr #16
  40a174:	b29b      	uxth	r3, r3
  40a176:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40a17a:	4581      	cmp	r9, r0
  40a17c:	ea4f 4b22 	mov.w	fp, r2, asr #16
  40a180:	f84c 3b04 	str.w	r3, [ip], #4
  40a184:	d2db      	bcs.n	40a13e <quorem+0x42>
  40a186:	f856 300e 	ldr.w	r3, [r6, lr]
  40a18a:	b933      	cbnz	r3, 40a19a <quorem+0x9e>
  40a18c:	9b01      	ldr	r3, [sp, #4]
  40a18e:	3b04      	subs	r3, #4
  40a190:	429e      	cmp	r6, r3
  40a192:	461a      	mov	r2, r3
  40a194:	d330      	bcc.n	40a1f8 <quorem+0xfc>
  40a196:	f8c8 4010 	str.w	r4, [r8, #16]
  40a19a:	4640      	mov	r0, r8
  40a19c:	f001 fa61 	bl	40b662 <__mcmp>
  40a1a0:	2800      	cmp	r0, #0
  40a1a2:	db25      	blt.n	40a1f0 <quorem+0xf4>
  40a1a4:	3501      	adds	r5, #1
  40a1a6:	4630      	mov	r0, r6
  40a1a8:	f04f 0e00 	mov.w	lr, #0
  40a1ac:	f857 2b04 	ldr.w	r2, [r7], #4
  40a1b0:	f8d0 c000 	ldr.w	ip, [r0]
  40a1b4:	b293      	uxth	r3, r2
  40a1b6:	ebae 0303 	sub.w	r3, lr, r3
  40a1ba:	0c12      	lsrs	r2, r2, #16
  40a1bc:	fa13 f38c 	uxtah	r3, r3, ip
  40a1c0:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
  40a1c4:	eb02 4223 	add.w	r2, r2, r3, asr #16
  40a1c8:	b29b      	uxth	r3, r3
  40a1ca:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40a1ce:	45b9      	cmp	r9, r7
  40a1d0:	ea4f 4e22 	mov.w	lr, r2, asr #16
  40a1d4:	f840 3b04 	str.w	r3, [r0], #4
  40a1d8:	d2e8      	bcs.n	40a1ac <quorem+0xb0>
  40a1da:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
  40a1de:	eb06 0384 	add.w	r3, r6, r4, lsl #2
  40a1e2:	b92a      	cbnz	r2, 40a1f0 <quorem+0xf4>
  40a1e4:	3b04      	subs	r3, #4
  40a1e6:	429e      	cmp	r6, r3
  40a1e8:	461a      	mov	r2, r3
  40a1ea:	d30b      	bcc.n	40a204 <quorem+0x108>
  40a1ec:	f8c8 4010 	str.w	r4, [r8, #16]
  40a1f0:	4628      	mov	r0, r5
  40a1f2:	b003      	add	sp, #12
  40a1f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a1f8:	6812      	ldr	r2, [r2, #0]
  40a1fa:	3b04      	subs	r3, #4
  40a1fc:	2a00      	cmp	r2, #0
  40a1fe:	d1ca      	bne.n	40a196 <quorem+0x9a>
  40a200:	3c01      	subs	r4, #1
  40a202:	e7c5      	b.n	40a190 <quorem+0x94>
  40a204:	6812      	ldr	r2, [r2, #0]
  40a206:	3b04      	subs	r3, #4
  40a208:	2a00      	cmp	r2, #0
  40a20a:	d1ef      	bne.n	40a1ec <quorem+0xf0>
  40a20c:	3c01      	subs	r4, #1
  40a20e:	e7ea      	b.n	40a1e6 <quorem+0xea>
  40a210:	2000      	movs	r0, #0
  40a212:	e7ee      	b.n	40a1f2 <quorem+0xf6>
  40a214:	0000      	movs	r0, r0
	...

0040a218 <_dtoa_r>:
  40a218:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a21c:	6a46      	ldr	r6, [r0, #36]	; 0x24
  40a21e:	b095      	sub	sp, #84	; 0x54
  40a220:	4604      	mov	r4, r0
  40a222:	9d21      	ldr	r5, [sp, #132]	; 0x84
  40a224:	e9cd 2302 	strd	r2, r3, [sp, #8]
  40a228:	b93e      	cbnz	r6, 40a23a <_dtoa_r+0x22>
  40a22a:	2010      	movs	r0, #16
  40a22c:	f000 ffb4 	bl	40b198 <malloc>
  40a230:	6260      	str	r0, [r4, #36]	; 0x24
  40a232:	6046      	str	r6, [r0, #4]
  40a234:	6086      	str	r6, [r0, #8]
  40a236:	6006      	str	r6, [r0, #0]
  40a238:	60c6      	str	r6, [r0, #12]
  40a23a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a23c:	6819      	ldr	r1, [r3, #0]
  40a23e:	b151      	cbz	r1, 40a256 <_dtoa_r+0x3e>
  40a240:	685a      	ldr	r2, [r3, #4]
  40a242:	604a      	str	r2, [r1, #4]
  40a244:	2301      	movs	r3, #1
  40a246:	4093      	lsls	r3, r2
  40a248:	608b      	str	r3, [r1, #8]
  40a24a:	4620      	mov	r0, r4
  40a24c:	f001 f834 	bl	40b2b8 <_Bfree>
  40a250:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a252:	2200      	movs	r2, #0
  40a254:	601a      	str	r2, [r3, #0]
  40a256:	9b03      	ldr	r3, [sp, #12]
  40a258:	2b00      	cmp	r3, #0
  40a25a:	bfbf      	itttt	lt
  40a25c:	2301      	movlt	r3, #1
  40a25e:	602b      	strlt	r3, [r5, #0]
  40a260:	9b03      	ldrlt	r3, [sp, #12]
  40a262:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
  40a266:	bfb2      	itee	lt
  40a268:	9303      	strlt	r3, [sp, #12]
  40a26a:	2300      	movge	r3, #0
  40a26c:	602b      	strge	r3, [r5, #0]
  40a26e:	f8dd 900c 	ldr.w	r9, [sp, #12]
  40a272:	4ba9      	ldr	r3, [pc, #676]	; (40a518 <_dtoa_r+0x300>)
  40a274:	ea33 0309 	bics.w	r3, r3, r9
  40a278:	d11b      	bne.n	40a2b2 <_dtoa_r+0x9a>
  40a27a:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40a27c:	f242 730f 	movw	r3, #9999	; 0x270f
  40a280:	6013      	str	r3, [r2, #0]
  40a282:	9b02      	ldr	r3, [sp, #8]
  40a284:	b923      	cbnz	r3, 40a290 <_dtoa_r+0x78>
  40a286:	f3c9 0013 	ubfx	r0, r9, #0, #20
  40a28a:	2800      	cmp	r0, #0
  40a28c:	f000 8581 	beq.w	40ad92 <_dtoa_r+0xb7a>
  40a290:	9b22      	ldr	r3, [sp, #136]	; 0x88
  40a292:	b953      	cbnz	r3, 40a2aa <_dtoa_r+0x92>
  40a294:	4ba1      	ldr	r3, [pc, #644]	; (40a51c <_dtoa_r+0x304>)
  40a296:	e021      	b.n	40a2dc <_dtoa_r+0xc4>
  40a298:	4ba1      	ldr	r3, [pc, #644]	; (40a520 <_dtoa_r+0x308>)
  40a29a:	9306      	str	r3, [sp, #24]
  40a29c:	3308      	adds	r3, #8
  40a29e:	9a22      	ldr	r2, [sp, #136]	; 0x88
  40a2a0:	6013      	str	r3, [r2, #0]
  40a2a2:	9806      	ldr	r0, [sp, #24]
  40a2a4:	b015      	add	sp, #84	; 0x54
  40a2a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a2aa:	4b9c      	ldr	r3, [pc, #624]	; (40a51c <_dtoa_r+0x304>)
  40a2ac:	9306      	str	r3, [sp, #24]
  40a2ae:	3303      	adds	r3, #3
  40a2b0:	e7f5      	b.n	40a29e <_dtoa_r+0x86>
  40a2b2:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  40a2b6:	2200      	movs	r2, #0
  40a2b8:	2300      	movs	r3, #0
  40a2ba:	4630      	mov	r0, r6
  40a2bc:	4639      	mov	r1, r7
  40a2be:	f002 fbe5 	bl	40ca8c <__aeabi_dcmpeq>
  40a2c2:	4680      	mov	r8, r0
  40a2c4:	b160      	cbz	r0, 40a2e0 <_dtoa_r+0xc8>
  40a2c6:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40a2c8:	2301      	movs	r3, #1
  40a2ca:	6013      	str	r3, [r2, #0]
  40a2cc:	9b22      	ldr	r3, [sp, #136]	; 0x88
  40a2ce:	2b00      	cmp	r3, #0
  40a2d0:	f000 855c 	beq.w	40ad8c <_dtoa_r+0xb74>
  40a2d4:	4b93      	ldr	r3, [pc, #588]	; (40a524 <_dtoa_r+0x30c>)
  40a2d6:	9a22      	ldr	r2, [sp, #136]	; 0x88
  40a2d8:	6013      	str	r3, [r2, #0]
  40a2da:	3b01      	subs	r3, #1
  40a2dc:	9306      	str	r3, [sp, #24]
  40a2de:	e7e0      	b.n	40a2a2 <_dtoa_r+0x8a>
  40a2e0:	ab12      	add	r3, sp, #72	; 0x48
  40a2e2:	9301      	str	r3, [sp, #4]
  40a2e4:	ab13      	add	r3, sp, #76	; 0x4c
  40a2e6:	9300      	str	r3, [sp, #0]
  40a2e8:	4632      	mov	r2, r6
  40a2ea:	463b      	mov	r3, r7
  40a2ec:	4620      	mov	r0, r4
  40a2ee:	f001 fa30 	bl	40b752 <__d2b>
  40a2f2:	f3c9 550a 	ubfx	r5, r9, #20, #11
  40a2f6:	4682      	mov	sl, r0
  40a2f8:	2d00      	cmp	r5, #0
  40a2fa:	d07c      	beq.n	40a3f6 <_dtoa_r+0x1de>
  40a2fc:	f3c7 0313 	ubfx	r3, r7, #0, #20
  40a300:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  40a304:	4630      	mov	r0, r6
  40a306:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  40a30a:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  40a30e:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  40a312:	2200      	movs	r2, #0
  40a314:	4b84      	ldr	r3, [pc, #528]	; (40a528 <_dtoa_r+0x310>)
  40a316:	f001 ff9d 	bl	40c254 <__aeabi_dsub>
  40a31a:	a379      	add	r3, pc, #484	; (adr r3, 40a500 <_dtoa_r+0x2e8>)
  40a31c:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a320:	f002 f94c 	bl	40c5bc <__aeabi_dmul>
  40a324:	a378      	add	r3, pc, #480	; (adr r3, 40a508 <_dtoa_r+0x2f0>)
  40a326:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a32a:	f001 ff95 	bl	40c258 <__adddf3>
  40a32e:	4606      	mov	r6, r0
  40a330:	4628      	mov	r0, r5
  40a332:	460f      	mov	r7, r1
  40a334:	f002 f8dc 	bl	40c4f0 <__aeabi_i2d>
  40a338:	a375      	add	r3, pc, #468	; (adr r3, 40a510 <_dtoa_r+0x2f8>)
  40a33a:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a33e:	f002 f93d 	bl	40c5bc <__aeabi_dmul>
  40a342:	4602      	mov	r2, r0
  40a344:	460b      	mov	r3, r1
  40a346:	4630      	mov	r0, r6
  40a348:	4639      	mov	r1, r7
  40a34a:	f001 ff85 	bl	40c258 <__adddf3>
  40a34e:	4606      	mov	r6, r0
  40a350:	460f      	mov	r7, r1
  40a352:	f002 fbe3 	bl	40cb1c <__aeabi_d2iz>
  40a356:	2200      	movs	r2, #0
  40a358:	4683      	mov	fp, r0
  40a35a:	2300      	movs	r3, #0
  40a35c:	4630      	mov	r0, r6
  40a35e:	4639      	mov	r1, r7
  40a360:	f002 fb9e 	bl	40caa0 <__aeabi_dcmplt>
  40a364:	b158      	cbz	r0, 40a37e <_dtoa_r+0x166>
  40a366:	4658      	mov	r0, fp
  40a368:	f002 f8c2 	bl	40c4f0 <__aeabi_i2d>
  40a36c:	4602      	mov	r2, r0
  40a36e:	460b      	mov	r3, r1
  40a370:	4630      	mov	r0, r6
  40a372:	4639      	mov	r1, r7
  40a374:	f002 fb8a 	bl	40ca8c <__aeabi_dcmpeq>
  40a378:	b908      	cbnz	r0, 40a37e <_dtoa_r+0x166>
  40a37a:	f10b 3bff 	add.w	fp, fp, #4294967295
  40a37e:	f1bb 0f16 	cmp.w	fp, #22
  40a382:	d857      	bhi.n	40a434 <_dtoa_r+0x21c>
  40a384:	4969      	ldr	r1, [pc, #420]	; (40a52c <_dtoa_r+0x314>)
  40a386:	eb01 01cb 	add.w	r1, r1, fp, lsl #3
  40a38a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a38e:	e9d1 0100 	ldrd	r0, r1, [r1]
  40a392:	f002 fba3 	bl	40cadc <__aeabi_dcmpgt>
  40a396:	2800      	cmp	r0, #0
  40a398:	d04e      	beq.n	40a438 <_dtoa_r+0x220>
  40a39a:	f10b 3bff 	add.w	fp, fp, #4294967295
  40a39e:	2300      	movs	r3, #0
  40a3a0:	930d      	str	r3, [sp, #52]	; 0x34
  40a3a2:	9b12      	ldr	r3, [sp, #72]	; 0x48
  40a3a4:	1b5d      	subs	r5, r3, r5
  40a3a6:	1e6b      	subs	r3, r5, #1
  40a3a8:	9307      	str	r3, [sp, #28]
  40a3aa:	bf43      	ittte	mi
  40a3ac:	2300      	movmi	r3, #0
  40a3ae:	f1c5 0801 	rsbmi	r8, r5, #1
  40a3b2:	9307      	strmi	r3, [sp, #28]
  40a3b4:	f04f 0800 	movpl.w	r8, #0
  40a3b8:	f1bb 0f00 	cmp.w	fp, #0
  40a3bc:	db3e      	blt.n	40a43c <_dtoa_r+0x224>
  40a3be:	9b07      	ldr	r3, [sp, #28]
  40a3c0:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
  40a3c4:	445b      	add	r3, fp
  40a3c6:	9307      	str	r3, [sp, #28]
  40a3c8:	2300      	movs	r3, #0
  40a3ca:	9308      	str	r3, [sp, #32]
  40a3cc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40a3ce:	2b09      	cmp	r3, #9
  40a3d0:	f200 80b0 	bhi.w	40a534 <_dtoa_r+0x31c>
  40a3d4:	2b05      	cmp	r3, #5
  40a3d6:	bfc4      	itt	gt
  40a3d8:	3b04      	subgt	r3, #4
  40a3da:	931e      	strgt	r3, [sp, #120]	; 0x78
  40a3dc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40a3de:	f1a3 0302 	sub.w	r3, r3, #2
  40a3e2:	bfcc      	ite	gt
  40a3e4:	2600      	movgt	r6, #0
  40a3e6:	2601      	movle	r6, #1
  40a3e8:	2b03      	cmp	r3, #3
  40a3ea:	f200 80af 	bhi.w	40a54c <_dtoa_r+0x334>
  40a3ee:	e8df f003 	tbb	[pc, r3]
  40a3f2:	8583      	.short	0x8583
  40a3f4:	772d      	.short	0x772d
  40a3f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  40a3f8:	9d12      	ldr	r5, [sp, #72]	; 0x48
  40a3fa:	441d      	add	r5, r3
  40a3fc:	f205 4332 	addw	r3, r5, #1074	; 0x432
  40a400:	2b20      	cmp	r3, #32
  40a402:	dd11      	ble.n	40a428 <_dtoa_r+0x210>
  40a404:	9a02      	ldr	r2, [sp, #8]
  40a406:	f205 4012 	addw	r0, r5, #1042	; 0x412
  40a40a:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  40a40e:	fa22 f000 	lsr.w	r0, r2, r0
  40a412:	fa09 f303 	lsl.w	r3, r9, r3
  40a416:	4318      	orrs	r0, r3
  40a418:	f002 f85a 	bl	40c4d0 <__aeabi_ui2d>
  40a41c:	2301      	movs	r3, #1
  40a41e:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  40a422:	3d01      	subs	r5, #1
  40a424:	9310      	str	r3, [sp, #64]	; 0x40
  40a426:	e774      	b.n	40a312 <_dtoa_r+0xfa>
  40a428:	f1c3 0020 	rsb	r0, r3, #32
  40a42c:	9b02      	ldr	r3, [sp, #8]
  40a42e:	fa03 f000 	lsl.w	r0, r3, r0
  40a432:	e7f1      	b.n	40a418 <_dtoa_r+0x200>
  40a434:	2301      	movs	r3, #1
  40a436:	e7b3      	b.n	40a3a0 <_dtoa_r+0x188>
  40a438:	900d      	str	r0, [sp, #52]	; 0x34
  40a43a:	e7b2      	b.n	40a3a2 <_dtoa_r+0x18a>
  40a43c:	f1cb 0300 	rsb	r3, fp, #0
  40a440:	9308      	str	r3, [sp, #32]
  40a442:	2300      	movs	r3, #0
  40a444:	eba8 080b 	sub.w	r8, r8, fp
  40a448:	930c      	str	r3, [sp, #48]	; 0x30
  40a44a:	e7bf      	b.n	40a3cc <_dtoa_r+0x1b4>
  40a44c:	2301      	movs	r3, #1
  40a44e:	9309      	str	r3, [sp, #36]	; 0x24
  40a450:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  40a452:	2b00      	cmp	r3, #0
  40a454:	dd7d      	ble.n	40a552 <_dtoa_r+0x33a>
  40a456:	9304      	str	r3, [sp, #16]
  40a458:	4699      	mov	r9, r3
  40a45a:	6a65      	ldr	r5, [r4, #36]	; 0x24
  40a45c:	2200      	movs	r2, #0
  40a45e:	606a      	str	r2, [r5, #4]
  40a460:	2104      	movs	r1, #4
  40a462:	f101 0214 	add.w	r2, r1, #20
  40a466:	429a      	cmp	r2, r3
  40a468:	d978      	bls.n	40a55c <_dtoa_r+0x344>
  40a46a:	6869      	ldr	r1, [r5, #4]
  40a46c:	4620      	mov	r0, r4
  40a46e:	f000 feef 	bl	40b250 <_Balloc>
  40a472:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40a474:	6028      	str	r0, [r5, #0]
  40a476:	681b      	ldr	r3, [r3, #0]
  40a478:	9306      	str	r3, [sp, #24]
  40a47a:	f1b9 0f0e 	cmp.w	r9, #14
  40a47e:	f200 80ee 	bhi.w	40a65e <_dtoa_r+0x446>
  40a482:	2e00      	cmp	r6, #0
  40a484:	f000 80eb 	beq.w	40a65e <_dtoa_r+0x446>
  40a488:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a48c:	f1bb 0f00 	cmp.w	fp, #0
  40a490:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  40a494:	dd77      	ble.n	40a586 <_dtoa_r+0x36e>
  40a496:	4a25      	ldr	r2, [pc, #148]	; (40a52c <_dtoa_r+0x314>)
  40a498:	f00b 030f 	and.w	r3, fp, #15
  40a49c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  40a4a0:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a4a4:	ea4f 162b 	mov.w	r6, fp, asr #4
  40a4a8:	06f0      	lsls	r0, r6, #27
  40a4aa:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  40a4ae:	d55a      	bpl.n	40a566 <_dtoa_r+0x34e>
  40a4b0:	4b1f      	ldr	r3, [pc, #124]	; (40a530 <_dtoa_r+0x318>)
  40a4b2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  40a4b6:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  40a4ba:	f002 f9a9 	bl	40c810 <__aeabi_ddiv>
  40a4be:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a4c2:	f006 060f 	and.w	r6, r6, #15
  40a4c6:	2503      	movs	r5, #3
  40a4c8:	4f19      	ldr	r7, [pc, #100]	; (40a530 <_dtoa_r+0x318>)
  40a4ca:	2e00      	cmp	r6, #0
  40a4cc:	d14d      	bne.n	40a56a <_dtoa_r+0x352>
  40a4ce:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a4d2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a4d6:	f002 f99b 	bl	40c810 <__aeabi_ddiv>
  40a4da:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a4de:	e06c      	b.n	40a5ba <_dtoa_r+0x3a2>
  40a4e0:	2301      	movs	r3, #1
  40a4e2:	9309      	str	r3, [sp, #36]	; 0x24
  40a4e4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  40a4e6:	445b      	add	r3, fp
  40a4e8:	f103 0901 	add.w	r9, r3, #1
  40a4ec:	9304      	str	r3, [sp, #16]
  40a4ee:	464b      	mov	r3, r9
  40a4f0:	2b01      	cmp	r3, #1
  40a4f2:	bfb8      	it	lt
  40a4f4:	2301      	movlt	r3, #1
  40a4f6:	e7b0      	b.n	40a45a <_dtoa_r+0x242>
  40a4f8:	2300      	movs	r3, #0
  40a4fa:	e7a8      	b.n	40a44e <_dtoa_r+0x236>
  40a4fc:	2300      	movs	r3, #0
  40a4fe:	e7f0      	b.n	40a4e2 <_dtoa_r+0x2ca>
  40a500:	636f4361 	.word	0x636f4361
  40a504:	3fd287a7 	.word	0x3fd287a7
  40a508:	8b60c8b3 	.word	0x8b60c8b3
  40a50c:	3fc68a28 	.word	0x3fc68a28
  40a510:	509f79fb 	.word	0x509f79fb
  40a514:	3fd34413 	.word	0x3fd34413
  40a518:	7ff00000 	.word	0x7ff00000
  40a51c:	0040ded5 	.word	0x0040ded5
  40a520:	0040decc 	.word	0x0040decc
  40a524:	0040dea9 	.word	0x0040dea9
  40a528:	3ff80000 	.word	0x3ff80000
  40a52c:	0040df68 	.word	0x0040df68
  40a530:	0040df40 	.word	0x0040df40
  40a534:	2601      	movs	r6, #1
  40a536:	2300      	movs	r3, #0
  40a538:	931e      	str	r3, [sp, #120]	; 0x78
  40a53a:	9609      	str	r6, [sp, #36]	; 0x24
  40a53c:	f04f 33ff 	mov.w	r3, #4294967295
  40a540:	9304      	str	r3, [sp, #16]
  40a542:	4699      	mov	r9, r3
  40a544:	2200      	movs	r2, #0
  40a546:	2312      	movs	r3, #18
  40a548:	921f      	str	r2, [sp, #124]	; 0x7c
  40a54a:	e786      	b.n	40a45a <_dtoa_r+0x242>
  40a54c:	2301      	movs	r3, #1
  40a54e:	9309      	str	r3, [sp, #36]	; 0x24
  40a550:	e7f4      	b.n	40a53c <_dtoa_r+0x324>
  40a552:	2301      	movs	r3, #1
  40a554:	9304      	str	r3, [sp, #16]
  40a556:	4699      	mov	r9, r3
  40a558:	461a      	mov	r2, r3
  40a55a:	e7f5      	b.n	40a548 <_dtoa_r+0x330>
  40a55c:	686a      	ldr	r2, [r5, #4]
  40a55e:	3201      	adds	r2, #1
  40a560:	606a      	str	r2, [r5, #4]
  40a562:	0049      	lsls	r1, r1, #1
  40a564:	e77d      	b.n	40a462 <_dtoa_r+0x24a>
  40a566:	2502      	movs	r5, #2
  40a568:	e7ae      	b.n	40a4c8 <_dtoa_r+0x2b0>
  40a56a:	07f1      	lsls	r1, r6, #31
  40a56c:	d508      	bpl.n	40a580 <_dtoa_r+0x368>
  40a56e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  40a572:	e9d7 2300 	ldrd	r2, r3, [r7]
  40a576:	f002 f821 	bl	40c5bc <__aeabi_dmul>
  40a57a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  40a57e:	3501      	adds	r5, #1
  40a580:	1076      	asrs	r6, r6, #1
  40a582:	3708      	adds	r7, #8
  40a584:	e7a1      	b.n	40a4ca <_dtoa_r+0x2b2>
  40a586:	f000 80a5 	beq.w	40a6d4 <_dtoa_r+0x4bc>
  40a58a:	f1cb 0600 	rsb	r6, fp, #0
  40a58e:	4ba3      	ldr	r3, [pc, #652]	; (40a81c <_dtoa_r+0x604>)
  40a590:	4fa3      	ldr	r7, [pc, #652]	; (40a820 <_dtoa_r+0x608>)
  40a592:	f006 020f 	and.w	r2, r6, #15
  40a596:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  40a59a:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a59e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  40a5a2:	f002 f80b 	bl	40c5bc <__aeabi_dmul>
  40a5a6:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a5aa:	1136      	asrs	r6, r6, #4
  40a5ac:	2300      	movs	r3, #0
  40a5ae:	2502      	movs	r5, #2
  40a5b0:	2e00      	cmp	r6, #0
  40a5b2:	f040 8084 	bne.w	40a6be <_dtoa_r+0x4a6>
  40a5b6:	2b00      	cmp	r3, #0
  40a5b8:	d18f      	bne.n	40a4da <_dtoa_r+0x2c2>
  40a5ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  40a5bc:	2b00      	cmp	r3, #0
  40a5be:	f000 808b 	beq.w	40a6d8 <_dtoa_r+0x4c0>
  40a5c2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a5c6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  40a5ca:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  40a5ce:	2200      	movs	r2, #0
  40a5d0:	4b94      	ldr	r3, [pc, #592]	; (40a824 <_dtoa_r+0x60c>)
  40a5d2:	f002 fa65 	bl	40caa0 <__aeabi_dcmplt>
  40a5d6:	2800      	cmp	r0, #0
  40a5d8:	d07e      	beq.n	40a6d8 <_dtoa_r+0x4c0>
  40a5da:	f1b9 0f00 	cmp.w	r9, #0
  40a5de:	d07b      	beq.n	40a6d8 <_dtoa_r+0x4c0>
  40a5e0:	9b04      	ldr	r3, [sp, #16]
  40a5e2:	2b00      	cmp	r3, #0
  40a5e4:	dd37      	ble.n	40a656 <_dtoa_r+0x43e>
  40a5e6:	2200      	movs	r2, #0
  40a5e8:	4b8f      	ldr	r3, [pc, #572]	; (40a828 <_dtoa_r+0x610>)
  40a5ea:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  40a5ee:	f001 ffe5 	bl	40c5bc <__aeabi_dmul>
  40a5f2:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a5f6:	9e04      	ldr	r6, [sp, #16]
  40a5f8:	f10b 37ff 	add.w	r7, fp, #4294967295
  40a5fc:	3501      	adds	r5, #1
  40a5fe:	4628      	mov	r0, r5
  40a600:	f001 ff76 	bl	40c4f0 <__aeabi_i2d>
  40a604:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a608:	f001 ffd8 	bl	40c5bc <__aeabi_dmul>
  40a60c:	4b87      	ldr	r3, [pc, #540]	; (40a82c <_dtoa_r+0x614>)
  40a60e:	2200      	movs	r2, #0
  40a610:	f001 fe22 	bl	40c258 <__adddf3>
  40a614:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  40a618:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  40a61a:	f1a3 7550 	sub.w	r5, r3, #54525952	; 0x3400000
  40a61e:	950b      	str	r5, [sp, #44]	; 0x2c
  40a620:	2e00      	cmp	r6, #0
  40a622:	d15c      	bne.n	40a6de <_dtoa_r+0x4c6>
  40a624:	2200      	movs	r2, #0
  40a626:	4b82      	ldr	r3, [pc, #520]	; (40a830 <_dtoa_r+0x618>)
  40a628:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a62c:	f001 fe12 	bl	40c254 <__aeabi_dsub>
  40a630:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  40a632:	462b      	mov	r3, r5
  40a634:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a638:	f002 fa50 	bl	40cadc <__aeabi_dcmpgt>
  40a63c:	2800      	cmp	r0, #0
  40a63e:	f040 82f7 	bne.w	40ac30 <_dtoa_r+0xa18>
  40a642:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  40a644:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
  40a648:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a64c:	f002 fa28 	bl	40caa0 <__aeabi_dcmplt>
  40a650:	2800      	cmp	r0, #0
  40a652:	f040 82eb 	bne.w	40ac2c <_dtoa_r+0xa14>
  40a656:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  40a65a:	e9cd 2302 	strd	r2, r3, [sp, #8]
  40a65e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  40a660:	2b00      	cmp	r3, #0
  40a662:	f2c0 8151 	blt.w	40a908 <_dtoa_r+0x6f0>
  40a666:	f1bb 0f0e 	cmp.w	fp, #14
  40a66a:	f300 814d 	bgt.w	40a908 <_dtoa_r+0x6f0>
  40a66e:	4b6b      	ldr	r3, [pc, #428]	; (40a81c <_dtoa_r+0x604>)
  40a670:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
  40a674:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a678:	e9cd 2304 	strd	r2, r3, [sp, #16]
  40a67c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  40a67e:	2b00      	cmp	r3, #0
  40a680:	f280 80da 	bge.w	40a838 <_dtoa_r+0x620>
  40a684:	f1b9 0f00 	cmp.w	r9, #0
  40a688:	f300 80d6 	bgt.w	40a838 <_dtoa_r+0x620>
  40a68c:	f040 82cd 	bne.w	40ac2a <_dtoa_r+0xa12>
  40a690:	2200      	movs	r2, #0
  40a692:	4b67      	ldr	r3, [pc, #412]	; (40a830 <_dtoa_r+0x618>)
  40a694:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  40a698:	f001 ff90 	bl	40c5bc <__aeabi_dmul>
  40a69c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a6a0:	f002 fa12 	bl	40cac8 <__aeabi_dcmpge>
  40a6a4:	464e      	mov	r6, r9
  40a6a6:	464f      	mov	r7, r9
  40a6a8:	2800      	cmp	r0, #0
  40a6aa:	f040 82a4 	bne.w	40abf6 <_dtoa_r+0x9de>
  40a6ae:	9b06      	ldr	r3, [sp, #24]
  40a6b0:	9a06      	ldr	r2, [sp, #24]
  40a6b2:	1c5d      	adds	r5, r3, #1
  40a6b4:	2331      	movs	r3, #49	; 0x31
  40a6b6:	7013      	strb	r3, [r2, #0]
  40a6b8:	f10b 0b01 	add.w	fp, fp, #1
  40a6bc:	e29f      	b.n	40abfe <_dtoa_r+0x9e6>
  40a6be:	07f2      	lsls	r2, r6, #31
  40a6c0:	d505      	bpl.n	40a6ce <_dtoa_r+0x4b6>
  40a6c2:	e9d7 2300 	ldrd	r2, r3, [r7]
  40a6c6:	f001 ff79 	bl	40c5bc <__aeabi_dmul>
  40a6ca:	3501      	adds	r5, #1
  40a6cc:	2301      	movs	r3, #1
  40a6ce:	1076      	asrs	r6, r6, #1
  40a6d0:	3708      	adds	r7, #8
  40a6d2:	e76d      	b.n	40a5b0 <_dtoa_r+0x398>
  40a6d4:	2502      	movs	r5, #2
  40a6d6:	e770      	b.n	40a5ba <_dtoa_r+0x3a2>
  40a6d8:	465f      	mov	r7, fp
  40a6da:	464e      	mov	r6, r9
  40a6dc:	e78f      	b.n	40a5fe <_dtoa_r+0x3e6>
  40a6de:	9a06      	ldr	r2, [sp, #24]
  40a6e0:	4b4e      	ldr	r3, [pc, #312]	; (40a81c <_dtoa_r+0x604>)
  40a6e2:	4432      	add	r2, r6
  40a6e4:	9211      	str	r2, [sp, #68]	; 0x44
  40a6e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40a6e8:	1e71      	subs	r1, r6, #1
  40a6ea:	2a00      	cmp	r2, #0
  40a6ec:	d048      	beq.n	40a780 <_dtoa_r+0x568>
  40a6ee:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
  40a6f2:	e9d3 2300 	ldrd	r2, r3, [r3]
  40a6f6:	2000      	movs	r0, #0
  40a6f8:	494e      	ldr	r1, [pc, #312]	; (40a834 <_dtoa_r+0x61c>)
  40a6fa:	f002 f889 	bl	40c810 <__aeabi_ddiv>
  40a6fe:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a702:	f001 fda7 	bl	40c254 <__aeabi_dsub>
  40a706:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  40a70a:	9d06      	ldr	r5, [sp, #24]
  40a70c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a710:	f002 fa04 	bl	40cb1c <__aeabi_d2iz>
  40a714:	4606      	mov	r6, r0
  40a716:	f001 feeb 	bl	40c4f0 <__aeabi_i2d>
  40a71a:	4602      	mov	r2, r0
  40a71c:	460b      	mov	r3, r1
  40a71e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a722:	f001 fd97 	bl	40c254 <__aeabi_dsub>
  40a726:	3630      	adds	r6, #48	; 0x30
  40a728:	f805 6b01 	strb.w	r6, [r5], #1
  40a72c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a730:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a734:	f002 f9b4 	bl	40caa0 <__aeabi_dcmplt>
  40a738:	2800      	cmp	r0, #0
  40a73a:	d165      	bne.n	40a808 <_dtoa_r+0x5f0>
  40a73c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a740:	2000      	movs	r0, #0
  40a742:	4938      	ldr	r1, [pc, #224]	; (40a824 <_dtoa_r+0x60c>)
  40a744:	f001 fd86 	bl	40c254 <__aeabi_dsub>
  40a748:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a74c:	f002 f9a8 	bl	40caa0 <__aeabi_dcmplt>
  40a750:	2800      	cmp	r0, #0
  40a752:	f040 80b9 	bne.w	40a8c8 <_dtoa_r+0x6b0>
  40a756:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40a758:	429d      	cmp	r5, r3
  40a75a:	f43f af7c 	beq.w	40a656 <_dtoa_r+0x43e>
  40a75e:	2200      	movs	r2, #0
  40a760:	4b31      	ldr	r3, [pc, #196]	; (40a828 <_dtoa_r+0x610>)
  40a762:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  40a766:	f001 ff29 	bl	40c5bc <__aeabi_dmul>
  40a76a:	2200      	movs	r2, #0
  40a76c:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  40a770:	4b2d      	ldr	r3, [pc, #180]	; (40a828 <_dtoa_r+0x610>)
  40a772:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a776:	f001 ff21 	bl	40c5bc <__aeabi_dmul>
  40a77a:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a77e:	e7c5      	b.n	40a70c <_dtoa_r+0x4f4>
  40a780:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
  40a784:	e9d1 0100 	ldrd	r0, r1, [r1]
  40a788:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a78c:	f001 ff16 	bl	40c5bc <__aeabi_dmul>
  40a790:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  40a794:	9d06      	ldr	r5, [sp, #24]
  40a796:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a79a:	f002 f9bf 	bl	40cb1c <__aeabi_d2iz>
  40a79e:	4606      	mov	r6, r0
  40a7a0:	f001 fea6 	bl	40c4f0 <__aeabi_i2d>
  40a7a4:	3630      	adds	r6, #48	; 0x30
  40a7a6:	4602      	mov	r2, r0
  40a7a8:	460b      	mov	r3, r1
  40a7aa:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a7ae:	f001 fd51 	bl	40c254 <__aeabi_dsub>
  40a7b2:	f805 6b01 	strb.w	r6, [r5], #1
  40a7b6:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40a7b8:	42ab      	cmp	r3, r5
  40a7ba:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a7be:	f04f 0200 	mov.w	r2, #0
  40a7c2:	d125      	bne.n	40a810 <_dtoa_r+0x5f8>
  40a7c4:	4b1b      	ldr	r3, [pc, #108]	; (40a834 <_dtoa_r+0x61c>)
  40a7c6:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
  40a7ca:	f001 fd45 	bl	40c258 <__adddf3>
  40a7ce:	4602      	mov	r2, r0
  40a7d0:	460b      	mov	r3, r1
  40a7d2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a7d6:	f002 f981 	bl	40cadc <__aeabi_dcmpgt>
  40a7da:	2800      	cmp	r0, #0
  40a7dc:	d174      	bne.n	40a8c8 <_dtoa_r+0x6b0>
  40a7de:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  40a7e2:	2000      	movs	r0, #0
  40a7e4:	4913      	ldr	r1, [pc, #76]	; (40a834 <_dtoa_r+0x61c>)
  40a7e6:	f001 fd35 	bl	40c254 <__aeabi_dsub>
  40a7ea:	4602      	mov	r2, r0
  40a7ec:	460b      	mov	r3, r1
  40a7ee:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  40a7f2:	f002 f955 	bl	40caa0 <__aeabi_dcmplt>
  40a7f6:	2800      	cmp	r0, #0
  40a7f8:	f43f af2d 	beq.w	40a656 <_dtoa_r+0x43e>
  40a7fc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  40a800:	2b30      	cmp	r3, #48	; 0x30
  40a802:	f105 32ff 	add.w	r2, r5, #4294967295
  40a806:	d001      	beq.n	40a80c <_dtoa_r+0x5f4>
  40a808:	46bb      	mov	fp, r7
  40a80a:	e04c      	b.n	40a8a6 <_dtoa_r+0x68e>
  40a80c:	4615      	mov	r5, r2
  40a80e:	e7f5      	b.n	40a7fc <_dtoa_r+0x5e4>
  40a810:	4b05      	ldr	r3, [pc, #20]	; (40a828 <_dtoa_r+0x610>)
  40a812:	f001 fed3 	bl	40c5bc <__aeabi_dmul>
  40a816:	e9cd 0102 	strd	r0, r1, [sp, #8]
  40a81a:	e7bc      	b.n	40a796 <_dtoa_r+0x57e>
  40a81c:	0040df68 	.word	0x0040df68
  40a820:	0040df40 	.word	0x0040df40
  40a824:	3ff00000 	.word	0x3ff00000
  40a828:	40240000 	.word	0x40240000
  40a82c:	401c0000 	.word	0x401c0000
  40a830:	40140000 	.word	0x40140000
  40a834:	3fe00000 	.word	0x3fe00000
  40a838:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  40a83c:	9d06      	ldr	r5, [sp, #24]
  40a83e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  40a842:	4630      	mov	r0, r6
  40a844:	4639      	mov	r1, r7
  40a846:	f001 ffe3 	bl	40c810 <__aeabi_ddiv>
  40a84a:	f002 f967 	bl	40cb1c <__aeabi_d2iz>
  40a84e:	4680      	mov	r8, r0
  40a850:	f001 fe4e 	bl	40c4f0 <__aeabi_i2d>
  40a854:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  40a858:	f001 feb0 	bl	40c5bc <__aeabi_dmul>
  40a85c:	4602      	mov	r2, r0
  40a85e:	460b      	mov	r3, r1
  40a860:	4630      	mov	r0, r6
  40a862:	4639      	mov	r1, r7
  40a864:	f108 0630 	add.w	r6, r8, #48	; 0x30
  40a868:	f001 fcf4 	bl	40c254 <__aeabi_dsub>
  40a86c:	f805 6b01 	strb.w	r6, [r5], #1
  40a870:	9e06      	ldr	r6, [sp, #24]
  40a872:	1bae      	subs	r6, r5, r6
  40a874:	45b1      	cmp	r9, r6
  40a876:	4602      	mov	r2, r0
  40a878:	460b      	mov	r3, r1
  40a87a:	d138      	bne.n	40a8ee <_dtoa_r+0x6d6>
  40a87c:	f001 fcec 	bl	40c258 <__adddf3>
  40a880:	4606      	mov	r6, r0
  40a882:	460f      	mov	r7, r1
  40a884:	4602      	mov	r2, r0
  40a886:	460b      	mov	r3, r1
  40a888:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  40a88c:	f002 f908 	bl	40caa0 <__aeabi_dcmplt>
  40a890:	b9c8      	cbnz	r0, 40a8c6 <_dtoa_r+0x6ae>
  40a892:	4632      	mov	r2, r6
  40a894:	463b      	mov	r3, r7
  40a896:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  40a89a:	f002 f8f7 	bl	40ca8c <__aeabi_dcmpeq>
  40a89e:	b110      	cbz	r0, 40a8a6 <_dtoa_r+0x68e>
  40a8a0:	f018 0f01 	tst.w	r8, #1
  40a8a4:	d10f      	bne.n	40a8c6 <_dtoa_r+0x6ae>
  40a8a6:	4651      	mov	r1, sl
  40a8a8:	4620      	mov	r0, r4
  40a8aa:	f000 fd05 	bl	40b2b8 <_Bfree>
  40a8ae:	2300      	movs	r3, #0
  40a8b0:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40a8b2:	702b      	strb	r3, [r5, #0]
  40a8b4:	f10b 0301 	add.w	r3, fp, #1
  40a8b8:	6013      	str	r3, [r2, #0]
  40a8ba:	9b22      	ldr	r3, [sp, #136]	; 0x88
  40a8bc:	2b00      	cmp	r3, #0
  40a8be:	f43f acf0 	beq.w	40a2a2 <_dtoa_r+0x8a>
  40a8c2:	601d      	str	r5, [r3, #0]
  40a8c4:	e4ed      	b.n	40a2a2 <_dtoa_r+0x8a>
  40a8c6:	465f      	mov	r7, fp
  40a8c8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  40a8cc:	2a39      	cmp	r2, #57	; 0x39
  40a8ce:	f105 33ff 	add.w	r3, r5, #4294967295
  40a8d2:	d106      	bne.n	40a8e2 <_dtoa_r+0x6ca>
  40a8d4:	9a06      	ldr	r2, [sp, #24]
  40a8d6:	429a      	cmp	r2, r3
  40a8d8:	d107      	bne.n	40a8ea <_dtoa_r+0x6d2>
  40a8da:	2330      	movs	r3, #48	; 0x30
  40a8dc:	7013      	strb	r3, [r2, #0]
  40a8de:	3701      	adds	r7, #1
  40a8e0:	4613      	mov	r3, r2
  40a8e2:	781a      	ldrb	r2, [r3, #0]
  40a8e4:	3201      	adds	r2, #1
  40a8e6:	701a      	strb	r2, [r3, #0]
  40a8e8:	e78e      	b.n	40a808 <_dtoa_r+0x5f0>
  40a8ea:	461d      	mov	r5, r3
  40a8ec:	e7ec      	b.n	40a8c8 <_dtoa_r+0x6b0>
  40a8ee:	2200      	movs	r2, #0
  40a8f0:	4bb4      	ldr	r3, [pc, #720]	; (40abc4 <_dtoa_r+0x9ac>)
  40a8f2:	f001 fe63 	bl	40c5bc <__aeabi_dmul>
  40a8f6:	2200      	movs	r2, #0
  40a8f8:	2300      	movs	r3, #0
  40a8fa:	4606      	mov	r6, r0
  40a8fc:	460f      	mov	r7, r1
  40a8fe:	f002 f8c5 	bl	40ca8c <__aeabi_dcmpeq>
  40a902:	2800      	cmp	r0, #0
  40a904:	d09b      	beq.n	40a83e <_dtoa_r+0x626>
  40a906:	e7ce      	b.n	40a8a6 <_dtoa_r+0x68e>
  40a908:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40a90a:	2a00      	cmp	r2, #0
  40a90c:	f000 8129 	beq.w	40ab62 <_dtoa_r+0x94a>
  40a910:	9a1e      	ldr	r2, [sp, #120]	; 0x78
  40a912:	2a01      	cmp	r2, #1
  40a914:	f300 810e 	bgt.w	40ab34 <_dtoa_r+0x91c>
  40a918:	9a10      	ldr	r2, [sp, #64]	; 0x40
  40a91a:	2a00      	cmp	r2, #0
  40a91c:	f000 8106 	beq.w	40ab2c <_dtoa_r+0x914>
  40a920:	f203 4333 	addw	r3, r3, #1075	; 0x433
  40a924:	9e08      	ldr	r6, [sp, #32]
  40a926:	4645      	mov	r5, r8
  40a928:	9a07      	ldr	r2, [sp, #28]
  40a92a:	2101      	movs	r1, #1
  40a92c:	441a      	add	r2, r3
  40a92e:	4620      	mov	r0, r4
  40a930:	4498      	add	r8, r3
  40a932:	9207      	str	r2, [sp, #28]
  40a934:	f000 fd60 	bl	40b3f8 <__i2b>
  40a938:	4607      	mov	r7, r0
  40a93a:	2d00      	cmp	r5, #0
  40a93c:	dd0b      	ble.n	40a956 <_dtoa_r+0x73e>
  40a93e:	9b07      	ldr	r3, [sp, #28]
  40a940:	2b00      	cmp	r3, #0
  40a942:	dd08      	ble.n	40a956 <_dtoa_r+0x73e>
  40a944:	42ab      	cmp	r3, r5
  40a946:	9a07      	ldr	r2, [sp, #28]
  40a948:	bfa8      	it	ge
  40a94a:	462b      	movge	r3, r5
  40a94c:	eba8 0803 	sub.w	r8, r8, r3
  40a950:	1aed      	subs	r5, r5, r3
  40a952:	1ad3      	subs	r3, r2, r3
  40a954:	9307      	str	r3, [sp, #28]
  40a956:	9b08      	ldr	r3, [sp, #32]
  40a958:	b1fb      	cbz	r3, 40a99a <_dtoa_r+0x782>
  40a95a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40a95c:	2b00      	cmp	r3, #0
  40a95e:	f000 8104 	beq.w	40ab6a <_dtoa_r+0x952>
  40a962:	2e00      	cmp	r6, #0
  40a964:	dd11      	ble.n	40a98a <_dtoa_r+0x772>
  40a966:	4639      	mov	r1, r7
  40a968:	4632      	mov	r2, r6
  40a96a:	4620      	mov	r0, r4
  40a96c:	f000 fdda 	bl	40b524 <__pow5mult>
  40a970:	4652      	mov	r2, sl
  40a972:	4601      	mov	r1, r0
  40a974:	4607      	mov	r7, r0
  40a976:	4620      	mov	r0, r4
  40a978:	f000 fd47 	bl	40b40a <__multiply>
  40a97c:	4651      	mov	r1, sl
  40a97e:	900a      	str	r0, [sp, #40]	; 0x28
  40a980:	4620      	mov	r0, r4
  40a982:	f000 fc99 	bl	40b2b8 <_Bfree>
  40a986:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  40a988:	469a      	mov	sl, r3
  40a98a:	9b08      	ldr	r3, [sp, #32]
  40a98c:	1b9a      	subs	r2, r3, r6
  40a98e:	d004      	beq.n	40a99a <_dtoa_r+0x782>
  40a990:	4651      	mov	r1, sl
  40a992:	4620      	mov	r0, r4
  40a994:	f000 fdc6 	bl	40b524 <__pow5mult>
  40a998:	4682      	mov	sl, r0
  40a99a:	2101      	movs	r1, #1
  40a99c:	4620      	mov	r0, r4
  40a99e:	f000 fd2b 	bl	40b3f8 <__i2b>
  40a9a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40a9a4:	2b00      	cmp	r3, #0
  40a9a6:	4606      	mov	r6, r0
  40a9a8:	f340 80e1 	ble.w	40ab6e <_dtoa_r+0x956>
  40a9ac:	461a      	mov	r2, r3
  40a9ae:	4601      	mov	r1, r0
  40a9b0:	4620      	mov	r0, r4
  40a9b2:	f000 fdb7 	bl	40b524 <__pow5mult>
  40a9b6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40a9b8:	2b01      	cmp	r3, #1
  40a9ba:	4606      	mov	r6, r0
  40a9bc:	f340 80da 	ble.w	40ab74 <_dtoa_r+0x95c>
  40a9c0:	2300      	movs	r3, #0
  40a9c2:	9308      	str	r3, [sp, #32]
  40a9c4:	6933      	ldr	r3, [r6, #16]
  40a9c6:	eb06 0383 	add.w	r3, r6, r3, lsl #2
  40a9ca:	6918      	ldr	r0, [r3, #16]
  40a9cc:	f000 fcc6 	bl	40b35c <__hi0bits>
  40a9d0:	f1c0 0020 	rsb	r0, r0, #32
  40a9d4:	9b07      	ldr	r3, [sp, #28]
  40a9d6:	4418      	add	r0, r3
  40a9d8:	f010 001f 	ands.w	r0, r0, #31
  40a9dc:	f000 80f0 	beq.w	40abc0 <_dtoa_r+0x9a8>
  40a9e0:	f1c0 0320 	rsb	r3, r0, #32
  40a9e4:	2b04      	cmp	r3, #4
  40a9e6:	f340 80e2 	ble.w	40abae <_dtoa_r+0x996>
  40a9ea:	9b07      	ldr	r3, [sp, #28]
  40a9ec:	f1c0 001c 	rsb	r0, r0, #28
  40a9f0:	4480      	add	r8, r0
  40a9f2:	4405      	add	r5, r0
  40a9f4:	4403      	add	r3, r0
  40a9f6:	9307      	str	r3, [sp, #28]
  40a9f8:	f1b8 0f00 	cmp.w	r8, #0
  40a9fc:	dd05      	ble.n	40aa0a <_dtoa_r+0x7f2>
  40a9fe:	4651      	mov	r1, sl
  40aa00:	4642      	mov	r2, r8
  40aa02:	4620      	mov	r0, r4
  40aa04:	f000 fddc 	bl	40b5c0 <__lshift>
  40aa08:	4682      	mov	sl, r0
  40aa0a:	9b07      	ldr	r3, [sp, #28]
  40aa0c:	2b00      	cmp	r3, #0
  40aa0e:	dd05      	ble.n	40aa1c <_dtoa_r+0x804>
  40aa10:	4631      	mov	r1, r6
  40aa12:	461a      	mov	r2, r3
  40aa14:	4620      	mov	r0, r4
  40aa16:	f000 fdd3 	bl	40b5c0 <__lshift>
  40aa1a:	4606      	mov	r6, r0
  40aa1c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  40aa1e:	2b00      	cmp	r3, #0
  40aa20:	f000 80d2 	beq.w	40abc8 <_dtoa_r+0x9b0>
  40aa24:	4631      	mov	r1, r6
  40aa26:	4650      	mov	r0, sl
  40aa28:	f000 fe1b 	bl	40b662 <__mcmp>
  40aa2c:	2800      	cmp	r0, #0
  40aa2e:	f280 80cb 	bge.w	40abc8 <_dtoa_r+0x9b0>
  40aa32:	2300      	movs	r3, #0
  40aa34:	4651      	mov	r1, sl
  40aa36:	220a      	movs	r2, #10
  40aa38:	4620      	mov	r0, r4
  40aa3a:	f000 fc54 	bl	40b2e6 <__multadd>
  40aa3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40aa40:	f10b 3bff 	add.w	fp, fp, #4294967295
  40aa44:	4682      	mov	sl, r0
  40aa46:	2b00      	cmp	r3, #0
  40aa48:	f000 81aa 	beq.w	40ada0 <_dtoa_r+0xb88>
  40aa4c:	2300      	movs	r3, #0
  40aa4e:	4639      	mov	r1, r7
  40aa50:	220a      	movs	r2, #10
  40aa52:	4620      	mov	r0, r4
  40aa54:	f000 fc47 	bl	40b2e6 <__multadd>
  40aa58:	9b04      	ldr	r3, [sp, #16]
  40aa5a:	2b00      	cmp	r3, #0
  40aa5c:	4607      	mov	r7, r0
  40aa5e:	dc03      	bgt.n	40aa68 <_dtoa_r+0x850>
  40aa60:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40aa62:	2b02      	cmp	r3, #2
  40aa64:	f300 80b8 	bgt.w	40abd8 <_dtoa_r+0x9c0>
  40aa68:	2d00      	cmp	r5, #0
  40aa6a:	dd05      	ble.n	40aa78 <_dtoa_r+0x860>
  40aa6c:	4639      	mov	r1, r7
  40aa6e:	462a      	mov	r2, r5
  40aa70:	4620      	mov	r0, r4
  40aa72:	f000 fda5 	bl	40b5c0 <__lshift>
  40aa76:	4607      	mov	r7, r0
  40aa78:	9b08      	ldr	r3, [sp, #32]
  40aa7a:	2b00      	cmp	r3, #0
  40aa7c:	f000 8110 	beq.w	40aca0 <_dtoa_r+0xa88>
  40aa80:	6879      	ldr	r1, [r7, #4]
  40aa82:	4620      	mov	r0, r4
  40aa84:	f000 fbe4 	bl	40b250 <_Balloc>
  40aa88:	693a      	ldr	r2, [r7, #16]
  40aa8a:	3202      	adds	r2, #2
  40aa8c:	4605      	mov	r5, r0
  40aa8e:	0092      	lsls	r2, r2, #2
  40aa90:	f107 010c 	add.w	r1, r7, #12
  40aa94:	300c      	adds	r0, #12
  40aa96:	f7fe fdb5 	bl	409604 <memcpy>
  40aa9a:	2201      	movs	r2, #1
  40aa9c:	4629      	mov	r1, r5
  40aa9e:	4620      	mov	r0, r4
  40aaa0:	f000 fd8e 	bl	40b5c0 <__lshift>
  40aaa4:	9b02      	ldr	r3, [sp, #8]
  40aaa6:	f8dd 8018 	ldr.w	r8, [sp, #24]
  40aaaa:	9707      	str	r7, [sp, #28]
  40aaac:	f003 0301 	and.w	r3, r3, #1
  40aab0:	4607      	mov	r7, r0
  40aab2:	9308      	str	r3, [sp, #32]
  40aab4:	4631      	mov	r1, r6
  40aab6:	4650      	mov	r0, sl
  40aab8:	f7ff fb20 	bl	40a0fc <quorem>
  40aabc:	9907      	ldr	r1, [sp, #28]
  40aabe:	4605      	mov	r5, r0
  40aac0:	f100 0930 	add.w	r9, r0, #48	; 0x30
  40aac4:	4650      	mov	r0, sl
  40aac6:	f000 fdcc 	bl	40b662 <__mcmp>
  40aaca:	463a      	mov	r2, r7
  40aacc:	9002      	str	r0, [sp, #8]
  40aace:	4631      	mov	r1, r6
  40aad0:	4620      	mov	r0, r4
  40aad2:	f000 fde0 	bl	40b696 <__mdiff>
  40aad6:	68c3      	ldr	r3, [r0, #12]
  40aad8:	4602      	mov	r2, r0
  40aada:	2b00      	cmp	r3, #0
  40aadc:	f040 80e2 	bne.w	40aca4 <_dtoa_r+0xa8c>
  40aae0:	4601      	mov	r1, r0
  40aae2:	9009      	str	r0, [sp, #36]	; 0x24
  40aae4:	4650      	mov	r0, sl
  40aae6:	f000 fdbc 	bl	40b662 <__mcmp>
  40aaea:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40aaec:	4603      	mov	r3, r0
  40aaee:	4611      	mov	r1, r2
  40aaf0:	4620      	mov	r0, r4
  40aaf2:	9309      	str	r3, [sp, #36]	; 0x24
  40aaf4:	f000 fbe0 	bl	40b2b8 <_Bfree>
  40aaf8:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40aafa:	2b00      	cmp	r3, #0
  40aafc:	f040 80d4 	bne.w	40aca8 <_dtoa_r+0xa90>
  40ab00:	9a1e      	ldr	r2, [sp, #120]	; 0x78
  40ab02:	2a00      	cmp	r2, #0
  40ab04:	f040 80d0 	bne.w	40aca8 <_dtoa_r+0xa90>
  40ab08:	9a08      	ldr	r2, [sp, #32]
  40ab0a:	2a00      	cmp	r2, #0
  40ab0c:	f040 80cc 	bne.w	40aca8 <_dtoa_r+0xa90>
  40ab10:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
  40ab14:	f000 80e8 	beq.w	40ace8 <_dtoa_r+0xad0>
  40ab18:	9b02      	ldr	r3, [sp, #8]
  40ab1a:	2b00      	cmp	r3, #0
  40ab1c:	dd01      	ble.n	40ab22 <_dtoa_r+0x90a>
  40ab1e:	f105 0931 	add.w	r9, r5, #49	; 0x31
  40ab22:	f108 0501 	add.w	r5, r8, #1
  40ab26:	f888 9000 	strb.w	r9, [r8]
  40ab2a:	e06a      	b.n	40ac02 <_dtoa_r+0x9ea>
  40ab2c:	9b12      	ldr	r3, [sp, #72]	; 0x48
  40ab2e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  40ab32:	e6f7      	b.n	40a924 <_dtoa_r+0x70c>
  40ab34:	9b08      	ldr	r3, [sp, #32]
  40ab36:	f109 36ff 	add.w	r6, r9, #4294967295
  40ab3a:	42b3      	cmp	r3, r6
  40ab3c:	bfbf      	itttt	lt
  40ab3e:	9b08      	ldrlt	r3, [sp, #32]
  40ab40:	9608      	strlt	r6, [sp, #32]
  40ab42:	1af2      	sublt	r2, r6, r3
  40ab44:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
  40ab46:	bfb7      	itett	lt
  40ab48:	189b      	addlt	r3, r3, r2
  40ab4a:	1b9e      	subge	r6, r3, r6
  40ab4c:	930c      	strlt	r3, [sp, #48]	; 0x30
  40ab4e:	2600      	movlt	r6, #0
  40ab50:	f1b9 0f00 	cmp.w	r9, #0
  40ab54:	bfb9      	ittee	lt
  40ab56:	eba8 0509 	sublt.w	r5, r8, r9
  40ab5a:	2300      	movlt	r3, #0
  40ab5c:	4645      	movge	r5, r8
  40ab5e:	464b      	movge	r3, r9
  40ab60:	e6e2      	b.n	40a928 <_dtoa_r+0x710>
  40ab62:	9e08      	ldr	r6, [sp, #32]
  40ab64:	9f09      	ldr	r7, [sp, #36]	; 0x24
  40ab66:	4645      	mov	r5, r8
  40ab68:	e6e7      	b.n	40a93a <_dtoa_r+0x722>
  40ab6a:	9a08      	ldr	r2, [sp, #32]
  40ab6c:	e710      	b.n	40a990 <_dtoa_r+0x778>
  40ab6e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40ab70:	2b01      	cmp	r3, #1
  40ab72:	dc18      	bgt.n	40aba6 <_dtoa_r+0x98e>
  40ab74:	9b02      	ldr	r3, [sp, #8]
  40ab76:	b9b3      	cbnz	r3, 40aba6 <_dtoa_r+0x98e>
  40ab78:	9b03      	ldr	r3, [sp, #12]
  40ab7a:	f3c3 0313 	ubfx	r3, r3, #0, #20
  40ab7e:	b9a3      	cbnz	r3, 40abaa <_dtoa_r+0x992>
  40ab80:	9b03      	ldr	r3, [sp, #12]
  40ab82:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  40ab86:	0d1b      	lsrs	r3, r3, #20
  40ab88:	051b      	lsls	r3, r3, #20
  40ab8a:	b12b      	cbz	r3, 40ab98 <_dtoa_r+0x980>
  40ab8c:	9b07      	ldr	r3, [sp, #28]
  40ab8e:	3301      	adds	r3, #1
  40ab90:	9307      	str	r3, [sp, #28]
  40ab92:	f108 0801 	add.w	r8, r8, #1
  40ab96:	2301      	movs	r3, #1
  40ab98:	9308      	str	r3, [sp, #32]
  40ab9a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40ab9c:	2b00      	cmp	r3, #0
  40ab9e:	f47f af11 	bne.w	40a9c4 <_dtoa_r+0x7ac>
  40aba2:	2001      	movs	r0, #1
  40aba4:	e716      	b.n	40a9d4 <_dtoa_r+0x7bc>
  40aba6:	2300      	movs	r3, #0
  40aba8:	e7f6      	b.n	40ab98 <_dtoa_r+0x980>
  40abaa:	9b02      	ldr	r3, [sp, #8]
  40abac:	e7f4      	b.n	40ab98 <_dtoa_r+0x980>
  40abae:	f43f af23 	beq.w	40a9f8 <_dtoa_r+0x7e0>
  40abb2:	9a07      	ldr	r2, [sp, #28]
  40abb4:	331c      	adds	r3, #28
  40abb6:	441a      	add	r2, r3
  40abb8:	4498      	add	r8, r3
  40abba:	441d      	add	r5, r3
  40abbc:	4613      	mov	r3, r2
  40abbe:	e71a      	b.n	40a9f6 <_dtoa_r+0x7de>
  40abc0:	4603      	mov	r3, r0
  40abc2:	e7f6      	b.n	40abb2 <_dtoa_r+0x99a>
  40abc4:	40240000 	.word	0x40240000
  40abc8:	f1b9 0f00 	cmp.w	r9, #0
  40abcc:	dc33      	bgt.n	40ac36 <_dtoa_r+0xa1e>
  40abce:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40abd0:	2b02      	cmp	r3, #2
  40abd2:	dd30      	ble.n	40ac36 <_dtoa_r+0xa1e>
  40abd4:	f8cd 9010 	str.w	r9, [sp, #16]
  40abd8:	9b04      	ldr	r3, [sp, #16]
  40abda:	b963      	cbnz	r3, 40abf6 <_dtoa_r+0x9de>
  40abdc:	4631      	mov	r1, r6
  40abde:	2205      	movs	r2, #5
  40abe0:	4620      	mov	r0, r4
  40abe2:	f000 fb80 	bl	40b2e6 <__multadd>
  40abe6:	4601      	mov	r1, r0
  40abe8:	4606      	mov	r6, r0
  40abea:	4650      	mov	r0, sl
  40abec:	f000 fd39 	bl	40b662 <__mcmp>
  40abf0:	2800      	cmp	r0, #0
  40abf2:	f73f ad5c 	bgt.w	40a6ae <_dtoa_r+0x496>
  40abf6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  40abf8:	9d06      	ldr	r5, [sp, #24]
  40abfa:	ea6f 0b03 	mvn.w	fp, r3
  40abfe:	2300      	movs	r3, #0
  40ac00:	9307      	str	r3, [sp, #28]
  40ac02:	4631      	mov	r1, r6
  40ac04:	4620      	mov	r0, r4
  40ac06:	f000 fb57 	bl	40b2b8 <_Bfree>
  40ac0a:	2f00      	cmp	r7, #0
  40ac0c:	f43f ae4b 	beq.w	40a8a6 <_dtoa_r+0x68e>
  40ac10:	9b07      	ldr	r3, [sp, #28]
  40ac12:	b12b      	cbz	r3, 40ac20 <_dtoa_r+0xa08>
  40ac14:	42bb      	cmp	r3, r7
  40ac16:	d003      	beq.n	40ac20 <_dtoa_r+0xa08>
  40ac18:	4619      	mov	r1, r3
  40ac1a:	4620      	mov	r0, r4
  40ac1c:	f000 fb4c 	bl	40b2b8 <_Bfree>
  40ac20:	4639      	mov	r1, r7
  40ac22:	4620      	mov	r0, r4
  40ac24:	f000 fb48 	bl	40b2b8 <_Bfree>
  40ac28:	e63d      	b.n	40a8a6 <_dtoa_r+0x68e>
  40ac2a:	2600      	movs	r6, #0
  40ac2c:	4637      	mov	r7, r6
  40ac2e:	e7e2      	b.n	40abf6 <_dtoa_r+0x9de>
  40ac30:	46bb      	mov	fp, r7
  40ac32:	4637      	mov	r7, r6
  40ac34:	e53b      	b.n	40a6ae <_dtoa_r+0x496>
  40ac36:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40ac38:	f8cd 9010 	str.w	r9, [sp, #16]
  40ac3c:	2b00      	cmp	r3, #0
  40ac3e:	f47f af13 	bne.w	40aa68 <_dtoa_r+0x850>
  40ac42:	9d06      	ldr	r5, [sp, #24]
  40ac44:	4631      	mov	r1, r6
  40ac46:	4650      	mov	r0, sl
  40ac48:	f7ff fa58 	bl	40a0fc <quorem>
  40ac4c:	f100 0930 	add.w	r9, r0, #48	; 0x30
  40ac50:	f805 9b01 	strb.w	r9, [r5], #1
  40ac54:	9b06      	ldr	r3, [sp, #24]
  40ac56:	9a04      	ldr	r2, [sp, #16]
  40ac58:	1aeb      	subs	r3, r5, r3
  40ac5a:	429a      	cmp	r2, r3
  40ac5c:	f300 8083 	bgt.w	40ad66 <_dtoa_r+0xb4e>
  40ac60:	9b06      	ldr	r3, [sp, #24]
  40ac62:	2a01      	cmp	r2, #1
  40ac64:	bfac      	ite	ge
  40ac66:	189b      	addge	r3, r3, r2
  40ac68:	3301      	addlt	r3, #1
  40ac6a:	4698      	mov	r8, r3
  40ac6c:	2300      	movs	r3, #0
  40ac6e:	9307      	str	r3, [sp, #28]
  40ac70:	4651      	mov	r1, sl
  40ac72:	2201      	movs	r2, #1
  40ac74:	4620      	mov	r0, r4
  40ac76:	f000 fca3 	bl	40b5c0 <__lshift>
  40ac7a:	4631      	mov	r1, r6
  40ac7c:	4682      	mov	sl, r0
  40ac7e:	f000 fcf0 	bl	40b662 <__mcmp>
  40ac82:	2800      	cmp	r0, #0
  40ac84:	dc35      	bgt.n	40acf2 <_dtoa_r+0xada>
  40ac86:	d102      	bne.n	40ac8e <_dtoa_r+0xa76>
  40ac88:	f019 0f01 	tst.w	r9, #1
  40ac8c:	d131      	bne.n	40acf2 <_dtoa_r+0xada>
  40ac8e:	4645      	mov	r5, r8
  40ac90:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  40ac94:	2b30      	cmp	r3, #48	; 0x30
  40ac96:	f105 32ff 	add.w	r2, r5, #4294967295
  40ac9a:	d1b2      	bne.n	40ac02 <_dtoa_r+0x9ea>
  40ac9c:	4615      	mov	r5, r2
  40ac9e:	e7f7      	b.n	40ac90 <_dtoa_r+0xa78>
  40aca0:	4638      	mov	r0, r7
  40aca2:	e6ff      	b.n	40aaa4 <_dtoa_r+0x88c>
  40aca4:	2301      	movs	r3, #1
  40aca6:	e722      	b.n	40aaee <_dtoa_r+0x8d6>
  40aca8:	9a02      	ldr	r2, [sp, #8]
  40acaa:	2a00      	cmp	r2, #0
  40acac:	db04      	blt.n	40acb8 <_dtoa_r+0xaa0>
  40acae:	d129      	bne.n	40ad04 <_dtoa_r+0xaec>
  40acb0:	9a1e      	ldr	r2, [sp, #120]	; 0x78
  40acb2:	bb3a      	cbnz	r2, 40ad04 <_dtoa_r+0xaec>
  40acb4:	9a08      	ldr	r2, [sp, #32]
  40acb6:	bb2a      	cbnz	r2, 40ad04 <_dtoa_r+0xaec>
  40acb8:	2b00      	cmp	r3, #0
  40acba:	f77f af32 	ble.w	40ab22 <_dtoa_r+0x90a>
  40acbe:	4651      	mov	r1, sl
  40acc0:	2201      	movs	r2, #1
  40acc2:	4620      	mov	r0, r4
  40acc4:	f000 fc7c 	bl	40b5c0 <__lshift>
  40acc8:	4631      	mov	r1, r6
  40acca:	4682      	mov	sl, r0
  40accc:	f000 fcc9 	bl	40b662 <__mcmp>
  40acd0:	2800      	cmp	r0, #0
  40acd2:	dc05      	bgt.n	40ace0 <_dtoa_r+0xac8>
  40acd4:	f47f af25 	bne.w	40ab22 <_dtoa_r+0x90a>
  40acd8:	f019 0f01 	tst.w	r9, #1
  40acdc:	f43f af21 	beq.w	40ab22 <_dtoa_r+0x90a>
  40ace0:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
  40ace4:	f47f af1b 	bne.w	40ab1e <_dtoa_r+0x906>
  40ace8:	2339      	movs	r3, #57	; 0x39
  40acea:	f888 3000 	strb.w	r3, [r8]
  40acee:	f108 0801 	add.w	r8, r8, #1
  40acf2:	4645      	mov	r5, r8
  40acf4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  40acf8:	2b39      	cmp	r3, #57	; 0x39
  40acfa:	f105 32ff 	add.w	r2, r5, #4294967295
  40acfe:	d03a      	beq.n	40ad76 <_dtoa_r+0xb5e>
  40ad00:	3301      	adds	r3, #1
  40ad02:	e03f      	b.n	40ad84 <_dtoa_r+0xb6c>
  40ad04:	2b00      	cmp	r3, #0
  40ad06:	f108 0501 	add.w	r5, r8, #1
  40ad0a:	dd05      	ble.n	40ad18 <_dtoa_r+0xb00>
  40ad0c:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
  40ad10:	d0ea      	beq.n	40ace8 <_dtoa_r+0xad0>
  40ad12:	f109 0901 	add.w	r9, r9, #1
  40ad16:	e706      	b.n	40ab26 <_dtoa_r+0x90e>
  40ad18:	9b06      	ldr	r3, [sp, #24]
  40ad1a:	9a04      	ldr	r2, [sp, #16]
  40ad1c:	f805 9c01 	strb.w	r9, [r5, #-1]
  40ad20:	1aeb      	subs	r3, r5, r3
  40ad22:	4293      	cmp	r3, r2
  40ad24:	46a8      	mov	r8, r5
  40ad26:	d0a3      	beq.n	40ac70 <_dtoa_r+0xa58>
  40ad28:	4651      	mov	r1, sl
  40ad2a:	2300      	movs	r3, #0
  40ad2c:	220a      	movs	r2, #10
  40ad2e:	4620      	mov	r0, r4
  40ad30:	f000 fad9 	bl	40b2e6 <__multadd>
  40ad34:	9b07      	ldr	r3, [sp, #28]
  40ad36:	9907      	ldr	r1, [sp, #28]
  40ad38:	42bb      	cmp	r3, r7
  40ad3a:	4682      	mov	sl, r0
  40ad3c:	f04f 0300 	mov.w	r3, #0
  40ad40:	f04f 020a 	mov.w	r2, #10
  40ad44:	4620      	mov	r0, r4
  40ad46:	d104      	bne.n	40ad52 <_dtoa_r+0xb3a>
  40ad48:	f000 facd 	bl	40b2e6 <__multadd>
  40ad4c:	9007      	str	r0, [sp, #28]
  40ad4e:	4607      	mov	r7, r0
  40ad50:	e6b0      	b.n	40aab4 <_dtoa_r+0x89c>
  40ad52:	f000 fac8 	bl	40b2e6 <__multadd>
  40ad56:	2300      	movs	r3, #0
  40ad58:	9007      	str	r0, [sp, #28]
  40ad5a:	220a      	movs	r2, #10
  40ad5c:	4639      	mov	r1, r7
  40ad5e:	4620      	mov	r0, r4
  40ad60:	f000 fac1 	bl	40b2e6 <__multadd>
  40ad64:	e7f3      	b.n	40ad4e <_dtoa_r+0xb36>
  40ad66:	4651      	mov	r1, sl
  40ad68:	2300      	movs	r3, #0
  40ad6a:	220a      	movs	r2, #10
  40ad6c:	4620      	mov	r0, r4
  40ad6e:	f000 faba 	bl	40b2e6 <__multadd>
  40ad72:	4682      	mov	sl, r0
  40ad74:	e766      	b.n	40ac44 <_dtoa_r+0xa2c>
  40ad76:	9b06      	ldr	r3, [sp, #24]
  40ad78:	4293      	cmp	r3, r2
  40ad7a:	d105      	bne.n	40ad88 <_dtoa_r+0xb70>
  40ad7c:	9a06      	ldr	r2, [sp, #24]
  40ad7e:	f10b 0b01 	add.w	fp, fp, #1
  40ad82:	2331      	movs	r3, #49	; 0x31
  40ad84:	7013      	strb	r3, [r2, #0]
  40ad86:	e73c      	b.n	40ac02 <_dtoa_r+0x9ea>
  40ad88:	4615      	mov	r5, r2
  40ad8a:	e7b3      	b.n	40acf4 <_dtoa_r+0xadc>
  40ad8c:	4b09      	ldr	r3, [pc, #36]	; (40adb4 <_dtoa_r+0xb9c>)
  40ad8e:	f7ff baa5 	b.w	40a2dc <_dtoa_r+0xc4>
  40ad92:	9b22      	ldr	r3, [sp, #136]	; 0x88
  40ad94:	2b00      	cmp	r3, #0
  40ad96:	f47f aa7f 	bne.w	40a298 <_dtoa_r+0x80>
  40ad9a:	4b07      	ldr	r3, [pc, #28]	; (40adb8 <_dtoa_r+0xba0>)
  40ad9c:	f7ff ba9e 	b.w	40a2dc <_dtoa_r+0xc4>
  40ada0:	9b04      	ldr	r3, [sp, #16]
  40ada2:	2b00      	cmp	r3, #0
  40ada4:	f73f af4d 	bgt.w	40ac42 <_dtoa_r+0xa2a>
  40ada8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  40adaa:	2b02      	cmp	r3, #2
  40adac:	f77f af49 	ble.w	40ac42 <_dtoa_r+0xa2a>
  40adb0:	e712      	b.n	40abd8 <_dtoa_r+0x9c0>
  40adb2:	bf00      	nop
  40adb4:	0040dea8 	.word	0x0040dea8
  40adb8:	0040decc 	.word	0x0040decc

0040adbc <__sflush_r>:
  40adbc:	898a      	ldrh	r2, [r1, #12]
  40adbe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40adc2:	4605      	mov	r5, r0
  40adc4:	0710      	lsls	r0, r2, #28
  40adc6:	460c      	mov	r4, r1
  40adc8:	d45a      	bmi.n	40ae80 <__sflush_r+0xc4>
  40adca:	684b      	ldr	r3, [r1, #4]
  40adcc:	2b00      	cmp	r3, #0
  40adce:	dc05      	bgt.n	40addc <__sflush_r+0x20>
  40add0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  40add2:	2b00      	cmp	r3, #0
  40add4:	dc02      	bgt.n	40addc <__sflush_r+0x20>
  40add6:	2000      	movs	r0, #0
  40add8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40addc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  40adde:	2e00      	cmp	r6, #0
  40ade0:	d0f9      	beq.n	40add6 <__sflush_r+0x1a>
  40ade2:	2300      	movs	r3, #0
  40ade4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  40ade8:	682f      	ldr	r7, [r5, #0]
  40adea:	602b      	str	r3, [r5, #0]
  40adec:	d033      	beq.n	40ae56 <__sflush_r+0x9a>
  40adee:	6d60      	ldr	r0, [r4, #84]	; 0x54
  40adf0:	89a3      	ldrh	r3, [r4, #12]
  40adf2:	075a      	lsls	r2, r3, #29
  40adf4:	d505      	bpl.n	40ae02 <__sflush_r+0x46>
  40adf6:	6863      	ldr	r3, [r4, #4]
  40adf8:	1ac0      	subs	r0, r0, r3
  40adfa:	6b63      	ldr	r3, [r4, #52]	; 0x34
  40adfc:	b10b      	cbz	r3, 40ae02 <__sflush_r+0x46>
  40adfe:	6c23      	ldr	r3, [r4, #64]	; 0x40
  40ae00:	1ac0      	subs	r0, r0, r3
  40ae02:	2300      	movs	r3, #0
  40ae04:	4602      	mov	r2, r0
  40ae06:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  40ae08:	6a21      	ldr	r1, [r4, #32]
  40ae0a:	4628      	mov	r0, r5
  40ae0c:	47b0      	blx	r6
  40ae0e:	1c43      	adds	r3, r0, #1
  40ae10:	89a3      	ldrh	r3, [r4, #12]
  40ae12:	d106      	bne.n	40ae22 <__sflush_r+0x66>
  40ae14:	6829      	ldr	r1, [r5, #0]
  40ae16:	291d      	cmp	r1, #29
  40ae18:	d84b      	bhi.n	40aeb2 <__sflush_r+0xf6>
  40ae1a:	4a2b      	ldr	r2, [pc, #172]	; (40aec8 <__sflush_r+0x10c>)
  40ae1c:	40ca      	lsrs	r2, r1
  40ae1e:	07d6      	lsls	r6, r2, #31
  40ae20:	d547      	bpl.n	40aeb2 <__sflush_r+0xf6>
  40ae22:	2200      	movs	r2, #0
  40ae24:	6062      	str	r2, [r4, #4]
  40ae26:	04d9      	lsls	r1, r3, #19
  40ae28:	6922      	ldr	r2, [r4, #16]
  40ae2a:	6022      	str	r2, [r4, #0]
  40ae2c:	d504      	bpl.n	40ae38 <__sflush_r+0x7c>
  40ae2e:	1c42      	adds	r2, r0, #1
  40ae30:	d101      	bne.n	40ae36 <__sflush_r+0x7a>
  40ae32:	682b      	ldr	r3, [r5, #0]
  40ae34:	b903      	cbnz	r3, 40ae38 <__sflush_r+0x7c>
  40ae36:	6560      	str	r0, [r4, #84]	; 0x54
  40ae38:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40ae3a:	602f      	str	r7, [r5, #0]
  40ae3c:	2900      	cmp	r1, #0
  40ae3e:	d0ca      	beq.n	40add6 <__sflush_r+0x1a>
  40ae40:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40ae44:	4299      	cmp	r1, r3
  40ae46:	d002      	beq.n	40ae4e <__sflush_r+0x92>
  40ae48:	4628      	mov	r0, r5
  40ae4a:	f000 fcdf 	bl	40b80c <_free_r>
  40ae4e:	2000      	movs	r0, #0
  40ae50:	6360      	str	r0, [r4, #52]	; 0x34
  40ae52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40ae56:	6a21      	ldr	r1, [r4, #32]
  40ae58:	2301      	movs	r3, #1
  40ae5a:	4628      	mov	r0, r5
  40ae5c:	47b0      	blx	r6
  40ae5e:	1c41      	adds	r1, r0, #1
  40ae60:	d1c6      	bne.n	40adf0 <__sflush_r+0x34>
  40ae62:	682b      	ldr	r3, [r5, #0]
  40ae64:	2b00      	cmp	r3, #0
  40ae66:	d0c3      	beq.n	40adf0 <__sflush_r+0x34>
  40ae68:	2b1d      	cmp	r3, #29
  40ae6a:	d001      	beq.n	40ae70 <__sflush_r+0xb4>
  40ae6c:	2b16      	cmp	r3, #22
  40ae6e:	d101      	bne.n	40ae74 <__sflush_r+0xb8>
  40ae70:	602f      	str	r7, [r5, #0]
  40ae72:	e7b0      	b.n	40add6 <__sflush_r+0x1a>
  40ae74:	89a3      	ldrh	r3, [r4, #12]
  40ae76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40ae7a:	81a3      	strh	r3, [r4, #12]
  40ae7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40ae80:	690f      	ldr	r7, [r1, #16]
  40ae82:	2f00      	cmp	r7, #0
  40ae84:	d0a7      	beq.n	40add6 <__sflush_r+0x1a>
  40ae86:	0793      	lsls	r3, r2, #30
  40ae88:	680e      	ldr	r6, [r1, #0]
  40ae8a:	bf08      	it	eq
  40ae8c:	694b      	ldreq	r3, [r1, #20]
  40ae8e:	600f      	str	r7, [r1, #0]
  40ae90:	bf18      	it	ne
  40ae92:	2300      	movne	r3, #0
  40ae94:	eba6 0807 	sub.w	r8, r6, r7
  40ae98:	608b      	str	r3, [r1, #8]
  40ae9a:	f1b8 0f00 	cmp.w	r8, #0
  40ae9e:	dd9a      	ble.n	40add6 <__sflush_r+0x1a>
  40aea0:	4643      	mov	r3, r8
  40aea2:	463a      	mov	r2, r7
  40aea4:	6a21      	ldr	r1, [r4, #32]
  40aea6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  40aea8:	4628      	mov	r0, r5
  40aeaa:	47b0      	blx	r6
  40aeac:	2800      	cmp	r0, #0
  40aeae:	dc07      	bgt.n	40aec0 <__sflush_r+0x104>
  40aeb0:	89a3      	ldrh	r3, [r4, #12]
  40aeb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40aeb6:	81a3      	strh	r3, [r4, #12]
  40aeb8:	f04f 30ff 	mov.w	r0, #4294967295
  40aebc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40aec0:	4407      	add	r7, r0
  40aec2:	eba8 0800 	sub.w	r8, r8, r0
  40aec6:	e7e8      	b.n	40ae9a <__sflush_r+0xde>
  40aec8:	20400001 	.word	0x20400001

0040aecc <_fflush_r>:
  40aecc:	b538      	push	{r3, r4, r5, lr}
  40aece:	690b      	ldr	r3, [r1, #16]
  40aed0:	4605      	mov	r5, r0
  40aed2:	460c      	mov	r4, r1
  40aed4:	b1db      	cbz	r3, 40af0e <_fflush_r+0x42>
  40aed6:	b118      	cbz	r0, 40aee0 <_fflush_r+0x14>
  40aed8:	6983      	ldr	r3, [r0, #24]
  40aeda:	b90b      	cbnz	r3, 40aee0 <_fflush_r+0x14>
  40aedc:	f000 f860 	bl	40afa0 <__sinit>
  40aee0:	4b0c      	ldr	r3, [pc, #48]	; (40af14 <_fflush_r+0x48>)
  40aee2:	429c      	cmp	r4, r3
  40aee4:	d109      	bne.n	40aefa <_fflush_r+0x2e>
  40aee6:	686c      	ldr	r4, [r5, #4]
  40aee8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40aeec:	b17b      	cbz	r3, 40af0e <_fflush_r+0x42>
  40aeee:	4621      	mov	r1, r4
  40aef0:	4628      	mov	r0, r5
  40aef2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40aef6:	f7ff bf61 	b.w	40adbc <__sflush_r>
  40aefa:	4b07      	ldr	r3, [pc, #28]	; (40af18 <_fflush_r+0x4c>)
  40aefc:	429c      	cmp	r4, r3
  40aefe:	d101      	bne.n	40af04 <_fflush_r+0x38>
  40af00:	68ac      	ldr	r4, [r5, #8]
  40af02:	e7f1      	b.n	40aee8 <_fflush_r+0x1c>
  40af04:	4b05      	ldr	r3, [pc, #20]	; (40af1c <_fflush_r+0x50>)
  40af06:	429c      	cmp	r4, r3
  40af08:	bf08      	it	eq
  40af0a:	68ec      	ldreq	r4, [r5, #12]
  40af0c:	e7ec      	b.n	40aee8 <_fflush_r+0x1c>
  40af0e:	2000      	movs	r0, #0
  40af10:	bd38      	pop	{r3, r4, r5, pc}
  40af12:	bf00      	nop
  40af14:	0040defc 	.word	0x0040defc
  40af18:	0040df1c 	.word	0x0040df1c
  40af1c:	0040dedc 	.word	0x0040dedc

0040af20 <_cleanup_r>:
  40af20:	4901      	ldr	r1, [pc, #4]	; (40af28 <_cleanup_r+0x8>)
  40af22:	f000 b8a9 	b.w	40b078 <_fwalk_reent>
  40af26:	bf00      	nop
  40af28:	0040aecd 	.word	0x0040aecd

0040af2c <std.isra.0>:
  40af2c:	2300      	movs	r3, #0
  40af2e:	b510      	push	{r4, lr}
  40af30:	4604      	mov	r4, r0
  40af32:	6003      	str	r3, [r0, #0]
  40af34:	6043      	str	r3, [r0, #4]
  40af36:	6083      	str	r3, [r0, #8]
  40af38:	8181      	strh	r1, [r0, #12]
  40af3a:	6643      	str	r3, [r0, #100]	; 0x64
  40af3c:	81c2      	strh	r2, [r0, #14]
  40af3e:	6103      	str	r3, [r0, #16]
  40af40:	6143      	str	r3, [r0, #20]
  40af42:	6183      	str	r3, [r0, #24]
  40af44:	4619      	mov	r1, r3
  40af46:	2208      	movs	r2, #8
  40af48:	305c      	adds	r0, #92	; 0x5c
  40af4a:	f7fe fb66 	bl	40961a <memset>
  40af4e:	4b05      	ldr	r3, [pc, #20]	; (40af64 <std.isra.0+0x38>)
  40af50:	6263      	str	r3, [r4, #36]	; 0x24
  40af52:	4b05      	ldr	r3, [pc, #20]	; (40af68 <std.isra.0+0x3c>)
  40af54:	62a3      	str	r3, [r4, #40]	; 0x28
  40af56:	4b05      	ldr	r3, [pc, #20]	; (40af6c <std.isra.0+0x40>)
  40af58:	62e3      	str	r3, [r4, #44]	; 0x2c
  40af5a:	4b05      	ldr	r3, [pc, #20]	; (40af70 <std.isra.0+0x44>)
  40af5c:	6224      	str	r4, [r4, #32]
  40af5e:	6323      	str	r3, [r4, #48]	; 0x30
  40af60:	bd10      	pop	{r4, pc}
  40af62:	bf00      	nop
  40af64:	0040bea1 	.word	0x0040bea1
  40af68:	0040bec3 	.word	0x0040bec3
  40af6c:	0040befb 	.word	0x0040befb
  40af70:	0040bf1f 	.word	0x0040bf1f

0040af74 <__sfmoreglue>:
  40af74:	b570      	push	{r4, r5, r6, lr}
  40af76:	1e4a      	subs	r2, r1, #1
  40af78:	2568      	movs	r5, #104	; 0x68
  40af7a:	4355      	muls	r5, r2
  40af7c:	460e      	mov	r6, r1
  40af7e:	f105 0174 	add.w	r1, r5, #116	; 0x74
  40af82:	f000 fc91 	bl	40b8a8 <_malloc_r>
  40af86:	4604      	mov	r4, r0
  40af88:	b140      	cbz	r0, 40af9c <__sfmoreglue+0x28>
  40af8a:	2100      	movs	r1, #0
  40af8c:	e880 0042 	stmia.w	r0, {r1, r6}
  40af90:	300c      	adds	r0, #12
  40af92:	60a0      	str	r0, [r4, #8]
  40af94:	f105 0268 	add.w	r2, r5, #104	; 0x68
  40af98:	f7fe fb3f 	bl	40961a <memset>
  40af9c:	4620      	mov	r0, r4
  40af9e:	bd70      	pop	{r4, r5, r6, pc}

0040afa0 <__sinit>:
  40afa0:	6983      	ldr	r3, [r0, #24]
  40afa2:	b510      	push	{r4, lr}
  40afa4:	4604      	mov	r4, r0
  40afa6:	bb33      	cbnz	r3, 40aff6 <__sinit+0x56>
  40afa8:	6483      	str	r3, [r0, #72]	; 0x48
  40afaa:	64c3      	str	r3, [r0, #76]	; 0x4c
  40afac:	6503      	str	r3, [r0, #80]	; 0x50
  40afae:	4b12      	ldr	r3, [pc, #72]	; (40aff8 <__sinit+0x58>)
  40afb0:	4a12      	ldr	r2, [pc, #72]	; (40affc <__sinit+0x5c>)
  40afb2:	681b      	ldr	r3, [r3, #0]
  40afb4:	6282      	str	r2, [r0, #40]	; 0x28
  40afb6:	4298      	cmp	r0, r3
  40afb8:	bf04      	itt	eq
  40afba:	2301      	moveq	r3, #1
  40afbc:	6183      	streq	r3, [r0, #24]
  40afbe:	f000 f81f 	bl	40b000 <__sfp>
  40afc2:	6060      	str	r0, [r4, #4]
  40afc4:	4620      	mov	r0, r4
  40afc6:	f000 f81b 	bl	40b000 <__sfp>
  40afca:	60a0      	str	r0, [r4, #8]
  40afcc:	4620      	mov	r0, r4
  40afce:	f000 f817 	bl	40b000 <__sfp>
  40afd2:	2200      	movs	r2, #0
  40afd4:	60e0      	str	r0, [r4, #12]
  40afd6:	2104      	movs	r1, #4
  40afd8:	6860      	ldr	r0, [r4, #4]
  40afda:	f7ff ffa7 	bl	40af2c <std.isra.0>
  40afde:	2201      	movs	r2, #1
  40afe0:	2109      	movs	r1, #9
  40afe2:	68a0      	ldr	r0, [r4, #8]
  40afe4:	f7ff ffa2 	bl	40af2c <std.isra.0>
  40afe8:	2202      	movs	r2, #2
  40afea:	2112      	movs	r1, #18
  40afec:	68e0      	ldr	r0, [r4, #12]
  40afee:	f7ff ff9d 	bl	40af2c <std.isra.0>
  40aff2:	2301      	movs	r3, #1
  40aff4:	61a3      	str	r3, [r4, #24]
  40aff6:	bd10      	pop	{r4, pc}
  40aff8:	0040de94 	.word	0x0040de94
  40affc:	0040af21 	.word	0x0040af21

0040b000 <__sfp>:
  40b000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40b002:	4b1c      	ldr	r3, [pc, #112]	; (40b074 <__sfp+0x74>)
  40b004:	681e      	ldr	r6, [r3, #0]
  40b006:	69b3      	ldr	r3, [r6, #24]
  40b008:	4607      	mov	r7, r0
  40b00a:	b913      	cbnz	r3, 40b012 <__sfp+0x12>
  40b00c:	4630      	mov	r0, r6
  40b00e:	f7ff ffc7 	bl	40afa0 <__sinit>
  40b012:	3648      	adds	r6, #72	; 0x48
  40b014:	68b4      	ldr	r4, [r6, #8]
  40b016:	6873      	ldr	r3, [r6, #4]
  40b018:	3b01      	subs	r3, #1
  40b01a:	d503      	bpl.n	40b024 <__sfp+0x24>
  40b01c:	6833      	ldr	r3, [r6, #0]
  40b01e:	b133      	cbz	r3, 40b02e <__sfp+0x2e>
  40b020:	6836      	ldr	r6, [r6, #0]
  40b022:	e7f7      	b.n	40b014 <__sfp+0x14>
  40b024:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  40b028:	b16d      	cbz	r5, 40b046 <__sfp+0x46>
  40b02a:	3468      	adds	r4, #104	; 0x68
  40b02c:	e7f4      	b.n	40b018 <__sfp+0x18>
  40b02e:	2104      	movs	r1, #4
  40b030:	4638      	mov	r0, r7
  40b032:	f7ff ff9f 	bl	40af74 <__sfmoreglue>
  40b036:	6030      	str	r0, [r6, #0]
  40b038:	2800      	cmp	r0, #0
  40b03a:	d1f1      	bne.n	40b020 <__sfp+0x20>
  40b03c:	230c      	movs	r3, #12
  40b03e:	603b      	str	r3, [r7, #0]
  40b040:	4604      	mov	r4, r0
  40b042:	4620      	mov	r0, r4
  40b044:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40b046:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40b04a:	81e3      	strh	r3, [r4, #14]
  40b04c:	2301      	movs	r3, #1
  40b04e:	81a3      	strh	r3, [r4, #12]
  40b050:	6665      	str	r5, [r4, #100]	; 0x64
  40b052:	6025      	str	r5, [r4, #0]
  40b054:	60a5      	str	r5, [r4, #8]
  40b056:	6065      	str	r5, [r4, #4]
  40b058:	6125      	str	r5, [r4, #16]
  40b05a:	6165      	str	r5, [r4, #20]
  40b05c:	61a5      	str	r5, [r4, #24]
  40b05e:	2208      	movs	r2, #8
  40b060:	4629      	mov	r1, r5
  40b062:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  40b066:	f7fe fad8 	bl	40961a <memset>
  40b06a:	6365      	str	r5, [r4, #52]	; 0x34
  40b06c:	63a5      	str	r5, [r4, #56]	; 0x38
  40b06e:	64a5      	str	r5, [r4, #72]	; 0x48
  40b070:	64e5      	str	r5, [r4, #76]	; 0x4c
  40b072:	e7e6      	b.n	40b042 <__sfp+0x42>
  40b074:	0040de94 	.word	0x0040de94

0040b078 <_fwalk_reent>:
  40b078:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40b07c:	4680      	mov	r8, r0
  40b07e:	4689      	mov	r9, r1
  40b080:	f100 0448 	add.w	r4, r0, #72	; 0x48
  40b084:	2600      	movs	r6, #0
  40b086:	b914      	cbnz	r4, 40b08e <_fwalk_reent+0x16>
  40b088:	4630      	mov	r0, r6
  40b08a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40b08e:	68a5      	ldr	r5, [r4, #8]
  40b090:	6867      	ldr	r7, [r4, #4]
  40b092:	3f01      	subs	r7, #1
  40b094:	d501      	bpl.n	40b09a <_fwalk_reent+0x22>
  40b096:	6824      	ldr	r4, [r4, #0]
  40b098:	e7f5      	b.n	40b086 <_fwalk_reent+0xe>
  40b09a:	89ab      	ldrh	r3, [r5, #12]
  40b09c:	2b01      	cmp	r3, #1
  40b09e:	d907      	bls.n	40b0b0 <_fwalk_reent+0x38>
  40b0a0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  40b0a4:	3301      	adds	r3, #1
  40b0a6:	d003      	beq.n	40b0b0 <_fwalk_reent+0x38>
  40b0a8:	4629      	mov	r1, r5
  40b0aa:	4640      	mov	r0, r8
  40b0ac:	47c8      	blx	r9
  40b0ae:	4306      	orrs	r6, r0
  40b0b0:	3568      	adds	r5, #104	; 0x68
  40b0b2:	e7ee      	b.n	40b092 <_fwalk_reent+0x1a>

0040b0b4 <_localeconv_r>:
  40b0b4:	4b04      	ldr	r3, [pc, #16]	; (40b0c8 <_localeconv_r+0x14>)
  40b0b6:	681b      	ldr	r3, [r3, #0]
  40b0b8:	6a18      	ldr	r0, [r3, #32]
  40b0ba:	4b04      	ldr	r3, [pc, #16]	; (40b0cc <_localeconv_r+0x18>)
  40b0bc:	2800      	cmp	r0, #0
  40b0be:	bf08      	it	eq
  40b0c0:	4618      	moveq	r0, r3
  40b0c2:	30f0      	adds	r0, #240	; 0xf0
  40b0c4:	4770      	bx	lr
  40b0c6:	bf00      	nop
  40b0c8:	20000178 	.word	0x20000178
  40b0cc:	200001dc 	.word	0x200001dc

0040b0d0 <__swhatbuf_r>:
  40b0d0:	b570      	push	{r4, r5, r6, lr}
  40b0d2:	460e      	mov	r6, r1
  40b0d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40b0d8:	2900      	cmp	r1, #0
  40b0da:	b090      	sub	sp, #64	; 0x40
  40b0dc:	4614      	mov	r4, r2
  40b0de:	461d      	mov	r5, r3
  40b0e0:	da07      	bge.n	40b0f2 <__swhatbuf_r+0x22>
  40b0e2:	2300      	movs	r3, #0
  40b0e4:	602b      	str	r3, [r5, #0]
  40b0e6:	89b3      	ldrh	r3, [r6, #12]
  40b0e8:	061a      	lsls	r2, r3, #24
  40b0ea:	d410      	bmi.n	40b10e <__swhatbuf_r+0x3e>
  40b0ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40b0f0:	e00e      	b.n	40b110 <__swhatbuf_r+0x40>
  40b0f2:	aa01      	add	r2, sp, #4
  40b0f4:	f000 fffa 	bl	40c0ec <_fstat_r>
  40b0f8:	2800      	cmp	r0, #0
  40b0fa:	dbf2      	blt.n	40b0e2 <__swhatbuf_r+0x12>
  40b0fc:	9a02      	ldr	r2, [sp, #8]
  40b0fe:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  40b102:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  40b106:	425a      	negs	r2, r3
  40b108:	415a      	adcs	r2, r3
  40b10a:	602a      	str	r2, [r5, #0]
  40b10c:	e7ee      	b.n	40b0ec <__swhatbuf_r+0x1c>
  40b10e:	2340      	movs	r3, #64	; 0x40
  40b110:	2000      	movs	r0, #0
  40b112:	6023      	str	r3, [r4, #0]
  40b114:	b010      	add	sp, #64	; 0x40
  40b116:	bd70      	pop	{r4, r5, r6, pc}

0040b118 <__smakebuf_r>:
  40b118:	898b      	ldrh	r3, [r1, #12]
  40b11a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  40b11c:	079d      	lsls	r5, r3, #30
  40b11e:	4606      	mov	r6, r0
  40b120:	460c      	mov	r4, r1
  40b122:	d507      	bpl.n	40b134 <__smakebuf_r+0x1c>
  40b124:	f104 0347 	add.w	r3, r4, #71	; 0x47
  40b128:	6023      	str	r3, [r4, #0]
  40b12a:	6123      	str	r3, [r4, #16]
  40b12c:	2301      	movs	r3, #1
  40b12e:	6163      	str	r3, [r4, #20]
  40b130:	b002      	add	sp, #8
  40b132:	bd70      	pop	{r4, r5, r6, pc}
  40b134:	ab01      	add	r3, sp, #4
  40b136:	466a      	mov	r2, sp
  40b138:	f7ff ffca 	bl	40b0d0 <__swhatbuf_r>
  40b13c:	9900      	ldr	r1, [sp, #0]
  40b13e:	4605      	mov	r5, r0
  40b140:	4630      	mov	r0, r6
  40b142:	f000 fbb1 	bl	40b8a8 <_malloc_r>
  40b146:	b948      	cbnz	r0, 40b15c <__smakebuf_r+0x44>
  40b148:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40b14c:	059a      	lsls	r2, r3, #22
  40b14e:	d4ef      	bmi.n	40b130 <__smakebuf_r+0x18>
  40b150:	f023 0303 	bic.w	r3, r3, #3
  40b154:	f043 0302 	orr.w	r3, r3, #2
  40b158:	81a3      	strh	r3, [r4, #12]
  40b15a:	e7e3      	b.n	40b124 <__smakebuf_r+0xc>
  40b15c:	4b0d      	ldr	r3, [pc, #52]	; (40b194 <__smakebuf_r+0x7c>)
  40b15e:	62b3      	str	r3, [r6, #40]	; 0x28
  40b160:	89a3      	ldrh	r3, [r4, #12]
  40b162:	6020      	str	r0, [r4, #0]
  40b164:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40b168:	81a3      	strh	r3, [r4, #12]
  40b16a:	9b00      	ldr	r3, [sp, #0]
  40b16c:	6163      	str	r3, [r4, #20]
  40b16e:	9b01      	ldr	r3, [sp, #4]
  40b170:	6120      	str	r0, [r4, #16]
  40b172:	b15b      	cbz	r3, 40b18c <__smakebuf_r+0x74>
  40b174:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40b178:	4630      	mov	r0, r6
  40b17a:	f000 ffc9 	bl	40c110 <_isatty_r>
  40b17e:	b128      	cbz	r0, 40b18c <__smakebuf_r+0x74>
  40b180:	89a3      	ldrh	r3, [r4, #12]
  40b182:	f023 0303 	bic.w	r3, r3, #3
  40b186:	f043 0301 	orr.w	r3, r3, #1
  40b18a:	81a3      	strh	r3, [r4, #12]
  40b18c:	89a3      	ldrh	r3, [r4, #12]
  40b18e:	431d      	orrs	r5, r3
  40b190:	81a5      	strh	r5, [r4, #12]
  40b192:	e7cd      	b.n	40b130 <__smakebuf_r+0x18>
  40b194:	0040af21 	.word	0x0040af21

0040b198 <malloc>:
  40b198:	4b02      	ldr	r3, [pc, #8]	; (40b1a4 <malloc+0xc>)
  40b19a:	4601      	mov	r1, r0
  40b19c:	6818      	ldr	r0, [r3, #0]
  40b19e:	f000 bb83 	b.w	40b8a8 <_malloc_r>
  40b1a2:	bf00      	nop
  40b1a4:	20000178 	.word	0x20000178
	...

0040b1b0 <memchr>:
  40b1b0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40b1b4:	2a10      	cmp	r2, #16
  40b1b6:	db2b      	blt.n	40b210 <memchr+0x60>
  40b1b8:	f010 0f07 	tst.w	r0, #7
  40b1bc:	d008      	beq.n	40b1d0 <memchr+0x20>
  40b1be:	f810 3b01 	ldrb.w	r3, [r0], #1
  40b1c2:	3a01      	subs	r2, #1
  40b1c4:	428b      	cmp	r3, r1
  40b1c6:	d02d      	beq.n	40b224 <memchr+0x74>
  40b1c8:	f010 0f07 	tst.w	r0, #7
  40b1cc:	b342      	cbz	r2, 40b220 <memchr+0x70>
  40b1ce:	d1f6      	bne.n	40b1be <memchr+0xe>
  40b1d0:	b4f0      	push	{r4, r5, r6, r7}
  40b1d2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  40b1d6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  40b1da:	f022 0407 	bic.w	r4, r2, #7
  40b1de:	f07f 0700 	mvns.w	r7, #0
  40b1e2:	2300      	movs	r3, #0
  40b1e4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  40b1e8:	3c08      	subs	r4, #8
  40b1ea:	ea85 0501 	eor.w	r5, r5, r1
  40b1ee:	ea86 0601 	eor.w	r6, r6, r1
  40b1f2:	fa85 f547 	uadd8	r5, r5, r7
  40b1f6:	faa3 f587 	sel	r5, r3, r7
  40b1fa:	fa86 f647 	uadd8	r6, r6, r7
  40b1fe:	faa5 f687 	sel	r6, r5, r7
  40b202:	b98e      	cbnz	r6, 40b228 <memchr+0x78>
  40b204:	d1ee      	bne.n	40b1e4 <memchr+0x34>
  40b206:	bcf0      	pop	{r4, r5, r6, r7}
  40b208:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40b20c:	f002 0207 	and.w	r2, r2, #7
  40b210:	b132      	cbz	r2, 40b220 <memchr+0x70>
  40b212:	f810 3b01 	ldrb.w	r3, [r0], #1
  40b216:	3a01      	subs	r2, #1
  40b218:	ea83 0301 	eor.w	r3, r3, r1
  40b21c:	b113      	cbz	r3, 40b224 <memchr+0x74>
  40b21e:	d1f8      	bne.n	40b212 <memchr+0x62>
  40b220:	2000      	movs	r0, #0
  40b222:	4770      	bx	lr
  40b224:	3801      	subs	r0, #1
  40b226:	4770      	bx	lr
  40b228:	2d00      	cmp	r5, #0
  40b22a:	bf06      	itte	eq
  40b22c:	4635      	moveq	r5, r6
  40b22e:	3803      	subeq	r0, #3
  40b230:	3807      	subne	r0, #7
  40b232:	f015 0f01 	tst.w	r5, #1
  40b236:	d107      	bne.n	40b248 <memchr+0x98>
  40b238:	3001      	adds	r0, #1
  40b23a:	f415 7f80 	tst.w	r5, #256	; 0x100
  40b23e:	bf02      	ittt	eq
  40b240:	3001      	addeq	r0, #1
  40b242:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  40b246:	3001      	addeq	r0, #1
  40b248:	bcf0      	pop	{r4, r5, r6, r7}
  40b24a:	3801      	subs	r0, #1
  40b24c:	4770      	bx	lr
  40b24e:	bf00      	nop

0040b250 <_Balloc>:
  40b250:	b570      	push	{r4, r5, r6, lr}
  40b252:	6a45      	ldr	r5, [r0, #36]	; 0x24
  40b254:	4604      	mov	r4, r0
  40b256:	460e      	mov	r6, r1
  40b258:	b93d      	cbnz	r5, 40b26a <_Balloc+0x1a>
  40b25a:	2010      	movs	r0, #16
  40b25c:	f7ff ff9c 	bl	40b198 <malloc>
  40b260:	6260      	str	r0, [r4, #36]	; 0x24
  40b262:	6045      	str	r5, [r0, #4]
  40b264:	6085      	str	r5, [r0, #8]
  40b266:	6005      	str	r5, [r0, #0]
  40b268:	60c5      	str	r5, [r0, #12]
  40b26a:	6a65      	ldr	r5, [r4, #36]	; 0x24
  40b26c:	68eb      	ldr	r3, [r5, #12]
  40b26e:	b183      	cbz	r3, 40b292 <_Balloc+0x42>
  40b270:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40b272:	68db      	ldr	r3, [r3, #12]
  40b274:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
  40b278:	b9b8      	cbnz	r0, 40b2aa <_Balloc+0x5a>
  40b27a:	2101      	movs	r1, #1
  40b27c:	fa01 f506 	lsl.w	r5, r1, r6
  40b280:	1d6a      	adds	r2, r5, #5
  40b282:	0092      	lsls	r2, r2, #2
  40b284:	4620      	mov	r0, r4
  40b286:	f000 fab3 	bl	40b7f0 <_calloc_r>
  40b28a:	b160      	cbz	r0, 40b2a6 <_Balloc+0x56>
  40b28c:	6046      	str	r6, [r0, #4]
  40b28e:	6085      	str	r5, [r0, #8]
  40b290:	e00e      	b.n	40b2b0 <_Balloc+0x60>
  40b292:	2221      	movs	r2, #33	; 0x21
  40b294:	2104      	movs	r1, #4
  40b296:	4620      	mov	r0, r4
  40b298:	f000 faaa 	bl	40b7f0 <_calloc_r>
  40b29c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40b29e:	60e8      	str	r0, [r5, #12]
  40b2a0:	68db      	ldr	r3, [r3, #12]
  40b2a2:	2b00      	cmp	r3, #0
  40b2a4:	d1e4      	bne.n	40b270 <_Balloc+0x20>
  40b2a6:	2000      	movs	r0, #0
  40b2a8:	bd70      	pop	{r4, r5, r6, pc}
  40b2aa:	6802      	ldr	r2, [r0, #0]
  40b2ac:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
  40b2b0:	2300      	movs	r3, #0
  40b2b2:	6103      	str	r3, [r0, #16]
  40b2b4:	60c3      	str	r3, [r0, #12]
  40b2b6:	bd70      	pop	{r4, r5, r6, pc}

0040b2b8 <_Bfree>:
  40b2b8:	b570      	push	{r4, r5, r6, lr}
  40b2ba:	6a44      	ldr	r4, [r0, #36]	; 0x24
  40b2bc:	4606      	mov	r6, r0
  40b2be:	460d      	mov	r5, r1
  40b2c0:	b93c      	cbnz	r4, 40b2d2 <_Bfree+0x1a>
  40b2c2:	2010      	movs	r0, #16
  40b2c4:	f7ff ff68 	bl	40b198 <malloc>
  40b2c8:	6270      	str	r0, [r6, #36]	; 0x24
  40b2ca:	6044      	str	r4, [r0, #4]
  40b2cc:	6084      	str	r4, [r0, #8]
  40b2ce:	6004      	str	r4, [r0, #0]
  40b2d0:	60c4      	str	r4, [r0, #12]
  40b2d2:	b13d      	cbz	r5, 40b2e4 <_Bfree+0x2c>
  40b2d4:	6a73      	ldr	r3, [r6, #36]	; 0x24
  40b2d6:	686a      	ldr	r2, [r5, #4]
  40b2d8:	68db      	ldr	r3, [r3, #12]
  40b2da:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  40b2de:	6029      	str	r1, [r5, #0]
  40b2e0:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
  40b2e4:	bd70      	pop	{r4, r5, r6, pc}

0040b2e6 <__multadd>:
  40b2e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40b2ea:	690d      	ldr	r5, [r1, #16]
  40b2ec:	461f      	mov	r7, r3
  40b2ee:	4606      	mov	r6, r0
  40b2f0:	460c      	mov	r4, r1
  40b2f2:	f101 0e14 	add.w	lr, r1, #20
  40b2f6:	2300      	movs	r3, #0
  40b2f8:	f8de 0000 	ldr.w	r0, [lr]
  40b2fc:	b281      	uxth	r1, r0
  40b2fe:	fb02 7101 	mla	r1, r2, r1, r7
  40b302:	0c0f      	lsrs	r7, r1, #16
  40b304:	0c00      	lsrs	r0, r0, #16
  40b306:	fb02 7000 	mla	r0, r2, r0, r7
  40b30a:	b289      	uxth	r1, r1
  40b30c:	3301      	adds	r3, #1
  40b30e:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  40b312:	429d      	cmp	r5, r3
  40b314:	ea4f 4710 	mov.w	r7, r0, lsr #16
  40b318:	f84e 1b04 	str.w	r1, [lr], #4
  40b31c:	dcec      	bgt.n	40b2f8 <__multadd+0x12>
  40b31e:	b1d7      	cbz	r7, 40b356 <__multadd+0x70>
  40b320:	68a3      	ldr	r3, [r4, #8]
  40b322:	429d      	cmp	r5, r3
  40b324:	db12      	blt.n	40b34c <__multadd+0x66>
  40b326:	6861      	ldr	r1, [r4, #4]
  40b328:	4630      	mov	r0, r6
  40b32a:	3101      	adds	r1, #1
  40b32c:	f7ff ff90 	bl	40b250 <_Balloc>
  40b330:	6922      	ldr	r2, [r4, #16]
  40b332:	3202      	adds	r2, #2
  40b334:	f104 010c 	add.w	r1, r4, #12
  40b338:	4680      	mov	r8, r0
  40b33a:	0092      	lsls	r2, r2, #2
  40b33c:	300c      	adds	r0, #12
  40b33e:	f7fe f961 	bl	409604 <memcpy>
  40b342:	4621      	mov	r1, r4
  40b344:	4630      	mov	r0, r6
  40b346:	f7ff ffb7 	bl	40b2b8 <_Bfree>
  40b34a:	4644      	mov	r4, r8
  40b34c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
  40b350:	3501      	adds	r5, #1
  40b352:	615f      	str	r7, [r3, #20]
  40b354:	6125      	str	r5, [r4, #16]
  40b356:	4620      	mov	r0, r4
  40b358:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0040b35c <__hi0bits>:
  40b35c:	0c02      	lsrs	r2, r0, #16
  40b35e:	0412      	lsls	r2, r2, #16
  40b360:	4603      	mov	r3, r0
  40b362:	b9b2      	cbnz	r2, 40b392 <__hi0bits+0x36>
  40b364:	0403      	lsls	r3, r0, #16
  40b366:	2010      	movs	r0, #16
  40b368:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
  40b36c:	bf04      	itt	eq
  40b36e:	021b      	lsleq	r3, r3, #8
  40b370:	3008      	addeq	r0, #8
  40b372:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
  40b376:	bf04      	itt	eq
  40b378:	011b      	lsleq	r3, r3, #4
  40b37a:	3004      	addeq	r0, #4
  40b37c:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
  40b380:	bf04      	itt	eq
  40b382:	009b      	lsleq	r3, r3, #2
  40b384:	3002      	addeq	r0, #2
  40b386:	2b00      	cmp	r3, #0
  40b388:	db06      	blt.n	40b398 <__hi0bits+0x3c>
  40b38a:	005b      	lsls	r3, r3, #1
  40b38c:	d503      	bpl.n	40b396 <__hi0bits+0x3a>
  40b38e:	3001      	adds	r0, #1
  40b390:	4770      	bx	lr
  40b392:	2000      	movs	r0, #0
  40b394:	e7e8      	b.n	40b368 <__hi0bits+0xc>
  40b396:	2020      	movs	r0, #32
  40b398:	4770      	bx	lr

0040b39a <__lo0bits>:
  40b39a:	6803      	ldr	r3, [r0, #0]
  40b39c:	f013 0207 	ands.w	r2, r3, #7
  40b3a0:	4601      	mov	r1, r0
  40b3a2:	d00b      	beq.n	40b3bc <__lo0bits+0x22>
  40b3a4:	07da      	lsls	r2, r3, #31
  40b3a6:	d423      	bmi.n	40b3f0 <__lo0bits+0x56>
  40b3a8:	0798      	lsls	r0, r3, #30
  40b3aa:	bf49      	itett	mi
  40b3ac:	085b      	lsrmi	r3, r3, #1
  40b3ae:	089b      	lsrpl	r3, r3, #2
  40b3b0:	2001      	movmi	r0, #1
  40b3b2:	600b      	strmi	r3, [r1, #0]
  40b3b4:	bf5c      	itt	pl
  40b3b6:	600b      	strpl	r3, [r1, #0]
  40b3b8:	2002      	movpl	r0, #2
  40b3ba:	4770      	bx	lr
  40b3bc:	b298      	uxth	r0, r3
  40b3be:	b9a8      	cbnz	r0, 40b3ec <__lo0bits+0x52>
  40b3c0:	0c1b      	lsrs	r3, r3, #16
  40b3c2:	2010      	movs	r0, #16
  40b3c4:	f013 0fff 	tst.w	r3, #255	; 0xff
  40b3c8:	bf04      	itt	eq
  40b3ca:	0a1b      	lsreq	r3, r3, #8
  40b3cc:	3008      	addeq	r0, #8
  40b3ce:	071a      	lsls	r2, r3, #28
  40b3d0:	bf04      	itt	eq
  40b3d2:	091b      	lsreq	r3, r3, #4
  40b3d4:	3004      	addeq	r0, #4
  40b3d6:	079a      	lsls	r2, r3, #30
  40b3d8:	bf04      	itt	eq
  40b3da:	089b      	lsreq	r3, r3, #2
  40b3dc:	3002      	addeq	r0, #2
  40b3de:	07da      	lsls	r2, r3, #31
  40b3e0:	d402      	bmi.n	40b3e8 <__lo0bits+0x4e>
  40b3e2:	085b      	lsrs	r3, r3, #1
  40b3e4:	d006      	beq.n	40b3f4 <__lo0bits+0x5a>
  40b3e6:	3001      	adds	r0, #1
  40b3e8:	600b      	str	r3, [r1, #0]
  40b3ea:	4770      	bx	lr
  40b3ec:	4610      	mov	r0, r2
  40b3ee:	e7e9      	b.n	40b3c4 <__lo0bits+0x2a>
  40b3f0:	2000      	movs	r0, #0
  40b3f2:	4770      	bx	lr
  40b3f4:	2020      	movs	r0, #32
  40b3f6:	4770      	bx	lr

0040b3f8 <__i2b>:
  40b3f8:	b510      	push	{r4, lr}
  40b3fa:	460c      	mov	r4, r1
  40b3fc:	2101      	movs	r1, #1
  40b3fe:	f7ff ff27 	bl	40b250 <_Balloc>
  40b402:	2201      	movs	r2, #1
  40b404:	6144      	str	r4, [r0, #20]
  40b406:	6102      	str	r2, [r0, #16]
  40b408:	bd10      	pop	{r4, pc}

0040b40a <__multiply>:
  40b40a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40b40e:	4614      	mov	r4, r2
  40b410:	690a      	ldr	r2, [r1, #16]
  40b412:	6923      	ldr	r3, [r4, #16]
  40b414:	429a      	cmp	r2, r3
  40b416:	bfb8      	it	lt
  40b418:	460b      	movlt	r3, r1
  40b41a:	4689      	mov	r9, r1
  40b41c:	bfbc      	itt	lt
  40b41e:	46a1      	movlt	r9, r4
  40b420:	461c      	movlt	r4, r3
  40b422:	f8d9 7010 	ldr.w	r7, [r9, #16]
  40b426:	f8d4 a010 	ldr.w	sl, [r4, #16]
  40b42a:	f8d9 3008 	ldr.w	r3, [r9, #8]
  40b42e:	f8d9 1004 	ldr.w	r1, [r9, #4]
  40b432:	eb07 060a 	add.w	r6, r7, sl
  40b436:	429e      	cmp	r6, r3
  40b438:	bfc8      	it	gt
  40b43a:	3101      	addgt	r1, #1
  40b43c:	f7ff ff08 	bl	40b250 <_Balloc>
  40b440:	f100 0514 	add.w	r5, r0, #20
  40b444:	eb05 0886 	add.w	r8, r5, r6, lsl #2
  40b448:	462b      	mov	r3, r5
  40b44a:	2200      	movs	r2, #0
  40b44c:	4543      	cmp	r3, r8
  40b44e:	d316      	bcc.n	40b47e <__multiply+0x74>
  40b450:	f104 0214 	add.w	r2, r4, #20
  40b454:	f109 0114 	add.w	r1, r9, #20
  40b458:	eb02 038a 	add.w	r3, r2, sl, lsl #2
  40b45c:	eb01 0787 	add.w	r7, r1, r7, lsl #2
  40b460:	9301      	str	r3, [sp, #4]
  40b462:	9c01      	ldr	r4, [sp, #4]
  40b464:	4294      	cmp	r4, r2
  40b466:	4613      	mov	r3, r2
  40b468:	d80c      	bhi.n	40b484 <__multiply+0x7a>
  40b46a:	2e00      	cmp	r6, #0
  40b46c:	dd03      	ble.n	40b476 <__multiply+0x6c>
  40b46e:	f858 3d04 	ldr.w	r3, [r8, #-4]!
  40b472:	2b00      	cmp	r3, #0
  40b474:	d054      	beq.n	40b520 <__multiply+0x116>
  40b476:	6106      	str	r6, [r0, #16]
  40b478:	b003      	add	sp, #12
  40b47a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40b47e:	f843 2b04 	str.w	r2, [r3], #4
  40b482:	e7e3      	b.n	40b44c <__multiply+0x42>
  40b484:	f8b3 a000 	ldrh.w	sl, [r3]
  40b488:	3204      	adds	r2, #4
  40b48a:	f1ba 0f00 	cmp.w	sl, #0
  40b48e:	d020      	beq.n	40b4d2 <__multiply+0xc8>
  40b490:	46ae      	mov	lr, r5
  40b492:	4689      	mov	r9, r1
  40b494:	f04f 0c00 	mov.w	ip, #0
  40b498:	f859 4b04 	ldr.w	r4, [r9], #4
  40b49c:	f8be b000 	ldrh.w	fp, [lr]
  40b4a0:	b2a3      	uxth	r3, r4
  40b4a2:	fb0a b303 	mla	r3, sl, r3, fp
  40b4a6:	ea4f 4b14 	mov.w	fp, r4, lsr #16
  40b4aa:	f8de 4000 	ldr.w	r4, [lr]
  40b4ae:	4463      	add	r3, ip
  40b4b0:	ea4f 4c14 	mov.w	ip, r4, lsr #16
  40b4b4:	fb0a c40b 	mla	r4, sl, fp, ip
  40b4b8:	eb04 4413 	add.w	r4, r4, r3, lsr #16
  40b4bc:	b29b      	uxth	r3, r3
  40b4be:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  40b4c2:	454f      	cmp	r7, r9
  40b4c4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
  40b4c8:	f84e 3b04 	str.w	r3, [lr], #4
  40b4cc:	d8e4      	bhi.n	40b498 <__multiply+0x8e>
  40b4ce:	f8ce c000 	str.w	ip, [lr]
  40b4d2:	f832 9c02 	ldrh.w	r9, [r2, #-2]
  40b4d6:	f1b9 0f00 	cmp.w	r9, #0
  40b4da:	d01f      	beq.n	40b51c <__multiply+0x112>
  40b4dc:	682b      	ldr	r3, [r5, #0]
  40b4de:	46ae      	mov	lr, r5
  40b4e0:	468c      	mov	ip, r1
  40b4e2:	f04f 0a00 	mov.w	sl, #0
  40b4e6:	f8bc 4000 	ldrh.w	r4, [ip]
  40b4ea:	f8be b002 	ldrh.w	fp, [lr, #2]
  40b4ee:	fb09 b404 	mla	r4, r9, r4, fp
  40b4f2:	44a2      	add	sl, r4
  40b4f4:	b29b      	uxth	r3, r3
  40b4f6:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
  40b4fa:	f84e 3b04 	str.w	r3, [lr], #4
  40b4fe:	f85c 3b04 	ldr.w	r3, [ip], #4
  40b502:	f8be 4000 	ldrh.w	r4, [lr]
  40b506:	0c1b      	lsrs	r3, r3, #16
  40b508:	fb09 4303 	mla	r3, r9, r3, r4
  40b50c:	eb03 431a 	add.w	r3, r3, sl, lsr #16
  40b510:	4567      	cmp	r7, ip
  40b512:	ea4f 4a13 	mov.w	sl, r3, lsr #16
  40b516:	d8e6      	bhi.n	40b4e6 <__multiply+0xdc>
  40b518:	f8ce 3000 	str.w	r3, [lr]
  40b51c:	3504      	adds	r5, #4
  40b51e:	e7a0      	b.n	40b462 <__multiply+0x58>
  40b520:	3e01      	subs	r6, #1
  40b522:	e7a2      	b.n	40b46a <__multiply+0x60>

0040b524 <__pow5mult>:
  40b524:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40b528:	4615      	mov	r5, r2
  40b52a:	f012 0203 	ands.w	r2, r2, #3
  40b52e:	4606      	mov	r6, r0
  40b530:	460f      	mov	r7, r1
  40b532:	d007      	beq.n	40b544 <__pow5mult+0x20>
  40b534:	3a01      	subs	r2, #1
  40b536:	4c21      	ldr	r4, [pc, #132]	; (40b5bc <__pow5mult+0x98>)
  40b538:	2300      	movs	r3, #0
  40b53a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
  40b53e:	f7ff fed2 	bl	40b2e6 <__multadd>
  40b542:	4607      	mov	r7, r0
  40b544:	10ad      	asrs	r5, r5, #2
  40b546:	d035      	beq.n	40b5b4 <__pow5mult+0x90>
  40b548:	6a74      	ldr	r4, [r6, #36]	; 0x24
  40b54a:	b93c      	cbnz	r4, 40b55c <__pow5mult+0x38>
  40b54c:	2010      	movs	r0, #16
  40b54e:	f7ff fe23 	bl	40b198 <malloc>
  40b552:	6270      	str	r0, [r6, #36]	; 0x24
  40b554:	6044      	str	r4, [r0, #4]
  40b556:	6084      	str	r4, [r0, #8]
  40b558:	6004      	str	r4, [r0, #0]
  40b55a:	60c4      	str	r4, [r0, #12]
  40b55c:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
  40b560:	f8d8 4008 	ldr.w	r4, [r8, #8]
  40b564:	b94c      	cbnz	r4, 40b57a <__pow5mult+0x56>
  40b566:	f240 2171 	movw	r1, #625	; 0x271
  40b56a:	4630      	mov	r0, r6
  40b56c:	f7ff ff44 	bl	40b3f8 <__i2b>
  40b570:	2300      	movs	r3, #0
  40b572:	f8c8 0008 	str.w	r0, [r8, #8]
  40b576:	4604      	mov	r4, r0
  40b578:	6003      	str	r3, [r0, #0]
  40b57a:	f04f 0800 	mov.w	r8, #0
  40b57e:	07eb      	lsls	r3, r5, #31
  40b580:	d50a      	bpl.n	40b598 <__pow5mult+0x74>
  40b582:	4639      	mov	r1, r7
  40b584:	4622      	mov	r2, r4
  40b586:	4630      	mov	r0, r6
  40b588:	f7ff ff3f 	bl	40b40a <__multiply>
  40b58c:	4639      	mov	r1, r7
  40b58e:	4681      	mov	r9, r0
  40b590:	4630      	mov	r0, r6
  40b592:	f7ff fe91 	bl	40b2b8 <_Bfree>
  40b596:	464f      	mov	r7, r9
  40b598:	106d      	asrs	r5, r5, #1
  40b59a:	d00b      	beq.n	40b5b4 <__pow5mult+0x90>
  40b59c:	6820      	ldr	r0, [r4, #0]
  40b59e:	b938      	cbnz	r0, 40b5b0 <__pow5mult+0x8c>
  40b5a0:	4622      	mov	r2, r4
  40b5a2:	4621      	mov	r1, r4
  40b5a4:	4630      	mov	r0, r6
  40b5a6:	f7ff ff30 	bl	40b40a <__multiply>
  40b5aa:	6020      	str	r0, [r4, #0]
  40b5ac:	f8c0 8000 	str.w	r8, [r0]
  40b5b0:	4604      	mov	r4, r0
  40b5b2:	e7e4      	b.n	40b57e <__pow5mult+0x5a>
  40b5b4:	4638      	mov	r0, r7
  40b5b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40b5ba:	bf00      	nop
  40b5bc:	0040e030 	.word	0x0040e030

0040b5c0 <__lshift>:
  40b5c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40b5c4:	460c      	mov	r4, r1
  40b5c6:	ea4f 1a62 	mov.w	sl, r2, asr #5
  40b5ca:	6923      	ldr	r3, [r4, #16]
  40b5cc:	6849      	ldr	r1, [r1, #4]
  40b5ce:	eb0a 0903 	add.w	r9, sl, r3
  40b5d2:	68a3      	ldr	r3, [r4, #8]
  40b5d4:	4607      	mov	r7, r0
  40b5d6:	4616      	mov	r6, r2
  40b5d8:	f109 0501 	add.w	r5, r9, #1
  40b5dc:	42ab      	cmp	r3, r5
  40b5de:	db31      	blt.n	40b644 <__lshift+0x84>
  40b5e0:	4638      	mov	r0, r7
  40b5e2:	f7ff fe35 	bl	40b250 <_Balloc>
  40b5e6:	2200      	movs	r2, #0
  40b5e8:	4680      	mov	r8, r0
  40b5ea:	f100 0314 	add.w	r3, r0, #20
  40b5ee:	4611      	mov	r1, r2
  40b5f0:	4552      	cmp	r2, sl
  40b5f2:	db2a      	blt.n	40b64a <__lshift+0x8a>
  40b5f4:	6920      	ldr	r0, [r4, #16]
  40b5f6:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
  40b5fa:	f104 0114 	add.w	r1, r4, #20
  40b5fe:	f016 021f 	ands.w	r2, r6, #31
  40b602:	eb03 038a 	add.w	r3, r3, sl, lsl #2
  40b606:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
  40b60a:	d022      	beq.n	40b652 <__lshift+0x92>
  40b60c:	f1c2 0c20 	rsb	ip, r2, #32
  40b610:	2000      	movs	r0, #0
  40b612:	680e      	ldr	r6, [r1, #0]
  40b614:	4096      	lsls	r6, r2
  40b616:	4330      	orrs	r0, r6
  40b618:	f843 0b04 	str.w	r0, [r3], #4
  40b61c:	f851 0b04 	ldr.w	r0, [r1], #4
  40b620:	458e      	cmp	lr, r1
  40b622:	fa20 f00c 	lsr.w	r0, r0, ip
  40b626:	d8f4      	bhi.n	40b612 <__lshift+0x52>
  40b628:	6018      	str	r0, [r3, #0]
  40b62a:	b108      	cbz	r0, 40b630 <__lshift+0x70>
  40b62c:	f109 0502 	add.w	r5, r9, #2
  40b630:	3d01      	subs	r5, #1
  40b632:	4638      	mov	r0, r7
  40b634:	f8c8 5010 	str.w	r5, [r8, #16]
  40b638:	4621      	mov	r1, r4
  40b63a:	f7ff fe3d 	bl	40b2b8 <_Bfree>
  40b63e:	4640      	mov	r0, r8
  40b640:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40b644:	3101      	adds	r1, #1
  40b646:	005b      	lsls	r3, r3, #1
  40b648:	e7c8      	b.n	40b5dc <__lshift+0x1c>
  40b64a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  40b64e:	3201      	adds	r2, #1
  40b650:	e7ce      	b.n	40b5f0 <__lshift+0x30>
  40b652:	3b04      	subs	r3, #4
  40b654:	f851 2b04 	ldr.w	r2, [r1], #4
  40b658:	f843 2f04 	str.w	r2, [r3, #4]!
  40b65c:	458e      	cmp	lr, r1
  40b65e:	d8f9      	bhi.n	40b654 <__lshift+0x94>
  40b660:	e7e6      	b.n	40b630 <__lshift+0x70>

0040b662 <__mcmp>:
  40b662:	6903      	ldr	r3, [r0, #16]
  40b664:	690a      	ldr	r2, [r1, #16]
  40b666:	1a9b      	subs	r3, r3, r2
  40b668:	b530      	push	{r4, r5, lr}
  40b66a:	d10c      	bne.n	40b686 <__mcmp+0x24>
  40b66c:	0092      	lsls	r2, r2, #2
  40b66e:	3014      	adds	r0, #20
  40b670:	3114      	adds	r1, #20
  40b672:	1884      	adds	r4, r0, r2
  40b674:	4411      	add	r1, r2
  40b676:	f854 5d04 	ldr.w	r5, [r4, #-4]!
  40b67a:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  40b67e:	4295      	cmp	r5, r2
  40b680:	d003      	beq.n	40b68a <__mcmp+0x28>
  40b682:	d305      	bcc.n	40b690 <__mcmp+0x2e>
  40b684:	2301      	movs	r3, #1
  40b686:	4618      	mov	r0, r3
  40b688:	bd30      	pop	{r4, r5, pc}
  40b68a:	42a0      	cmp	r0, r4
  40b68c:	d3f3      	bcc.n	40b676 <__mcmp+0x14>
  40b68e:	e7fa      	b.n	40b686 <__mcmp+0x24>
  40b690:	f04f 33ff 	mov.w	r3, #4294967295
  40b694:	e7f7      	b.n	40b686 <__mcmp+0x24>

0040b696 <__mdiff>:
  40b696:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40b69a:	460d      	mov	r5, r1
  40b69c:	4607      	mov	r7, r0
  40b69e:	4611      	mov	r1, r2
  40b6a0:	4628      	mov	r0, r5
  40b6a2:	4614      	mov	r4, r2
  40b6a4:	f7ff ffdd 	bl	40b662 <__mcmp>
  40b6a8:	1e06      	subs	r6, r0, #0
  40b6aa:	d108      	bne.n	40b6be <__mdiff+0x28>
  40b6ac:	4631      	mov	r1, r6
  40b6ae:	4638      	mov	r0, r7
  40b6b0:	f7ff fdce 	bl	40b250 <_Balloc>
  40b6b4:	2301      	movs	r3, #1
  40b6b6:	6103      	str	r3, [r0, #16]
  40b6b8:	6146      	str	r6, [r0, #20]
  40b6ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40b6be:	bfa4      	itt	ge
  40b6c0:	4623      	movge	r3, r4
  40b6c2:	462c      	movge	r4, r5
  40b6c4:	4638      	mov	r0, r7
  40b6c6:	6861      	ldr	r1, [r4, #4]
  40b6c8:	bfa6      	itte	ge
  40b6ca:	461d      	movge	r5, r3
  40b6cc:	2600      	movge	r6, #0
  40b6ce:	2601      	movlt	r6, #1
  40b6d0:	f7ff fdbe 	bl	40b250 <_Balloc>
  40b6d4:	692b      	ldr	r3, [r5, #16]
  40b6d6:	60c6      	str	r6, [r0, #12]
  40b6d8:	6926      	ldr	r6, [r4, #16]
  40b6da:	f105 0914 	add.w	r9, r5, #20
  40b6de:	f104 0214 	add.w	r2, r4, #20
  40b6e2:	eb02 0786 	add.w	r7, r2, r6, lsl #2
  40b6e6:	eb09 0883 	add.w	r8, r9, r3, lsl #2
  40b6ea:	f100 0514 	add.w	r5, r0, #20
  40b6ee:	f04f 0c00 	mov.w	ip, #0
  40b6f2:	f852 ab04 	ldr.w	sl, [r2], #4
  40b6f6:	f859 4b04 	ldr.w	r4, [r9], #4
  40b6fa:	fa1c f18a 	uxtah	r1, ip, sl
  40b6fe:	b2a3      	uxth	r3, r4
  40b700:	1ac9      	subs	r1, r1, r3
  40b702:	0c23      	lsrs	r3, r4, #16
  40b704:	ebc3 431a 	rsb	r3, r3, sl, lsr #16
  40b708:	eb03 4321 	add.w	r3, r3, r1, asr #16
  40b70c:	b289      	uxth	r1, r1
  40b70e:	ea4f 4c23 	mov.w	ip, r3, asr #16
  40b712:	45c8      	cmp	r8, r9
  40b714:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
  40b718:	4696      	mov	lr, r2
  40b71a:	f845 3b04 	str.w	r3, [r5], #4
  40b71e:	d8e8      	bhi.n	40b6f2 <__mdiff+0x5c>
  40b720:	45be      	cmp	lr, r7
  40b722:	d305      	bcc.n	40b730 <__mdiff+0x9a>
  40b724:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  40b728:	b18b      	cbz	r3, 40b74e <__mdiff+0xb8>
  40b72a:	6106      	str	r6, [r0, #16]
  40b72c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40b730:	f85e 1b04 	ldr.w	r1, [lr], #4
  40b734:	fa1c f381 	uxtah	r3, ip, r1
  40b738:	141a      	asrs	r2, r3, #16
  40b73a:	eb02 4211 	add.w	r2, r2, r1, lsr #16
  40b73e:	b29b      	uxth	r3, r3
  40b740:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40b744:	ea4f 4c22 	mov.w	ip, r2, asr #16
  40b748:	f845 3b04 	str.w	r3, [r5], #4
  40b74c:	e7e8      	b.n	40b720 <__mdiff+0x8a>
  40b74e:	3e01      	subs	r6, #1
  40b750:	e7e8      	b.n	40b724 <__mdiff+0x8e>

0040b752 <__d2b>:
  40b752:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  40b756:	2101      	movs	r1, #1
  40b758:	461c      	mov	r4, r3
  40b75a:	4690      	mov	r8, r2
  40b75c:	9e08      	ldr	r6, [sp, #32]
  40b75e:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40b760:	f7ff fd76 	bl	40b250 <_Balloc>
  40b764:	f3c4 0213 	ubfx	r2, r4, #0, #20
  40b768:	f3c4 540a 	ubfx	r4, r4, #20, #11
  40b76c:	4607      	mov	r7, r0
  40b76e:	bb34      	cbnz	r4, 40b7be <__d2b+0x6c>
  40b770:	9201      	str	r2, [sp, #4]
  40b772:	f1b8 0f00 	cmp.w	r8, #0
  40b776:	d027      	beq.n	40b7c8 <__d2b+0x76>
  40b778:	a802      	add	r0, sp, #8
  40b77a:	f840 8d08 	str.w	r8, [r0, #-8]!
  40b77e:	f7ff fe0c 	bl	40b39a <__lo0bits>
  40b782:	9900      	ldr	r1, [sp, #0]
  40b784:	b1f0      	cbz	r0, 40b7c4 <__d2b+0x72>
  40b786:	9a01      	ldr	r2, [sp, #4]
  40b788:	f1c0 0320 	rsb	r3, r0, #32
  40b78c:	fa02 f303 	lsl.w	r3, r2, r3
  40b790:	430b      	orrs	r3, r1
  40b792:	40c2      	lsrs	r2, r0
  40b794:	617b      	str	r3, [r7, #20]
  40b796:	9201      	str	r2, [sp, #4]
  40b798:	9b01      	ldr	r3, [sp, #4]
  40b79a:	61bb      	str	r3, [r7, #24]
  40b79c:	2b00      	cmp	r3, #0
  40b79e:	bf14      	ite	ne
  40b7a0:	2102      	movne	r1, #2
  40b7a2:	2101      	moveq	r1, #1
  40b7a4:	6139      	str	r1, [r7, #16]
  40b7a6:	b1c4      	cbz	r4, 40b7da <__d2b+0x88>
  40b7a8:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
  40b7ac:	4404      	add	r4, r0
  40b7ae:	6034      	str	r4, [r6, #0]
  40b7b0:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  40b7b4:	6028      	str	r0, [r5, #0]
  40b7b6:	4638      	mov	r0, r7
  40b7b8:	b002      	add	sp, #8
  40b7ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40b7be:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  40b7c2:	e7d5      	b.n	40b770 <__d2b+0x1e>
  40b7c4:	6179      	str	r1, [r7, #20]
  40b7c6:	e7e7      	b.n	40b798 <__d2b+0x46>
  40b7c8:	a801      	add	r0, sp, #4
  40b7ca:	f7ff fde6 	bl	40b39a <__lo0bits>
  40b7ce:	9b01      	ldr	r3, [sp, #4]
  40b7d0:	617b      	str	r3, [r7, #20]
  40b7d2:	2101      	movs	r1, #1
  40b7d4:	6139      	str	r1, [r7, #16]
  40b7d6:	3020      	adds	r0, #32
  40b7d8:	e7e5      	b.n	40b7a6 <__d2b+0x54>
  40b7da:	eb07 0381 	add.w	r3, r7, r1, lsl #2
  40b7de:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  40b7e2:	6030      	str	r0, [r6, #0]
  40b7e4:	6918      	ldr	r0, [r3, #16]
  40b7e6:	f7ff fdb9 	bl	40b35c <__hi0bits>
  40b7ea:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
  40b7ee:	e7e1      	b.n	40b7b4 <__d2b+0x62>

0040b7f0 <_calloc_r>:
  40b7f0:	b538      	push	{r3, r4, r5, lr}
  40b7f2:	fb02 f401 	mul.w	r4, r2, r1
  40b7f6:	4621      	mov	r1, r4
  40b7f8:	f000 f856 	bl	40b8a8 <_malloc_r>
  40b7fc:	4605      	mov	r5, r0
  40b7fe:	b118      	cbz	r0, 40b808 <_calloc_r+0x18>
  40b800:	4622      	mov	r2, r4
  40b802:	2100      	movs	r1, #0
  40b804:	f7fd ff09 	bl	40961a <memset>
  40b808:	4628      	mov	r0, r5
  40b80a:	bd38      	pop	{r3, r4, r5, pc}

0040b80c <_free_r>:
  40b80c:	b538      	push	{r3, r4, r5, lr}
  40b80e:	4605      	mov	r5, r0
  40b810:	2900      	cmp	r1, #0
  40b812:	d045      	beq.n	40b8a0 <_free_r+0x94>
  40b814:	f851 3c04 	ldr.w	r3, [r1, #-4]
  40b818:	1f0c      	subs	r4, r1, #4
  40b81a:	2b00      	cmp	r3, #0
  40b81c:	bfb8      	it	lt
  40b81e:	18e4      	addlt	r4, r4, r3
  40b820:	f000 fcc4 	bl	40c1ac <__malloc_lock>
  40b824:	4a1f      	ldr	r2, [pc, #124]	; (40b8a4 <_free_r+0x98>)
  40b826:	6813      	ldr	r3, [r2, #0]
  40b828:	4610      	mov	r0, r2
  40b82a:	b933      	cbnz	r3, 40b83a <_free_r+0x2e>
  40b82c:	6063      	str	r3, [r4, #4]
  40b82e:	6014      	str	r4, [r2, #0]
  40b830:	4628      	mov	r0, r5
  40b832:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40b836:	f000 bcba 	b.w	40c1ae <__malloc_unlock>
  40b83a:	42a3      	cmp	r3, r4
  40b83c:	d90c      	bls.n	40b858 <_free_r+0x4c>
  40b83e:	6821      	ldr	r1, [r4, #0]
  40b840:	1862      	adds	r2, r4, r1
  40b842:	4293      	cmp	r3, r2
  40b844:	bf04      	itt	eq
  40b846:	681a      	ldreq	r2, [r3, #0]
  40b848:	685b      	ldreq	r3, [r3, #4]
  40b84a:	6063      	str	r3, [r4, #4]
  40b84c:	bf04      	itt	eq
  40b84e:	1852      	addeq	r2, r2, r1
  40b850:	6022      	streq	r2, [r4, #0]
  40b852:	6004      	str	r4, [r0, #0]
  40b854:	e7ec      	b.n	40b830 <_free_r+0x24>
  40b856:	4613      	mov	r3, r2
  40b858:	685a      	ldr	r2, [r3, #4]
  40b85a:	b10a      	cbz	r2, 40b860 <_free_r+0x54>
  40b85c:	42a2      	cmp	r2, r4
  40b85e:	d9fa      	bls.n	40b856 <_free_r+0x4a>
  40b860:	6819      	ldr	r1, [r3, #0]
  40b862:	1858      	adds	r0, r3, r1
  40b864:	42a0      	cmp	r0, r4
  40b866:	d10b      	bne.n	40b880 <_free_r+0x74>
  40b868:	6820      	ldr	r0, [r4, #0]
  40b86a:	4401      	add	r1, r0
  40b86c:	1858      	adds	r0, r3, r1
  40b86e:	4282      	cmp	r2, r0
  40b870:	6019      	str	r1, [r3, #0]
  40b872:	d1dd      	bne.n	40b830 <_free_r+0x24>
  40b874:	6810      	ldr	r0, [r2, #0]
  40b876:	6852      	ldr	r2, [r2, #4]
  40b878:	605a      	str	r2, [r3, #4]
  40b87a:	4401      	add	r1, r0
  40b87c:	6019      	str	r1, [r3, #0]
  40b87e:	e7d7      	b.n	40b830 <_free_r+0x24>
  40b880:	d902      	bls.n	40b888 <_free_r+0x7c>
  40b882:	230c      	movs	r3, #12
  40b884:	602b      	str	r3, [r5, #0]
  40b886:	e7d3      	b.n	40b830 <_free_r+0x24>
  40b888:	6820      	ldr	r0, [r4, #0]
  40b88a:	1821      	adds	r1, r4, r0
  40b88c:	428a      	cmp	r2, r1
  40b88e:	bf04      	itt	eq
  40b890:	6811      	ldreq	r1, [r2, #0]
  40b892:	6852      	ldreq	r2, [r2, #4]
  40b894:	6062      	str	r2, [r4, #4]
  40b896:	bf04      	itt	eq
  40b898:	1809      	addeq	r1, r1, r0
  40b89a:	6021      	streq	r1, [r4, #0]
  40b89c:	605c      	str	r4, [r3, #4]
  40b89e:	e7c7      	b.n	40b830 <_free_r+0x24>
  40b8a0:	bd38      	pop	{r3, r4, r5, pc}
  40b8a2:	bf00      	nop
  40b8a4:	20000438 	.word	0x20000438

0040b8a8 <_malloc_r>:
  40b8a8:	b570      	push	{r4, r5, r6, lr}
  40b8aa:	1ccd      	adds	r5, r1, #3
  40b8ac:	f025 0503 	bic.w	r5, r5, #3
  40b8b0:	3508      	adds	r5, #8
  40b8b2:	2d0c      	cmp	r5, #12
  40b8b4:	bf38      	it	cc
  40b8b6:	250c      	movcc	r5, #12
  40b8b8:	2d00      	cmp	r5, #0
  40b8ba:	4606      	mov	r6, r0
  40b8bc:	db01      	blt.n	40b8c2 <_malloc_r+0x1a>
  40b8be:	42a9      	cmp	r1, r5
  40b8c0:	d903      	bls.n	40b8ca <_malloc_r+0x22>
  40b8c2:	230c      	movs	r3, #12
  40b8c4:	6033      	str	r3, [r6, #0]
  40b8c6:	2000      	movs	r0, #0
  40b8c8:	bd70      	pop	{r4, r5, r6, pc}
  40b8ca:	f000 fc6f 	bl	40c1ac <__malloc_lock>
  40b8ce:	4a23      	ldr	r2, [pc, #140]	; (40b95c <_malloc_r+0xb4>)
  40b8d0:	6814      	ldr	r4, [r2, #0]
  40b8d2:	4621      	mov	r1, r4
  40b8d4:	b991      	cbnz	r1, 40b8fc <_malloc_r+0x54>
  40b8d6:	4c22      	ldr	r4, [pc, #136]	; (40b960 <_malloc_r+0xb8>)
  40b8d8:	6823      	ldr	r3, [r4, #0]
  40b8da:	b91b      	cbnz	r3, 40b8e4 <_malloc_r+0x3c>
  40b8dc:	4630      	mov	r0, r6
  40b8de:	f000 facf 	bl	40be80 <_sbrk_r>
  40b8e2:	6020      	str	r0, [r4, #0]
  40b8e4:	4629      	mov	r1, r5
  40b8e6:	4630      	mov	r0, r6
  40b8e8:	f000 faca 	bl	40be80 <_sbrk_r>
  40b8ec:	1c43      	adds	r3, r0, #1
  40b8ee:	d126      	bne.n	40b93e <_malloc_r+0x96>
  40b8f0:	230c      	movs	r3, #12
  40b8f2:	6033      	str	r3, [r6, #0]
  40b8f4:	4630      	mov	r0, r6
  40b8f6:	f000 fc5a 	bl	40c1ae <__malloc_unlock>
  40b8fa:	e7e4      	b.n	40b8c6 <_malloc_r+0x1e>
  40b8fc:	680b      	ldr	r3, [r1, #0]
  40b8fe:	1b5b      	subs	r3, r3, r5
  40b900:	d41a      	bmi.n	40b938 <_malloc_r+0x90>
  40b902:	2b0b      	cmp	r3, #11
  40b904:	d90f      	bls.n	40b926 <_malloc_r+0x7e>
  40b906:	600b      	str	r3, [r1, #0]
  40b908:	50cd      	str	r5, [r1, r3]
  40b90a:	18cc      	adds	r4, r1, r3
  40b90c:	4630      	mov	r0, r6
  40b90e:	f000 fc4e 	bl	40c1ae <__malloc_unlock>
  40b912:	f104 000b 	add.w	r0, r4, #11
  40b916:	1d23      	adds	r3, r4, #4
  40b918:	f020 0007 	bic.w	r0, r0, #7
  40b91c:	1ac3      	subs	r3, r0, r3
  40b91e:	d01b      	beq.n	40b958 <_malloc_r+0xb0>
  40b920:	425a      	negs	r2, r3
  40b922:	50e2      	str	r2, [r4, r3]
  40b924:	bd70      	pop	{r4, r5, r6, pc}
  40b926:	428c      	cmp	r4, r1
  40b928:	bf0d      	iteet	eq
  40b92a:	6863      	ldreq	r3, [r4, #4]
  40b92c:	684b      	ldrne	r3, [r1, #4]
  40b92e:	6063      	strne	r3, [r4, #4]
  40b930:	6013      	streq	r3, [r2, #0]
  40b932:	bf18      	it	ne
  40b934:	460c      	movne	r4, r1
  40b936:	e7e9      	b.n	40b90c <_malloc_r+0x64>
  40b938:	460c      	mov	r4, r1
  40b93a:	6849      	ldr	r1, [r1, #4]
  40b93c:	e7ca      	b.n	40b8d4 <_malloc_r+0x2c>
  40b93e:	1cc4      	adds	r4, r0, #3
  40b940:	f024 0403 	bic.w	r4, r4, #3
  40b944:	42a0      	cmp	r0, r4
  40b946:	d005      	beq.n	40b954 <_malloc_r+0xac>
  40b948:	1a21      	subs	r1, r4, r0
  40b94a:	4630      	mov	r0, r6
  40b94c:	f000 fa98 	bl	40be80 <_sbrk_r>
  40b950:	3001      	adds	r0, #1
  40b952:	d0cd      	beq.n	40b8f0 <_malloc_r+0x48>
  40b954:	6025      	str	r5, [r4, #0]
  40b956:	e7d9      	b.n	40b90c <_malloc_r+0x64>
  40b958:	bd70      	pop	{r4, r5, r6, pc}
  40b95a:	bf00      	nop
  40b95c:	20000438 	.word	0x20000438
  40b960:	2000043c 	.word	0x2000043c

0040b964 <__ssputs_r>:
  40b964:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40b968:	688e      	ldr	r6, [r1, #8]
  40b96a:	429e      	cmp	r6, r3
  40b96c:	4682      	mov	sl, r0
  40b96e:	460c      	mov	r4, r1
  40b970:	4691      	mov	r9, r2
  40b972:	4698      	mov	r8, r3
  40b974:	d835      	bhi.n	40b9e2 <__ssputs_r+0x7e>
  40b976:	898a      	ldrh	r2, [r1, #12]
  40b978:	f412 6f90 	tst.w	r2, #1152	; 0x480
  40b97c:	d031      	beq.n	40b9e2 <__ssputs_r+0x7e>
  40b97e:	6825      	ldr	r5, [r4, #0]
  40b980:	6909      	ldr	r1, [r1, #16]
  40b982:	1a6f      	subs	r7, r5, r1
  40b984:	6965      	ldr	r5, [r4, #20]
  40b986:	2302      	movs	r3, #2
  40b988:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40b98c:	fb95 f5f3 	sdiv	r5, r5, r3
  40b990:	f108 0301 	add.w	r3, r8, #1
  40b994:	443b      	add	r3, r7
  40b996:	429d      	cmp	r5, r3
  40b998:	bf38      	it	cc
  40b99a:	461d      	movcc	r5, r3
  40b99c:	0553      	lsls	r3, r2, #21
  40b99e:	d531      	bpl.n	40ba04 <__ssputs_r+0xa0>
  40b9a0:	4629      	mov	r1, r5
  40b9a2:	f7ff ff81 	bl	40b8a8 <_malloc_r>
  40b9a6:	4606      	mov	r6, r0
  40b9a8:	b950      	cbnz	r0, 40b9c0 <__ssputs_r+0x5c>
  40b9aa:	230c      	movs	r3, #12
  40b9ac:	f8ca 3000 	str.w	r3, [sl]
  40b9b0:	89a3      	ldrh	r3, [r4, #12]
  40b9b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40b9b6:	81a3      	strh	r3, [r4, #12]
  40b9b8:	f04f 30ff 	mov.w	r0, #4294967295
  40b9bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40b9c0:	463a      	mov	r2, r7
  40b9c2:	6921      	ldr	r1, [r4, #16]
  40b9c4:	f7fd fe1e 	bl	409604 <memcpy>
  40b9c8:	89a3      	ldrh	r3, [r4, #12]
  40b9ca:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  40b9ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40b9d2:	81a3      	strh	r3, [r4, #12]
  40b9d4:	6126      	str	r6, [r4, #16]
  40b9d6:	6165      	str	r5, [r4, #20]
  40b9d8:	443e      	add	r6, r7
  40b9da:	1bed      	subs	r5, r5, r7
  40b9dc:	6026      	str	r6, [r4, #0]
  40b9de:	60a5      	str	r5, [r4, #8]
  40b9e0:	4646      	mov	r6, r8
  40b9e2:	4546      	cmp	r6, r8
  40b9e4:	bf28      	it	cs
  40b9e6:	4646      	movcs	r6, r8
  40b9e8:	4632      	mov	r2, r6
  40b9ea:	4649      	mov	r1, r9
  40b9ec:	6820      	ldr	r0, [r4, #0]
  40b9ee:	f000 fbc3 	bl	40c178 <memmove>
  40b9f2:	68a3      	ldr	r3, [r4, #8]
  40b9f4:	1b9b      	subs	r3, r3, r6
  40b9f6:	60a3      	str	r3, [r4, #8]
  40b9f8:	6823      	ldr	r3, [r4, #0]
  40b9fa:	441e      	add	r6, r3
  40b9fc:	6026      	str	r6, [r4, #0]
  40b9fe:	2000      	movs	r0, #0
  40ba00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40ba04:	462a      	mov	r2, r5
  40ba06:	f000 fbd3 	bl	40c1b0 <_realloc_r>
  40ba0a:	4606      	mov	r6, r0
  40ba0c:	2800      	cmp	r0, #0
  40ba0e:	d1e1      	bne.n	40b9d4 <__ssputs_r+0x70>
  40ba10:	6921      	ldr	r1, [r4, #16]
  40ba12:	4650      	mov	r0, sl
  40ba14:	f7ff fefa 	bl	40b80c <_free_r>
  40ba18:	e7c7      	b.n	40b9aa <__ssputs_r+0x46>
	...

0040ba1c <_svfiprintf_r>:
  40ba1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40ba20:	b09d      	sub	sp, #116	; 0x74
  40ba22:	4680      	mov	r8, r0
  40ba24:	9303      	str	r3, [sp, #12]
  40ba26:	898b      	ldrh	r3, [r1, #12]
  40ba28:	061c      	lsls	r4, r3, #24
  40ba2a:	460d      	mov	r5, r1
  40ba2c:	4616      	mov	r6, r2
  40ba2e:	d50f      	bpl.n	40ba50 <_svfiprintf_r+0x34>
  40ba30:	690b      	ldr	r3, [r1, #16]
  40ba32:	b96b      	cbnz	r3, 40ba50 <_svfiprintf_r+0x34>
  40ba34:	2140      	movs	r1, #64	; 0x40
  40ba36:	f7ff ff37 	bl	40b8a8 <_malloc_r>
  40ba3a:	6028      	str	r0, [r5, #0]
  40ba3c:	6128      	str	r0, [r5, #16]
  40ba3e:	b928      	cbnz	r0, 40ba4c <_svfiprintf_r+0x30>
  40ba40:	230c      	movs	r3, #12
  40ba42:	f8c8 3000 	str.w	r3, [r8]
  40ba46:	f04f 30ff 	mov.w	r0, #4294967295
  40ba4a:	e0c5      	b.n	40bbd8 <_svfiprintf_r+0x1bc>
  40ba4c:	2340      	movs	r3, #64	; 0x40
  40ba4e:	616b      	str	r3, [r5, #20]
  40ba50:	2300      	movs	r3, #0
  40ba52:	9309      	str	r3, [sp, #36]	; 0x24
  40ba54:	2320      	movs	r3, #32
  40ba56:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  40ba5a:	2330      	movs	r3, #48	; 0x30
  40ba5c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  40ba60:	f04f 0b01 	mov.w	fp, #1
  40ba64:	4637      	mov	r7, r6
  40ba66:	463c      	mov	r4, r7
  40ba68:	f814 3b01 	ldrb.w	r3, [r4], #1
  40ba6c:	2b00      	cmp	r3, #0
  40ba6e:	d13c      	bne.n	40baea <_svfiprintf_r+0xce>
  40ba70:	ebb7 0a06 	subs.w	sl, r7, r6
  40ba74:	d00b      	beq.n	40ba8e <_svfiprintf_r+0x72>
  40ba76:	4653      	mov	r3, sl
  40ba78:	4632      	mov	r2, r6
  40ba7a:	4629      	mov	r1, r5
  40ba7c:	4640      	mov	r0, r8
  40ba7e:	f7ff ff71 	bl	40b964 <__ssputs_r>
  40ba82:	3001      	adds	r0, #1
  40ba84:	f000 80a3 	beq.w	40bbce <_svfiprintf_r+0x1b2>
  40ba88:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40ba8a:	4453      	add	r3, sl
  40ba8c:	9309      	str	r3, [sp, #36]	; 0x24
  40ba8e:	783b      	ldrb	r3, [r7, #0]
  40ba90:	2b00      	cmp	r3, #0
  40ba92:	f000 809c 	beq.w	40bbce <_svfiprintf_r+0x1b2>
  40ba96:	2300      	movs	r3, #0
  40ba98:	f04f 32ff 	mov.w	r2, #4294967295
  40ba9c:	9304      	str	r3, [sp, #16]
  40ba9e:	9307      	str	r3, [sp, #28]
  40baa0:	9205      	str	r2, [sp, #20]
  40baa2:	9306      	str	r3, [sp, #24]
  40baa4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  40baa8:	931a      	str	r3, [sp, #104]	; 0x68
  40baaa:	2205      	movs	r2, #5
  40baac:	7821      	ldrb	r1, [r4, #0]
  40baae:	4850      	ldr	r0, [pc, #320]	; (40bbf0 <_svfiprintf_r+0x1d4>)
  40bab0:	f7ff fb7e 	bl	40b1b0 <memchr>
  40bab4:	1c67      	adds	r7, r4, #1
  40bab6:	9b04      	ldr	r3, [sp, #16]
  40bab8:	b9d8      	cbnz	r0, 40baf2 <_svfiprintf_r+0xd6>
  40baba:	06d9      	lsls	r1, r3, #27
  40babc:	bf44      	itt	mi
  40babe:	2220      	movmi	r2, #32
  40bac0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40bac4:	071a      	lsls	r2, r3, #28
  40bac6:	bf44      	itt	mi
  40bac8:	222b      	movmi	r2, #43	; 0x2b
  40baca:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40bace:	7822      	ldrb	r2, [r4, #0]
  40bad0:	2a2a      	cmp	r2, #42	; 0x2a
  40bad2:	d016      	beq.n	40bb02 <_svfiprintf_r+0xe6>
  40bad4:	9a07      	ldr	r2, [sp, #28]
  40bad6:	2100      	movs	r1, #0
  40bad8:	200a      	movs	r0, #10
  40bada:	4627      	mov	r7, r4
  40badc:	3401      	adds	r4, #1
  40bade:	783b      	ldrb	r3, [r7, #0]
  40bae0:	3b30      	subs	r3, #48	; 0x30
  40bae2:	2b09      	cmp	r3, #9
  40bae4:	d951      	bls.n	40bb8a <_svfiprintf_r+0x16e>
  40bae6:	b1c9      	cbz	r1, 40bb1c <_svfiprintf_r+0x100>
  40bae8:	e011      	b.n	40bb0e <_svfiprintf_r+0xf2>
  40baea:	2b25      	cmp	r3, #37	; 0x25
  40baec:	d0c0      	beq.n	40ba70 <_svfiprintf_r+0x54>
  40baee:	4627      	mov	r7, r4
  40baf0:	e7b9      	b.n	40ba66 <_svfiprintf_r+0x4a>
  40baf2:	4a3f      	ldr	r2, [pc, #252]	; (40bbf0 <_svfiprintf_r+0x1d4>)
  40baf4:	1a80      	subs	r0, r0, r2
  40baf6:	fa0b f000 	lsl.w	r0, fp, r0
  40bafa:	4318      	orrs	r0, r3
  40bafc:	9004      	str	r0, [sp, #16]
  40bafe:	463c      	mov	r4, r7
  40bb00:	e7d3      	b.n	40baaa <_svfiprintf_r+0x8e>
  40bb02:	9a03      	ldr	r2, [sp, #12]
  40bb04:	1d11      	adds	r1, r2, #4
  40bb06:	6812      	ldr	r2, [r2, #0]
  40bb08:	9103      	str	r1, [sp, #12]
  40bb0a:	2a00      	cmp	r2, #0
  40bb0c:	db01      	blt.n	40bb12 <_svfiprintf_r+0xf6>
  40bb0e:	9207      	str	r2, [sp, #28]
  40bb10:	e004      	b.n	40bb1c <_svfiprintf_r+0x100>
  40bb12:	4252      	negs	r2, r2
  40bb14:	f043 0302 	orr.w	r3, r3, #2
  40bb18:	9207      	str	r2, [sp, #28]
  40bb1a:	9304      	str	r3, [sp, #16]
  40bb1c:	783b      	ldrb	r3, [r7, #0]
  40bb1e:	2b2e      	cmp	r3, #46	; 0x2e
  40bb20:	d10e      	bne.n	40bb40 <_svfiprintf_r+0x124>
  40bb22:	787b      	ldrb	r3, [r7, #1]
  40bb24:	2b2a      	cmp	r3, #42	; 0x2a
  40bb26:	f107 0101 	add.w	r1, r7, #1
  40bb2a:	d132      	bne.n	40bb92 <_svfiprintf_r+0x176>
  40bb2c:	9b03      	ldr	r3, [sp, #12]
  40bb2e:	1d1a      	adds	r2, r3, #4
  40bb30:	681b      	ldr	r3, [r3, #0]
  40bb32:	9203      	str	r2, [sp, #12]
  40bb34:	2b00      	cmp	r3, #0
  40bb36:	bfb8      	it	lt
  40bb38:	f04f 33ff 	movlt.w	r3, #4294967295
  40bb3c:	3702      	adds	r7, #2
  40bb3e:	9305      	str	r3, [sp, #20]
  40bb40:	4c2c      	ldr	r4, [pc, #176]	; (40bbf4 <_svfiprintf_r+0x1d8>)
  40bb42:	7839      	ldrb	r1, [r7, #0]
  40bb44:	2203      	movs	r2, #3
  40bb46:	4620      	mov	r0, r4
  40bb48:	f7ff fb32 	bl	40b1b0 <memchr>
  40bb4c:	b138      	cbz	r0, 40bb5e <_svfiprintf_r+0x142>
  40bb4e:	2340      	movs	r3, #64	; 0x40
  40bb50:	1b00      	subs	r0, r0, r4
  40bb52:	fa03 f000 	lsl.w	r0, r3, r0
  40bb56:	9b04      	ldr	r3, [sp, #16]
  40bb58:	4303      	orrs	r3, r0
  40bb5a:	9304      	str	r3, [sp, #16]
  40bb5c:	3701      	adds	r7, #1
  40bb5e:	7839      	ldrb	r1, [r7, #0]
  40bb60:	4825      	ldr	r0, [pc, #148]	; (40bbf8 <_svfiprintf_r+0x1dc>)
  40bb62:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  40bb66:	2206      	movs	r2, #6
  40bb68:	1c7e      	adds	r6, r7, #1
  40bb6a:	f7ff fb21 	bl	40b1b0 <memchr>
  40bb6e:	2800      	cmp	r0, #0
  40bb70:	d035      	beq.n	40bbde <_svfiprintf_r+0x1c2>
  40bb72:	4b22      	ldr	r3, [pc, #136]	; (40bbfc <_svfiprintf_r+0x1e0>)
  40bb74:	b9fb      	cbnz	r3, 40bbb6 <_svfiprintf_r+0x19a>
  40bb76:	9b03      	ldr	r3, [sp, #12]
  40bb78:	3307      	adds	r3, #7
  40bb7a:	f023 0307 	bic.w	r3, r3, #7
  40bb7e:	3308      	adds	r3, #8
  40bb80:	9303      	str	r3, [sp, #12]
  40bb82:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40bb84:	444b      	add	r3, r9
  40bb86:	9309      	str	r3, [sp, #36]	; 0x24
  40bb88:	e76c      	b.n	40ba64 <_svfiprintf_r+0x48>
  40bb8a:	fb00 3202 	mla	r2, r0, r2, r3
  40bb8e:	2101      	movs	r1, #1
  40bb90:	e7a3      	b.n	40bada <_svfiprintf_r+0xbe>
  40bb92:	2300      	movs	r3, #0
  40bb94:	9305      	str	r3, [sp, #20]
  40bb96:	4618      	mov	r0, r3
  40bb98:	240a      	movs	r4, #10
  40bb9a:	460f      	mov	r7, r1
  40bb9c:	3101      	adds	r1, #1
  40bb9e:	783a      	ldrb	r2, [r7, #0]
  40bba0:	3a30      	subs	r2, #48	; 0x30
  40bba2:	2a09      	cmp	r2, #9
  40bba4:	d903      	bls.n	40bbae <_svfiprintf_r+0x192>
  40bba6:	2b00      	cmp	r3, #0
  40bba8:	d0ca      	beq.n	40bb40 <_svfiprintf_r+0x124>
  40bbaa:	9005      	str	r0, [sp, #20]
  40bbac:	e7c8      	b.n	40bb40 <_svfiprintf_r+0x124>
  40bbae:	fb04 2000 	mla	r0, r4, r0, r2
  40bbb2:	2301      	movs	r3, #1
  40bbb4:	e7f1      	b.n	40bb9a <_svfiprintf_r+0x17e>
  40bbb6:	ab03      	add	r3, sp, #12
  40bbb8:	9300      	str	r3, [sp, #0]
  40bbba:	462a      	mov	r2, r5
  40bbbc:	4b10      	ldr	r3, [pc, #64]	; (40bc00 <_svfiprintf_r+0x1e4>)
  40bbbe:	a904      	add	r1, sp, #16
  40bbc0:	4640      	mov	r0, r8
  40bbc2:	f7fd fdc3 	bl	40974c <_printf_float>
  40bbc6:	f1b0 3fff 	cmp.w	r0, #4294967295
  40bbca:	4681      	mov	r9, r0
  40bbcc:	d1d9      	bne.n	40bb82 <_svfiprintf_r+0x166>
  40bbce:	89ab      	ldrh	r3, [r5, #12]
  40bbd0:	065b      	lsls	r3, r3, #25
  40bbd2:	f53f af38 	bmi.w	40ba46 <_svfiprintf_r+0x2a>
  40bbd6:	9809      	ldr	r0, [sp, #36]	; 0x24
  40bbd8:	b01d      	add	sp, #116	; 0x74
  40bbda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bbde:	ab03      	add	r3, sp, #12
  40bbe0:	9300      	str	r3, [sp, #0]
  40bbe2:	462a      	mov	r2, r5
  40bbe4:	4b06      	ldr	r3, [pc, #24]	; (40bc00 <_svfiprintf_r+0x1e4>)
  40bbe6:	a904      	add	r1, sp, #16
  40bbe8:	4640      	mov	r0, r8
  40bbea:	f7fe f85d 	bl	409ca8 <_printf_i>
  40bbee:	e7ea      	b.n	40bbc6 <_svfiprintf_r+0x1aa>
  40bbf0:	0040e03c 	.word	0x0040e03c
  40bbf4:	0040e042 	.word	0x0040e042
  40bbf8:	0040e046 	.word	0x0040e046
  40bbfc:	0040974d 	.word	0x0040974d
  40bc00:	0040b965 	.word	0x0040b965

0040bc04 <__sfputc_r>:
  40bc04:	6893      	ldr	r3, [r2, #8]
  40bc06:	3b01      	subs	r3, #1
  40bc08:	2b00      	cmp	r3, #0
  40bc0a:	b410      	push	{r4}
  40bc0c:	6093      	str	r3, [r2, #8]
  40bc0e:	da08      	bge.n	40bc22 <__sfputc_r+0x1e>
  40bc10:	6994      	ldr	r4, [r2, #24]
  40bc12:	42a3      	cmp	r3, r4
  40bc14:	db02      	blt.n	40bc1c <__sfputc_r+0x18>
  40bc16:	b2cb      	uxtb	r3, r1
  40bc18:	2b0a      	cmp	r3, #10
  40bc1a:	d102      	bne.n	40bc22 <__sfputc_r+0x1e>
  40bc1c:	bc10      	pop	{r4}
  40bc1e:	f000 b983 	b.w	40bf28 <__swbuf_r>
  40bc22:	6813      	ldr	r3, [r2, #0]
  40bc24:	1c58      	adds	r0, r3, #1
  40bc26:	6010      	str	r0, [r2, #0]
  40bc28:	7019      	strb	r1, [r3, #0]
  40bc2a:	b2c8      	uxtb	r0, r1
  40bc2c:	bc10      	pop	{r4}
  40bc2e:	4770      	bx	lr

0040bc30 <__sfputs_r>:
  40bc30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40bc32:	4606      	mov	r6, r0
  40bc34:	460f      	mov	r7, r1
  40bc36:	4614      	mov	r4, r2
  40bc38:	18d5      	adds	r5, r2, r3
  40bc3a:	42ac      	cmp	r4, r5
  40bc3c:	d101      	bne.n	40bc42 <__sfputs_r+0x12>
  40bc3e:	2000      	movs	r0, #0
  40bc40:	e007      	b.n	40bc52 <__sfputs_r+0x22>
  40bc42:	463a      	mov	r2, r7
  40bc44:	f814 1b01 	ldrb.w	r1, [r4], #1
  40bc48:	4630      	mov	r0, r6
  40bc4a:	f7ff ffdb 	bl	40bc04 <__sfputc_r>
  40bc4e:	1c43      	adds	r3, r0, #1
  40bc50:	d1f3      	bne.n	40bc3a <__sfputs_r+0xa>
  40bc52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0040bc54 <_vfiprintf_r>:
  40bc54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40bc58:	b09d      	sub	sp, #116	; 0x74
  40bc5a:	460c      	mov	r4, r1
  40bc5c:	4617      	mov	r7, r2
  40bc5e:	9303      	str	r3, [sp, #12]
  40bc60:	4606      	mov	r6, r0
  40bc62:	b118      	cbz	r0, 40bc6c <_vfiprintf_r+0x18>
  40bc64:	6983      	ldr	r3, [r0, #24]
  40bc66:	b90b      	cbnz	r3, 40bc6c <_vfiprintf_r+0x18>
  40bc68:	f7ff f99a 	bl	40afa0 <__sinit>
  40bc6c:	4b7c      	ldr	r3, [pc, #496]	; (40be60 <_vfiprintf_r+0x20c>)
  40bc6e:	429c      	cmp	r4, r3
  40bc70:	d157      	bne.n	40bd22 <_vfiprintf_r+0xce>
  40bc72:	6874      	ldr	r4, [r6, #4]
  40bc74:	89a3      	ldrh	r3, [r4, #12]
  40bc76:	0718      	lsls	r0, r3, #28
  40bc78:	d55d      	bpl.n	40bd36 <_vfiprintf_r+0xe2>
  40bc7a:	6923      	ldr	r3, [r4, #16]
  40bc7c:	2b00      	cmp	r3, #0
  40bc7e:	d05a      	beq.n	40bd36 <_vfiprintf_r+0xe2>
  40bc80:	2300      	movs	r3, #0
  40bc82:	9309      	str	r3, [sp, #36]	; 0x24
  40bc84:	2320      	movs	r3, #32
  40bc86:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  40bc8a:	2330      	movs	r3, #48	; 0x30
  40bc8c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  40bc90:	f04f 0b01 	mov.w	fp, #1
  40bc94:	46b8      	mov	r8, r7
  40bc96:	4645      	mov	r5, r8
  40bc98:	f815 3b01 	ldrb.w	r3, [r5], #1
  40bc9c:	2b00      	cmp	r3, #0
  40bc9e:	d155      	bne.n	40bd4c <_vfiprintf_r+0xf8>
  40bca0:	ebb8 0a07 	subs.w	sl, r8, r7
  40bca4:	d00b      	beq.n	40bcbe <_vfiprintf_r+0x6a>
  40bca6:	4653      	mov	r3, sl
  40bca8:	463a      	mov	r2, r7
  40bcaa:	4621      	mov	r1, r4
  40bcac:	4630      	mov	r0, r6
  40bcae:	f7ff ffbf 	bl	40bc30 <__sfputs_r>
  40bcb2:	3001      	adds	r0, #1
  40bcb4:	f000 80c4 	beq.w	40be40 <_vfiprintf_r+0x1ec>
  40bcb8:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40bcba:	4453      	add	r3, sl
  40bcbc:	9309      	str	r3, [sp, #36]	; 0x24
  40bcbe:	f898 3000 	ldrb.w	r3, [r8]
  40bcc2:	2b00      	cmp	r3, #0
  40bcc4:	f000 80bc 	beq.w	40be40 <_vfiprintf_r+0x1ec>
  40bcc8:	2300      	movs	r3, #0
  40bcca:	f04f 32ff 	mov.w	r2, #4294967295
  40bcce:	9304      	str	r3, [sp, #16]
  40bcd0:	9307      	str	r3, [sp, #28]
  40bcd2:	9205      	str	r2, [sp, #20]
  40bcd4:	9306      	str	r3, [sp, #24]
  40bcd6:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  40bcda:	931a      	str	r3, [sp, #104]	; 0x68
  40bcdc:	2205      	movs	r2, #5
  40bcde:	7829      	ldrb	r1, [r5, #0]
  40bce0:	4860      	ldr	r0, [pc, #384]	; (40be64 <_vfiprintf_r+0x210>)
  40bce2:	f7ff fa65 	bl	40b1b0 <memchr>
  40bce6:	f105 0801 	add.w	r8, r5, #1
  40bcea:	9b04      	ldr	r3, [sp, #16]
  40bcec:	2800      	cmp	r0, #0
  40bcee:	d131      	bne.n	40bd54 <_vfiprintf_r+0x100>
  40bcf0:	06d9      	lsls	r1, r3, #27
  40bcf2:	bf44      	itt	mi
  40bcf4:	2220      	movmi	r2, #32
  40bcf6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40bcfa:	071a      	lsls	r2, r3, #28
  40bcfc:	bf44      	itt	mi
  40bcfe:	222b      	movmi	r2, #43	; 0x2b
  40bd00:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  40bd04:	782a      	ldrb	r2, [r5, #0]
  40bd06:	2a2a      	cmp	r2, #42	; 0x2a
  40bd08:	d02c      	beq.n	40bd64 <_vfiprintf_r+0x110>
  40bd0a:	9a07      	ldr	r2, [sp, #28]
  40bd0c:	2100      	movs	r1, #0
  40bd0e:	200a      	movs	r0, #10
  40bd10:	46a8      	mov	r8, r5
  40bd12:	3501      	adds	r5, #1
  40bd14:	f898 3000 	ldrb.w	r3, [r8]
  40bd18:	3b30      	subs	r3, #48	; 0x30
  40bd1a:	2b09      	cmp	r3, #9
  40bd1c:	d96d      	bls.n	40bdfa <_vfiprintf_r+0x1a6>
  40bd1e:	b371      	cbz	r1, 40bd7e <_vfiprintf_r+0x12a>
  40bd20:	e026      	b.n	40bd70 <_vfiprintf_r+0x11c>
  40bd22:	4b51      	ldr	r3, [pc, #324]	; (40be68 <_vfiprintf_r+0x214>)
  40bd24:	429c      	cmp	r4, r3
  40bd26:	d101      	bne.n	40bd2c <_vfiprintf_r+0xd8>
  40bd28:	68b4      	ldr	r4, [r6, #8]
  40bd2a:	e7a3      	b.n	40bc74 <_vfiprintf_r+0x20>
  40bd2c:	4b4f      	ldr	r3, [pc, #316]	; (40be6c <_vfiprintf_r+0x218>)
  40bd2e:	429c      	cmp	r4, r3
  40bd30:	bf08      	it	eq
  40bd32:	68f4      	ldreq	r4, [r6, #12]
  40bd34:	e79e      	b.n	40bc74 <_vfiprintf_r+0x20>
  40bd36:	4621      	mov	r1, r4
  40bd38:	4630      	mov	r0, r6
  40bd3a:	f000 f959 	bl	40bff0 <__swsetup_r>
  40bd3e:	2800      	cmp	r0, #0
  40bd40:	d09e      	beq.n	40bc80 <_vfiprintf_r+0x2c>
  40bd42:	f04f 30ff 	mov.w	r0, #4294967295
  40bd46:	b01d      	add	sp, #116	; 0x74
  40bd48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bd4c:	2b25      	cmp	r3, #37	; 0x25
  40bd4e:	d0a7      	beq.n	40bca0 <_vfiprintf_r+0x4c>
  40bd50:	46a8      	mov	r8, r5
  40bd52:	e7a0      	b.n	40bc96 <_vfiprintf_r+0x42>
  40bd54:	4a43      	ldr	r2, [pc, #268]	; (40be64 <_vfiprintf_r+0x210>)
  40bd56:	1a80      	subs	r0, r0, r2
  40bd58:	fa0b f000 	lsl.w	r0, fp, r0
  40bd5c:	4318      	orrs	r0, r3
  40bd5e:	9004      	str	r0, [sp, #16]
  40bd60:	4645      	mov	r5, r8
  40bd62:	e7bb      	b.n	40bcdc <_vfiprintf_r+0x88>
  40bd64:	9a03      	ldr	r2, [sp, #12]
  40bd66:	1d11      	adds	r1, r2, #4
  40bd68:	6812      	ldr	r2, [r2, #0]
  40bd6a:	9103      	str	r1, [sp, #12]
  40bd6c:	2a00      	cmp	r2, #0
  40bd6e:	db01      	blt.n	40bd74 <_vfiprintf_r+0x120>
  40bd70:	9207      	str	r2, [sp, #28]
  40bd72:	e004      	b.n	40bd7e <_vfiprintf_r+0x12a>
  40bd74:	4252      	negs	r2, r2
  40bd76:	f043 0302 	orr.w	r3, r3, #2
  40bd7a:	9207      	str	r2, [sp, #28]
  40bd7c:	9304      	str	r3, [sp, #16]
  40bd7e:	f898 3000 	ldrb.w	r3, [r8]
  40bd82:	2b2e      	cmp	r3, #46	; 0x2e
  40bd84:	d110      	bne.n	40bda8 <_vfiprintf_r+0x154>
  40bd86:	f898 3001 	ldrb.w	r3, [r8, #1]
  40bd8a:	2b2a      	cmp	r3, #42	; 0x2a
  40bd8c:	f108 0101 	add.w	r1, r8, #1
  40bd90:	d137      	bne.n	40be02 <_vfiprintf_r+0x1ae>
  40bd92:	9b03      	ldr	r3, [sp, #12]
  40bd94:	1d1a      	adds	r2, r3, #4
  40bd96:	681b      	ldr	r3, [r3, #0]
  40bd98:	9203      	str	r2, [sp, #12]
  40bd9a:	2b00      	cmp	r3, #0
  40bd9c:	bfb8      	it	lt
  40bd9e:	f04f 33ff 	movlt.w	r3, #4294967295
  40bda2:	f108 0802 	add.w	r8, r8, #2
  40bda6:	9305      	str	r3, [sp, #20]
  40bda8:	4d31      	ldr	r5, [pc, #196]	; (40be70 <_vfiprintf_r+0x21c>)
  40bdaa:	f898 1000 	ldrb.w	r1, [r8]
  40bdae:	2203      	movs	r2, #3
  40bdb0:	4628      	mov	r0, r5
  40bdb2:	f7ff f9fd 	bl	40b1b0 <memchr>
  40bdb6:	b140      	cbz	r0, 40bdca <_vfiprintf_r+0x176>
  40bdb8:	2340      	movs	r3, #64	; 0x40
  40bdba:	1b40      	subs	r0, r0, r5
  40bdbc:	fa03 f000 	lsl.w	r0, r3, r0
  40bdc0:	9b04      	ldr	r3, [sp, #16]
  40bdc2:	4303      	orrs	r3, r0
  40bdc4:	9304      	str	r3, [sp, #16]
  40bdc6:	f108 0801 	add.w	r8, r8, #1
  40bdca:	f898 1000 	ldrb.w	r1, [r8]
  40bdce:	4829      	ldr	r0, [pc, #164]	; (40be74 <_vfiprintf_r+0x220>)
  40bdd0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  40bdd4:	2206      	movs	r2, #6
  40bdd6:	f108 0701 	add.w	r7, r8, #1
  40bdda:	f7ff f9e9 	bl	40b1b0 <memchr>
  40bdde:	2800      	cmp	r0, #0
  40bde0:	d034      	beq.n	40be4c <_vfiprintf_r+0x1f8>
  40bde2:	4b25      	ldr	r3, [pc, #148]	; (40be78 <_vfiprintf_r+0x224>)
  40bde4:	bb03      	cbnz	r3, 40be28 <_vfiprintf_r+0x1d4>
  40bde6:	9b03      	ldr	r3, [sp, #12]
  40bde8:	3307      	adds	r3, #7
  40bdea:	f023 0307 	bic.w	r3, r3, #7
  40bdee:	3308      	adds	r3, #8
  40bdf0:	9303      	str	r3, [sp, #12]
  40bdf2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40bdf4:	444b      	add	r3, r9
  40bdf6:	9309      	str	r3, [sp, #36]	; 0x24
  40bdf8:	e74c      	b.n	40bc94 <_vfiprintf_r+0x40>
  40bdfa:	fb00 3202 	mla	r2, r0, r2, r3
  40bdfe:	2101      	movs	r1, #1
  40be00:	e786      	b.n	40bd10 <_vfiprintf_r+0xbc>
  40be02:	2300      	movs	r3, #0
  40be04:	9305      	str	r3, [sp, #20]
  40be06:	4618      	mov	r0, r3
  40be08:	250a      	movs	r5, #10
  40be0a:	4688      	mov	r8, r1
  40be0c:	3101      	adds	r1, #1
  40be0e:	f898 2000 	ldrb.w	r2, [r8]
  40be12:	3a30      	subs	r2, #48	; 0x30
  40be14:	2a09      	cmp	r2, #9
  40be16:	d903      	bls.n	40be20 <_vfiprintf_r+0x1cc>
  40be18:	2b00      	cmp	r3, #0
  40be1a:	d0c5      	beq.n	40bda8 <_vfiprintf_r+0x154>
  40be1c:	9005      	str	r0, [sp, #20]
  40be1e:	e7c3      	b.n	40bda8 <_vfiprintf_r+0x154>
  40be20:	fb05 2000 	mla	r0, r5, r0, r2
  40be24:	2301      	movs	r3, #1
  40be26:	e7f0      	b.n	40be0a <_vfiprintf_r+0x1b6>
  40be28:	ab03      	add	r3, sp, #12
  40be2a:	9300      	str	r3, [sp, #0]
  40be2c:	4622      	mov	r2, r4
  40be2e:	4b13      	ldr	r3, [pc, #76]	; (40be7c <_vfiprintf_r+0x228>)
  40be30:	a904      	add	r1, sp, #16
  40be32:	4630      	mov	r0, r6
  40be34:	f7fd fc8a 	bl	40974c <_printf_float>
  40be38:	f1b0 3fff 	cmp.w	r0, #4294967295
  40be3c:	4681      	mov	r9, r0
  40be3e:	d1d8      	bne.n	40bdf2 <_vfiprintf_r+0x19e>
  40be40:	89a3      	ldrh	r3, [r4, #12]
  40be42:	065b      	lsls	r3, r3, #25
  40be44:	f53f af7d 	bmi.w	40bd42 <_vfiprintf_r+0xee>
  40be48:	9809      	ldr	r0, [sp, #36]	; 0x24
  40be4a:	e77c      	b.n	40bd46 <_vfiprintf_r+0xf2>
  40be4c:	ab03      	add	r3, sp, #12
  40be4e:	9300      	str	r3, [sp, #0]
  40be50:	4622      	mov	r2, r4
  40be52:	4b0a      	ldr	r3, [pc, #40]	; (40be7c <_vfiprintf_r+0x228>)
  40be54:	a904      	add	r1, sp, #16
  40be56:	4630      	mov	r0, r6
  40be58:	f7fd ff26 	bl	409ca8 <_printf_i>
  40be5c:	e7ec      	b.n	40be38 <_vfiprintf_r+0x1e4>
  40be5e:	bf00      	nop
  40be60:	0040defc 	.word	0x0040defc
  40be64:	0040e03c 	.word	0x0040e03c
  40be68:	0040df1c 	.word	0x0040df1c
  40be6c:	0040dedc 	.word	0x0040dedc
  40be70:	0040e042 	.word	0x0040e042
  40be74:	0040e046 	.word	0x0040e046
  40be78:	0040974d 	.word	0x0040974d
  40be7c:	0040bc31 	.word	0x0040bc31

0040be80 <_sbrk_r>:
  40be80:	b538      	push	{r3, r4, r5, lr}
  40be82:	4c06      	ldr	r4, [pc, #24]	; (40be9c <_sbrk_r+0x1c>)
  40be84:	2300      	movs	r3, #0
  40be86:	4605      	mov	r5, r0
  40be88:	4608      	mov	r0, r1
  40be8a:	6023      	str	r3, [r4, #0]
  40be8c:	f7f9 fba6 	bl	4055dc <_sbrk>
  40be90:	1c43      	adds	r3, r0, #1
  40be92:	d102      	bne.n	40be9a <_sbrk_r+0x1a>
  40be94:	6823      	ldr	r3, [r4, #0]
  40be96:	b103      	cbz	r3, 40be9a <_sbrk_r+0x1a>
  40be98:	602b      	str	r3, [r5, #0]
  40be9a:	bd38      	pop	{r3, r4, r5, pc}
  40be9c:	20002974 	.word	0x20002974

0040bea0 <__sread>:
  40bea0:	b510      	push	{r4, lr}
  40bea2:	460c      	mov	r4, r1
  40bea4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40bea8:	f000 f9a8 	bl	40c1fc <_read_r>
  40beac:	2800      	cmp	r0, #0
  40beae:	bfab      	itete	ge
  40beb0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  40beb2:	89a3      	ldrhlt	r3, [r4, #12]
  40beb4:	181b      	addge	r3, r3, r0
  40beb6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  40beba:	bfac      	ite	ge
  40bebc:	6563      	strge	r3, [r4, #84]	; 0x54
  40bebe:	81a3      	strhlt	r3, [r4, #12]
  40bec0:	bd10      	pop	{r4, pc}

0040bec2 <__swrite>:
  40bec2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40bec6:	461f      	mov	r7, r3
  40bec8:	898b      	ldrh	r3, [r1, #12]
  40beca:	05db      	lsls	r3, r3, #23
  40becc:	4605      	mov	r5, r0
  40bece:	460c      	mov	r4, r1
  40bed0:	4616      	mov	r6, r2
  40bed2:	d505      	bpl.n	40bee0 <__swrite+0x1e>
  40bed4:	2302      	movs	r3, #2
  40bed6:	2200      	movs	r2, #0
  40bed8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40bedc:	f000 f928 	bl	40c130 <_lseek_r>
  40bee0:	89a3      	ldrh	r3, [r4, #12]
  40bee2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40bee6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40beea:	81a3      	strh	r3, [r4, #12]
  40beec:	4632      	mov	r2, r6
  40beee:	463b      	mov	r3, r7
  40bef0:	4628      	mov	r0, r5
  40bef2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40bef6:	f000 b869 	b.w	40bfcc <_write_r>

0040befa <__sseek>:
  40befa:	b510      	push	{r4, lr}
  40befc:	460c      	mov	r4, r1
  40befe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40bf02:	f000 f915 	bl	40c130 <_lseek_r>
  40bf06:	1c43      	adds	r3, r0, #1
  40bf08:	89a3      	ldrh	r3, [r4, #12]
  40bf0a:	bf15      	itete	ne
  40bf0c:	6560      	strne	r0, [r4, #84]	; 0x54
  40bf0e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40bf12:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  40bf16:	81a3      	strheq	r3, [r4, #12]
  40bf18:	bf18      	it	ne
  40bf1a:	81a3      	strhne	r3, [r4, #12]
  40bf1c:	bd10      	pop	{r4, pc}

0040bf1e <__sclose>:
  40bf1e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40bf22:	f000 b8d3 	b.w	40c0cc <_close_r>
	...

0040bf28 <__swbuf_r>:
  40bf28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40bf2a:	460e      	mov	r6, r1
  40bf2c:	4614      	mov	r4, r2
  40bf2e:	4605      	mov	r5, r0
  40bf30:	b118      	cbz	r0, 40bf3a <__swbuf_r+0x12>
  40bf32:	6983      	ldr	r3, [r0, #24]
  40bf34:	b90b      	cbnz	r3, 40bf3a <__swbuf_r+0x12>
  40bf36:	f7ff f833 	bl	40afa0 <__sinit>
  40bf3a:	4b21      	ldr	r3, [pc, #132]	; (40bfc0 <__swbuf_r+0x98>)
  40bf3c:	429c      	cmp	r4, r3
  40bf3e:	d12a      	bne.n	40bf96 <__swbuf_r+0x6e>
  40bf40:	686c      	ldr	r4, [r5, #4]
  40bf42:	69a3      	ldr	r3, [r4, #24]
  40bf44:	60a3      	str	r3, [r4, #8]
  40bf46:	89a3      	ldrh	r3, [r4, #12]
  40bf48:	071a      	lsls	r2, r3, #28
  40bf4a:	d52e      	bpl.n	40bfaa <__swbuf_r+0x82>
  40bf4c:	6923      	ldr	r3, [r4, #16]
  40bf4e:	b363      	cbz	r3, 40bfaa <__swbuf_r+0x82>
  40bf50:	6923      	ldr	r3, [r4, #16]
  40bf52:	6820      	ldr	r0, [r4, #0]
  40bf54:	1ac0      	subs	r0, r0, r3
  40bf56:	6963      	ldr	r3, [r4, #20]
  40bf58:	b2f6      	uxtb	r6, r6
  40bf5a:	4298      	cmp	r0, r3
  40bf5c:	4637      	mov	r7, r6
  40bf5e:	db04      	blt.n	40bf6a <__swbuf_r+0x42>
  40bf60:	4621      	mov	r1, r4
  40bf62:	4628      	mov	r0, r5
  40bf64:	f7fe ffb2 	bl	40aecc <_fflush_r>
  40bf68:	bb28      	cbnz	r0, 40bfb6 <__swbuf_r+0x8e>
  40bf6a:	68a3      	ldr	r3, [r4, #8]
  40bf6c:	3b01      	subs	r3, #1
  40bf6e:	60a3      	str	r3, [r4, #8]
  40bf70:	6823      	ldr	r3, [r4, #0]
  40bf72:	1c5a      	adds	r2, r3, #1
  40bf74:	6022      	str	r2, [r4, #0]
  40bf76:	701e      	strb	r6, [r3, #0]
  40bf78:	6963      	ldr	r3, [r4, #20]
  40bf7a:	3001      	adds	r0, #1
  40bf7c:	4298      	cmp	r0, r3
  40bf7e:	d004      	beq.n	40bf8a <__swbuf_r+0x62>
  40bf80:	89a3      	ldrh	r3, [r4, #12]
  40bf82:	07db      	lsls	r3, r3, #31
  40bf84:	d519      	bpl.n	40bfba <__swbuf_r+0x92>
  40bf86:	2e0a      	cmp	r6, #10
  40bf88:	d117      	bne.n	40bfba <__swbuf_r+0x92>
  40bf8a:	4621      	mov	r1, r4
  40bf8c:	4628      	mov	r0, r5
  40bf8e:	f7fe ff9d 	bl	40aecc <_fflush_r>
  40bf92:	b190      	cbz	r0, 40bfba <__swbuf_r+0x92>
  40bf94:	e00f      	b.n	40bfb6 <__swbuf_r+0x8e>
  40bf96:	4b0b      	ldr	r3, [pc, #44]	; (40bfc4 <__swbuf_r+0x9c>)
  40bf98:	429c      	cmp	r4, r3
  40bf9a:	d101      	bne.n	40bfa0 <__swbuf_r+0x78>
  40bf9c:	68ac      	ldr	r4, [r5, #8]
  40bf9e:	e7d0      	b.n	40bf42 <__swbuf_r+0x1a>
  40bfa0:	4b09      	ldr	r3, [pc, #36]	; (40bfc8 <__swbuf_r+0xa0>)
  40bfa2:	429c      	cmp	r4, r3
  40bfa4:	bf08      	it	eq
  40bfa6:	68ec      	ldreq	r4, [r5, #12]
  40bfa8:	e7cb      	b.n	40bf42 <__swbuf_r+0x1a>
  40bfaa:	4621      	mov	r1, r4
  40bfac:	4628      	mov	r0, r5
  40bfae:	f000 f81f 	bl	40bff0 <__swsetup_r>
  40bfb2:	2800      	cmp	r0, #0
  40bfb4:	d0cc      	beq.n	40bf50 <__swbuf_r+0x28>
  40bfb6:	f04f 37ff 	mov.w	r7, #4294967295
  40bfba:	4638      	mov	r0, r7
  40bfbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40bfbe:	bf00      	nop
  40bfc0:	0040defc 	.word	0x0040defc
  40bfc4:	0040df1c 	.word	0x0040df1c
  40bfc8:	0040dedc 	.word	0x0040dedc

0040bfcc <_write_r>:
  40bfcc:	b538      	push	{r3, r4, r5, lr}
  40bfce:	4c07      	ldr	r4, [pc, #28]	; (40bfec <_write_r+0x20>)
  40bfd0:	4605      	mov	r5, r0
  40bfd2:	4608      	mov	r0, r1
  40bfd4:	4611      	mov	r1, r2
  40bfd6:	2200      	movs	r2, #0
  40bfd8:	6022      	str	r2, [r4, #0]
  40bfda:	461a      	mov	r2, r3
  40bfdc:	f7f4 ffec 	bl	400fb8 <_write>
  40bfe0:	1c43      	adds	r3, r0, #1
  40bfe2:	d102      	bne.n	40bfea <_write_r+0x1e>
  40bfe4:	6823      	ldr	r3, [r4, #0]
  40bfe6:	b103      	cbz	r3, 40bfea <_write_r+0x1e>
  40bfe8:	602b      	str	r3, [r5, #0]
  40bfea:	bd38      	pop	{r3, r4, r5, pc}
  40bfec:	20002974 	.word	0x20002974

0040bff0 <__swsetup_r>:
  40bff0:	4b32      	ldr	r3, [pc, #200]	; (40c0bc <__swsetup_r+0xcc>)
  40bff2:	b570      	push	{r4, r5, r6, lr}
  40bff4:	681d      	ldr	r5, [r3, #0]
  40bff6:	4606      	mov	r6, r0
  40bff8:	460c      	mov	r4, r1
  40bffa:	b125      	cbz	r5, 40c006 <__swsetup_r+0x16>
  40bffc:	69ab      	ldr	r3, [r5, #24]
  40bffe:	b913      	cbnz	r3, 40c006 <__swsetup_r+0x16>
  40c000:	4628      	mov	r0, r5
  40c002:	f7fe ffcd 	bl	40afa0 <__sinit>
  40c006:	4b2e      	ldr	r3, [pc, #184]	; (40c0c0 <__swsetup_r+0xd0>)
  40c008:	429c      	cmp	r4, r3
  40c00a:	d10f      	bne.n	40c02c <__swsetup_r+0x3c>
  40c00c:	686c      	ldr	r4, [r5, #4]
  40c00e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40c012:	b29a      	uxth	r2, r3
  40c014:	0715      	lsls	r5, r2, #28
  40c016:	d42c      	bmi.n	40c072 <__swsetup_r+0x82>
  40c018:	06d0      	lsls	r0, r2, #27
  40c01a:	d411      	bmi.n	40c040 <__swsetup_r+0x50>
  40c01c:	2209      	movs	r2, #9
  40c01e:	6032      	str	r2, [r6, #0]
  40c020:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40c024:	81a3      	strh	r3, [r4, #12]
  40c026:	f04f 30ff 	mov.w	r0, #4294967295
  40c02a:	bd70      	pop	{r4, r5, r6, pc}
  40c02c:	4b25      	ldr	r3, [pc, #148]	; (40c0c4 <__swsetup_r+0xd4>)
  40c02e:	429c      	cmp	r4, r3
  40c030:	d101      	bne.n	40c036 <__swsetup_r+0x46>
  40c032:	68ac      	ldr	r4, [r5, #8]
  40c034:	e7eb      	b.n	40c00e <__swsetup_r+0x1e>
  40c036:	4b24      	ldr	r3, [pc, #144]	; (40c0c8 <__swsetup_r+0xd8>)
  40c038:	429c      	cmp	r4, r3
  40c03a:	bf08      	it	eq
  40c03c:	68ec      	ldreq	r4, [r5, #12]
  40c03e:	e7e6      	b.n	40c00e <__swsetup_r+0x1e>
  40c040:	0751      	lsls	r1, r2, #29
  40c042:	d512      	bpl.n	40c06a <__swsetup_r+0x7a>
  40c044:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40c046:	b141      	cbz	r1, 40c05a <__swsetup_r+0x6a>
  40c048:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40c04c:	4299      	cmp	r1, r3
  40c04e:	d002      	beq.n	40c056 <__swsetup_r+0x66>
  40c050:	4630      	mov	r0, r6
  40c052:	f7ff fbdb 	bl	40b80c <_free_r>
  40c056:	2300      	movs	r3, #0
  40c058:	6363      	str	r3, [r4, #52]	; 0x34
  40c05a:	89a3      	ldrh	r3, [r4, #12]
  40c05c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
  40c060:	81a3      	strh	r3, [r4, #12]
  40c062:	2300      	movs	r3, #0
  40c064:	6063      	str	r3, [r4, #4]
  40c066:	6923      	ldr	r3, [r4, #16]
  40c068:	6023      	str	r3, [r4, #0]
  40c06a:	89a3      	ldrh	r3, [r4, #12]
  40c06c:	f043 0308 	orr.w	r3, r3, #8
  40c070:	81a3      	strh	r3, [r4, #12]
  40c072:	6923      	ldr	r3, [r4, #16]
  40c074:	b94b      	cbnz	r3, 40c08a <__swsetup_r+0x9a>
  40c076:	89a3      	ldrh	r3, [r4, #12]
  40c078:	f403 7320 	and.w	r3, r3, #640	; 0x280
  40c07c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40c080:	d003      	beq.n	40c08a <__swsetup_r+0x9a>
  40c082:	4621      	mov	r1, r4
  40c084:	4630      	mov	r0, r6
  40c086:	f7ff f847 	bl	40b118 <__smakebuf_r>
  40c08a:	89a2      	ldrh	r2, [r4, #12]
  40c08c:	f012 0301 	ands.w	r3, r2, #1
  40c090:	d00c      	beq.n	40c0ac <__swsetup_r+0xbc>
  40c092:	2300      	movs	r3, #0
  40c094:	60a3      	str	r3, [r4, #8]
  40c096:	6963      	ldr	r3, [r4, #20]
  40c098:	425b      	negs	r3, r3
  40c09a:	61a3      	str	r3, [r4, #24]
  40c09c:	6923      	ldr	r3, [r4, #16]
  40c09e:	b953      	cbnz	r3, 40c0b6 <__swsetup_r+0xc6>
  40c0a0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40c0a4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
  40c0a8:	d1ba      	bne.n	40c020 <__swsetup_r+0x30>
  40c0aa:	bd70      	pop	{r4, r5, r6, pc}
  40c0ac:	0792      	lsls	r2, r2, #30
  40c0ae:	bf58      	it	pl
  40c0b0:	6963      	ldrpl	r3, [r4, #20]
  40c0b2:	60a3      	str	r3, [r4, #8]
  40c0b4:	e7f2      	b.n	40c09c <__swsetup_r+0xac>
  40c0b6:	2000      	movs	r0, #0
  40c0b8:	e7f7      	b.n	40c0aa <__swsetup_r+0xba>
  40c0ba:	bf00      	nop
  40c0bc:	20000178 	.word	0x20000178
  40c0c0:	0040defc 	.word	0x0040defc
  40c0c4:	0040df1c 	.word	0x0040df1c
  40c0c8:	0040dedc 	.word	0x0040dedc

0040c0cc <_close_r>:
  40c0cc:	b538      	push	{r3, r4, r5, lr}
  40c0ce:	4c06      	ldr	r4, [pc, #24]	; (40c0e8 <_close_r+0x1c>)
  40c0d0:	2300      	movs	r3, #0
  40c0d2:	4605      	mov	r5, r0
  40c0d4:	4608      	mov	r0, r1
  40c0d6:	6023      	str	r3, [r4, #0]
  40c0d8:	f7f9 faac 	bl	405634 <_close>
  40c0dc:	1c43      	adds	r3, r0, #1
  40c0de:	d102      	bne.n	40c0e6 <_close_r+0x1a>
  40c0e0:	6823      	ldr	r3, [r4, #0]
  40c0e2:	b103      	cbz	r3, 40c0e6 <_close_r+0x1a>
  40c0e4:	602b      	str	r3, [r5, #0]
  40c0e6:	bd38      	pop	{r3, r4, r5, pc}
  40c0e8:	20002974 	.word	0x20002974

0040c0ec <_fstat_r>:
  40c0ec:	b538      	push	{r3, r4, r5, lr}
  40c0ee:	4c07      	ldr	r4, [pc, #28]	; (40c10c <_fstat_r+0x20>)
  40c0f0:	2300      	movs	r3, #0
  40c0f2:	4605      	mov	r5, r0
  40c0f4:	4608      	mov	r0, r1
  40c0f6:	4611      	mov	r1, r2
  40c0f8:	6023      	str	r3, [r4, #0]
  40c0fa:	f7f9 faa7 	bl	40564c <_fstat>
  40c0fe:	1c43      	adds	r3, r0, #1
  40c100:	d102      	bne.n	40c108 <_fstat_r+0x1c>
  40c102:	6823      	ldr	r3, [r4, #0]
  40c104:	b103      	cbz	r3, 40c108 <_fstat_r+0x1c>
  40c106:	602b      	str	r3, [r5, #0]
  40c108:	bd38      	pop	{r3, r4, r5, pc}
  40c10a:	bf00      	nop
  40c10c:	20002974 	.word	0x20002974

0040c110 <_isatty_r>:
  40c110:	b538      	push	{r3, r4, r5, lr}
  40c112:	4c06      	ldr	r4, [pc, #24]	; (40c12c <_isatty_r+0x1c>)
  40c114:	2300      	movs	r3, #0
  40c116:	4605      	mov	r5, r0
  40c118:	4608      	mov	r0, r1
  40c11a:	6023      	str	r3, [r4, #0]
  40c11c:	f7f9 faa6 	bl	40566c <_isatty>
  40c120:	1c43      	adds	r3, r0, #1
  40c122:	d102      	bne.n	40c12a <_isatty_r+0x1a>
  40c124:	6823      	ldr	r3, [r4, #0]
  40c126:	b103      	cbz	r3, 40c12a <_isatty_r+0x1a>
  40c128:	602b      	str	r3, [r5, #0]
  40c12a:	bd38      	pop	{r3, r4, r5, pc}
  40c12c:	20002974 	.word	0x20002974

0040c130 <_lseek_r>:
  40c130:	b538      	push	{r3, r4, r5, lr}
  40c132:	4c07      	ldr	r4, [pc, #28]	; (40c150 <_lseek_r+0x20>)
  40c134:	4605      	mov	r5, r0
  40c136:	4608      	mov	r0, r1
  40c138:	4611      	mov	r1, r2
  40c13a:	2200      	movs	r2, #0
  40c13c:	6022      	str	r2, [r4, #0]
  40c13e:	461a      	mov	r2, r3
  40c140:	f7f9 fa9f 	bl	405682 <_lseek>
  40c144:	1c43      	adds	r3, r0, #1
  40c146:	d102      	bne.n	40c14e <_lseek_r+0x1e>
  40c148:	6823      	ldr	r3, [r4, #0]
  40c14a:	b103      	cbz	r3, 40c14e <_lseek_r+0x1e>
  40c14c:	602b      	str	r3, [r5, #0]
  40c14e:	bd38      	pop	{r3, r4, r5, pc}
  40c150:	20002974 	.word	0x20002974

0040c154 <__ascii_mbtowc>:
  40c154:	b082      	sub	sp, #8
  40c156:	b901      	cbnz	r1, 40c15a <__ascii_mbtowc+0x6>
  40c158:	a901      	add	r1, sp, #4
  40c15a:	b142      	cbz	r2, 40c16e <__ascii_mbtowc+0x1a>
  40c15c:	b14b      	cbz	r3, 40c172 <__ascii_mbtowc+0x1e>
  40c15e:	7813      	ldrb	r3, [r2, #0]
  40c160:	600b      	str	r3, [r1, #0]
  40c162:	7812      	ldrb	r2, [r2, #0]
  40c164:	1c10      	adds	r0, r2, #0
  40c166:	bf18      	it	ne
  40c168:	2001      	movne	r0, #1
  40c16a:	b002      	add	sp, #8
  40c16c:	4770      	bx	lr
  40c16e:	4610      	mov	r0, r2
  40c170:	e7fb      	b.n	40c16a <__ascii_mbtowc+0x16>
  40c172:	f06f 0001 	mvn.w	r0, #1
  40c176:	e7f8      	b.n	40c16a <__ascii_mbtowc+0x16>

0040c178 <memmove>:
  40c178:	4288      	cmp	r0, r1
  40c17a:	b510      	push	{r4, lr}
  40c17c:	eb01 0302 	add.w	r3, r1, r2
  40c180:	d803      	bhi.n	40c18a <memmove+0x12>
  40c182:	1e42      	subs	r2, r0, #1
  40c184:	4299      	cmp	r1, r3
  40c186:	d10c      	bne.n	40c1a2 <memmove+0x2a>
  40c188:	bd10      	pop	{r4, pc}
  40c18a:	4298      	cmp	r0, r3
  40c18c:	d2f9      	bcs.n	40c182 <memmove+0xa>
  40c18e:	1881      	adds	r1, r0, r2
  40c190:	1ad2      	subs	r2, r2, r3
  40c192:	42d3      	cmn	r3, r2
  40c194:	d100      	bne.n	40c198 <memmove+0x20>
  40c196:	bd10      	pop	{r4, pc}
  40c198:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  40c19c:	f801 4d01 	strb.w	r4, [r1, #-1]!
  40c1a0:	e7f7      	b.n	40c192 <memmove+0x1a>
  40c1a2:	f811 4b01 	ldrb.w	r4, [r1], #1
  40c1a6:	f802 4f01 	strb.w	r4, [r2, #1]!
  40c1aa:	e7eb      	b.n	40c184 <memmove+0xc>

0040c1ac <__malloc_lock>:
  40c1ac:	4770      	bx	lr

0040c1ae <__malloc_unlock>:
  40c1ae:	4770      	bx	lr

0040c1b0 <_realloc_r>:
  40c1b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40c1b2:	4607      	mov	r7, r0
  40c1b4:	4614      	mov	r4, r2
  40c1b6:	460e      	mov	r6, r1
  40c1b8:	b921      	cbnz	r1, 40c1c4 <_realloc_r+0x14>
  40c1ba:	4611      	mov	r1, r2
  40c1bc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  40c1c0:	f7ff bb72 	b.w	40b8a8 <_malloc_r>
  40c1c4:	b922      	cbnz	r2, 40c1d0 <_realloc_r+0x20>
  40c1c6:	f7ff fb21 	bl	40b80c <_free_r>
  40c1ca:	4625      	mov	r5, r4
  40c1cc:	4628      	mov	r0, r5
  40c1ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40c1d0:	f000 f833 	bl	40c23a <_malloc_usable_size_r>
  40c1d4:	4284      	cmp	r4, r0
  40c1d6:	d90f      	bls.n	40c1f8 <_realloc_r+0x48>
  40c1d8:	4621      	mov	r1, r4
  40c1da:	4638      	mov	r0, r7
  40c1dc:	f7ff fb64 	bl	40b8a8 <_malloc_r>
  40c1e0:	4605      	mov	r5, r0
  40c1e2:	2800      	cmp	r0, #0
  40c1e4:	d0f2      	beq.n	40c1cc <_realloc_r+0x1c>
  40c1e6:	4631      	mov	r1, r6
  40c1e8:	4622      	mov	r2, r4
  40c1ea:	f7fd fa0b 	bl	409604 <memcpy>
  40c1ee:	4631      	mov	r1, r6
  40c1f0:	4638      	mov	r0, r7
  40c1f2:	f7ff fb0b 	bl	40b80c <_free_r>
  40c1f6:	e7e9      	b.n	40c1cc <_realloc_r+0x1c>
  40c1f8:	4635      	mov	r5, r6
  40c1fa:	e7e7      	b.n	40c1cc <_realloc_r+0x1c>

0040c1fc <_read_r>:
  40c1fc:	b538      	push	{r3, r4, r5, lr}
  40c1fe:	4c07      	ldr	r4, [pc, #28]	; (40c21c <_read_r+0x20>)
  40c200:	4605      	mov	r5, r0
  40c202:	4608      	mov	r0, r1
  40c204:	4611      	mov	r1, r2
  40c206:	2200      	movs	r2, #0
  40c208:	6022      	str	r2, [r4, #0]
  40c20a:	461a      	mov	r2, r3
  40c20c:	f7f4 feaa 	bl	400f64 <_read>
  40c210:	1c43      	adds	r3, r0, #1
  40c212:	d102      	bne.n	40c21a <_read_r+0x1e>
  40c214:	6823      	ldr	r3, [r4, #0]
  40c216:	b103      	cbz	r3, 40c21a <_read_r+0x1e>
  40c218:	602b      	str	r3, [r5, #0]
  40c21a:	bd38      	pop	{r3, r4, r5, pc}
  40c21c:	20002974 	.word	0x20002974

0040c220 <__ascii_wctomb>:
  40c220:	b149      	cbz	r1, 40c236 <__ascii_wctomb+0x16>
  40c222:	2aff      	cmp	r2, #255	; 0xff
  40c224:	bf85      	ittet	hi
  40c226:	238a      	movhi	r3, #138	; 0x8a
  40c228:	6003      	strhi	r3, [r0, #0]
  40c22a:	700a      	strbls	r2, [r1, #0]
  40c22c:	f04f 30ff 	movhi.w	r0, #4294967295
  40c230:	bf98      	it	ls
  40c232:	2001      	movls	r0, #1
  40c234:	4770      	bx	lr
  40c236:	4608      	mov	r0, r1
  40c238:	4770      	bx	lr

0040c23a <_malloc_usable_size_r>:
  40c23a:	f851 0c04 	ldr.w	r0, [r1, #-4]
  40c23e:	2800      	cmp	r0, #0
  40c240:	f1a0 0004 	sub.w	r0, r0, #4
  40c244:	bfbc      	itt	lt
  40c246:	580b      	ldrlt	r3, [r1, r0]
  40c248:	18c0      	addlt	r0, r0, r3
  40c24a:	4770      	bx	lr

0040c24c <__aeabi_drsub>:
  40c24c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  40c250:	e002      	b.n	40c258 <__adddf3>
  40c252:	bf00      	nop

0040c254 <__aeabi_dsub>:
  40c254:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0040c258 <__adddf3>:
  40c258:	b530      	push	{r4, r5, lr}
  40c25a:	ea4f 0441 	mov.w	r4, r1, lsl #1
  40c25e:	ea4f 0543 	mov.w	r5, r3, lsl #1
  40c262:	ea94 0f05 	teq	r4, r5
  40c266:	bf08      	it	eq
  40c268:	ea90 0f02 	teqeq	r0, r2
  40c26c:	bf1f      	itttt	ne
  40c26e:	ea54 0c00 	orrsne.w	ip, r4, r0
  40c272:	ea55 0c02 	orrsne.w	ip, r5, r2
  40c276:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  40c27a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  40c27e:	f000 80e2 	beq.w	40c446 <__adddf3+0x1ee>
  40c282:	ea4f 5454 	mov.w	r4, r4, lsr #21
  40c286:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  40c28a:	bfb8      	it	lt
  40c28c:	426d      	neglt	r5, r5
  40c28e:	dd0c      	ble.n	40c2aa <__adddf3+0x52>
  40c290:	442c      	add	r4, r5
  40c292:	ea80 0202 	eor.w	r2, r0, r2
  40c296:	ea81 0303 	eor.w	r3, r1, r3
  40c29a:	ea82 0000 	eor.w	r0, r2, r0
  40c29e:	ea83 0101 	eor.w	r1, r3, r1
  40c2a2:	ea80 0202 	eor.w	r2, r0, r2
  40c2a6:	ea81 0303 	eor.w	r3, r1, r3
  40c2aa:	2d36      	cmp	r5, #54	; 0x36
  40c2ac:	bf88      	it	hi
  40c2ae:	bd30      	pophi	{r4, r5, pc}
  40c2b0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40c2b4:	ea4f 3101 	mov.w	r1, r1, lsl #12
  40c2b8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  40c2bc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  40c2c0:	d002      	beq.n	40c2c8 <__adddf3+0x70>
  40c2c2:	4240      	negs	r0, r0
  40c2c4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40c2c8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  40c2cc:	ea4f 3303 	mov.w	r3, r3, lsl #12
  40c2d0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  40c2d4:	d002      	beq.n	40c2dc <__adddf3+0x84>
  40c2d6:	4252      	negs	r2, r2
  40c2d8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  40c2dc:	ea94 0f05 	teq	r4, r5
  40c2e0:	f000 80a7 	beq.w	40c432 <__adddf3+0x1da>
  40c2e4:	f1a4 0401 	sub.w	r4, r4, #1
  40c2e8:	f1d5 0e20 	rsbs	lr, r5, #32
  40c2ec:	db0d      	blt.n	40c30a <__adddf3+0xb2>
  40c2ee:	fa02 fc0e 	lsl.w	ip, r2, lr
  40c2f2:	fa22 f205 	lsr.w	r2, r2, r5
  40c2f6:	1880      	adds	r0, r0, r2
  40c2f8:	f141 0100 	adc.w	r1, r1, #0
  40c2fc:	fa03 f20e 	lsl.w	r2, r3, lr
  40c300:	1880      	adds	r0, r0, r2
  40c302:	fa43 f305 	asr.w	r3, r3, r5
  40c306:	4159      	adcs	r1, r3
  40c308:	e00e      	b.n	40c328 <__adddf3+0xd0>
  40c30a:	f1a5 0520 	sub.w	r5, r5, #32
  40c30e:	f10e 0e20 	add.w	lr, lr, #32
  40c312:	2a01      	cmp	r2, #1
  40c314:	fa03 fc0e 	lsl.w	ip, r3, lr
  40c318:	bf28      	it	cs
  40c31a:	f04c 0c02 	orrcs.w	ip, ip, #2
  40c31e:	fa43 f305 	asr.w	r3, r3, r5
  40c322:	18c0      	adds	r0, r0, r3
  40c324:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  40c328:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40c32c:	d507      	bpl.n	40c33e <__adddf3+0xe6>
  40c32e:	f04f 0e00 	mov.w	lr, #0
  40c332:	f1dc 0c00 	rsbs	ip, ip, #0
  40c336:	eb7e 0000 	sbcs.w	r0, lr, r0
  40c33a:	eb6e 0101 	sbc.w	r1, lr, r1
  40c33e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  40c342:	d31b      	bcc.n	40c37c <__adddf3+0x124>
  40c344:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  40c348:	d30c      	bcc.n	40c364 <__adddf3+0x10c>
  40c34a:	0849      	lsrs	r1, r1, #1
  40c34c:	ea5f 0030 	movs.w	r0, r0, rrx
  40c350:	ea4f 0c3c 	mov.w	ip, ip, rrx
  40c354:	f104 0401 	add.w	r4, r4, #1
  40c358:	ea4f 5244 	mov.w	r2, r4, lsl #21
  40c35c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  40c360:	f080 809a 	bcs.w	40c498 <__adddf3+0x240>
  40c364:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  40c368:	bf08      	it	eq
  40c36a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  40c36e:	f150 0000 	adcs.w	r0, r0, #0
  40c372:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40c376:	ea41 0105 	orr.w	r1, r1, r5
  40c37a:	bd30      	pop	{r4, r5, pc}
  40c37c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  40c380:	4140      	adcs	r0, r0
  40c382:	eb41 0101 	adc.w	r1, r1, r1
  40c386:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40c38a:	f1a4 0401 	sub.w	r4, r4, #1
  40c38e:	d1e9      	bne.n	40c364 <__adddf3+0x10c>
  40c390:	f091 0f00 	teq	r1, #0
  40c394:	bf04      	itt	eq
  40c396:	4601      	moveq	r1, r0
  40c398:	2000      	moveq	r0, #0
  40c39a:	fab1 f381 	clz	r3, r1
  40c39e:	bf08      	it	eq
  40c3a0:	3320      	addeq	r3, #32
  40c3a2:	f1a3 030b 	sub.w	r3, r3, #11
  40c3a6:	f1b3 0220 	subs.w	r2, r3, #32
  40c3aa:	da0c      	bge.n	40c3c6 <__adddf3+0x16e>
  40c3ac:	320c      	adds	r2, #12
  40c3ae:	dd08      	ble.n	40c3c2 <__adddf3+0x16a>
  40c3b0:	f102 0c14 	add.w	ip, r2, #20
  40c3b4:	f1c2 020c 	rsb	r2, r2, #12
  40c3b8:	fa01 f00c 	lsl.w	r0, r1, ip
  40c3bc:	fa21 f102 	lsr.w	r1, r1, r2
  40c3c0:	e00c      	b.n	40c3dc <__adddf3+0x184>
  40c3c2:	f102 0214 	add.w	r2, r2, #20
  40c3c6:	bfd8      	it	le
  40c3c8:	f1c2 0c20 	rsble	ip, r2, #32
  40c3cc:	fa01 f102 	lsl.w	r1, r1, r2
  40c3d0:	fa20 fc0c 	lsr.w	ip, r0, ip
  40c3d4:	bfdc      	itt	le
  40c3d6:	ea41 010c 	orrle.w	r1, r1, ip
  40c3da:	4090      	lslle	r0, r2
  40c3dc:	1ae4      	subs	r4, r4, r3
  40c3de:	bfa2      	ittt	ge
  40c3e0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  40c3e4:	4329      	orrge	r1, r5
  40c3e6:	bd30      	popge	{r4, r5, pc}
  40c3e8:	ea6f 0404 	mvn.w	r4, r4
  40c3ec:	3c1f      	subs	r4, #31
  40c3ee:	da1c      	bge.n	40c42a <__adddf3+0x1d2>
  40c3f0:	340c      	adds	r4, #12
  40c3f2:	dc0e      	bgt.n	40c412 <__adddf3+0x1ba>
  40c3f4:	f104 0414 	add.w	r4, r4, #20
  40c3f8:	f1c4 0220 	rsb	r2, r4, #32
  40c3fc:	fa20 f004 	lsr.w	r0, r0, r4
  40c400:	fa01 f302 	lsl.w	r3, r1, r2
  40c404:	ea40 0003 	orr.w	r0, r0, r3
  40c408:	fa21 f304 	lsr.w	r3, r1, r4
  40c40c:	ea45 0103 	orr.w	r1, r5, r3
  40c410:	bd30      	pop	{r4, r5, pc}
  40c412:	f1c4 040c 	rsb	r4, r4, #12
  40c416:	f1c4 0220 	rsb	r2, r4, #32
  40c41a:	fa20 f002 	lsr.w	r0, r0, r2
  40c41e:	fa01 f304 	lsl.w	r3, r1, r4
  40c422:	ea40 0003 	orr.w	r0, r0, r3
  40c426:	4629      	mov	r1, r5
  40c428:	bd30      	pop	{r4, r5, pc}
  40c42a:	fa21 f004 	lsr.w	r0, r1, r4
  40c42e:	4629      	mov	r1, r5
  40c430:	bd30      	pop	{r4, r5, pc}
  40c432:	f094 0f00 	teq	r4, #0
  40c436:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  40c43a:	bf06      	itte	eq
  40c43c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  40c440:	3401      	addeq	r4, #1
  40c442:	3d01      	subne	r5, #1
  40c444:	e74e      	b.n	40c2e4 <__adddf3+0x8c>
  40c446:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40c44a:	bf18      	it	ne
  40c44c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  40c450:	d029      	beq.n	40c4a6 <__adddf3+0x24e>
  40c452:	ea94 0f05 	teq	r4, r5
  40c456:	bf08      	it	eq
  40c458:	ea90 0f02 	teqeq	r0, r2
  40c45c:	d005      	beq.n	40c46a <__adddf3+0x212>
  40c45e:	ea54 0c00 	orrs.w	ip, r4, r0
  40c462:	bf04      	itt	eq
  40c464:	4619      	moveq	r1, r3
  40c466:	4610      	moveq	r0, r2
  40c468:	bd30      	pop	{r4, r5, pc}
  40c46a:	ea91 0f03 	teq	r1, r3
  40c46e:	bf1e      	ittt	ne
  40c470:	2100      	movne	r1, #0
  40c472:	2000      	movne	r0, #0
  40c474:	bd30      	popne	{r4, r5, pc}
  40c476:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  40c47a:	d105      	bne.n	40c488 <__adddf3+0x230>
  40c47c:	0040      	lsls	r0, r0, #1
  40c47e:	4149      	adcs	r1, r1
  40c480:	bf28      	it	cs
  40c482:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  40c486:	bd30      	pop	{r4, r5, pc}
  40c488:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  40c48c:	bf3c      	itt	cc
  40c48e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  40c492:	bd30      	popcc	{r4, r5, pc}
  40c494:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40c498:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  40c49c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  40c4a0:	f04f 0000 	mov.w	r0, #0
  40c4a4:	bd30      	pop	{r4, r5, pc}
  40c4a6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  40c4aa:	bf1a      	itte	ne
  40c4ac:	4619      	movne	r1, r3
  40c4ae:	4610      	movne	r0, r2
  40c4b0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  40c4b4:	bf1c      	itt	ne
  40c4b6:	460b      	movne	r3, r1
  40c4b8:	4602      	movne	r2, r0
  40c4ba:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  40c4be:	bf06      	itte	eq
  40c4c0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  40c4c4:	ea91 0f03 	teqeq	r1, r3
  40c4c8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  40c4cc:	bd30      	pop	{r4, r5, pc}
  40c4ce:	bf00      	nop

0040c4d0 <__aeabi_ui2d>:
  40c4d0:	f090 0f00 	teq	r0, #0
  40c4d4:	bf04      	itt	eq
  40c4d6:	2100      	moveq	r1, #0
  40c4d8:	4770      	bxeq	lr
  40c4da:	b530      	push	{r4, r5, lr}
  40c4dc:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40c4e0:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40c4e4:	f04f 0500 	mov.w	r5, #0
  40c4e8:	f04f 0100 	mov.w	r1, #0
  40c4ec:	e750      	b.n	40c390 <__adddf3+0x138>
  40c4ee:	bf00      	nop

0040c4f0 <__aeabi_i2d>:
  40c4f0:	f090 0f00 	teq	r0, #0
  40c4f4:	bf04      	itt	eq
  40c4f6:	2100      	moveq	r1, #0
  40c4f8:	4770      	bxeq	lr
  40c4fa:	b530      	push	{r4, r5, lr}
  40c4fc:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40c500:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40c504:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  40c508:	bf48      	it	mi
  40c50a:	4240      	negmi	r0, r0
  40c50c:	f04f 0100 	mov.w	r1, #0
  40c510:	e73e      	b.n	40c390 <__adddf3+0x138>
  40c512:	bf00      	nop

0040c514 <__aeabi_f2d>:
  40c514:	0042      	lsls	r2, r0, #1
  40c516:	ea4f 01e2 	mov.w	r1, r2, asr #3
  40c51a:	ea4f 0131 	mov.w	r1, r1, rrx
  40c51e:	ea4f 7002 	mov.w	r0, r2, lsl #28
  40c522:	bf1f      	itttt	ne
  40c524:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  40c528:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  40c52c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  40c530:	4770      	bxne	lr
  40c532:	f092 0f00 	teq	r2, #0
  40c536:	bf14      	ite	ne
  40c538:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  40c53c:	4770      	bxeq	lr
  40c53e:	b530      	push	{r4, r5, lr}
  40c540:	f44f 7460 	mov.w	r4, #896	; 0x380
  40c544:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40c548:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40c54c:	e720      	b.n	40c390 <__adddf3+0x138>
  40c54e:	bf00      	nop

0040c550 <__aeabi_ul2d>:
  40c550:	ea50 0201 	orrs.w	r2, r0, r1
  40c554:	bf08      	it	eq
  40c556:	4770      	bxeq	lr
  40c558:	b530      	push	{r4, r5, lr}
  40c55a:	f04f 0500 	mov.w	r5, #0
  40c55e:	e00a      	b.n	40c576 <__aeabi_l2d+0x16>

0040c560 <__aeabi_l2d>:
  40c560:	ea50 0201 	orrs.w	r2, r0, r1
  40c564:	bf08      	it	eq
  40c566:	4770      	bxeq	lr
  40c568:	b530      	push	{r4, r5, lr}
  40c56a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  40c56e:	d502      	bpl.n	40c576 <__aeabi_l2d+0x16>
  40c570:	4240      	negs	r0, r0
  40c572:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40c576:	f44f 6480 	mov.w	r4, #1024	; 0x400
  40c57a:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40c57e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  40c582:	f43f aedc 	beq.w	40c33e <__adddf3+0xe6>
  40c586:	f04f 0203 	mov.w	r2, #3
  40c58a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  40c58e:	bf18      	it	ne
  40c590:	3203      	addne	r2, #3
  40c592:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  40c596:	bf18      	it	ne
  40c598:	3203      	addne	r2, #3
  40c59a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  40c59e:	f1c2 0320 	rsb	r3, r2, #32
  40c5a2:	fa00 fc03 	lsl.w	ip, r0, r3
  40c5a6:	fa20 f002 	lsr.w	r0, r0, r2
  40c5aa:	fa01 fe03 	lsl.w	lr, r1, r3
  40c5ae:	ea40 000e 	orr.w	r0, r0, lr
  40c5b2:	fa21 f102 	lsr.w	r1, r1, r2
  40c5b6:	4414      	add	r4, r2
  40c5b8:	e6c1      	b.n	40c33e <__adddf3+0xe6>
  40c5ba:	bf00      	nop

0040c5bc <__aeabi_dmul>:
  40c5bc:	b570      	push	{r4, r5, r6, lr}
  40c5be:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40c5c2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  40c5c6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40c5ca:	bf1d      	ittte	ne
  40c5cc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  40c5d0:	ea94 0f0c 	teqne	r4, ip
  40c5d4:	ea95 0f0c 	teqne	r5, ip
  40c5d8:	f000 f8de 	bleq	40c798 <__aeabi_dmul+0x1dc>
  40c5dc:	442c      	add	r4, r5
  40c5de:	ea81 0603 	eor.w	r6, r1, r3
  40c5e2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  40c5e6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  40c5ea:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  40c5ee:	bf18      	it	ne
  40c5f0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  40c5f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40c5f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  40c5fc:	d038      	beq.n	40c670 <__aeabi_dmul+0xb4>
  40c5fe:	fba0 ce02 	umull	ip, lr, r0, r2
  40c602:	f04f 0500 	mov.w	r5, #0
  40c606:	fbe1 e502 	umlal	lr, r5, r1, r2
  40c60a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  40c60e:	fbe0 e503 	umlal	lr, r5, r0, r3
  40c612:	f04f 0600 	mov.w	r6, #0
  40c616:	fbe1 5603 	umlal	r5, r6, r1, r3
  40c61a:	f09c 0f00 	teq	ip, #0
  40c61e:	bf18      	it	ne
  40c620:	f04e 0e01 	orrne.w	lr, lr, #1
  40c624:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  40c628:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  40c62c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  40c630:	d204      	bcs.n	40c63c <__aeabi_dmul+0x80>
  40c632:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  40c636:	416d      	adcs	r5, r5
  40c638:	eb46 0606 	adc.w	r6, r6, r6
  40c63c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  40c640:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  40c644:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  40c648:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  40c64c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  40c650:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  40c654:	bf88      	it	hi
  40c656:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  40c65a:	d81e      	bhi.n	40c69a <__aeabi_dmul+0xde>
  40c65c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  40c660:	bf08      	it	eq
  40c662:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  40c666:	f150 0000 	adcs.w	r0, r0, #0
  40c66a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40c66e:	bd70      	pop	{r4, r5, r6, pc}
  40c670:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  40c674:	ea46 0101 	orr.w	r1, r6, r1
  40c678:	ea40 0002 	orr.w	r0, r0, r2
  40c67c:	ea81 0103 	eor.w	r1, r1, r3
  40c680:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  40c684:	bfc2      	ittt	gt
  40c686:	ebd4 050c 	rsbsgt	r5, r4, ip
  40c68a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  40c68e:	bd70      	popgt	{r4, r5, r6, pc}
  40c690:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40c694:	f04f 0e00 	mov.w	lr, #0
  40c698:	3c01      	subs	r4, #1
  40c69a:	f300 80ab 	bgt.w	40c7f4 <__aeabi_dmul+0x238>
  40c69e:	f114 0f36 	cmn.w	r4, #54	; 0x36
  40c6a2:	bfde      	ittt	le
  40c6a4:	2000      	movle	r0, #0
  40c6a6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  40c6aa:	bd70      	pople	{r4, r5, r6, pc}
  40c6ac:	f1c4 0400 	rsb	r4, r4, #0
  40c6b0:	3c20      	subs	r4, #32
  40c6b2:	da35      	bge.n	40c720 <__aeabi_dmul+0x164>
  40c6b4:	340c      	adds	r4, #12
  40c6b6:	dc1b      	bgt.n	40c6f0 <__aeabi_dmul+0x134>
  40c6b8:	f104 0414 	add.w	r4, r4, #20
  40c6bc:	f1c4 0520 	rsb	r5, r4, #32
  40c6c0:	fa00 f305 	lsl.w	r3, r0, r5
  40c6c4:	fa20 f004 	lsr.w	r0, r0, r4
  40c6c8:	fa01 f205 	lsl.w	r2, r1, r5
  40c6cc:	ea40 0002 	orr.w	r0, r0, r2
  40c6d0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  40c6d4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  40c6d8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  40c6dc:	fa21 f604 	lsr.w	r6, r1, r4
  40c6e0:	eb42 0106 	adc.w	r1, r2, r6
  40c6e4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40c6e8:	bf08      	it	eq
  40c6ea:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40c6ee:	bd70      	pop	{r4, r5, r6, pc}
  40c6f0:	f1c4 040c 	rsb	r4, r4, #12
  40c6f4:	f1c4 0520 	rsb	r5, r4, #32
  40c6f8:	fa00 f304 	lsl.w	r3, r0, r4
  40c6fc:	fa20 f005 	lsr.w	r0, r0, r5
  40c700:	fa01 f204 	lsl.w	r2, r1, r4
  40c704:	ea40 0002 	orr.w	r0, r0, r2
  40c708:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40c70c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  40c710:	f141 0100 	adc.w	r1, r1, #0
  40c714:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40c718:	bf08      	it	eq
  40c71a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40c71e:	bd70      	pop	{r4, r5, r6, pc}
  40c720:	f1c4 0520 	rsb	r5, r4, #32
  40c724:	fa00 f205 	lsl.w	r2, r0, r5
  40c728:	ea4e 0e02 	orr.w	lr, lr, r2
  40c72c:	fa20 f304 	lsr.w	r3, r0, r4
  40c730:	fa01 f205 	lsl.w	r2, r1, r5
  40c734:	ea43 0302 	orr.w	r3, r3, r2
  40c738:	fa21 f004 	lsr.w	r0, r1, r4
  40c73c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40c740:	fa21 f204 	lsr.w	r2, r1, r4
  40c744:	ea20 0002 	bic.w	r0, r0, r2
  40c748:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  40c74c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  40c750:	bf08      	it	eq
  40c752:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  40c756:	bd70      	pop	{r4, r5, r6, pc}
  40c758:	f094 0f00 	teq	r4, #0
  40c75c:	d10f      	bne.n	40c77e <__aeabi_dmul+0x1c2>
  40c75e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  40c762:	0040      	lsls	r0, r0, #1
  40c764:	eb41 0101 	adc.w	r1, r1, r1
  40c768:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40c76c:	bf08      	it	eq
  40c76e:	3c01      	subeq	r4, #1
  40c770:	d0f7      	beq.n	40c762 <__aeabi_dmul+0x1a6>
  40c772:	ea41 0106 	orr.w	r1, r1, r6
  40c776:	f095 0f00 	teq	r5, #0
  40c77a:	bf18      	it	ne
  40c77c:	4770      	bxne	lr
  40c77e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  40c782:	0052      	lsls	r2, r2, #1
  40c784:	eb43 0303 	adc.w	r3, r3, r3
  40c788:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  40c78c:	bf08      	it	eq
  40c78e:	3d01      	subeq	r5, #1
  40c790:	d0f7      	beq.n	40c782 <__aeabi_dmul+0x1c6>
  40c792:	ea43 0306 	orr.w	r3, r3, r6
  40c796:	4770      	bx	lr
  40c798:	ea94 0f0c 	teq	r4, ip
  40c79c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  40c7a0:	bf18      	it	ne
  40c7a2:	ea95 0f0c 	teqne	r5, ip
  40c7a6:	d00c      	beq.n	40c7c2 <__aeabi_dmul+0x206>
  40c7a8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40c7ac:	bf18      	it	ne
  40c7ae:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40c7b2:	d1d1      	bne.n	40c758 <__aeabi_dmul+0x19c>
  40c7b4:	ea81 0103 	eor.w	r1, r1, r3
  40c7b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40c7bc:	f04f 0000 	mov.w	r0, #0
  40c7c0:	bd70      	pop	{r4, r5, r6, pc}
  40c7c2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40c7c6:	bf06      	itte	eq
  40c7c8:	4610      	moveq	r0, r2
  40c7ca:	4619      	moveq	r1, r3
  40c7cc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40c7d0:	d019      	beq.n	40c806 <__aeabi_dmul+0x24a>
  40c7d2:	ea94 0f0c 	teq	r4, ip
  40c7d6:	d102      	bne.n	40c7de <__aeabi_dmul+0x222>
  40c7d8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  40c7dc:	d113      	bne.n	40c806 <__aeabi_dmul+0x24a>
  40c7de:	ea95 0f0c 	teq	r5, ip
  40c7e2:	d105      	bne.n	40c7f0 <__aeabi_dmul+0x234>
  40c7e4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  40c7e8:	bf1c      	itt	ne
  40c7ea:	4610      	movne	r0, r2
  40c7ec:	4619      	movne	r1, r3
  40c7ee:	d10a      	bne.n	40c806 <__aeabi_dmul+0x24a>
  40c7f0:	ea81 0103 	eor.w	r1, r1, r3
  40c7f4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  40c7f8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  40c7fc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  40c800:	f04f 0000 	mov.w	r0, #0
  40c804:	bd70      	pop	{r4, r5, r6, pc}
  40c806:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  40c80a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  40c80e:	bd70      	pop	{r4, r5, r6, pc}

0040c810 <__aeabi_ddiv>:
  40c810:	b570      	push	{r4, r5, r6, lr}
  40c812:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40c816:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  40c81a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  40c81e:	bf1d      	ittte	ne
  40c820:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  40c824:	ea94 0f0c 	teqne	r4, ip
  40c828:	ea95 0f0c 	teqne	r5, ip
  40c82c:	f000 f8a7 	bleq	40c97e <__aeabi_ddiv+0x16e>
  40c830:	eba4 0405 	sub.w	r4, r4, r5
  40c834:	ea81 0e03 	eor.w	lr, r1, r3
  40c838:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  40c83c:	ea4f 3101 	mov.w	r1, r1, lsl #12
  40c840:	f000 8088 	beq.w	40c954 <__aeabi_ddiv+0x144>
  40c844:	ea4f 3303 	mov.w	r3, r3, lsl #12
  40c848:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  40c84c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  40c850:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  40c854:	ea4f 2202 	mov.w	r2, r2, lsl #8
  40c858:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  40c85c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  40c860:	ea4f 2600 	mov.w	r6, r0, lsl #8
  40c864:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  40c868:	429d      	cmp	r5, r3
  40c86a:	bf08      	it	eq
  40c86c:	4296      	cmpeq	r6, r2
  40c86e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  40c872:	f504 7440 	add.w	r4, r4, #768	; 0x300
  40c876:	d202      	bcs.n	40c87e <__aeabi_ddiv+0x6e>
  40c878:	085b      	lsrs	r3, r3, #1
  40c87a:	ea4f 0232 	mov.w	r2, r2, rrx
  40c87e:	1ab6      	subs	r6, r6, r2
  40c880:	eb65 0503 	sbc.w	r5, r5, r3
  40c884:	085b      	lsrs	r3, r3, #1
  40c886:	ea4f 0232 	mov.w	r2, r2, rrx
  40c88a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  40c88e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  40c892:	ebb6 0e02 	subs.w	lr, r6, r2
  40c896:	eb75 0e03 	sbcs.w	lr, r5, r3
  40c89a:	bf22      	ittt	cs
  40c89c:	1ab6      	subcs	r6, r6, r2
  40c89e:	4675      	movcs	r5, lr
  40c8a0:	ea40 000c 	orrcs.w	r0, r0, ip
  40c8a4:	085b      	lsrs	r3, r3, #1
  40c8a6:	ea4f 0232 	mov.w	r2, r2, rrx
  40c8aa:	ebb6 0e02 	subs.w	lr, r6, r2
  40c8ae:	eb75 0e03 	sbcs.w	lr, r5, r3
  40c8b2:	bf22      	ittt	cs
  40c8b4:	1ab6      	subcs	r6, r6, r2
  40c8b6:	4675      	movcs	r5, lr
  40c8b8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  40c8bc:	085b      	lsrs	r3, r3, #1
  40c8be:	ea4f 0232 	mov.w	r2, r2, rrx
  40c8c2:	ebb6 0e02 	subs.w	lr, r6, r2
  40c8c6:	eb75 0e03 	sbcs.w	lr, r5, r3
  40c8ca:	bf22      	ittt	cs
  40c8cc:	1ab6      	subcs	r6, r6, r2
  40c8ce:	4675      	movcs	r5, lr
  40c8d0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  40c8d4:	085b      	lsrs	r3, r3, #1
  40c8d6:	ea4f 0232 	mov.w	r2, r2, rrx
  40c8da:	ebb6 0e02 	subs.w	lr, r6, r2
  40c8de:	eb75 0e03 	sbcs.w	lr, r5, r3
  40c8e2:	bf22      	ittt	cs
  40c8e4:	1ab6      	subcs	r6, r6, r2
  40c8e6:	4675      	movcs	r5, lr
  40c8e8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  40c8ec:	ea55 0e06 	orrs.w	lr, r5, r6
  40c8f0:	d018      	beq.n	40c924 <__aeabi_ddiv+0x114>
  40c8f2:	ea4f 1505 	mov.w	r5, r5, lsl #4
  40c8f6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  40c8fa:	ea4f 1606 	mov.w	r6, r6, lsl #4
  40c8fe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  40c902:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  40c906:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  40c90a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  40c90e:	d1c0      	bne.n	40c892 <__aeabi_ddiv+0x82>
  40c910:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40c914:	d10b      	bne.n	40c92e <__aeabi_ddiv+0x11e>
  40c916:	ea41 0100 	orr.w	r1, r1, r0
  40c91a:	f04f 0000 	mov.w	r0, #0
  40c91e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  40c922:	e7b6      	b.n	40c892 <__aeabi_ddiv+0x82>
  40c924:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  40c928:	bf04      	itt	eq
  40c92a:	4301      	orreq	r1, r0
  40c92c:	2000      	moveq	r0, #0
  40c92e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  40c932:	bf88      	it	hi
  40c934:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  40c938:	f63f aeaf 	bhi.w	40c69a <__aeabi_dmul+0xde>
  40c93c:	ebb5 0c03 	subs.w	ip, r5, r3
  40c940:	bf04      	itt	eq
  40c942:	ebb6 0c02 	subseq.w	ip, r6, r2
  40c946:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  40c94a:	f150 0000 	adcs.w	r0, r0, #0
  40c94e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  40c952:	bd70      	pop	{r4, r5, r6, pc}
  40c954:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  40c958:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  40c95c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  40c960:	bfc2      	ittt	gt
  40c962:	ebd4 050c 	rsbsgt	r5, r4, ip
  40c966:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  40c96a:	bd70      	popgt	{r4, r5, r6, pc}
  40c96c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  40c970:	f04f 0e00 	mov.w	lr, #0
  40c974:	3c01      	subs	r4, #1
  40c976:	e690      	b.n	40c69a <__aeabi_dmul+0xde>
  40c978:	ea45 0e06 	orr.w	lr, r5, r6
  40c97c:	e68d      	b.n	40c69a <__aeabi_dmul+0xde>
  40c97e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  40c982:	ea94 0f0c 	teq	r4, ip
  40c986:	bf08      	it	eq
  40c988:	ea95 0f0c 	teqeq	r5, ip
  40c98c:	f43f af3b 	beq.w	40c806 <__aeabi_dmul+0x24a>
  40c990:	ea94 0f0c 	teq	r4, ip
  40c994:	d10a      	bne.n	40c9ac <__aeabi_ddiv+0x19c>
  40c996:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  40c99a:	f47f af34 	bne.w	40c806 <__aeabi_dmul+0x24a>
  40c99e:	ea95 0f0c 	teq	r5, ip
  40c9a2:	f47f af25 	bne.w	40c7f0 <__aeabi_dmul+0x234>
  40c9a6:	4610      	mov	r0, r2
  40c9a8:	4619      	mov	r1, r3
  40c9aa:	e72c      	b.n	40c806 <__aeabi_dmul+0x24a>
  40c9ac:	ea95 0f0c 	teq	r5, ip
  40c9b0:	d106      	bne.n	40c9c0 <__aeabi_ddiv+0x1b0>
  40c9b2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  40c9b6:	f43f aefd 	beq.w	40c7b4 <__aeabi_dmul+0x1f8>
  40c9ba:	4610      	mov	r0, r2
  40c9bc:	4619      	mov	r1, r3
  40c9be:	e722      	b.n	40c806 <__aeabi_dmul+0x24a>
  40c9c0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40c9c4:	bf18      	it	ne
  40c9c6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40c9ca:	f47f aec5 	bne.w	40c758 <__aeabi_dmul+0x19c>
  40c9ce:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  40c9d2:	f47f af0d 	bne.w	40c7f0 <__aeabi_dmul+0x234>
  40c9d6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  40c9da:	f47f aeeb 	bne.w	40c7b4 <__aeabi_dmul+0x1f8>
  40c9de:	e712      	b.n	40c806 <__aeabi_dmul+0x24a>

0040c9e0 <__gedf2>:
  40c9e0:	f04f 3cff 	mov.w	ip, #4294967295
  40c9e4:	e006      	b.n	40c9f4 <__cmpdf2+0x4>
  40c9e6:	bf00      	nop

0040c9e8 <__ledf2>:
  40c9e8:	f04f 0c01 	mov.w	ip, #1
  40c9ec:	e002      	b.n	40c9f4 <__cmpdf2+0x4>
  40c9ee:	bf00      	nop

0040c9f0 <__cmpdf2>:
  40c9f0:	f04f 0c01 	mov.w	ip, #1
  40c9f4:	f84d cd04 	str.w	ip, [sp, #-4]!
  40c9f8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  40c9fc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40ca00:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  40ca04:	bf18      	it	ne
  40ca06:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  40ca0a:	d01b      	beq.n	40ca44 <__cmpdf2+0x54>
  40ca0c:	b001      	add	sp, #4
  40ca0e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  40ca12:	bf0c      	ite	eq
  40ca14:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  40ca18:	ea91 0f03 	teqne	r1, r3
  40ca1c:	bf02      	ittt	eq
  40ca1e:	ea90 0f02 	teqeq	r0, r2
  40ca22:	2000      	moveq	r0, #0
  40ca24:	4770      	bxeq	lr
  40ca26:	f110 0f00 	cmn.w	r0, #0
  40ca2a:	ea91 0f03 	teq	r1, r3
  40ca2e:	bf58      	it	pl
  40ca30:	4299      	cmppl	r1, r3
  40ca32:	bf08      	it	eq
  40ca34:	4290      	cmpeq	r0, r2
  40ca36:	bf2c      	ite	cs
  40ca38:	17d8      	asrcs	r0, r3, #31
  40ca3a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  40ca3e:	f040 0001 	orr.w	r0, r0, #1
  40ca42:	4770      	bx	lr
  40ca44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  40ca48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40ca4c:	d102      	bne.n	40ca54 <__cmpdf2+0x64>
  40ca4e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  40ca52:	d107      	bne.n	40ca64 <__cmpdf2+0x74>
  40ca54:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  40ca58:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40ca5c:	d1d6      	bne.n	40ca0c <__cmpdf2+0x1c>
  40ca5e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  40ca62:	d0d3      	beq.n	40ca0c <__cmpdf2+0x1c>
  40ca64:	f85d 0b04 	ldr.w	r0, [sp], #4
  40ca68:	4770      	bx	lr
  40ca6a:	bf00      	nop

0040ca6c <__aeabi_cdrcmple>:
  40ca6c:	4684      	mov	ip, r0
  40ca6e:	4610      	mov	r0, r2
  40ca70:	4662      	mov	r2, ip
  40ca72:	468c      	mov	ip, r1
  40ca74:	4619      	mov	r1, r3
  40ca76:	4663      	mov	r3, ip
  40ca78:	e000      	b.n	40ca7c <__aeabi_cdcmpeq>
  40ca7a:	bf00      	nop

0040ca7c <__aeabi_cdcmpeq>:
  40ca7c:	b501      	push	{r0, lr}
  40ca7e:	f7ff ffb7 	bl	40c9f0 <__cmpdf2>
  40ca82:	2800      	cmp	r0, #0
  40ca84:	bf48      	it	mi
  40ca86:	f110 0f00 	cmnmi.w	r0, #0
  40ca8a:	bd01      	pop	{r0, pc}

0040ca8c <__aeabi_dcmpeq>:
  40ca8c:	f84d ed08 	str.w	lr, [sp, #-8]!
  40ca90:	f7ff fff4 	bl	40ca7c <__aeabi_cdcmpeq>
  40ca94:	bf0c      	ite	eq
  40ca96:	2001      	moveq	r0, #1
  40ca98:	2000      	movne	r0, #0
  40ca9a:	f85d fb08 	ldr.w	pc, [sp], #8
  40ca9e:	bf00      	nop

0040caa0 <__aeabi_dcmplt>:
  40caa0:	f84d ed08 	str.w	lr, [sp, #-8]!
  40caa4:	f7ff ffea 	bl	40ca7c <__aeabi_cdcmpeq>
  40caa8:	bf34      	ite	cc
  40caaa:	2001      	movcc	r0, #1
  40caac:	2000      	movcs	r0, #0
  40caae:	f85d fb08 	ldr.w	pc, [sp], #8
  40cab2:	bf00      	nop

0040cab4 <__aeabi_dcmple>:
  40cab4:	f84d ed08 	str.w	lr, [sp, #-8]!
  40cab8:	f7ff ffe0 	bl	40ca7c <__aeabi_cdcmpeq>
  40cabc:	bf94      	ite	ls
  40cabe:	2001      	movls	r0, #1
  40cac0:	2000      	movhi	r0, #0
  40cac2:	f85d fb08 	ldr.w	pc, [sp], #8
  40cac6:	bf00      	nop

0040cac8 <__aeabi_dcmpge>:
  40cac8:	f84d ed08 	str.w	lr, [sp, #-8]!
  40cacc:	f7ff ffce 	bl	40ca6c <__aeabi_cdrcmple>
  40cad0:	bf94      	ite	ls
  40cad2:	2001      	movls	r0, #1
  40cad4:	2000      	movhi	r0, #0
  40cad6:	f85d fb08 	ldr.w	pc, [sp], #8
  40cada:	bf00      	nop

0040cadc <__aeabi_dcmpgt>:
  40cadc:	f84d ed08 	str.w	lr, [sp, #-8]!
  40cae0:	f7ff ffc4 	bl	40ca6c <__aeabi_cdrcmple>
  40cae4:	bf34      	ite	cc
  40cae6:	2001      	movcc	r0, #1
  40cae8:	2000      	movcs	r0, #0
  40caea:	f85d fb08 	ldr.w	pc, [sp], #8
  40caee:	bf00      	nop

0040caf0 <__aeabi_dcmpun>:
  40caf0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  40caf4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40caf8:	d102      	bne.n	40cb00 <__aeabi_dcmpun+0x10>
  40cafa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  40cafe:	d10a      	bne.n	40cb16 <__aeabi_dcmpun+0x26>
  40cb00:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  40cb04:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40cb08:	d102      	bne.n	40cb10 <__aeabi_dcmpun+0x20>
  40cb0a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  40cb0e:	d102      	bne.n	40cb16 <__aeabi_dcmpun+0x26>
  40cb10:	f04f 0000 	mov.w	r0, #0
  40cb14:	4770      	bx	lr
  40cb16:	f04f 0001 	mov.w	r0, #1
  40cb1a:	4770      	bx	lr

0040cb1c <__aeabi_d2iz>:
  40cb1c:	ea4f 0241 	mov.w	r2, r1, lsl #1
  40cb20:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  40cb24:	d215      	bcs.n	40cb52 <__aeabi_d2iz+0x36>
  40cb26:	d511      	bpl.n	40cb4c <__aeabi_d2iz+0x30>
  40cb28:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  40cb2c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  40cb30:	d912      	bls.n	40cb58 <__aeabi_d2iz+0x3c>
  40cb32:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40cb36:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40cb3a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  40cb3e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40cb42:	fa23 f002 	lsr.w	r0, r3, r2
  40cb46:	bf18      	it	ne
  40cb48:	4240      	negne	r0, r0
  40cb4a:	4770      	bx	lr
  40cb4c:	f04f 0000 	mov.w	r0, #0
  40cb50:	4770      	bx	lr
  40cb52:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  40cb56:	d105      	bne.n	40cb64 <__aeabi_d2iz+0x48>
  40cb58:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  40cb5c:	bf08      	it	eq
  40cb5e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40cb62:	4770      	bx	lr
  40cb64:	f04f 0000 	mov.w	r0, #0
  40cb68:	4770      	bx	lr
  40cb6a:	bf00      	nop

0040cb6c <__aeabi_d2uiz>:
  40cb6c:	004a      	lsls	r2, r1, #1
  40cb6e:	d211      	bcs.n	40cb94 <__aeabi_d2uiz+0x28>
  40cb70:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  40cb74:	d211      	bcs.n	40cb9a <__aeabi_d2uiz+0x2e>
  40cb76:	d50d      	bpl.n	40cb94 <__aeabi_d2uiz+0x28>
  40cb78:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  40cb7c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  40cb80:	d40e      	bmi.n	40cba0 <__aeabi_d2uiz+0x34>
  40cb82:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40cb86:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40cb8a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  40cb8e:	fa23 f002 	lsr.w	r0, r3, r2
  40cb92:	4770      	bx	lr
  40cb94:	f04f 0000 	mov.w	r0, #0
  40cb98:	4770      	bx	lr
  40cb9a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  40cb9e:	d102      	bne.n	40cba6 <__aeabi_d2uiz+0x3a>
  40cba0:	f04f 30ff 	mov.w	r0, #4294967295
  40cba4:	4770      	bx	lr
  40cba6:	f04f 0000 	mov.w	r0, #0
  40cbaa:	4770      	bx	lr

0040cbac <__aeabi_uldivmod>:
  40cbac:	b953      	cbnz	r3, 40cbc4 <__aeabi_uldivmod+0x18>
  40cbae:	b94a      	cbnz	r2, 40cbc4 <__aeabi_uldivmod+0x18>
  40cbb0:	2900      	cmp	r1, #0
  40cbb2:	bf08      	it	eq
  40cbb4:	2800      	cmpeq	r0, #0
  40cbb6:	bf1c      	itt	ne
  40cbb8:	f04f 31ff 	movne.w	r1, #4294967295
  40cbbc:	f04f 30ff 	movne.w	r0, #4294967295
  40cbc0:	f000 b97a 	b.w	40ceb8 <__aeabi_idiv0>
  40cbc4:	f1ad 0c08 	sub.w	ip, sp, #8
  40cbc8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  40cbcc:	f000 f806 	bl	40cbdc <__udivmoddi4>
  40cbd0:	f8dd e004 	ldr.w	lr, [sp, #4]
  40cbd4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40cbd8:	b004      	add	sp, #16
  40cbda:	4770      	bx	lr

0040cbdc <__udivmoddi4>:
  40cbdc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40cbe0:	468c      	mov	ip, r1
  40cbe2:	460d      	mov	r5, r1
  40cbe4:	4604      	mov	r4, r0
  40cbe6:	9e08      	ldr	r6, [sp, #32]
  40cbe8:	2b00      	cmp	r3, #0
  40cbea:	d151      	bne.n	40cc90 <__udivmoddi4+0xb4>
  40cbec:	428a      	cmp	r2, r1
  40cbee:	4617      	mov	r7, r2
  40cbf0:	d96d      	bls.n	40ccce <__udivmoddi4+0xf2>
  40cbf2:	fab2 fe82 	clz	lr, r2
  40cbf6:	f1be 0f00 	cmp.w	lr, #0
  40cbfa:	d00b      	beq.n	40cc14 <__udivmoddi4+0x38>
  40cbfc:	f1ce 0c20 	rsb	ip, lr, #32
  40cc00:	fa01 f50e 	lsl.w	r5, r1, lr
  40cc04:	fa20 fc0c 	lsr.w	ip, r0, ip
  40cc08:	fa02 f70e 	lsl.w	r7, r2, lr
  40cc0c:	ea4c 0c05 	orr.w	ip, ip, r5
  40cc10:	fa00 f40e 	lsl.w	r4, r0, lr
  40cc14:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  40cc18:	0c25      	lsrs	r5, r4, #16
  40cc1a:	fbbc f8fa 	udiv	r8, ip, sl
  40cc1e:	fa1f f987 	uxth.w	r9, r7
  40cc22:	fb0a cc18 	mls	ip, sl, r8, ip
  40cc26:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  40cc2a:	fb08 f309 	mul.w	r3, r8, r9
  40cc2e:	42ab      	cmp	r3, r5
  40cc30:	d90a      	bls.n	40cc48 <__udivmoddi4+0x6c>
  40cc32:	19ed      	adds	r5, r5, r7
  40cc34:	f108 32ff 	add.w	r2, r8, #4294967295
  40cc38:	f080 8123 	bcs.w	40ce82 <__udivmoddi4+0x2a6>
  40cc3c:	42ab      	cmp	r3, r5
  40cc3e:	f240 8120 	bls.w	40ce82 <__udivmoddi4+0x2a6>
  40cc42:	f1a8 0802 	sub.w	r8, r8, #2
  40cc46:	443d      	add	r5, r7
  40cc48:	1aed      	subs	r5, r5, r3
  40cc4a:	b2a4      	uxth	r4, r4
  40cc4c:	fbb5 f0fa 	udiv	r0, r5, sl
  40cc50:	fb0a 5510 	mls	r5, sl, r0, r5
  40cc54:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  40cc58:	fb00 f909 	mul.w	r9, r0, r9
  40cc5c:	45a1      	cmp	r9, r4
  40cc5e:	d909      	bls.n	40cc74 <__udivmoddi4+0x98>
  40cc60:	19e4      	adds	r4, r4, r7
  40cc62:	f100 33ff 	add.w	r3, r0, #4294967295
  40cc66:	f080 810a 	bcs.w	40ce7e <__udivmoddi4+0x2a2>
  40cc6a:	45a1      	cmp	r9, r4
  40cc6c:	f240 8107 	bls.w	40ce7e <__udivmoddi4+0x2a2>
  40cc70:	3802      	subs	r0, #2
  40cc72:	443c      	add	r4, r7
  40cc74:	eba4 0409 	sub.w	r4, r4, r9
  40cc78:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  40cc7c:	2100      	movs	r1, #0
  40cc7e:	2e00      	cmp	r6, #0
  40cc80:	d061      	beq.n	40cd46 <__udivmoddi4+0x16a>
  40cc82:	fa24 f40e 	lsr.w	r4, r4, lr
  40cc86:	2300      	movs	r3, #0
  40cc88:	6034      	str	r4, [r6, #0]
  40cc8a:	6073      	str	r3, [r6, #4]
  40cc8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40cc90:	428b      	cmp	r3, r1
  40cc92:	d907      	bls.n	40cca4 <__udivmoddi4+0xc8>
  40cc94:	2e00      	cmp	r6, #0
  40cc96:	d054      	beq.n	40cd42 <__udivmoddi4+0x166>
  40cc98:	2100      	movs	r1, #0
  40cc9a:	e886 0021 	stmia.w	r6, {r0, r5}
  40cc9e:	4608      	mov	r0, r1
  40cca0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40cca4:	fab3 f183 	clz	r1, r3
  40cca8:	2900      	cmp	r1, #0
  40ccaa:	f040 808e 	bne.w	40cdca <__udivmoddi4+0x1ee>
  40ccae:	42ab      	cmp	r3, r5
  40ccb0:	d302      	bcc.n	40ccb8 <__udivmoddi4+0xdc>
  40ccb2:	4282      	cmp	r2, r0
  40ccb4:	f200 80fa 	bhi.w	40ceac <__udivmoddi4+0x2d0>
  40ccb8:	1a84      	subs	r4, r0, r2
  40ccba:	eb65 0503 	sbc.w	r5, r5, r3
  40ccbe:	2001      	movs	r0, #1
  40ccc0:	46ac      	mov	ip, r5
  40ccc2:	2e00      	cmp	r6, #0
  40ccc4:	d03f      	beq.n	40cd46 <__udivmoddi4+0x16a>
  40ccc6:	e886 1010 	stmia.w	r6, {r4, ip}
  40ccca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40ccce:	b912      	cbnz	r2, 40ccd6 <__udivmoddi4+0xfa>
  40ccd0:	2701      	movs	r7, #1
  40ccd2:	fbb7 f7f2 	udiv	r7, r7, r2
  40ccd6:	fab7 fe87 	clz	lr, r7
  40ccda:	f1be 0f00 	cmp.w	lr, #0
  40ccde:	d134      	bne.n	40cd4a <__udivmoddi4+0x16e>
  40cce0:	1beb      	subs	r3, r5, r7
  40cce2:	0c3a      	lsrs	r2, r7, #16
  40cce4:	fa1f fc87 	uxth.w	ip, r7
  40cce8:	2101      	movs	r1, #1
  40ccea:	fbb3 f8f2 	udiv	r8, r3, r2
  40ccee:	0c25      	lsrs	r5, r4, #16
  40ccf0:	fb02 3318 	mls	r3, r2, r8, r3
  40ccf4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  40ccf8:	fb0c f308 	mul.w	r3, ip, r8
  40ccfc:	42ab      	cmp	r3, r5
  40ccfe:	d907      	bls.n	40cd10 <__udivmoddi4+0x134>
  40cd00:	19ed      	adds	r5, r5, r7
  40cd02:	f108 30ff 	add.w	r0, r8, #4294967295
  40cd06:	d202      	bcs.n	40cd0e <__udivmoddi4+0x132>
  40cd08:	42ab      	cmp	r3, r5
  40cd0a:	f200 80d1 	bhi.w	40ceb0 <__udivmoddi4+0x2d4>
  40cd0e:	4680      	mov	r8, r0
  40cd10:	1aed      	subs	r5, r5, r3
  40cd12:	b2a3      	uxth	r3, r4
  40cd14:	fbb5 f0f2 	udiv	r0, r5, r2
  40cd18:	fb02 5510 	mls	r5, r2, r0, r5
  40cd1c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  40cd20:	fb0c fc00 	mul.w	ip, ip, r0
  40cd24:	45a4      	cmp	ip, r4
  40cd26:	d907      	bls.n	40cd38 <__udivmoddi4+0x15c>
  40cd28:	19e4      	adds	r4, r4, r7
  40cd2a:	f100 33ff 	add.w	r3, r0, #4294967295
  40cd2e:	d202      	bcs.n	40cd36 <__udivmoddi4+0x15a>
  40cd30:	45a4      	cmp	ip, r4
  40cd32:	f200 80b8 	bhi.w	40cea6 <__udivmoddi4+0x2ca>
  40cd36:	4618      	mov	r0, r3
  40cd38:	eba4 040c 	sub.w	r4, r4, ip
  40cd3c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  40cd40:	e79d      	b.n	40cc7e <__udivmoddi4+0xa2>
  40cd42:	4631      	mov	r1, r6
  40cd44:	4630      	mov	r0, r6
  40cd46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40cd4a:	f1ce 0420 	rsb	r4, lr, #32
  40cd4e:	fa05 f30e 	lsl.w	r3, r5, lr
  40cd52:	fa07 f70e 	lsl.w	r7, r7, lr
  40cd56:	fa20 f804 	lsr.w	r8, r0, r4
  40cd5a:	0c3a      	lsrs	r2, r7, #16
  40cd5c:	fa25 f404 	lsr.w	r4, r5, r4
  40cd60:	ea48 0803 	orr.w	r8, r8, r3
  40cd64:	fbb4 f1f2 	udiv	r1, r4, r2
  40cd68:	ea4f 4518 	mov.w	r5, r8, lsr #16
  40cd6c:	fb02 4411 	mls	r4, r2, r1, r4
  40cd70:	fa1f fc87 	uxth.w	ip, r7
  40cd74:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  40cd78:	fb01 f30c 	mul.w	r3, r1, ip
  40cd7c:	42ab      	cmp	r3, r5
  40cd7e:	fa00 f40e 	lsl.w	r4, r0, lr
  40cd82:	d909      	bls.n	40cd98 <__udivmoddi4+0x1bc>
  40cd84:	19ed      	adds	r5, r5, r7
  40cd86:	f101 30ff 	add.w	r0, r1, #4294967295
  40cd8a:	f080 808a 	bcs.w	40cea2 <__udivmoddi4+0x2c6>
  40cd8e:	42ab      	cmp	r3, r5
  40cd90:	f240 8087 	bls.w	40cea2 <__udivmoddi4+0x2c6>
  40cd94:	3902      	subs	r1, #2
  40cd96:	443d      	add	r5, r7
  40cd98:	1aeb      	subs	r3, r5, r3
  40cd9a:	fa1f f588 	uxth.w	r5, r8
  40cd9e:	fbb3 f0f2 	udiv	r0, r3, r2
  40cda2:	fb02 3310 	mls	r3, r2, r0, r3
  40cda6:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  40cdaa:	fb00 f30c 	mul.w	r3, r0, ip
  40cdae:	42ab      	cmp	r3, r5
  40cdb0:	d907      	bls.n	40cdc2 <__udivmoddi4+0x1e6>
  40cdb2:	19ed      	adds	r5, r5, r7
  40cdb4:	f100 38ff 	add.w	r8, r0, #4294967295
  40cdb8:	d26f      	bcs.n	40ce9a <__udivmoddi4+0x2be>
  40cdba:	42ab      	cmp	r3, r5
  40cdbc:	d96d      	bls.n	40ce9a <__udivmoddi4+0x2be>
  40cdbe:	3802      	subs	r0, #2
  40cdc0:	443d      	add	r5, r7
  40cdc2:	1aeb      	subs	r3, r5, r3
  40cdc4:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  40cdc8:	e78f      	b.n	40ccea <__udivmoddi4+0x10e>
  40cdca:	f1c1 0720 	rsb	r7, r1, #32
  40cdce:	fa22 f807 	lsr.w	r8, r2, r7
  40cdd2:	408b      	lsls	r3, r1
  40cdd4:	fa05 f401 	lsl.w	r4, r5, r1
  40cdd8:	ea48 0303 	orr.w	r3, r8, r3
  40cddc:	fa20 fe07 	lsr.w	lr, r0, r7
  40cde0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  40cde4:	40fd      	lsrs	r5, r7
  40cde6:	ea4e 0e04 	orr.w	lr, lr, r4
  40cdea:	fbb5 f9fc 	udiv	r9, r5, ip
  40cdee:	ea4f 441e 	mov.w	r4, lr, lsr #16
  40cdf2:	fb0c 5519 	mls	r5, ip, r9, r5
  40cdf6:	fa1f f883 	uxth.w	r8, r3
  40cdfa:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  40cdfe:	fb09 f408 	mul.w	r4, r9, r8
  40ce02:	42ac      	cmp	r4, r5
  40ce04:	fa02 f201 	lsl.w	r2, r2, r1
  40ce08:	fa00 fa01 	lsl.w	sl, r0, r1
  40ce0c:	d908      	bls.n	40ce20 <__udivmoddi4+0x244>
  40ce0e:	18ed      	adds	r5, r5, r3
  40ce10:	f109 30ff 	add.w	r0, r9, #4294967295
  40ce14:	d243      	bcs.n	40ce9e <__udivmoddi4+0x2c2>
  40ce16:	42ac      	cmp	r4, r5
  40ce18:	d941      	bls.n	40ce9e <__udivmoddi4+0x2c2>
  40ce1a:	f1a9 0902 	sub.w	r9, r9, #2
  40ce1e:	441d      	add	r5, r3
  40ce20:	1b2d      	subs	r5, r5, r4
  40ce22:	fa1f fe8e 	uxth.w	lr, lr
  40ce26:	fbb5 f0fc 	udiv	r0, r5, ip
  40ce2a:	fb0c 5510 	mls	r5, ip, r0, r5
  40ce2e:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  40ce32:	fb00 f808 	mul.w	r8, r0, r8
  40ce36:	45a0      	cmp	r8, r4
  40ce38:	d907      	bls.n	40ce4a <__udivmoddi4+0x26e>
  40ce3a:	18e4      	adds	r4, r4, r3
  40ce3c:	f100 35ff 	add.w	r5, r0, #4294967295
  40ce40:	d229      	bcs.n	40ce96 <__udivmoddi4+0x2ba>
  40ce42:	45a0      	cmp	r8, r4
  40ce44:	d927      	bls.n	40ce96 <__udivmoddi4+0x2ba>
  40ce46:	3802      	subs	r0, #2
  40ce48:	441c      	add	r4, r3
  40ce4a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  40ce4e:	eba4 0408 	sub.w	r4, r4, r8
  40ce52:	fba0 8902 	umull	r8, r9, r0, r2
  40ce56:	454c      	cmp	r4, r9
  40ce58:	46c6      	mov	lr, r8
  40ce5a:	464d      	mov	r5, r9
  40ce5c:	d315      	bcc.n	40ce8a <__udivmoddi4+0x2ae>
  40ce5e:	d012      	beq.n	40ce86 <__udivmoddi4+0x2aa>
  40ce60:	b156      	cbz	r6, 40ce78 <__udivmoddi4+0x29c>
  40ce62:	ebba 030e 	subs.w	r3, sl, lr
  40ce66:	eb64 0405 	sbc.w	r4, r4, r5
  40ce6a:	fa04 f707 	lsl.w	r7, r4, r7
  40ce6e:	40cb      	lsrs	r3, r1
  40ce70:	431f      	orrs	r7, r3
  40ce72:	40cc      	lsrs	r4, r1
  40ce74:	6037      	str	r7, [r6, #0]
  40ce76:	6074      	str	r4, [r6, #4]
  40ce78:	2100      	movs	r1, #0
  40ce7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40ce7e:	4618      	mov	r0, r3
  40ce80:	e6f8      	b.n	40cc74 <__udivmoddi4+0x98>
  40ce82:	4690      	mov	r8, r2
  40ce84:	e6e0      	b.n	40cc48 <__udivmoddi4+0x6c>
  40ce86:	45c2      	cmp	sl, r8
  40ce88:	d2ea      	bcs.n	40ce60 <__udivmoddi4+0x284>
  40ce8a:	ebb8 0e02 	subs.w	lr, r8, r2
  40ce8e:	eb69 0503 	sbc.w	r5, r9, r3
  40ce92:	3801      	subs	r0, #1
  40ce94:	e7e4      	b.n	40ce60 <__udivmoddi4+0x284>
  40ce96:	4628      	mov	r0, r5
  40ce98:	e7d7      	b.n	40ce4a <__udivmoddi4+0x26e>
  40ce9a:	4640      	mov	r0, r8
  40ce9c:	e791      	b.n	40cdc2 <__udivmoddi4+0x1e6>
  40ce9e:	4681      	mov	r9, r0
  40cea0:	e7be      	b.n	40ce20 <__udivmoddi4+0x244>
  40cea2:	4601      	mov	r1, r0
  40cea4:	e778      	b.n	40cd98 <__udivmoddi4+0x1bc>
  40cea6:	3802      	subs	r0, #2
  40cea8:	443c      	add	r4, r7
  40ceaa:	e745      	b.n	40cd38 <__udivmoddi4+0x15c>
  40ceac:	4608      	mov	r0, r1
  40ceae:	e708      	b.n	40ccc2 <__udivmoddi4+0xe6>
  40ceb0:	f1a8 0802 	sub.w	r8, r8, #2
  40ceb4:	443d      	add	r5, r7
  40ceb6:	e72b      	b.n	40cd10 <__udivmoddi4+0x134>

0040ceb8 <__aeabi_idiv0>:
  40ceb8:	4770      	bx	lr
  40ceba:	bf00      	nop
  40cebc:	65480a0a 	.word	0x65480a0a
  40cec0:	206f6c6c 	.word	0x206f6c6c
  40cec4:	72696843 	.word	0x72696843
  40cec8:	2d202170 	.word	0x2d202170
  40cecc:	69684320 	.word	0x69684320
  40ced0:	53207072 	.word	0x53207072
  40ced4:	63696e6f 	.word	0x63696e6f
  40ced8:	2062694c 	.word	0x2062694c
  40cedc:	6d617845 	.word	0x6d617845
  40cee0:	20656c70 	.word	0x20656c70
  40cee4:	6c707041 	.word	0x6c707041
  40cee8:	74616369 	.word	0x74616369
  40ceec:	0a6e6f69 	.word	0x0a6e6f69
  40cef0:	00000000 	.word	0x00000000
  40cef4:	313a3330 	.word	0x313a3330
  40cef8:	35353a30 	.word	0x35353a30
  40cefc:	00000000 	.word	0x00000000
  40cf00:	2079614d 	.word	0x2079614d
  40cf04:	32203931 	.word	0x32203931
  40cf08:	00333230 	.word	0x00333230
  40cf0c:	20202020 	.word	0x20202020
  40cf10:	706d6f43 	.word	0x706d6f43
  40cf14:	20656c69 	.word	0x20656c69
  40cf18:	656d6974 	.word	0x656d6974
  40cf1c:	2520203a 	.word	0x2520203a
  40cf20:	73252073 	.word	0x73252073
  40cf24:	0000000a 	.word	0x0000000a
  40cf28:	20202020 	.word	0x20202020
  40cf2c:	73726556 	.word	0x73726556
  40cf30:	3a6e6f69 	.word	0x3a6e6f69
  40cf34:	2e752520 	.word	0x2e752520
  40cf38:	252e7525 	.word	0x252e7525
  40cf3c:	00000075 	.word	0x00000075
  40cf40:	20202020 	.word	0x20202020
  40cf44:	696e6f53 	.word	0x696e6f53
  40cf48:	62694c63 	.word	0x62694c63
  40cf4c:	72657620 	.word	0x72657620
  40cf50:	6e6f6973 	.word	0x6e6f6973
  40cf54:	7525203a 	.word	0x7525203a
  40cf58:	2e75252e 	.word	0x2e75252e
  40cf5c:	000a7525 	.word	0x000a7525
  40cf60:	0000000a 	.word	0x0000000a
  40cf64:	74696e49 	.word	0x74696e49
  40cf68:	696c6169 	.word	0x696c6169
  40cf6c:	676e697a 	.word	0x676e697a
  40cf70:	6e657320 	.word	0x6e657320
  40cf74:	28726f73 	.word	0x28726f73
  40cf78:	2e2e2973 	.word	0x2e2e2973
  40cf7c:	0000202e 	.word	0x0000202e
  40cf80:	72617473 	.word	0x72617473
  40cf84:	676e6974 	.word	0x676e6974
  40cf88:	6f726720 	.word	0x6f726720
  40cf8c:	2e2e7075 	.word	0x2e2e7075
  40cf90:	0000202e 	.word	0x0000202e
  40cf94:	000a4b4f 	.word	0x000a4b4f
  40cf98:	4c494146 	.word	0x4c494146
  40cf9c:	203a4445 	.word	0x203a4445
  40cfa0:	000a6425 	.word	0x000a6425
  40cfa4:	736e6553 	.word	0x736e6553
  40cfa8:	5409726f 	.word	0x5409726f
  40cfac:	20657079 	.word	0x20657079
  40cfb0:	20202009 	.word	0x20202009
  40cfb4:	71657246 	.word	0x71657246
  40cfb8:	52200909 	.word	0x52200909
  40cfbc:	43204354 	.word	0x43204354
  40cfc0:	09206c61 	.word	0x09206c61
  40cfc4:	6d726946 	.word	0x6d726946
  40cfc8:	65726177 	.word	0x65726177
  40cfcc:	53200920 	.word	0x53200920
  40cfd0:	656c6163 	.word	0x656c6163
  40cfd4:	63614620 	.word	0x63614620
  40cfd8:	000a6f74 	.word	0x000a6f74
  40cfdc:	43096425 	.word	0x43096425
  40cfe0:	09642548 	.word	0x09642548
  40cfe4:	20752520 	.word	0x20752520
  40cfe8:	25097a48 	.word	0x25097a48
  40cfec:	75254075 	.word	0x75254075
  40cff0:	2509736d 	.word	0x2509736d
  40cff4:	75250973 	.word	0x75250973
  40cff8:	0000000a 	.word	0x0000000a
  40cffc:	666e6f43 	.word	0x666e6f43
  40d000:	72756769 	.word	0x72756769
  40d004:	20676e69 	.word	0x20676e69
  40d008:	736e6573 	.word	0x736e6573
  40d00c:	7328726f 	.word	0x7328726f
  40d010:	2e2e2e29 	.word	0x2e2e2e29
  40d014:	0000000a 	.word	0x0000000a
  40d018:	69766544 	.word	0x69766544
  40d01c:	25206563 	.word	0x25206563
  40d020:	45203a64 	.word	0x45203a64
  40d024:	726f7272 	.word	0x726f7272
  40d028:	72756420 	.word	0x72756420
  40d02c:	20676e69 	.word	0x20676e69
  40d030:	735f6863 	.word	0x735f6863
  40d034:	635f7465 	.word	0x635f7465
  40d038:	69666e6f 	.word	0x69666e6f
  40d03c:	0a292867 	.word	0x0a292867
  40d040:	00000000 	.word	0x00000000
  40d044:	74696e49 	.word	0x74696e49
  40d048:	696c6169 	.word	0x696c6169
  40d04c:	676e697a 	.word	0x676e697a
  40d050:	6d617320 	.word	0x6d617320
  40d054:	20656c70 	.word	0x20656c70
  40d058:	656d6974 	.word	0x656d6974
  40d05c:	6f662072 	.word	0x6f662072
  40d060:	64252072 	.word	0x64252072
  40d064:	6920736d 	.word	0x6920736d
  40d068:	7265746e 	.word	0x7265746e
  40d06c:	2e6c6176 	.word	0x2e6c6176
  40d070:	00202e2e 	.word	0x00202e2e
  40d074:	72617453 	.word	0x72617453
  40d078:	676e6974 	.word	0x676e6974
  40d07c:	61656d20 	.word	0x61656d20
  40d080:	65727573 	.word	0x65727573
  40d084:	746e656d 	.word	0x746e656d
  40d088:	00000a73 	.word	0x00000a73
  40d08c:	7074754f 	.word	0x7074754f
  40d090:	69747475 	.word	0x69747475
  40d094:	4d20676e 	.word	0x4d20676e
  40d098:	75736165 	.word	0x75736165
  40d09c:	656d6572 	.word	0x656d6572
  40d0a0:	5220746e 	.word	0x5220746e
  40d0a4:	6c757365 	.word	0x6c757365
  40d0a8:	000a7374 	.word	0x000a7374
  40d0ac:	74726f50 	.word	0x74726f50
  40d0b0:	3a642520 	.word	0x3a642520
  40d0b4:	20202020 	.word	0x20202020
  40d0b8:	20202020 	.word	0x20202020
  40d0bc:	6f6e2020 	.word	0x6f6e2020
  40d0c0:	72617420 	.word	0x72617420
  40d0c4:	20746567 	.word	0x20746567
  40d0c8:	6e756f66 	.word	0x6e756f66
  40d0cc:	20202064 	.word	0x20202064
  40d0d0:	20202020 	.word	0x20202020
  40d0d4:	00000020 	.word	0x00000020
  40d0d8:	74726f50 	.word	0x74726f50
  40d0dc:	3a642520 	.word	0x3a642520
  40d0e0:	61522020 	.word	0x61522020
  40d0e4:	3a65676e 	.word	0x3a65676e
  40d0e8:	2e302520 	.word	0x2e302520
  40d0ec:	6d206631 	.word	0x6d206631
  40d0f0:	4120206d 	.word	0x4120206d
  40d0f4:	203a706d 	.word	0x203a706d
  40d0f8:	20207525 	.word	0x20207525
  40d0fc:	706d6153 	.word	0x706d6153
  40d100:	3a73656c 	.word	0x3a73656c
  40d104:	20752520 	.word	0x20752520
  40d108:	5f704f20 	.word	0x5f704f20
  40d10c:	71657266 	.word	0x71657266
  40d110:	6c25203a 	.word	0x6c25203a
  40d114:	42202075 	.word	0x42202075
  40d118:	77646e61 	.word	0x77646e61
  40d11c:	68746469 	.word	0x68746469
  40d120:	7525203a 	.word	0x7525203a
  40d124:	00000000 	.word	0x00000000
  40d128:	20202020 	.word	0x20202020
  40d12c:	20642520 	.word	0x20642520
  40d130:	20512f49 	.word	0x20512f49
  40d134:	706d6173 	.word	0x706d6173
  40d138:	2073656c 	.word	0x2073656c
  40d13c:	69706f63 	.word	0x69706f63
  40d140:	00006465 	.word	0x00006465
  40d144:	252c6425 	.word	0x252c6425
  40d148:	00000a64 	.word	0x00000a64
  40d14c:	20202020 	.word	0x20202020
  40d150:	72724520 	.word	0x72724520
  40d154:	7220726f 	.word	0x7220726f
  40d158:	69646165 	.word	0x69646165
  40d15c:	2520676e 	.word	0x2520676e
  40d160:	2f492064 	.word	0x2f492064
  40d164:	61732051 	.word	0x61732051
  40d168:	656c706d 	.word	0x656c706d
  40d16c:	00000073 	.word	0x00000073
  40d170:	454c4449 	.word	0x454c4449
  40d174:	00000000 	.word	0x00000000
  40d178:	45455246 	.word	0x45455246
  40d17c:	004e5552 	.word	0x004e5552
  40d180:	47495254 	.word	0x47495254
  40d184:	45524547 	.word	0x45524547
  40d188:	58545f44 	.word	0x58545f44
  40d18c:	0058525f 	.word	0x0058525f
  40d190:	47495254 	.word	0x47495254
  40d194:	45524547 	.word	0x45524547
  40d198:	58525f44 	.word	0x58525f44
  40d19c:	4c4e4f5f 	.word	0x4c4e4f5f
  40d1a0:	00000059 	.word	0x00000059
  40d1a4:	4e4b4e55 	.word	0x4e4b4e55
  40d1a8:	004e574f 	.word	0x004e574f
  40d1ac:	736e6553 	.word	0x736e6553
  40d1b0:	2520726f 	.word	0x2520726f
  40d1b4:	6d093a64 	.word	0x6d093a64
  40d1b8:	725f7861 	.word	0x725f7861
  40d1bc:	65676e61 	.word	0x65676e61
  40d1c0:	6d64253d 	.word	0x6d64253d
  40d1c4:	6d09206d 	.word	0x6d09206d
  40d1c8:	3d65646f 	.word	0x3d65646f
  40d1cc:	20207325 	.word	0x20207325
  40d1d0:	00000000 	.word	0x00000000
  40d1d4:	74617473 	.word	0x74617473
  40d1d8:	725f6369 	.word	0x725f6369
  40d1dc:	65676e61 	.word	0x65676e61
  40d1e0:	2064253d 	.word	0x2064253d
  40d1e4:	706d6173 	.word	0x706d6173
  40d1e8:	0073656c 	.word	0x0073656c
  40d1ec:	4420200a 	.word	0x4420200a
  40d1f0:	63657465 	.word	0x63657465
  40d1f4:	6e6f6974 	.word	0x6e6f6974
  40d1f8:	72687420 	.word	0x72687420
  40d1fc:	6f687365 	.word	0x6f687365
  40d200:	3a73646c 	.word	0x3a73646c
  40d204:	0000000a 	.word	0x0000000a
  40d208:	20202020 	.word	0x20202020
  40d20c:	09642520 	.word	0x09642520
  40d210:	72617473 	.word	0x72617473
  40d214:	25203a74 	.word	0x25203a74
  40d218:	6c096432 	.word	0x6c096432
  40d21c:	6c657665 	.word	0x6c657665
  40d220:	6425203a 	.word	0x6425203a
  40d224:	0000000a 	.word	0x0000000a
  40d228:	0000000a 	.word	0x0000000a
  40d22c:	76654420 	.word	0x76654420
  40d230:	20656369 	.word	0x20656369
  40d234:	203a6425 	.word	0x203a6425
  40d238:	6f727245 	.word	0x6f727245
  40d23c:	75642072 	.word	0x75642072
  40d240:	676e6972 	.word	0x676e6972
  40d244:	5f686320 	.word	0x5f686320
  40d248:	5f746567 	.word	0x5f746567
  40d24c:	666e6f63 	.word	0x666e6f63
  40d250:	29286769 	.word	0x29286769
  40d254:	0000000a 	.word	0x0000000a
  40d258:	72696843 	.word	0x72696843
  40d25c:	65732070 	.word	0x65732070
  40d260:	726f736e 	.word	0x726f736e
  40d264:	64644920 	.word	0x64644920
  40d268:	6c25203a 	.word	0x6c25203a
  40d26c:	41752064 	.word	0x41752064
  40d270:	00000a0a 	.word	0x00000a0a
  40d274:	72696843 	.word	0x72696843
  40d278:	65732070 	.word	0x65732070
  40d27c:	726f736e 	.word	0x726f736e
  40d280:	00203020 	.word	0x00203020
  40d284:	6e756f66 	.word	0x6e756f66
  40d288:	00000a64 	.word	0x00000a64
  40d28c:	20746f6e 	.word	0x20746f6e
  40d290:	6e756f66 	.word	0x6e756f66
  40d294:	00000a64 	.word	0x00000a64
  40d298:	72696843 	.word	0x72696843
  40d29c:	65732070 	.word	0x65732070
  40d2a0:	726f736e 	.word	0x726f736e
  40d2a4:	00203120 	.word	0x00203120
  40d2a8:	72696843 	.word	0x72696843
  40d2ac:	65732070 	.word	0x65732070
  40d2b0:	726f736e 	.word	0x726f736e
  40d2b4:	00203220 	.word	0x00203220
  40d2b8:	72696843 	.word	0x72696843
  40d2bc:	65732070 	.word	0x65732070
  40d2c0:	726f736e 	.word	0x726f736e
  40d2c4:	00203320 	.word	0x00203320

0040d2c8 <adc_interrupt_mask>:
  40d2c8:	00000001 00000002 00000004 00000008     ................
  40d2d8:	00000010 00000020 00000040 00000080     .... ...@.......
  40d2e8:	00800000 01000000 02000000 04000000     ................
  40d2f8:	08000000 10000000 00000000 00000000     ................
	...
  40d328:	6d727067 70675f74 2d746d72 5f313032     gprmt_gprmt-201_
  40d338:	61303176 00000000 65373432 37313662     v10a....247eb617
  40d348:	65303562 64363938 61313665 38343231     b50e896de61a1248
  40d358:	31373538 39353535 39623533 37363831     8571555935b91867
  40d368:	00000000                                ....

0040d36c <ram_ch201_gprmt_init>:
  40d36c:	07d01388 01900320 00af00fa 00000006     .... ...........
  40d37c:	0000fa00 0c000064 00010000              ....d.......

0040d388 <ch201_gprmt_fw>:
  40d388:	1209120a 12071208 12051206 80311204     ..............1.
  40d398:	4d81000c 4291000a 00080216 02084256     ...M...B....VB..
  40d3a8:	43814305 43090002 930c430a 4c81246a     .C.C...C.C..j$.L
  40d3b8:	43080000 480f4347 000a411e 205c934e     ...CGC.H.A..N.\ 
  40d3c8:	201d960a 93575357 93672412 9077240d     ... WSW..$g..$w.
  40d3d8:	24070003 24029267 3c0c4306 0215425e     ...$g..$.C.<^B..
  40d3e8:	425e3c08 3c05020d 020c425e 425e3c02     .<^B...<^B...<^B
  40d3f8:	5e060209 5e0e474e 02164e91 403e0008     ...^NG.^.N....>@
  40d408:	4f040228 54045314 5f0f5e04 4f0b5e0f     (..O.S.T.^._.^.O
  40d418:	442d4f2c feec12b0 0009903a 4a0f2c0c     ,O-D....:....,.J
  40d428:	503f5f0f 4f2e0930 00004c8f 930c8e0c     ._?P0..O.L......
  40d438:	e33c3402 9381531c 201e0002 0211425f     .4<..S..... _B..
  40d448:	9a0f5f0f 93052c19 9c812006 2c140008     ._...,... .....,
  40d458:	00064a81 4b2c4315 12b0442d 990cfddc     .J...C,K-D......
  40d468:	4c092802 4a0f3c09 0006811f 4f81831f     .(.L.<.J.......O
  40d478:	43050004 00024391 531a5328 00008391     ...C.C..(S.S....
  40d488:	9305239a 93812006 20070002 022443b2     .#... ..... .C$.
  40d498:	811a3c40 4a810006 49820004 490c0226     @<.....J...I&..I
  40d4a8:	1009c312 00044116 0006411a 9036560a     .....A...A...V6.
  40d4b8:	381afffd 0228403f 57074a07 57075317     ...8?@(..J.W.S.W
  40d4c8:	4a085f07 58085808 42265f08 00045116     ._.J.X.X._&B.Q..
  40d4d8:	482c4c05 12b0472d 990cfddc 82272805     .L,H-G.......('.
  40d4e8:	831a8228 23f48316 59098c09 423e8c05     (......#...Y..>B
  40d4f8:	5f4f434f 2c029905 535f8509 831e5909     OCO_...,.._S.Y..
  40d508:	4a0c23f8 fedc12b0 110f4f4f 4c82df0c     .#.J....OO.....L
  40d518:	50310224 4030000c 120fff6c 120d120e     $.1P..0@l.......
  40d528:	120b120c 403a120a 4a820177 c3d201a6     ......:@w..J....
  40d538:	93c2096a 203a0214 421c431b 421d023a     j.....: .C.B:..B
  40d548:	12b00238 921cfeec 2819096e 023a421f     8.......n..(.B:.
  40d558:	821f110f 931f0238 433f3802 431f3c01     ....8....8?C.<.C
  40d568:	097093c2 425e2407 118e0970 24029e0f     ..p..$^Bp......$
  40d578:	3c02430b 096c5f82 09704fc2 50b23c0f     .C.<._l..Op..<.P
  40d588:	096c0014 012d90b2 2806096c 00c880b2     ..l...-.l..(....
  40d598:	c312096c 096e1012 097043c2 203c930b     l.....n..Cp...< 
  40d5a8:	021443d2 3f1e40b2 3c360950 021493d2     .C...@.?P.6<....
  40d5b8:	90f22031 09560003 93c2240a 20040956     1 ....V..$..V.. 
  40d5c8:	185840b2 3c150942 095683d2 421c3c12     .@X.B..<..V..<.B
  40d5d8:	421d023a 12b00238 9c82feec 28050968     :..B8.......h..(
  40d5e8:	09684c82 09645392 43e23c04 83920956     .Lh..Sd..<.CV...
  40d5f8:	93e20964 240b0956 095693c2 43e2200d     d...V..$..V.. .C
  40d608:	d3e20214 40b2096a 01d01080 43d23c05     ....j..@.....<.C
  40d618:	3c020201 01f04382 000390f2 2c070956     ...<.C......V..,
  40d628:	0207425c 425d5c0c 12b00956 93e2f800     \B...\]BV.......
  40d638:	280d0214 01e0d3d2 01e0c3d2 067740b2     ...(.........@w.
  40d648:	423c01a6 ff8a12b0 01a64a82 435c3c05     ..<B.....J...<\C
  40d658:	fbfc12b0 0192c2a2 0192d2a2 095442d2     .............BT.
  40d668:	c0b101e0 000c00f0 413b413a 413d413c     ........:A;A<A=A
  40d678:	413f413e 120a1300 5a8040b2 42e20120     >A?A.....@.Z ..B
  40d688:	43d201e0 40f201e2 02010040 003c40f2     ...C...@@....@<.
  40d698:	40f20207 02040006 000940f2 40f20200     ...@.....@.....@
  40d6a8:	0208001a 000d40f2 40f20209 020c0011     .....@.....@....
  40d6b8:	001740f2 40f2020d 02150028 001e40f2     .@.....@(....@..
  40d6c8:	403f0210 403d0216 403e0006 532f0958     ..?@..=@..>@X./S
  40d6d8:	fffe4ebf 23fb831d 020543d2 021143c2     .N.....#.C...C..
  40d6e8:	008040b2 40f20202 01c20003 020040b2     .@.....@.....@..
  40d6f8:	40b201a6 01a60600 022840b2 40b201b0     ...@.....@(....@
  40d708:	01b20012 017740b2 40b201a6 01900080     .....@w....@....
  40d718:	000740b2 430a0192 d0323c02 425f0058     .@.....C.<2.X._B
  40d728:	9f0a0201 425a2423 4a0f0201 0010803f     ....#$ZB...J?...
  40d738:	803f241b 24180010 0020803f 43c22010     .$?....$?. .. .C
  40d748:	42e20214 40b20956 0950181e 096c421f     ...BV..@..P..Bl.
  40d758:	1000503f 01f04f82 12b0435c 42e2fbfc     ?P...O..\C.....B
  40d768:	c3e20954 3c0201e0 01e0d3e2 4303c232     T......<....2..C
  40d778:	096a93c2 d03227d2 3fd10018 096ad3d2     ..j..'2....?..j.
  40d788:	096c421f 1000503f 01f04f82 004090f2     .Bl.?P...O....@.
  40d798:	24490201 020792d2 24310966 020742d2     ..I$....f.1$.B..
  40d7a8:	425f0966 5f0f0204 000b803f 0207425e     f._B..._?...^B..
  40d7b8:	8f0e5e0e 000b803e 095693c2 40b22004     .^..>.....V.. .@
  40d7c8:	09421858 40b23c03 09422458 5f0f5f0f     X.B..<.@X$B.._._
  40d7d8:	503f5f0f 4f822c00 403b0944 403d4ff8     ._?P.,.OD.;@.O=@
  40d7e8:	436f0946 ff80b03e 5e0e2017 5e0e5e0e     F.oC>.... .^.^.^
  40d7f8:	4c00503e 00004e8d 4fc2535f 934c0957     >P.L.N.._S.OW.L.
  40d808:	40b22004 01a21082 40b23c19 01a21086     . .@.....<.@....
  40d818:	09504292 3c1201a0 4b8d532d 535ffffe     .BP....<-S.K.._S
  40d828:	007f803e 40b23fdf 09422040 095743d2     >....?.@@ B..CW.
  40d838:	09504292 40b201a0 01a21086 0957425f     .BP....@...._BW.
  40d848:	2406930f 0942403e 01a44eb2 23fc831f     ...$>@B..N.....#
  40d858:	021493c2 d0b22403 01a20018 01ae4392     .....$.......C..
  40d868:	01ae43a2 120f4130 120d120e 120b120c     .C..0A..........
  40d878:	421d120a 4d0a0202 020193e2 83d2201d     ...B...M..... ..
  40d888:	201a0972 0205425e 09724ec2 0207425c     r.. ^B...Nr.\B..
  40d898:	0207425f 5f0f5f0f 8c0f5f0f 2808936e     _B..._._._..n..(
  40d8a8:	2c069f0a 83d25d0a 93e20972 2ff80972     ...,.]..r...r../
  40d8b8:	12b0435c 3c09fbfc 067740b2 423c01a6     \C.....<.@w...<B
  40d8c8:	ff8a12b0 017740b2 4a8201a6 c0b10190     .....@w....J....
  40d8d8:	000c00f0 413b413a 413d413c 413f413e     ....:A;A<A=A>A?A
  40d8e8:	120f1300 0973425f 2415930f 2426831f     ...._Bs....$..&$
  40d8f8:	2029831f 002290b2 2c070952 0952421f     ..) ..".R..,.BR.
  40d908:	01c142df 53920200 83d20952 201b0955     .B.....SR...U.. 
  40d918:	097343c2 425f3c18 4f8201c1 43d20952     .Cs..<_B...OR..C
  40d928:	4fd20973 01c00200 0006903f 40f2200c     s..O....?.... .@
  40d938:	01e00024 000340b2 3c0501d8 01c142d2     $....@.....<.B..
  40d948:	43e20955 d0f20973 01c20010 0020d0f2     U..Cs......... .
  40d958:	c0b101c2 000200f0 1300413f 931d120a     ........?A......
  40d968:	e33d3403 3c02531d 531ce33c 4c0f4d0e     .4=..S.<<..S.M.L
  40d978:	110f110e 4e0c430b 12b04b0d 4c0afe94     .....C.N.K.....L
  40d988:	4b0d4f0c fe9412b0 3403931f 5a0f8c0e     .O.K.......4...Z
  40d998:	5c0e3c02 531b8a0f 3bed922b 413a4e0c     .<.\...S+..;.N:A
  40d9a8:	120f4130 120d120e 120b120c 01e0b3e2     0A..............
  40d9b8:	42d22412 095401e0 01e0c3e2 0192c2a2     .$.B..T.........
  40d9c8:	90f2434c 02010020 435c2401 fbfc12b0     LC.. ....$\C....
  40d9d8:	00f0c0b1 413b000a 413d413c 413f413e     ......;A<A=A>A?A
  40d9e8:	120f1300 097343c2 09525392 073090b2     .....Cs..SR...0.
  40d9f8:	28030952 09524382 421f3c05 4fd20952     R..(.CR..<.BR..O
  40da08:	01c00200 0020d0f2 c0b101c2 000200f0     ...... .........
  40da18:	1300413f 000ff03d 000fe03d 5d005d0d     ?A..=...=....].]
  40da28:	110c110c 110c110c 110c110c 110c110c     ................
  40da38:	110c110c 110c110c 110c110c 4130110c     ..............0A
  40da48:	000ff03d 000fe03d 5d005d0d 5c0c5c0c     =...=....].].\.\
  40da58:	5c0c5c0c 5c0c5c0c 5c0c5c0c 5c0c5c0c     .\.\.\.\.\.\.\.\
  40da68:	5c0c5c0c 5c0c5c0c 41305c0c 3402931c     .\.\.\.\.\0A...4
  40da78:	531ce33c 931d4c0f e33d3402 4d0c531d     <..S.L...4=..S.M
  40da88:	2c039f0c 4f0c4c0e c3124e0f 110f100f     ...,.L.O.N......
  40da98:	41305f0c f0b2120f 01a2ffef 2800403f     ._0A........?@.(
  40daa8:	0964521f 01a04f82 00f0c0b1 413f0002     .Rd..O........?A
  40dab8:	42921300 020a01da 01d84382 01e042e2     ...B.....C...B..
  40dac8:	00f0c0b1 13000000 0a004031 ff9812b0     ........1@......
  40dad8:	12b0430c 12b0faf6 c3e2ff9c 4292096a     .C..........j..B
  40dae8:	022201d2 00f0c0b1 13000000 41354134     ..".........4A5A
  40daf8:	41374136 41394138 4130413a 137740b2     6A7A8A9A:A0A.@w.
  40db08:	c0b101a6 000000f0 831c1300 23fd4303     .............C.#
  40db18:	d0324130 3ffd0010 4130431c 3fff4303     0A2....?.C0A.C.?
  40db28:	00001300 00000000 00000000 00000000     ................
	...
  40db68:	fd62fe62 ff32ffa0 0000fe22 f99aff92     b.b...2.".......
  40db78:	ff7cff14 0000ff92 fce6ff5a ff48ff92     ..|.....Z.....H.
  40db88:	20746553 69726570 253d646f 202c756c     Set period=%lu, 
  40db98:	6b636974 746e695f 61767265 6c253d6c     tick_interval=%l
  40dba8:	00000a75 5f6d756e 706d6173 3d73656c     u...num_samples=
  40dbb8:	0a756c25 00000000 20746553 706d6173     %lu.....Set samp
  40dbc8:	3a73656c 74657220 6c61765f 7525203a     les: ret_val: %u
  40dbd8:	65642020 74705f76 6e3e2d72 725f6d75       dev_ptr->num_r
  40dbe8:	61735f78 656c706d 25203a73 00000a75     x_samples: %u...
  40dbf8:	74697257 46532065 63755320 73736563     Write SF Success
  40dc08:	3a6c7566 0a752520 00000000 000009c4     ful: %u.........
  40dc18:	253a7525 74203a75 4f656d69 696c4666     %u:%u: timeOfFli
  40dc28:	3d746867 202c7525 6c616373 63614665     ght=%u, scaleFac
  40dc38:	3d726f74 202c7525 3d6d756e 2c756c25     tor=%u, num=%lu,
  40dc48:	6e656420 756c253d 6172202c 3d65676e      den=%lu, range=
  40dc58:	0a756c25 00000000 736e6553 2520726f     %lu.....Sensor %
  40dc68:	6e652075 51492064 61727420 6566736e     u end IQ transfe
  40dc78:	25203a72 0a20756c 00000000 000009c4     r: %lu .........
  40dc88:	736e6553 2520726f 20756868 74696e69     Sensor %hhu init
  40dc98:	696c6169 6974617a 74206e6f 64656d69     ialization timed
  40dca8:	74756f20 20726f20 7373696d 0a676e69      out or missing.
  40dcb8:	00000000 00000bc4 72646863 72775f76     ........chdrv_wr
  40dcc8:	5f657469 6d726966 65726177 0000000a     ite_firmware....
  40dcd8:	676f7250 6d6d6172 20676e69 72696843     Programming Chir
  40dce8:	65732070 726f736e 0a2e2e2e 00000000     p sensor........
  40dcf8:	746f7257 75252065 74796220 69207365     Wrote %u bytes i
  40dd08:	6c25206e 736d2075 00000a2e 72646863     n %lu ms....chdr
  40dd18:	6e695f76 725f7469 000a6d61 64616f4c     v_init_ram..Load
  40dd28:	20676e69 204d4152 74696e69 74616420     ing RAM init dat
  40dd38:	2e2e2e61 0000000a 74736554 43324920     a.......Test I2C
  40dd48:	61657220 25203a64 0a583430 00000000      read: %04X.....
  40dd58:	474f5250 4154535f 30203a54 32302578     PROG_STAT: 0x%02
  40dd68:	00000a58 6e616843 676e6967 43324920     X...Changing I2C
  40dd78:	64646120 73736572 206f7420 000a7525      address to %u..
  40dd88:	fffc4003 43206f4e 70726968 6e657320     .@..No Chirp sen
  40dd98:	20726f73 69766564 20736563 20657261     sor devices are 
  40dda8:	70736572 69646e6f 000a676e 736e6553     responding..Sens
  40ddb8:	6320726f 746e756f 7525203a 6c25202c     or count: %u, %l
  40ddc8:	736d2075 00000a2e 72696843 65732070     u ms....Chirp se
  40ddd8:	726f736e 696e6920 6c616974 64657a69     nsor initialized
  40dde8:	206e6f20 20433249 72646461 3a752520      on I2C addr %u:
  40ddf8:	0a2e7525 00000000 71657246 636e6575     %u......Frequenc
  40de08:	6f6c2079 64656b63 6c25202c 736d2075     y locked, %lu ms
  40de18:	0000000a 20435452 696c6163 74617262     ....RTC calibrat
  40de28:	202c6465 20756c25 000a736d 206c6143     ed, %lu ms..Cal 
  40de38:	75736572 203a746c 000a7525 696e6946     result: %u..Fini
  40de48:	54206873 6e692058 6d697420 25203a65     sh TX in time: %
  40de58:	0a20756c 00000000 002dc6c0 000000c0     lu .......-.....
  40de68:	00000800 00000000 646e6573 20676e69     ........sending 
  40de78:	20756c25 65747962 00000a73 000f4240     %lu bytes...@B..
  40de88:	000000c0 00000800 00000000              ............

0040de94 <_global_impure_ptr>:
  40de94:	2000017c 00464e49 00666e69 004e414e     |.. INF.inf.NAN.
  40dea4:	006e616e 31300030 35343332 39383736     nan.0.0123456789
  40deb4:	44434241 30004645 34333231 38373635     ABCDEF.012345678
  40dec4:	63626139 00666564 69666e49 7974696e     9abcdef.Infinity
  40ded4:	4e614e00 00000000                       .NaN....

0040dedc <__sf_fake_stderr>:
	...

0040defc <__sf_fake_stdin>:
	...

0040df1c <__sf_fake_stdout>:
	...

0040df40 <__mprec_bigtens>:
  40df40:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
  40df50:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
  40df60:	7f73bf3c 75154fdd                       <.s..O.u

0040df68 <__mprec_tens>:
  40df68:	00000000 3ff00000 00000000 40240000     .......?......$@
  40df78:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  40df88:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  40df98:	00000000 412e8480 00000000 416312d0     .......A......cA
  40dfa8:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
  40dfb8:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
  40dfc8:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
  40dfd8:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
  40dfe8:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
  40dff8:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
  40e008:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
  40e018:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
  40e028:	79d99db4 44ea7843                       ...yCx.D

0040e030 <p05.6047>:
  40e030:	00000005 00000019 0000007d 2b302d23     ........}...#-0+
  40e040:	6c680020 6665004c 47464567 50004300      .hlL.efgEFG.C.P
  40e050:	5849534f 00002e00                                OSIX...

0040e057 <_ctype_>:
  40e057:	20202000 20202020 28282020 20282828     .         ((((( 
  40e067:	20202020 20202020 20202020 20202020                     
  40e077:	10108820 10101010 10101010 10101010      ...............
  40e087:	04040410 04040404 10040404 10101010     ................
  40e097:	41411010 41414141 01010101 01010101     ..AAAAAA........
  40e0a7:	01010101 01010101 01010101 10101010     ................
  40e0b7:	42421010 42424242 02020202 02020202     ..BBBBBB........
  40e0c7:	02020202 02020202 02020202 10101010     ................
  40e0d7:	00000020 00000000 00000000 00000000      ...............
	...

0040e158 <_init>:
  40e158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40e15a:	bf00      	nop
  40e15c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40e15e:	bc08      	pop	{r3}
  40e160:	469e      	mov	lr, r3
  40e162:	4770      	bx	lr

0040e164 <__init_array_start>:
  40e164:	0040016d 	.word	0x0040016d

0040e168 <_fini>:
  40e168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40e16a:	bf00      	nop
  40e16c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40e16e:	bc08      	pop	{r3}
  40e170:	469e      	mov	lr, r3
  40e172:	4770      	bx	lr

0040e174 <__fini_array_start>:
  40e174:	00400149 	.word	0x00400149

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
2000000a:	b480      	push	{r7}
2000000c:	b089      	sub	sp, #36	; 0x24
2000000e:	af00      	add	r7, sp, #0
20000010:	60f8      	str	r0, [r7, #12]
20000012:	60b9      	str	r1, [r7, #8]
20000014:	607a      	str	r2, [r7, #4]
20000016:	603b      	str	r3, [r7, #0]
	uint32_t *p_ul_data =
			(uint32_t *) ((p_efc == EFC0) ?
			READ_BUFF_ADDR0 : READ_BUFF_ADDR1);
#elif (SAM3S || SAM4S || SAM3N || SAM3U || SAM4E || SAM4N || SAM4C || SAMG || \
	   SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAMS70 || SAME70)
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
20000018:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000001c:	61bb      	str	r3, [r7, #24]
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
2000001e:	683b      	ldr	r3, [r7, #0]
20000020:	2b00      	cmp	r3, #0
20000022:	d101      	bne.n	20000028 <efc_perform_read_sequence+0x1e>
		return EFC_RC_INVALID;
20000024:	2302      	movs	r3, #2
20000026:	e03c      	b.n	200000a2 <efc_perform_read_sequence+0x98>
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000028:	68fb      	ldr	r3, [r7, #12]
2000002a:	681b      	ldr	r3, [r3, #0]
2000002c:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
20000030:	68fb      	ldr	r3, [r7, #12]
20000032:	601a      	str	r2, [r3, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
20000034:	68bb      	ldr	r3, [r7, #8]
20000036:	b2db      	uxtb	r3, r3
20000038:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
2000003c:	68fb      	ldr	r3, [r7, #12]
2000003e:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	68fb      	ldr	r3, [r7, #12]
20000042:	689b      	ldr	r3, [r3, #8]
20000044:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
20000046:	697b      	ldr	r3, [r7, #20]
20000048:	f003 0301 	and.w	r3, r3, #1
2000004c:	2b01      	cmp	r3, #1
2000004e:	d0f7      	beq.n	20000040 <efc_perform_read_sequence+0x36>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000050:	2300      	movs	r3, #0
20000052:	61fb      	str	r3, [r7, #28]
20000054:	e00c      	b.n	20000070 <efc_perform_read_sequence+0x66>
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
20000056:	69fb      	ldr	r3, [r7, #28]
20000058:	009b      	lsls	r3, r3, #2
2000005a:	683a      	ldr	r2, [r7, #0]
2000005c:	4413      	add	r3, r2
2000005e:	69fa      	ldr	r2, [r7, #28]
20000060:	0092      	lsls	r2, r2, #2
20000062:	69b9      	ldr	r1, [r7, #24]
20000064:	440a      	add	r2, r1
20000066:	6812      	ldr	r2, [r2, #0]
20000068:	601a      	str	r2, [r3, #0]
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
2000006a:	69fb      	ldr	r3, [r7, #28]
2000006c:	3301      	adds	r3, #1
2000006e:	61fb      	str	r3, [r7, #28]
20000070:	69fa      	ldr	r2, [r7, #28]
20000072:	6abb      	ldr	r3, [r7, #40]	; 0x28
20000074:	429a      	cmp	r2, r3
20000076:	d3ee      	bcc.n	20000056 <efc_perform_read_sequence+0x4c>
	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000078:	687b      	ldr	r3, [r7, #4]
2000007a:	b2db      	uxtb	r3, r3
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000007c:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR =
20000080:	68fb      	ldr	r3, [r7, #12]
20000082:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000084:	68fb      	ldr	r3, [r7, #12]
20000086:	689b      	ldr	r3, [r3, #8]
20000088:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
2000008a:	697b      	ldr	r3, [r7, #20]
2000008c:	f003 0301 	and.w	r3, r3, #1
20000090:	2b01      	cmp	r3, #1
20000092:	d1f7      	bne.n	20000084 <efc_perform_read_sequence+0x7a>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
20000094:	68fb      	ldr	r3, [r7, #12]
20000096:	681b      	ldr	r3, [r3, #0]
20000098:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2000009c:	68fb      	ldr	r3, [r7, #12]
2000009e:	601a      	str	r2, [r3, #0]

	return EFC_RC_OK;
200000a0:	2300      	movs	r3, #0
}
200000a2:	4618      	mov	r0, r3
200000a4:	3724      	adds	r7, #36	; 0x24
200000a6:	46bd      	mov	sp, r7
200000a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200000ac:	4770      	bx	lr

200000ae <efc_write_fmr>:
 * \param ul_fmr Value of mode register
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
200000ae:	b480      	push	{r7}
200000b0:	b083      	sub	sp, #12
200000b2:	af00      	add	r7, sp, #0
200000b4:	6078      	str	r0, [r7, #4]
200000b6:	6039      	str	r1, [r7, #0]
	p_efc->EEFC_FMR = ul_fmr;
200000b8:	687b      	ldr	r3, [r7, #4]
200000ba:	683a      	ldr	r2, [r7, #0]
200000bc:	601a      	str	r2, [r3, #0]
}
200000be:	bf00      	nop
200000c0:	370c      	adds	r7, #12
200000c2:	46bd      	mov	sp, r7
200000c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200000c8:	4770      	bx	lr

200000ca <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
200000ca:	b480      	push	{r7}
200000cc:	b085      	sub	sp, #20
200000ce:	af00      	add	r7, sp, #0
200000d0:	6078      	str	r0, [r7, #4]
200000d2:	6039      	str	r1, [r7, #0]
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
200000d4:	687b      	ldr	r3, [r7, #4]
200000d6:	683a      	ldr	r2, [r7, #0]
200000d8:	605a      	str	r2, [r3, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
200000da:	687b      	ldr	r3, [r7, #4]
200000dc:	689b      	ldr	r3, [r3, #8]
200000de:	60fb      	str	r3, [r7, #12]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
200000e0:	68fb      	ldr	r3, [r7, #12]
200000e2:	f003 0301 	and.w	r3, r3, #1
200000e6:	2b01      	cmp	r3, #1
200000e8:	d1f7      	bne.n	200000da <efc_perform_fcr+0x10>

	return (ul_status & EEFC_ERROR_FLAGS);
200000ea:	68fb      	ldr	r3, [r7, #12]
200000ec:	f003 030e 	and.w	r3, r3, #14
}
200000f0:	4618      	mov	r0, r3
200000f2:	3714      	adds	r7, #20
200000f4:	46bd      	mov	sp, r7
200000f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200000fa:	4770      	bx	lr

200000fc <chirp_ch201_thresholds>:
200000fc:	0000 1770 001a 0bb8 0027 03e8 0038 01f4     ..p.....'...8...
2000010c:	004f 00fa 0059 00af                         O...Y...

20000114 <g_interrupt_enabled>:
20000114:	0001 0000                                   ....

20000118 <chirp_i2c_addrs>:
20000118:	2b2d 2a2c                                   -+,*

2000011c <chirp_i2c_buses>:
2000011c:	0000 0101                                   ....

20000120 <chirp_pin_prog>:
20000120:	0010 0000 0012 0000 0013 0000 001f 0000     ................

20000130 <chirp_pin_io>:
20000130:	0015 0000 0016 0000 0017 0000 001d 0000     ................

20000140 <chirp_pin_io_irq>:
20000140:	0000 0020 0000 0040 0000 0080 0000 2000     .. ...@........ 

20000150 <chirp_led_pins>:
20000150:	0000 0000 002f 0000 0005 0000 0001 0000     ..../...........

20000160 <ultrasound_timer_period_in_tick>:
20000160:	ffff 0000                                   ....

20000164 <adc_local>:
20000164:	8000 4003                                   ...@

20000168 <adc_reg>:
20000168:	8094 4003                                   ...@

2000016c <ul_flash_in_wait_mode>:
2000016c:	0000 0020                                   .. .

20000170 <SystemCoreClock>:
20000170:	1200 007a                                   ..z.

20000174 <ch201_gprmt_version>:
20000174:	d328 0040                                   (.@.

20000178 <_impure_ptr>:
20000178:	017c 2000                                   |.. 

2000017c <impure_data>:
2000017c:	0000 0000 defc 0040 df1c 0040 dedc 0040     ......@...@...@.
	...

200001dc <__global_locale>:
200001dc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
200001fc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
2000021c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
2000023c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
2000025c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
2000027c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
2000029c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
200002bc:	c221 0040 c155 0040 0000 0000 e057 0040     !.@.U.@.....W.@.
200002cc:	e055 0040 e041 0040 e041 0040 e041 0040     U.@.A.@.A.@.A.@.
200002dc:	e041 0040 e041 0040 e041 0040 e041 0040     A.@.A.@.A.@.A.@.
200002ec:	e041 0040 e041 0040 ffff ffff ffff ffff     A.@.A.@.........
200002fc:	ffff ffff ffff 0000 0001 5341 4943 0049     ..........ASCII.
	...
20000324:	0000 5341 4943 0049 0000 0000 0000 0000     ..ASCII.........
	...
